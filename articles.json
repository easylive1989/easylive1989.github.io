{
  "articles": [
    {
      "title": "這個 Flutter 小技巧，讓你看懂 Widget Test 到底哪裡壞了",
      "summary": "在 Flutter 開發中，我們除了寫程式之外，也會需要寫一些測試來確保功能沒有問題。Flutter SDK 內建提供了 Unit Test、Widget Test 與 Integration Test 三種測試工具供開發人員使用。這三種工具分別有些不同特性，Unit Test 無論是執行速度或是錯...",
      "content": "![](https://images.unsplash.com/photo-1501163109389-abf37ca1276a?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n在 Flutter 開發中，我們除了寫程式之外，也會需要寫一些測試來確保功能沒有問題。Flutter SDK 內建提供了 Unit Test、Widget Test 與 Integration Test 三種測試工具供開發人員使用。這三種工具分別有些不同特性，Unit Test 無論是執行速度或是錯誤訊息清晰度，都要比 Integration Test 要來得好很多。\n\n在 Flutter 開發中，除了撰寫功能程式碼之外，撰寫測試也是確保應用穩定性的重要一環。Flutter SDK 內建提供了三種測試工具：**Unit Test**、**Widget Test** 與 **Integration Test**。這三者的主要差異在於測試的層級與執行效能，其中 **Unit Test** 速度最快、錯誤訊息最清晰；而 **Integration Test**\n\n涵蓋範圍最廣，但速度最慢、維護成本也最高。\n\n![[https://docs.flutter.dev/testing/overview](https://docs.flutter.dev/testing/overview)](%E9%80%99%E5%80%8B%20Flutter%20%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%AE%93%E4%BD%A0%E7%9C%8B%E6%87%82%20Widget%20Test%20%E5%88%B0%E5%BA%95%E5%93%AA%E8%A3%A1%E5%A3%9E%E4%BA%86/image.png)\n\n[https://docs.flutter.dev/testing/overview](https://docs.flutter.dev/testing/overview)\n\n相較之下，**Widget Test** 的執行速度僅略慢於 Unit Test，但其錯誤訊息往往不夠直覺。例如，下列訊息僅指出某個 Widget 找不到，卻無法明確告訴我們原因：\n\n```bash\nExpected: no matching candidates\n  Actual: _TextWidgetFinder:<Found 1 widget with text \"1\": [\n            Text(\"1\", debugLabel: (englishLike headlineMedium 2021).merge((blackMountainView\nheadlineMedium).apply), inherit: false, color: Color(alpha: 1.0000, red: 0.1137, green: 0.1059,\nblue: 0.1255, colorSpace: ColorSpace.sRGB), family: Roboto, size: 28.0, weight: 400, letterSpacing:\n0.0, baseline: alphabetic, height: 1.3x, leadingDistribution: even, decoration: Color(alpha: 1.0000,\nred: 0.1137, green: 0.1059, blue: 0.1255, colorSpace: ColorSpace.sRGB) TextDecoration.none,\ndependencies: [DefaultSelectionStyle, DefaultTextStyle, MediaQuery]),\n```\n\n造成測試失敗的原因可能很多：邏輯錯誤、畫面未刷新、Widget 被遮擋 ……單靠這樣的訊息，很難快速定位問題，也因此 Widget Test 維護成本較高。\n\n## 使用 debugDumpApp 顯示 Widget Tree\n\n若上網搜尋「如何除錯 Widget Test」，很容易找到 Flutter 提供的 `debugDumpApp` API。這個工具可以輸出整個 Widget Tree，理論上可協助我們檢查畫面結構是否正確（[完整範例在這裡](https://dartpad.dev/?id=97d3dae3a802cc1d3076998ca6c43772)）。\n\n```bash\nAutomatedTestWidgetsFlutterBinding - DEBUG MODE\n[root]\n└View(state: _ViewState#f6410)\n └RawView\n  └_RawViewInternal-[_DeprecatedRawViewKey TestFlutterView#36943](renderObject: _ReusableRenderView#62b88)\n   └_ViewScope\n    └_PipelineOwnerScope\n     └_MediaQueryFromView(state: _MediaQueryFromViewState#8f554)\n      └MediaQuery(MediaQueryData(size: Size(800.0, 600.0), devicePixelRatio: 3.0, textScaler: no scaling, platformBrightness: Brightness.light, padding: EdgeInsets.zero, viewPadding: EdgeInsets.zero, viewInsets: EdgeInsets.zero, systemGestureInsets: EdgeInsets.zero, alwaysUse24HourFormat: false, accessibleNavigation: false, highContrast: false, onOffSwitchLabels: false, disableAnimations: false, invertColors: false, boldText: false, navigationMode: traditional, gestureSettings: DeviceGestureSettings(touchSlop: null), displayFeatures: [], supportsShowingSystemContextMenu: false))\n       └FocusTraversalGroup(policy: ReadingOrderTraversalPolicy#9bb45, state: _FocusTraversalGroupState#c8c8d)\n        └Focus(debugLabel: \"FocusTraversalGroup\", focusNode: _FocusTraversalGroupNode#1ee5d(FocusTraversalGroup [IN FOCUS PATH]), state: _FocusState#deea3)\n         └_FocusInheritedScope\n          └_FocusScopeWithExternalFocusNode(debugLabel: \"View Scope\", focusNode: FocusScopeNode#98f92(View Scope [IN FOCUS PATH]), dependencies: [_FocusInheritedScope], state: _FocusScopeState#7ba60)\n           └_FocusInheritedScope\n            └MyApp\n     \n```\n\n但實際使用後會發現，這份輸出往往冗長又難以閱讀。即使是一個簡單的 Counter App，Widget Tree 也可能超過兩百行，每行還充滿細節資訊。因此，透過 `debugDumpApp` 來排查畫面問題在實務上並不方便。\n\n那麼，我們該怎麼辦？在介紹解法之前，先來認識另一種測試方式——**Golden Test**。\n\n## 什麼是 Golden Test\n\n除了常見的 Unit Test、Widget Test 與 Integration Test 之外，Flutter 還有第四種測試：**Golden Test**。它不是用程式邏輯比對結果，而是透過**畫面比對**的方式確認 UI 是否異動。\n\nGolden Test 的原理很簡單：\n\n1. 先將正確的畫面狀態儲存為基準圖（snapshot）。\n2. 下次執行測試時，再將目前畫面與基準圖比較。\n3. 若畫面有任何變化，就會自動產生差異圖檔，讓開發者快速檢查變動位置。\n\n使用方式也很直觀：\n\n```dart\nexpect(find.byType(MaterialApp), matchesGoldenFile(\"snapshot.png\"));\n```\n\n若結果不同，Flutter 會在 snapshot.png 旁邊自動產生比較結果，使用者就能確認變動是否預期：\n\n```bash\ntest\n├── failures\n│   ├── snapshot_isolatedDiff.png\n│   ├── snapshot_maskedDiff.png\n│   ├── snapshot_masterImage.png\n│   ├── snapshot_testImage.png\n├── snapshot.png\n└── widget_test.dart\n```\n\n如果確認畫面變動是預期內的修改，只需執行以下指令即可更新基準圖：\n\n```dart\nflutter test --update-goldens\n```\n\n聰明的你可能已經想到：我們能否利用 Golden Test 的特性，讓 Widget Test 也能快速檢查畫面呢？\n\n## 使用 matchesGoldenFile 直接顯示畫面\n\n在 Widget Test 中，我們雖然不是真的在做 Golden Test，但其實還是可以使用 `matchesGoldenFile` 來將當前的畫面結果印出來。印出來之後，我們就能更快的檢查畫面是不是符合預期，而不用看 `debugDumpApp` 的那一長串資料了。\n\n雖然在 Widget Test 中我們並非真正執行 Golden Test，但仍可透過 `matchesGoldenFile` 來**輸出當前畫面結果**。\n\n這樣一來，我們就能以圖像的方式檢查畫面是否如預期，而不必苦讀 `debugDumpApp` 的長篇輸出。\n\n![snapshot.png](%E9%80%99%E5%80%8B%20Flutter%20%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%AE%93%E4%BD%A0%E7%9C%8B%E6%87%82%20Widget%20Test%20%E5%88%B0%E5%BA%95%E5%93%AA%E8%A3%A1%E5%A3%9E%E4%BA%86/snapshot.png)\n\n儘管測試環境中使用的字型可能與真實 App 不同（例如無法顯示文字或 Icon），但大部分畫面元素仍足以協助我們判斷 UI 是否正常。\n\n下次當 Widget Test 報錯卻不知從何下手時，試著加入 `matchesGoldenFile`，你可能能立刻看出問題所在。\n\n**注意事項**：`matchesGoldenFile` 在 Widget Test 只是一種用來 Debug 的手段，不適合一直放在測試中，務必在問題解決之後移除。\n\n## 小結\n\nWidget Test 是在速度與真實性之間取得平衡的測試方式，能快速驗證 App 的行為並提升測試覆蓋率。然而，它的除錯難度也較高。\n\n在進行逐步除錯（debug）之前，不妨先透過 `matchesGoldenFile` 生成畫面快照，快速比對結果。這個簡單的技巧，常能讓你瞬間發現問題根源。",
      "createdAt": "October 5, 2025 4:39 PM",
      "updatedAt": "October 24, 2025 4:47 PM",
      "id": "2838303f78f780a19f9eed48ccc9f2c6",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "這個 Flutter 小技巧，讓你看懂 Widget Test 到底哪裡壞了 2838303f78f780a19f9eed48ccc9f2c6.md"
    },
    {
      "title": "Widget Test 的 tap 原來這樣運作？一探 Flutter 測試點擊的祕密",
      "summary": "前陣子有同事問我：「WidgetTester 中的 `tap` 方法，到底是點擊卡片的哪個位置？它是真的模擬使用者的點擊行為，還是單純呼叫底層某個 callback 來觸發事件？」當下我其實不太確定，只好回家趕快研究一下。 雖然這些細節在大部分情境下不影響我們的日常測試，但世事難料，總有可能哪天派得...",
      "content": "![robottesting2.png](Widget%20Test%20%E7%9A%84%20tap%20%E5%8E%9F%E4%BE%86%E9%80%99%E6%A8%A3%E9%81%8B%E4%BD%9C%EF%BC%9F%E4%B8%80%E6%8E%A2%20Flutter%20%E6%B8%AC%E8%A9%A6%E9%BB%9E%E6%93%8A%E7%9A%84%E7%A5%95%E5%AF%86/robottesting2.png)\n\n前陣子有同事問我：「WidgetTester 中的 `tap` 方法，到底是點擊卡片的哪個位置？它是真的模擬使用者的點擊行為，還是單純呼叫底層某個 callback 來觸發事件？」當下我其實不太確定，只好回家趕快研究一下。\n\n雖然這些細節在大部分情境下不影響我們的日常測試，但世事難料，總有可能哪天派得上用場。所以趁有空時，就來探索一下這個小細節吧。\n\n今天想和大家分享一個關於 Widget Test 的冷知識。本篇文章會包含不少原始碼，如果你對底層實作細節沒有興趣，可以考慮先跳過。\n\n## WidgetTester 的 tap 方法\n\n首先來看 `tap` 的實作，這應該能回答第一個問題：**`tap` 方法到底是點擊 Widget 的哪個位置？**\n\n從程式碼中可以看到，它實際上呼叫了 `tapAt`，並傳入 `getCenter(...)`。光從名稱就能推測出來：`tap` 點擊的是 **Widget 的中心點**。\n\n```dart\nFuture<void> tap(\n  finders.FinderBase<Element> finder, {\n  int? pointer,\n  int buttons = kPrimaryButton,\n  bool warnIfMissed = true,\n  PointerDeviceKind kind = PointerDeviceKind.touch,\n}) {\n  return tapAt(\n    getCenter(finder, warnIfMissed: warnIfMissed, callee: 'tap'),\n    pointer: pointer,\n    buttons: buttons,\n    kind: kind,\n  );\n}\n```\n\n接下來的問題就是：它是怎麼找到「中心點」的？\n\n## 找尋 Widget 中心點\n\n往下追 `getCenter` 的實作，可以看到它呼叫了 `_getElementPoint`，這個方法的功能就是：**計算 Widget 某個位置的 Global 座標**。\n\n```dart\nOffset getCenter(\n  finders.FinderBase<Element> finder, {\n  bool warnIfMissed = false,\n  String callee = 'getCenter',\n}) {\n  return _getElementPoint(\n    finder,\n    (Size size) => size.center(Offset.zero),\n    warnIfMissed: warnIfMissed,\n    callee: callee,\n  );\n}\n\nOffset _getElementPoint(\n  finders.FinderBase<Element> finder,\n  Offset Function(Size size) sizeToPoint, {\n  required bool warnIfMissed,\n  required String callee,\n}) {\n  TestAsyncUtils.guardSync();\n  final Iterable<Element> elements = finder.evaluate();\n  \n  // 省略檢查細節\n\n  final Element element = elements.single;\n  final RenderObject? renderObject = element.renderObject;\n  \n  // 省略檢查細節\n\n  final RenderBox box = element.renderObject! as RenderBox;\n  final Offset location = box.localToGlobal(sizeToPoint(box.size));\n  \n  // 省略 warnIfMissed 細節\n\n  return location;\n}\n```\n\n總結來說：`getCenter` 並不複雜，它只是透過 finder 找出 Element，再用 RenderBox 算出 Widget 中心點的 Global 座標。\n\n除了 `getCenter`，還有像 `getTopLeft`、`getBottomLeft` 等方法，可以讓我們在測試中指定不同的點擊位置。\n\n## **tapAt 的點擊流程**\n\n找到座標之後，`tap` 會透過 `tapAt` 來模擬點擊。\n\n來看一下主要流程：\n\n1. `tapAt` 先呼叫 `startGesture`，建立一個 `TestGesture`，並執行 `result.down(downLocation)` 來模擬 **手指按下**。\n2. 接著呼叫 `gesture.up()` 來模擬 **手指放開**。\n\n```dart\nFuture<void> tapAt(\n  Offset location, {\n  int? pointer,\n  int buttons = kPrimaryButton,\n  PointerDeviceKind kind = PointerDeviceKind.touch,\n}) {\n  return TestAsyncUtils.guard<void>(() async {\n    final TestGesture gesture = await startGesture(\n      location,\n      pointer: pointer,\n      buttons: buttons,\n      kind: kind,\n    );\n    await gesture.up();\n  });\n}\n\nFuture<TestGesture> startGesture(\n  Offset downLocation, {\n  int? pointer,\n  PointerDeviceKind kind = PointerDeviceKind.touch,\n  int buttons = kPrimaryButton,\n}) async {\n  final TestGesture result = _createGesture(pointer: pointer, kind: kind, buttons: buttons);\n  if (kind == PointerDeviceKind.trackpad) {\n    // 處理觸控板的點擊行為\n  } else {\n    await result.down(downLocation);\n  }\n  return result;\n}\n```\n\n如果你曾經用 Listener 監聽過觸控事件，對這流程應該不陌生：\n\n- 按下時 → `PointerDownEvent`\n- 放開時 → `PointerUpEvent`\n\n想實際觀察的人，可以參考[這個範例](https://dartpad.dev/?id=5b0ff587c3653927bdc93e39fddac731)。\n\n## TestGesture 如何發送事件\n\n那這些事件是怎麼真正「傳到 Flutter Framework」的呢？\n\n答案就在 `TestGesture` 的 `down` 與 `up` 方法中。\n\n```dart\nFuture<void> down(Offset downLocation, {Duration timeStamp = Duration.zero}) async {\n  \n  // 省略檢查細節\n  \n  return TestAsyncUtils.guard<void>(() async {\n    return _dispatcher(_pointer.down(downLocation, timeStamp: timeStamp));\n  });\n}\n```\n\n這裡 `_dispatcher` 會發送一個 `PointerDownEvent`。在 `TestGesture` 的建構過程中，可以看到它實際上被綁定成 `sendEventToBinding`，最後透過 `WidgetsBinding` 把事件送進 Framework。\n\n```dart\nTestGesture _createGesture({\n  int? pointer,\n  required PointerDeviceKind kind,\n  required int buttons,\n}) {\n  return TestGesture(\n    dispatcher: sendEventToBinding,\n    kind: kind,\n    pointer: pointer ?? _getNextPointer(),\n    buttons: buttons,\n  );\n}\n\nFuture<void> sendEventToBinding(PointerEvent event) {\n  return TestAsyncUtils.guard<void>(() async {\n    binding.handlePointerEvent(event);\n  });\n}\n```\n\n熟悉 Flutter 的人應該對 `WidgetsBinding` 不陌生。我們常用的 `WidgetsBinding.instance.addPostFrameCallback(...)` 就是它的功能之一。\n\n在點擊事件的情境下，Engine 收到事件後，會透過 `WidgetsBinding`（更精確地說是 `GestureBinding`）把事件傳進 Framework，經過像 **GestureArena** 這樣的機制過濾與解析，最後才交給我們常用的 `GestureDetector`。\n\n## 整理一下\n\n整個 `tap` 的執行流程，可以簡單整理如下：\n\n![開發 - Frame 11.jpg](Widget%20Test%20%E7%9A%84%20tap%20%E5%8E%9F%E4%BE%86%E9%80%99%E6%A8%A3%E9%81%8B%E4%BD%9C%EF%BC%9F%E4%B8%80%E6%8E%A2%20Flutter%20%E6%B8%AC%E8%A9%A6%E9%BB%9E%E6%93%8A%E7%9A%84%E7%A5%95%E5%AF%86/%E9%96%8B%E7%99%BC_-_Frame_11.jpg)\n\n1. 呼叫 `WidgetTester.tap`\n2. 透過 finder 找到 Element，計算中心點的 Global 座標\n3. 呼叫 `tapAt`，傳入座標\n4. 建立 `TestGesture` 負責處理點擊\n5. 呼叫 `down` → 發送 `PointerDownEvent`\n6. 呼叫 `up` → 發送 `PointerUpEvent`\n\n## 小結\n\n透過研究 `WidgetTester.tap` 的實作，我們不僅加深了對 Widget Test 使用方式的理解，也更清楚它是如何與 Flutter Framework 互動。雖然這些細節未必直接影響日常開發，但它可以視為一種「閱讀程式碼的訓練」。在 AI 不斷進步的時代，我們反而更需要具備閱讀、理解 **別人程式碼** 的能力。\n\n每次遇到不熟悉的地方，都是充實知識庫的契機。在追原始碼的過程中，不只能更透徹地理解框架運作，也能從中學到設計思維與程式風格。\n\n希望這篇文章能帶給你一些啟發。如果有任何問題，歡迎留言與我討論，感謝你讀到這裡！",
      "createdAt": "August 23, 2025 9:08 AM",
      "updatedAt": "October 24, 2025 4:47 PM",
      "id": "2588303f78f780b3a789ccdae073e04a",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Widget Test 的 tap 原來這樣運作？一探 Flutter 測試點擊的祕密 2588303f78f780b3a789ccdae073e04a.md"
    },
    {
      "title": "Vibe Coding 回顧",
      "summary": "今年 AI 能力大躍進，不斷地在社群或網路看到別人說大部分的 Code 都是由 AI 產生，讓我不禁開始懷疑自己的開發方式。去年我還只是拿著 Github Copilot 當作更智能自動補完工具，完全沒有感覺這東西是能有大改變，覺得 AI 終究只是從上下文來預測結果，終究是有其極限。 在三月的時候，...",
      "content": "![image.png](Vibe%20Coding%20%E5%9B%9E%E9%A1%A7/image.png)\n\n今年 AI 能力大躍進，不斷地在社群或網路看到別人說大部分的 Code 都是由 AI 產生，讓我不禁開始懷疑自己的開發方式。去年我還只是拿著 Github Copilot 當作更智能自動補完工具，完全沒有感覺這東西是能有大改變，覺得 AI 終究只是從上下文來預測結果，終究是有其極限。\n\n在三月的時候，剛好在 Flutter Taipei Meetup 聽了有兩個關於 AI 的主題，這才發現或許 AI 已經進步到超乎我想像的地步了，是時候改變思維，擁抱變化了。至今大約 Vibe Coding 了半年多，剛好最近想法上有轉變（最後會提到），所以先來回顧一下這半年的 AI 使用心得了。\n\n三月那會兒，最流行的 AI 工具大概也就是 Cursor 或 Winsurf，有鑒於之前買了一年的 Github Copilot 的教訓，這次就來一個月、一個月的買 Cursor。那買了 Cursor 要用在什麼地方呢？首先在除了在工作中的產品嘗試之外，當時有個朋友找我弄個小小的自動化工具，想想這也是個挺好的機會，就來用 Vibe Coding 的方式來建立這個小工具吧。\n\n## 開始 Vibe Coding\n\n在開始這個 Side Project 時，我刻意選擇了自己幾乎不太懂的語言加框架，用 Electron + React + Playwright 來做一個自動化的爬蟲工具，希望自己能在開發的過程中學會這些技能（雖然事後看起來效果並不算太好）。\n\n一開始就像坊間常見的 Vibe Coding 分享一樣，直接開始跟 AI 對話，說明我想要什麼功能，要用什麼技術，從最基礎的畫面，一點一點的增加新功能。由於我對 Electron 也不熟，加上人的惰性，所以大多時候，只要功能正常，且我看的懂它在寫什麼，生成的 Code 我大多都直接接受，不太會進一步修改。\n\n### 失去動手改的能力\n\n但是這樣有個缺點，那就是我只看得懂，要自己動手改就比較難。變成任何小改動，我都是請AI 來做，而不是自己做。熟悉使用 AI 工具的人也都知道，AI 一跑起來快一點也要三四十秒、一分鐘的，甚至還有更久的。但是如果知道怎麼改而且熟悉工具的話，自己改可能也不到 AI 一半時間。\n\n我在自己的工作中也會使用 AI，常常會在內心評估每個改動到底是自己改比較快，還是 AI 改比較快。但是在不熟悉的技術中，這個評估幾乎變得沒有意義，因為幾乎都是 AI 改比較快。越常讓 AI 來改，就越加不可能出現自己改比較快的情況。\n\n或許看起來有一些負面影響，但我想這應該就是趨勢，單一任務或許 AI 做起來比較慢，但是 AI 可以同步執行多個任務，理論上來說應該會增加生產力（前提是任務沒有相依）。\n\n> AI 削弱了開發人員自己實作的能力，但是也開啟工作同步執行的能力。就像手工製作與工廠生產，單一機器的效率中難以跟真人匹敵，但是大量機器 24 小時同時運轉就不是人類可以比較的。\n> \n\n### 只有一個 AI 不夠\n\n在開發的過程中，碰到一個問題：打包 macOS 應用程式失敗。在本地端打包都沒什麼問題，但是上 CI 打包建置卻一直出錯。由於 Cursor 並無法直接讀到 Github Action 的結果，所以只好手動貼錯誤給 Cursor（或許現在有 MCP 能做到了？），請 Cursor 修復 Github Workflow 腳本。\n\n但即便如此，Cursor 還是一直鬼打牆，無法真正的解決問題。最後只好把 Github Workflow 腳本、Github Action 錯誤，再加上我想做的事情的 Context 通通整理貼到 Claude 與 Gemini 去問，而且兩者的回答還都不同，只好自己交叉比對結果與實驗，最後才讓打包工作能在 CI 上完成。\n\n> 讓 AI 自動改 Code 非常方便，但也意味著她也只選擇一種方向來處理，方向是對是錯，是好還是壞，還是得要依靠人的判斷。\n> \n\n## 免不了，也快不了的學習\n\n本想靠著 AI 實際做個東西，藉此在開發的過程中快速學一門新技術，但事後看起來還是有一定的極限，沒有想像中的這麼美好。\n\n### Electron 線程的坑\n\n最初是這個工具只有使用 Electron，而沒有 React，程式也是在 Electron 中啟動 Playwright 腳本。後來加入 React 之後，想把啟動 Playwright 腳本的工作也搬到 React 中，卻怎麼一直都無法正常運作。幾過一番折騰才了解 Playwright 只能由 Node.js 啟動，所以只能放在 Electron 中，讓 React 跟 Electron 溝通呼叫腳本，無法放在 React 中。\n\n這件工作也是來來回回請 AI 改了好幾次，每一次改就壞，過程中也出現奇奇怪怪的改法，看著都不太對勁。最後也是直接問了 AI 是否這個任務其實是有問題的，AI 才說了上面提到的問題（但也很有可能這結論也是錯的XD）。\n\n> AI 會盡全力滿足你的要求，即便這的要求不合理。如果沒有了人的判斷，可以想像如果開發時間一長，技術債會快速累積。\n> \n\n### 測試的難處\n\n同樣的問題也發生在測試，自己對測試的概念還算熟悉，本來想模仿工作中測試方式，用比較大粒度的方式來測試這個工具。與常見小粒度的測試方式不同，可能訓練資料比較缺乏，所以無論我怎麼跟 AI 溝通，都得不到理想的結果。\n\n原因可能是自己對技術的理解不夠，無法有效用該技術常見的用語與 AI 溝通，導致 AI 無法完成我想要的結果。另外一種可能是，這根本就是做不到的，但對這個語言與框架理解有限的我，也無法知道這件事。\n\n> 即便使用了 AI ，我們還是得學習相關技術，否則既限制了上限，也會浪費許多時間。\n> \n\n## 下一步\n\n最後，我已經對這個 Side Project 失去了興趣，暫時不會在這個 Side Project  上繼續 Vibe Coding。同時最近也從 Cursor 跳槽到 Claude Code，所以就趁這些轉變，回顧一下這半年的過程，總結一下 Vibe Coding 不熟悉技術的體驗。\n\n但這終究不是現實的常態，現在對於大部分開發人員來說，工作中使用的還是自己比較熟悉的技術，只是需要摸索與 AI 如何共生。自己也打算開始另外一個 Side Project，這次會使用自己熟悉的技能模仿實際工作中的流程來 Vibe Coding，看看能否帶來開發上的改變。\n\n## 小結\n\n透過這次 Vibe Coding 的過程，感受到動口不動手的快感，但也更清楚感受到 AI 的限制。無論如何，AI 已經開始改變了開發人員的工作方式，既要放下成見，接受 AI 的結果，也要持續學習，不斷反思與改善這個過程。",
      "createdAt": "August 7, 2025 8:15 PM",
      "updatedAt": "October 24, 2025 5:02 PM",
      "id": "2488303f78f7804eb849e2bb796fa8ca",
      "type": "輸出文章",
      "tag": "AI Coding",
      "filename": "Vibe Coding 回顧 2488303f78f7804eb849e2bb796fa8ca.md"
    },
    {
      "title": "避免隱晦的程式邏輯 - 避免把細節當狀態",
      "summary": "最近改開發的時候，碰到一段很難懂的 Code，讓自己看了非常久，明明程式邏輯沒多複雜，但是整體讓我覺得很不舒服，總覺得有太多東西混雜在裡面。 這段程式主要的功能是做電話號碼 OTP 驗證，功能沒有太複雜，也就是拿著使用者輸入的 OTP 驗證碼去打一隻 API 做驗證。 這段 Code 來回看了幾天，...",
      "content": "![](https://images.unsplash.com/photo-1701766993323-cc05898df2bd?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n最近改開發的時候，碰到一段很難懂的 Code，讓自己看了非常久，明明程式邏輯沒多複雜，但是整體讓我覺得很不舒服，總覺得有太多東西混雜在裡面。\n\n這段程式主要的功能是做電話號碼 OTP 驗證，功能沒有太複雜，也就是拿著使用者輸入的 OTP 驗證碼去打一隻 API 做驗證。\n\n這段 Code 來回看了幾天，請 AI 重構了無數回，也 Rollback 無數次。\n\n最後終於想通了到底問題在哪邊，到底是什麼讓整段程式難以理解。\n\n# **舉個例子**\n\n先來看看下面這段簡化過的程式碼例子：\n\n```dart\nclass OtpPage extends StatefulWidget {\n  @override\n  _OtpPageState createState() => _OtpPageState();\n}\n\nclass _OtpPageState extends State<OtpPage> {\n  String? errorMessage;\n  String otpCode = \"\";\n\n  Future<void> _verifyOtp(String otp) async {\n    try {\n      await otpService.verify(otp);\n    } catch (e) {\n   setState(() {\n        if (e.code == 'INVALID_OTP') {\n          errorMessage = \"OTP 驗證碼錯誤，請重新輸入\";\n     } else if (e.code == 'EXPIRED_OTP') {\n          errorMessage = \"OTP 驗證碼已過期\";\n        }\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          onChanged: (value) => otpCode = value,\n          decoration: InputDecoration(\n            hintText: \"請輸入 OTP 驗證碼\",\n          ),\n        ),\n        ElevatedButton(\n          onPressed: () => _verifyOtp(otpCode),\n          child: Text(\"驗證\"),\n        ),\n        if (errorMessage != null)\n          Text(\n            errorMessage!,\n            style: TextStyle(color: Colors.red),\n          ),\n      ],\n    );\n  }\n}\n```\n\n這段程式挺單純的，使用者輸入 OTP 驗證碼，按下驗證按鈕後就打 API 去驗證。\n\n在驗證的時候，程式會用 try/catch 來攔截 API 回的 400/500 錯誤，並且將指定錯誤訊息存到狀態中，以供畫面顯示。\n\n![1.jpg](%E9%81%BF%E5%85%8D%E9%9A%B1%E6%99%A6%E7%9A%84%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF%20-%20%E9%81%BF%E5%85%8D%E6%8A%8A%E7%B4%B0%E7%AF%80%E7%95%B6%E7%8B%80%E6%85%8B/1.jpg)\n\n這功能做起來也沒什麼問題，也挺好理解的，錯誤訊息就是要顯示給使用者看的，放在 _OtpPageState 中也是合情合理。\n\n但是如果故事只到此處，那也沒什麼好說的，難就難在需求總是會改，我們總是要回來重新閱讀這段程式碼。\n\n# **需求異動**\n\n有天客人抱怨錯誤訊息不夠清楚，害他沒看到驗證碼錯誤的訊息，覺得怎麼系統一直沒反應，然後就很不高興的刪除 App 了。\n\n既然客戶抱怨了，那我們只好想想辦法來解決客戶的問題。\n\n經過 PO 與設計師討論，最終決定強化錯誤提示，讓客人可以更清楚了解現在是發什麼狀況。\n\n![4.jpg](%E9%81%BF%E5%85%8D%E9%9A%B1%E6%99%A6%E7%9A%84%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF%20-%20%E9%81%BF%E5%85%8D%E6%8A%8A%E7%B4%B0%E7%AF%80%E7%95%B6%E7%8B%80%E6%85%8B/4.jpg)\n\n這邊有個小細節，就是只有在 OTP 驗證碼錯誤的情況下才需要顯示紅框，其餘像是過期就不顯示紅框。\n\n當開發人員看到設計之後，肯定覺得這題我會，不過就是一個 if 能解決的事，IDE 一開，手指一動，測試一跑，輕輕鬆鬆就完成了。\n\n```dart\nclass _OtpPageState extends State<OtpPage> {\n  String? errorMessage;\n  String otpCode = \"\";\n  String phoneNumber = \"0912345678\";\n\n  Future<void> _verifyOtp(String otp) async {\n    try {\n      await otpService.verify(otp);\n    } catch (e) {\n      setState(() {\n        if (e.code == 'INVALID_OTP') {\n          errorMessage = \"OTP 驗證碼錯誤，請重新輸入\";\n        } else if (e.code == 'EXPIRED_OTP') {\n          errorMessage = \"OTP 驗證碼已過期\";\n        }\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          onChanged: (value) => otpCode = value,\n          decoration: InputDecoration(\n            hintText: \"請輸入 OTP 驗證碼\",\n          ),\n          border: OutlineInputBorder(\n            borderSide: BorderSide(。\n              color: errorMessage == \"OTP 驗證碼錯誤，請重新輸入\" ?\n                  Colors.red :\n                  Colors.black,\n            ),\n          ),\n        ),\n        ElevatedButton(\n          onPressed: () => _verifyOtp(otpCode),\n          child: Text(\"驗證\"),\n        ),\n        if (errorMessage != null)\n          Text(\n            errorMessage!,\n            style: TextStyle(color: Colors.red),\n          ),\n        if (errorMessage == \"OTP 驗證碼錯誤，請重新輸入\")\n          Row(\n            children: [\n              Icon(Icons.phone, color: Colors.orange),\n              Text(\"請檢查您的電話號碼：\"),\n              Text(\n                phoneNumber,\n                style: TextStyle(\n                  fontWeight: FontWeight.bold,\n                  color: Colors.orange,\n                ),\n              ),\n            ],\n          ),\n      ],\n    );\n  }\n}\n```\n\n結果 Review 的時候一看，就出現了 errorMessage == “OTP 驗證碼錯誤，請重新輸入” 的 if 判斷。\n\n看到這裡，你肯定會想，功能完成是完成了，但是總感覺哪裡怪怪的。\n\n這裡就得回到我們的主題，**把細節當狀態了**。\n\n由於前面錯誤訊息與錯誤狀態是一對一，所以把訊息當狀態好像也沒什麼毛病。\n\n但當今天錯誤狀態與錯誤畫面細節不是一對一的時候，問題就出現了。\n\n直接把畫面細節當狀態來存的時候，當未來需要根據狀態來判斷時，就會變得很麻煩。\n\n尤其是當一個錯誤可能又會出現多個提示的時候，錯綜復雜的關係，讓閱讀的人根本不可能從當前的提示組合中理解當前是處於什麼錯誤狀態。\n\n所以我們應該儲存的是**錯誤狀態**，而不是**畫面細節**。\n\n# **更好的做法**\n\n了解問題之後，其實解法也就顯而易見，我們在 _OtpPageState 中應該存的是錯誤狀態，而不是錯誤訊息。\n\n```dart\nenum OtpError {\n  invalidOtp,\n  expiredOtp,\n}\n\nclass _OtpPageState extends State<OtpPage> {\n  OtpError? otpError;\n  String otpCode = \"\";\n  String phoneNumber = \"0912345678\";\n\n  Future<void> _verifyOtp(String otp) async {\n    try {\n      await otpService.verify(otp);\n    } catch (e) {\n      setState(() {\n        if (e.code == 'INVALID_OTP') {\n          otpError = OtpError.invalidOtp;\n        } else if (e.code == 'EXPIRED_OTP') {\n          otpError = OtpError.expiredOtp;\n        }\n      });\n    }\n  }\n\n  String? get errorMessage {\n    switch (otpError) {\n      case OtpError.invalidOtp:\n        return \"OTP 驗證碼錯誤，請重新輸入\";\n      case OtpError.expiredOtp:\n        return \"OTP 驗證碼已過期\";\n      default:\n        return null;\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          onChanged: (value) => otpCode = value,\n          decoration: InputDecoration(\n            hintText: \"請輸入 OTP 驗證碼\",\n            border: OutlineInputBorder(\n              borderSide: BorderSide(。\n                color: otpError == OtpError.invalidOtp ?\n                  Colors.red :\n                  Colors.black,\n              ),\n            ),\n          ),\n        ),\n        ElevatedButton(\n          onPressed: () => _verifyOtp(otpCode),\n          child: Text(\"驗證\"),\n        ),\n        if (errorMessage != null)\n          Text(\n            errorMessage!,\n            style: TextStyle(color: Colors.red),\n          ),\n      ],\n    );\n  }\n}\n```\n\n使用 enum 來儲存錯誤狀態之後，我們要拿這個錯誤狀態來衍生更多不同的顯示，就更容易的。\n\n當然錯誤不一定得用 enum 來表示，這部分就得視需求來決定。\n\n但重點是儲存錯誤狀態，能讓看的人更容易理解程式碼的邏輯。\n\n# **結語**\n\n避免把細節當狀態，是寫出易讀、易維護程式碼的重要概念。\n\n當你發現自己在用字串比對、或是用畫面顯示的內容做邏輯判斷時，就要停下來想想：我儲存的是系統狀態，還是畫面細節？\n\n存正確的狀態不只能讓讀的人更容易理解，也增加未來修改彈性。\n\n記住：**狀態管理的核心，是管理系統的真實狀況，而不是管理畫面的呈現細節。**\n\n在 Flutter 開發中，合理運用 enum、class 和狀態管理工具，可以讓你的程式碼更清晰、更容易測試和維護。",
      "createdAt": "July 7, 2025 10:48 PM",
      "updatedAt": "October 24, 2025 5:06 PM",
      "id": "2298303f78f7807fb25ff4f4fad22b5b",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "避免隱晦的程式邏輯 - 避免把細節當狀態 2298303f78f7807fb25ff4f4fad22b5b.md"
    },
    {
      "title": "避免隱晦的程式邏輯 - Index",
      "summary": "在開發過程中，我們會使用各種資料結構來表示不同類型的資料，例如 List、Set、Map 等。List 作為一種有序的元素集合，允許重複元素，並提供基於索引（Index）的存取方式，適用於需要保持元素順序的場景。在程式中，我們經常需要與 List 互動，例如取出所有資料來顯示，或對 List 進行篩...",
      "content": "![](https://images.unsplash.com/photo-1466781783364-36c955e42a7f?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n在開發過程中，我們會使用各種資料結構來表示不同類型的資料，例如 List、Set、Map 等。List 作為一種有序的元素集合，允許重複元素，並提供基於索引（Index）的存取方式，適用於需要保持元素順序的場景。在程式中，我們經常需要與 List 互動，例如取出所有資料來顯示，或對 List 進行篩選 (`where`) 與轉換 (`map`) 等操作。\n\n大多數情況下，對 List 的操作並不複雜，程式碼的可讀性也不會受到影響。然而，某些特定的寫法可能會降低可讀性，尤其是當我們使用索引來存取 List 時，可能會帶來潛在的問題。今天我們就來看看這些情況。\n\n# **使用 Index 表示資料**\n\n在較舊的開發方式中，為了避免 API 直接暴露資料的屬性，可能會讓 API 回傳一個 JSON 陣列，其中每個位置代表某個特定的資料屬性。例如：\n\n```\n[123, \"Jonh\", 27, \"john@gamil.com\", \"male\"]\n```\n\n當客戶端接收到這樣的回應時，必須透過 Index 來解析資料：\n\n```\nFuture<User> getUser() async {\n  final data = await api.get(\"/user\").data;\n  return User.from(\n    id: data[0],\n    name: data[1],\n    age: data[2],\n    email: data[3],\n    gender: data[4],\n  );\n}\n```\n\n類似地，當某個方法需要回傳多個值時，我們可能會選擇用 List 來存放結果，讓呼叫端透過 Index 來取出對應的值：\n\n```\nWidget build(BuildContext context) {\n  final results = summarizeFee(orders);\n  return Column(\n    children: [\n      Text(\"Price ${result[0].toString()}\"),\n      Text(\"Fee ${result[1].toString()}\"),\n    ],\n  );\n}\n\nList<int> summarizeFee(List<Order> orders) {\n  var price = 0;\n  var fee = 0;\n\n  for (var order in orders) {\n    price += order.price;\n    fee += order.fee;\n  }\n\n  return [price, fee];\n}\n```\n\n在這些例子中，當我們閱讀 `data[0]` 或 `results[0]` 時，完全無法從字面上理解它們的意義，必須對照命名參數或其他使用處，才能弄清楚這些 Index 所代表的資訊。\n\n那要如何解決呢？\n\n以第一個例子來說，即便使用 List 避免了直接暴露屬性名稱，但這種方法終究是「防君子不防小人」，沒有太大的實際意義，就盡量避免使用。而對於回傳多個值的情境，我們可以改用更具可讀性的方式，例如使用具名類別或 [Record](https://dart.dev/language/records) 來改善可讀性：\n\n```\n({int price, int fee}) summarizeFee(List<Order> orders) {\n  var price = 0;\n  var fee = 0;\n  for (var order in orders) {\n    price += order.price;\n    fee += order.fee;\n  }\n  return (price: price, fee: fee);\n}\n```\n\n接著我們來看看另一個 Index 造成的問題。\n\n# **Index 判斷**\n\n在以下程式碼中，我們根據 `index` 是否為 `0` 來決定是否要顯示標題：\n\n```\nWidget build(BuildContext context) {\n  return Column(\n    children: users.mapIndexed((index, user) {\n      return Column(\n        children: [\n          if (index == 0)\n            Text(\"User List Title\"),\n          Text(user.name),\n        ]\n      );\n    }).toList(),\n  );\n}\n```\n\n乍看之下，這段程式碼可能不容易理解為何會有這個判斷條件。但細看後會發現，這是為了讓標題只顯示一次。\n\n與其依賴 Index 來決定顯示標題的時機，我們可以直接將標題作為 `Column` 的第一個子元素，如下所示：\n\n```\nWidget build(BuildContext context) {\n  return Column(\n    children: [\n      Text(\"User List Title\"),\n      ...users.map((user) {\n        return Text(user.name);\n      }),\n    ],\n  );\n}\n```\n\n這樣的寫法不僅更直覺，也更清楚地表達了「標題應該只顯示一次，並位於使用者名稱清單的最上方」。\n\n然而，這仍然不完全等價於原始程式碼。原始版本的邏輯還包括「當 `users` 為空時，不應顯示標題」。因此，我們可以進一步調整程式碼，使其更明確地表達這一邏輯：\n\n```\nWidget build(BuildContext context) {\n  if (users.isEmpty) {\n    return SizedBox.shrink();\n  }\n\n  return Column(\n    children: [\n      Text(\"User List Title\"),\n      ...users.map((user) {\n        return Text(user.name);\n      }),\n    ],\n  );\n}\n```\n\n如此一來，讀者能夠一眼看出程式的意圖：標題僅在 `users` 非空時顯示，並且只會出現一次。\n\n# **小結**\n\n使用 Index 並非絕對不妥，而是應視情境而定。我們應該考慮索引是否真正表達了程式的意圖，還是讓讀者需要額外推理才能理解它的用途。透過適當的資料結構與語法特性，我們可以讓程式碼更易讀、更容易維護。",
      "createdAt": "March 9, 2025 3:15 PM",
      "updatedAt": "October 24, 2025 5:12 PM",
      "id": "1b18303f78f780719e3af619d44bc33f",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "避免隱晦的程式邏輯 - Index 1b18303f78f780719e3af619d44bc33f.md"
    },
    {
      "title": "避免隱晦的程式邏輯",
      "summary": "在開發中，我們為了完成某項功能的細部行為，可能會有很多種做法，如何評估哪種作法更好呢？其中一項準則就是清楚呈現邏輯。當程式碼能夠清楚呈現邏輯時，往後其他人在閱讀程式碼時，就能更快的了解其意圖。 就同如《先整理一下？》所提到的：「作者只有一個，但讀者通常會有很多個」，如果把邏輯用隱晦的方式完成，我們很...",
      "content": "![](https://images.unsplash.com/photo-1756253665162-c2fe14ad0caa?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n在開發中，我們為了完成某項功能的細部行為，可能會有很多種做法，如何評估哪種作法更好呢？其中一項準則就是清楚呈現邏輯。當程式碼能夠清楚呈現邏輯時，往後其他人在閱讀程式碼時，就能更快的了解其意圖。\n\n就同如《先整理一下？》所提到的：「作者只有一個，但讀者通常會有很多個」，如果把邏輯用隱晦的方式完成，我們很難保證每個人對都能理解這段邏輯的意圖，而呈現意圖也是 Kent Beck 簡單設計中的一項原則。\n\n## 舉個例子\n\n假設畫面有兩個彈跳視窗 A 與 B，這兩個彈跳視窗有些規則，規則如下：\n\n- 系統會先顯示彈跳視窗 A，接著才顯示彈跳視窗 B。\n- 如果使用者已經看過了彈跳視窗 A，則 A **此後都不再顯示**。\n- 如果使用者**今天**看過了彈跳視窗 B，則 B **今天不再顯示**。\n\n根據這三個規則，我們可以很容易地寫出類似下方這樣的程式碼：\n\n( 這裡讓我們先暫時忽略持久化的部分，畢竟這不是重點 )\n\n```dart\nFuture<void> showPopups() async {\n\tif (!hasPopupAShow) {\n\t\tawait showPopupA();\n\t\thasPopupAShow = true;\n\t}\n\n\tif (popupBShowDate != today()) {\n\t\tawait showPopupB();\n\t\tpopupBShowDate = today();\n\t}\n}\n\n```\n\n這段程式碼也完整地呈現了上述的三的規則。\n\n## 事情發生了改變\n\n若是今天需求發生了變化，在這兩個彈窗之間，又新增了一條規則\n\n- 如果使用者今天看過了 A，今天之內就不要再看到 B 了。\n\n那我們應該如何調整呢？觀眾們也可以先想想看，若是自己來處理的話，會怎麼做。\n\n![1737783415192.png](%E9%81%BF%E5%85%8D%E9%9A%B1%E6%99%A6%E7%9A%84%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF/1737783415192.png)\n\n## 一種作法\n\n一種作法是，我們可以在看完 A 的時候，順手把 B 的 popupBShowDate 也順手設了，這樣一來，當檢查到 B 的時候，自然也就會不打開 B。這個作法相當簡單，不要改動太多程式碼，只要僅僅多家一行程式碼就能完成，省時又省力。\n\n```dart\nFuture<void> showPopups() async {\n\tif (!hasPopupAShow) {\n\t\tawait showPopupA();\n\t\thasPopupAShow = true;\n\t\tpopupBShowDate = today();\n\t}\n\n\tif (popupBShowDate != today()) {\n\t\tawait showPopupB();\n\t\tpopupBShowDate = today();\n\t}\n}\n\n```\n\n這種作法乍聽起來也很自然：看了 A 之後，就當作 B 也看過了，但若是仔細想想，真的是這樣嗎？\n\n但若是對於作者以外的人來說，如果對這個功能不是很了解，在爬 Code 看到這段的時候，就可能很難聯想為什麼 A 看完之後，要同時把 B 的時間也設定了，也就更難推論出當初的作法：看過 A 之後，今天之內就不要再看到 B 了 的行為。\n\n## 另一種作法\n\n讓我們來看看另外一種作法：把 A 的彈窗顯示紀錄從 bool 改成 DateTime，當看過 A 之後，紀錄 A 看過的時間。\n\n接著我們就在能檢查 B 彈窗的時候，確認只有在今天都還沒看過 A 與 B 兩個彈窗時，才顯示 B。\n\n```dart\nFuture<void> showPopups() async {\n\tif (popupAShowDate == null) {\n\t\tawait showPopupA();\n\t\tpopupAShowDate = today();\n\t}\n\n\tif (popupBShowDate != today() && popupAShowDate != today()) {\n\t\tawait showPopupB();\n\t\tpopupBShowDate = today();\n\t}\n}\n\n```\n\n相比於第一個作法，我們可以更清楚在邏輯中展示 A 與 B 之間的關係，向讀者說明若是今天看過 A，就不要再顯示 B 了。\n\n雖然第二種寫法看起來比較囉唆，需要的改動也比較多，但是他能更準確地從 if 條件中看出 B 的顯示邏輯。\n\n看完兩種作法之後，不知道你喜歡哪種呢？或者你有更好的作法，歡迎留言交流分享。\n\n## 小結\n\n無論第一種作法或第二種，我們都能完成功能。在完成功能之後，我們還得花時間看看我們的程式碼，確認程式碼是否符合各種設計原則，透過不斷重構，讓程式碼不斷演化的過程中，能維持品質，支持後續的改動。\n\n年節已到，祝大家新年快樂。",
      "createdAt": "January 25, 2025 2:35 PM",
      "updatedAt": "October 24, 2025 5:13 PM",
      "id": "1868303f78f78085ae92e639d0bdfac2",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "避免隱晦的程式邏輯 1868303f78f78085ae92e639d0bdfac2.md"
    },
    {
      "title": "Container - 一個你最熟悉又最陌生的 Widget",
      "summary": "AI summary: Container 在 Flutter 中的行為複雜，設定大小後會拉大子 Widget，使用 alignment 可以解決此問題。深入了解 Container 的 build 方法和原始碼有助於開發者更有效地處理佈局問題。 每次在開發的時候，碰到不如預期的狀況時，都是一個非常...",
      "content": "AI summary: Container 在 Flutter 中的行為複雜，設定大小後會拉大子 Widget，使用 alignment 可以解決此問題。深入了解 Container 的 build 方法和原始碼有助於開發者更有效地處理佈局問題。\n\n![](https://images.unsplash.com/photo-1493946740644-2d8a1f1a6aff?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n每次在開發的時候，碰到不如預期的狀況時，都是一個非常好的機會，可以讓我們更深了解某些事。\n\n最近在開發的時候又碰到一些意料之外的事，經過一些實驗，終於定位了問題點。\n\n讓我們看看以下這段程式碼，在這段程式碼中，我們指定了 Container 的大小為 300 x 300，同時也指定 child 中的 Image 大小為 30 x 30。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: Image.asset(\n    \"assets/images/blog.png\",\n    width: 30,\n    height: 30,\n  ),\n)\n```\n\n大家可以在腦海中想像一下，這段程式碼在畫面中會呈現成什麼樣子？是否會覺得下圖這樣呢？\n\n![align_center.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/align_center.png)\n\n但結果卻是 Container 把 Image 也拉大到 300 x 300 了。\n\n![no_align.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/no_align.png)\n\n觀眾們可能會想，都設定圖片大小了，怎麼還是會被放到最大呢？\n\n顯然肯定有個人在搞鬼，今天就來看看這個搞鬼的人：**Container**。\n\n## Container 的行為\n\nContainer 作為開發 Flutter App 最常用的 Widget 之一，其實有著相當複雜的行為。如果我們看到[官方文件](https://api.flutter.dev/flutter/widgets/Container-class.html)，會發現其中有一段文字在描述 Container 的行為。\n\nContainer 的佈局行為按以下順序進行：\n\n- 優先遵循 `alignment`。\n- 根據 child 的大小來決定自身大小。\n- 遵循 `width`、`height` 和 `constraints`\n- 擴展以適配父級大小。\n- 嘗試盡量小化自身大小。\n\n若是調整一下剛剛的例子，把 `width` 與 `height` 拿掉。\n\n```dart\nContainer(\n  color: Colors.pinkAccent,\n  child: Image.asset(\n    \"assets/images/blog.png\",\n    width: 30,\n    height: 30,\n  ),\n)\n```\n\n此時就會發現，Container 就遵循了第二條規則：**根據 child 大小來決定自身大小**。\n\n![截圖 2024-12-19 晚上11.33.09.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.33.09.png)\n\n設定了 `width` 與 `height` 後，到底實際發生了什麼事呢？讓我們深入 Container 的 build 方法一探究竟。\n\n## Container 的 build 方法\n\n當我們設定了 `width` 或 `height` 而沒有給 `constraints` 時，實際上 Container 會幫我們生成一個 `BoxConstraints.tightFor(width: width, height: height)`。\n\n```dart\nContainer({\n    // 省略...\n  }) : // 省略 ...,\n       constraints =\n        (width != null || height != null)\n          ? constraints?.tighten(width: width, height: height)\n            ?? BoxConstraints.tightFor(width: width, height: height)\n          : constraints;\n\n```\n\n`tighFor` 方法會限制 Widget 的大小，指定 Widget 的寬高，那這個 BoxConstraints 會用在哪邊呢？\n\n```dart\nconst BoxConstraints.tightFor({\n    double? width,\n    double? height,\n  }) : minWidth = width ?? 0.0,\n       maxWidth = width ?? double.infinity,\n       minHeight = height ?? 0.0,\n       maxHeight = height ?? double.infinity;\n\n```\n\n在 build 方法中，我們可以看到剛剛的 constraints 被放在 ConstrainedBox 中，用來限制 Container 的子 Widget。以上面的例子來說，被限制的 Widget 就是放入的 child 的 Image。\n\n```dart\n@override\nWidget build(BuildContext context) {\n  // Container 的 build 方法\n  // 省略 ...\n\n  if (constraints != null) {\n    current = ConstrainedBox(constraints: constraints!, child: current);\n  }\n\n  // 省略 ...\n\n  return current!;\n}\n```\n\n所以也就使得了 Image 被拉到與 Container 一樣大小。\n\n## 使用 alignment\n\n熟悉 Flutter 的開發人員肯定對這狀況也不陌生，知道加上 alignment 參數就能解決問題。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  alignment: Alignment.center,\n  child: Image.asset(\n    \"assets/images/blog.png\",\n    width: 30,\n    height: 30,\n  ),\n)\n\n```\n\n那為什麼在 Container 中加上 `alignment` 時，圖片就能維持當初設定的大小呢？讓我們再次看回 Container 的 build 方法中。\n\n```dart\n@override\nWidget build(BuildContext context) {\n  // Container 的 build 方法\n  // 省略 ...\n\n  if (child == null && (constraints == null || !constraints!.isTight)) {\n    // 省略 ...\n  } else if (alignment != null) {\n    current = Align(alignment: alignment!, child: current);\n  }\n\n  // 省略 ...\n\n  if (constraints != null) {\n    current = ConstrainedBox(constraints: constraints!, child: current);\n  }\n\n  // 省略 ...\n\n  return current!;\n}\n\n```\n\n當 `alignment` 不為 null 時，就會在 child 外面包上一層 Align，接著才是在 Align 外面再包上 ConstrainedBox。這樣一來，就使得實際被拉大的是 Align，而非 Image。\n\n如果有認真看 Container 原始碼的觀眾可能會問，即便我沒有設定 `alignment`，但我有設定 `color`，而 ConstrainedBox 的下一層 child 應該是 ColoredBox，所以要拉大也是拉大 ColoredBox，而不應該是 Image 吧？\n\n```dart\n@override\nWidget build(BuildContext context) {\n  // Container 的 build 方法\n  // 省略 ...\n\n  if (child == null && (constraints == null || !constraints!.isTight)) {\n    // 省略 ...\n  } else if (alignment != null) {\n    current = Align(alignment: alignment!, child: current);\n  }\n\n  if (color != null) {\n    current = ColoredBox(color: color!, child: current);\n  }\n\n  // 省略 ...\n\n  if (constraints != null) {\n    current = ConstrainedBox(constraints: constraints!, child: current);\n  }\n\n  // 省略 ...\n\n  return current!;\n}\n```\n\n的確，ColoredBox 確實會被拉大，但是 ColoredBox 也直接把上頭來的 constraints 直接轉送給了他的 child。在這兩種狀況中，雖然 Image 上層還有其他 Widget，但是卻有不同的結果。\n\n若繼續深入 Align 與 ColoredBox 的佈局方式，很快就有答案了。\n\n一路追蹤 ColoredBox 的原始碼：ColoredBox -> _RenderColoredBox -> RenderProxyBoxWithHitTestBehavior -> RenderProxyBox，最後可以發現 ColoredBox 繼承了 RenderProxyBox。在 RenderProxyBox 的佈局中，其實也就只是把自己收到的限制，直接原封不動的傳給子 Widget，所以即便中間多墊了一層 ColoredBox，也不能避免 Image 被拉大的效果。\n\n```dart\n@override\nvoid performLayout() {\n  size = (child?..layout(constraints, parentUsesSize: true))?.size\n      ?? computeSizeForNoChild(constraints);\n  return;\n}\n```\n\n接著看到 Align，Align 繼承了 RenderPositionedBox。在 RenderPositionedBox 的佈局中，我們可以發現，它從上頭接收到了限制，接著轉頭就將限制放寬，讓子 Widget 可以挑選他希望的大小。所以在 Align 中，Image 可以維持當初設定的 30 x 30 的大小。\n\n```dart\n@override\nvoid performLayout() {\n  final BoxConstraints constraints = this.constraints;\n\n  // 省略 ...\n\n  if (child != null) {\n    child!.layout(constraints.loosen(), parentUsesSize: true);\n\n    // 省略 ...\n\n  } else {...}\n}\n```\n\n## 實驗放入不同的 Widget\n\n最後讓我們做一些實驗，如果採用相同 Container 設定，但是在 child 中放入不同東西，看看會發生什麼事？\n\n### 放入指定大小的 Container\n\n與 Image 一樣，放入了指定大小的 Container，結果這個 Container 還是被拉大到 300 x 300。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: Container(\n    width: 100,\n    height: 100,\n    color: Colors.blueAccent,\n  ),\n)\n```\n\n![截圖 2024-12-19 晚上11.43.51.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.43.51.png)\n\n### 放入 TextButton\n\n乍看之下，放入的 TextButton 好像沒被拉大，但實際上卻是有的，我們可以從 Hover 效果看出，按鈕還是被拉大了。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: TextButton(\n    onPressed: () {},\n    child: const Text('Click me'),\n  ),\n)\n```\n\n![截圖 2024-12-19 晚上11.47.46.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.47.46.png)\n\n### 放入 Text\n\n當我們試到 Text 的時候，卻發現 Text 好像就沒被拉大的問題，這又是怎麼一回事呢？\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: const Text(\"Hello World\"),\n)\n```\n\n![截圖 2024-12-19 晚上11.35.25.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.35.25.png)\n\n關於這個問題，有機會再讓我們深入探討，好奇的觀眾也可以先自行研究看看。\n\n## 小結\n\nContainer 做為我們最常使用的 Widget 之一，了解他如何運作對於開發必然有些幫助。雖然不是每天都會碰到 Widget 排版不如預期的問題，但是每次碰上就會相當困擾，需要花許多時間嘗試才能解決。\n\n追蹤原始碼，了解 Widget 底層的運作邏輯，能夠提供我們更多解決問題的思路。當未來碰上問題時，就能用正確又快速的方式解決，而不是留下更多的 Workaround。",
      "createdAt": "December 24, 2024 12:10 AM",
      "updatedAt": "October 24, 2025 5:15 PM",
      "id": "1658303f78f780648388f15ef489fe47",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Container - 一個你最熟悉又最陌生的 Widget 1658303f78f780648388f15ef489fe47.md"
    },
    {
      "title": "自製 Flutter Tab Bar - 深入底層更新機制",
      "summary": "AI summary: 本文探討了 Element 更新機制，並分析 Row + Expanded 與 AnimatedSize 無法正常運作的元因。最後提供了兩種解決方案：使用 Expanded 並將 flex 設為 0，或使用 GlobalObjectKey。 這個系列終於迎來最終回了，為了完成...",
      "content": "AI summary: 本文探討了 Element 更新機制，並分析 Row + Expanded 與 AnimatedSize 無法正常運作的元因。最後提供了兩種解決方案：使用 Expanded 並將 flex 設為 0，或使用 GlobalObjectKey。\n\n![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%A4%E6%9B%B4%E6%96%B0%E6%A9%9F%E5%88%B6/image.png)\n\n這個系列終於迎來最終回了，為了完成下圖這個特別的 Tab Bar 動畫效果，我們最初直接使用 CustomMultiChildLayout 來完成，但是也同時好奇為什麼 Row + Expanded + AnimatedSize 做不到一樣效果，所以在上一篇文章中分析了 Row 的佈局邏輯。\n\n![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%A4%E6%9B%B4%E6%96%B0%E6%A9%9F%E5%88%B6/image%201.png)\n\n但是在研究 Row 的過程中，卻發現事情跟想像中的不同。以 Row 的佈局邏輯來說，應該要能完美的配合 AnimatedSize 的動畫，讓 AnimatedSize 中子 Widget 在大小有所變化時，可以順暢地以動畫的方式呈現。\n\n但是當實際使用了 Row + Expanded 包在 AnimatedSize 外面時，效果並不如預期。當狀態改變時，AnimatedSize 中的 Tab 卻是一瞬間縮小，而不是以動畫形式變小。\n\n![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%A4%E6%9B%B4%E6%96%B0%E6%A9%9F%E5%88%B6/image%202.png)\n\n```dart\nRow(\n  children: [\n    for (int index = 0; index < tabLength; index++)\n      currentIndex == index\n          ? AnimatedSize(\n            duration: const Duration(milliseconds: 300),\n            child: _SelectedTab(index: index),\n          )\n          : Expanded(\n              child: AnimatedSize(\n                duration: const Duration(milliseconds: 300),\n                child: GestureDetector(\n                  onTap: () => setState(() => currentIndex = index),\n                  child: _UnselectedTab(index: index),\n                ),\n              ),\n            )\n  ],\n)\n```\n\n那這是為什麼呢？明明 Row 沒有限制子 Widget 大小，為什麼選中的 Tab 沒有按照預期的用動畫變大變小呢？\n\n答案其實是：**因為被選中的 Tab 沒被 Expanded 包住**。\n\n對 Flutter 不熟悉的觀眾可能會滿頭問號，為什麼沒有被 Expanded 包住會造成問題？而且如果要用 Expanded 包住被選中的 Tab，我們又要如何不限制選中的 Tab 大小？\n\n讓我們來一一解答這些問題吧。\n\n## Element Tree 的更新邏輯\n\n首先，對 Flutter 有研究的觀眾多少都會知道，Flutter 框架底層維護了三顆樹：Widget Tree、Element Tree 與 RenderObject Tree，他們分別掌管了不同職責。\n\n其中 Element 負責管理 Widget 與 RenderObject，當狀態改變時，能有效的因應變化，只調整有改變的部分，避免頻繁的重建 Element，進而提高效能。\n\n當畫面需要更新時，Element 會從需要更新的 Element 開始，一路往子 Element 更新。\n\n當更新某個 Element 時，Element 中的 `updateChild` 方法就會被呼叫，用來處理當前 Element 的下一層節點結構變化。在 `updateChild` 方法的上方也有一大段註釋在解釋其運作邏輯，其中包含了一段表格，用來展示幾種更新的狀況。\n\n```markdown\n|                 |   newWidget == null    |       newWidget != null          |\n| :-------------: | :--------------------- | :------------------------------- |\n|  child == null  |  Returns null.         |  Returns new [Element].          |\n|                 |                        |                                  |\n|  child != null  |  Old child is removed, | Old child updated if possible,   |\n|                 |  returns null.         | returns child or new [Element].  |  \n```\n\n表格中的 child 是指當前更新中的 Element 的子節點，而 newWidget 則是打算新增進來的 Widget。讓我們看個簡單的例子，假設我們在畫面中存在著一個 Text，這個 Text 會隨著不同的狀態而出現底色。\n\n```dart\nclass _MyTextState extends State<MyText> {\n  bool isHighlight = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () => setState(() => isHighlight = !isHighlight),\n      child: isHighlight\n          ? Container(color: Colors.red, child: const Text(\"Hello World\"))\n          : const Text(\"Hello World\"),\n    );\n  }\n}\n\n```\n\n若當前 isHighlight 為 false，畫面中的 Text(\"Hello World\") 也沒有任何底色。接著下一秒程式呼叫了 setState 並將 isHighlight 更新為 true。GestureDetector 的子 Widget 也從 Text 改變成 Container。\n\n此時 GestureDetector 的 Element 的 updateChild 方法就會被呼叫到，帶進來的 child 就是 Text，而 newWidget 則是 Container。（註：事實上，GestureDetector 並非 Text 的父母，而是祖父母，因為 GestureDetector 中還包了許多其他 Widget，這裡為了說明方便而簡化。）\n\n```dart\nElement? updateChild(Element? child, Widget? newWidget, Object? newSlot) {\n    ...\n}\n```\n\n按照上面表格的邏輯 child 不為 null，newWidget 也不為 null，就會走到 **Old child updated if possible, returns child or new [Element]** 這段分支。這段邏輯分支主要由三個 if 判斷實現，第一個 if 會比較 child.widget 與 newWidget 是否相同，這裡比較的是兩者是否是相同實例。通常如果使用 const 的 Widget 就會直接落入這個 if 條件中。\n\n```dart\nif (hasSameSuperclass && child.widget == newWidget) {\n  if (child.slot != newSlot) {\n    updateSlotForChild(child, newSlot);\n  }\n  newChild = child;\n}\n```\n\n若以上面的範例來說，child.widget 是 Text，而 newWidget 則是 Container。兩者類別都不同了，更別提是否是相同實例了。（註：以下 `updateChild` 方法邏輯經過簡化，原始碼可以參考[這邊](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart)。）\n\n接著看到下一段 if 判斷，判斷是否可以透過更新 Element 來避免建立新 Element。\n\n```dart\nif (hasSameSuperclass && child.widget == newWidget) {\n  // 省略...\n} else if (hasSameSuperclass && Widget.canUpdate(child.widget, newWidget)) {\n  if (child.slot != newSlot) {\n    updateSlotForChild(child, newSlot);\n  }\n  child.update(newWidget);\n  newChild = child;\n}\n```\n\n在這個 if 判斷中，最主要的判斷由 `Widget.canUpdate` 決定，來看一下 `Widget.canUpdate` 的邏輯。\n\n```dart\nabstract class Widget extends DiagnosticableTree {\n  static bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n  }\n}\n```\n\n帶入上面的範例後，我們會發現 oldWidget (Text) 的 runtimeType 與 newWidget (Container) 的 runtimeType 不同了，所以也無法直接更新 Element。\n\n至此也只有最後一條路可以走，也就是建立新的 Element，這邊再往下走就會先停用當前的 Element，接著在 inflateWidget 方法中呼叫 Widget 身上的 createElement 方法來建立新的 Element。\n\n```dart\nif (hasSameSuperclass && child.widget == newWidget) {\n  // 省略...\n} else if (hasSameSuperclass && Widget.canUpdate(child.widget, newWidget)) {\n  // 省略...\n} else {\n  deactivateChild(child);\n  newChild = inflateWidget(newWidget, newSlot);\n}\n```\n\n至此我們應該可以回答：**為什麼被選中的 Tab 沒被 Expanded 包住會造成 AnimatedSize 失效**，其實原因就是因為 AnimatedSize 重建了。那 AnimatedSize 被重建為什麼會造成動畫失效呢？其實原因也很好想像 AnimatedSize 若想要有動畫效果，他就必須有**改變前的狀態**與**改變後的狀態**，這樣才能夠知道要變大還是變小。\n\n假設當前 AnimatedSize 的寬度為 10，setState 後變成 20，AnimatedSize 就會知道要從寬度要從 10 慢慢變化成 20。但是如果是重建 AnimatedSize 的情況，AnimatedSize 就不會有 10 的資訊，而是重新建了一個寬度為 20 的 AnimatedSize，自然也就不會有動畫。\n\n往後有機會的話，我們再來深入 Animated 系列 Widget 是怎麼製作的，現在先讓我們看看要怎麼解決這個問題呢？這邊有兩個方法。\n\n## 使用 Expanded 包住被選中的 Tab\n\n可能有觀眾會好奇，用 Expanded 包住被選中的 Tab 的話，那我們還怎麼實現想要的效果呢？答案其實在上一篇文章中也有提到，其實就把 flex 設為 0 就好。在 flex 設為 0 的狀態下，Row 就會給該 Widget 任意大小的空間，讓 Widget 佔住他需要的大小。\n\n同時也因為包了 Expanded，所以在 Element 更新子節點的邏輯中，就能在 Widget.canUpdate 的邏輯中被判斷為可更新，進而避免重建。\n\n```dart\nRow(\n  children: [\n    for (int index = 0; index < tabLength; index++)\n      currentIndex == index\n          ? Expanded(\n              flex: 0,\n              child: AnimatedSize(\n                duration: const Duration(milliseconds: 300),\n                child: _SelectedTab(index: index),\n              ),\n            )\n          : Expanded(\n              child: AnimatedSize(\n                duration: const Duration(milliseconds: 300),\n                child: GestureDetector(\n                  onTap: () => setState(() => currentIndex = index),\n                  child: _UnselectedTab(index: index),\n                ),\n              ),\n            )\n  ],\n)\n```\n\n## 使用 GlobalObjectKey\n\n除了使用 Expanded + flex 為 0 的設定之外，我們還能使用 GlobalKey 來避免 Widget 重建的問題。使用了 GlobalKey，在 Element 更新子節點時，就能透過 GlobalKey 來辨識 Element 是否已經建立過，進而重複使用先前已經建好的 Element。\n\n```dart\nRow(\n  children: [\n    for (int index = 0; index < tabLength; index++)\n      currentIndex == index\n          ? AnimatedSize(\n            key: GlobalObjectKey(index),\n            duration: const Duration(milliseconds: 300),\n            child: _SelectedTab(index: index),\n          )\n          : Expanded(\n              child: AnimatedSize(\n                key: GlobalObjectKey(index),\n                duration: const Duration(milliseconds: 300),\n                child: GestureDetector(\n                  onTap: () => setState(() => currentIndex = index),\n                  child: _UnselectedTab(index: index),\n                ),\n              ),\n            )\n  ],\n)\n```\n\n當 Widget 使用了 GlobalKey 之後，雖然在 updateChild 方法中依舊會走到 inflateWidget 嘗試重建 Element，但是在 inflateWidget 方法中，其實還有一場敗部復活賽。Element 會從被停用的子節點中，找尋是否有與新子節點一樣的 GlobalKey 的節點，如果有的話，就把它拿回來重複利用。\n\n## 小結\n\n從使用 CustomMultiChildLayout 自製 Widget，再到探索 Row 的佈局邏輯，輾轉之後，還帶著觀眾一起看了部分 Element 更新機制。雖然我們可能不太有機會修改到底層框架的機制，但是認識這些機制有助於我們在開發的時候提高程式運行效能，也能在碰到問題的時候，有更多資訊可以提供解決思路。\n\n## 參考連結\n\n- Element 原始碼：https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart",
      "createdAt": "December 4, 2024 10:24 PM",
      "updatedAt": "October 24, 2025 5:17 PM",
      "id": "1528303f78f780bfaaf3e3f295198061",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "自製 Flutter Tab Bar - 深入底層更新機制 1528303f78f780bfaaf3e3f295198061.md"
    },
    {
      "title": "自製 Flutter Tab Bar - 探索  Row 的佈局邏輯",
      "summary": "在上一篇文章中，我們製作 Tab Bar 時，曾嘗試使用 Row + Expanded 來完成，但是最終使用 AnimatedSize 套上動畫時，結果卻不如預期，Tab Bar 並沒有在切換 Tab 時顯示動畫，今天我們就來深入暸解到底發生了什麼。文章中，我們會分析 Row 的原始碼，了解 Row...",
      "content": "![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%8E%A2%E7%B4%A2%20Row%20%E7%9A%84%E4%BD%88%E5%B1%80%E9%82%8F%E8%BC%AF/image.png)\n\n在上一篇文章中，我們製作 Tab Bar 時，曾嘗試使用 Row + Expanded 來完成，但是最終使用 AnimatedSize 套上動畫時，結果卻不如預期，Tab Bar 並沒有在切換 Tab 時顯示動畫，今天我們就來深入暸解到底發生了什麼。文章中，我們會分析 Row 的原始碼，了解 Row 的行為，嘗試理解到底是哪邊有問題。\n\n## 軟體開發的抽象洩漏\n\n為什麼我們要研究底層框架的邏輯呢？我們用了框架，用了套件，不就是為了讓開發更容易嗎？我們不需要認識 Flutter 怎麼把文字、圖片顯示在畫面上，我們不需要事先了解隱藏在背後的複雜邏輯才能開始開發，只需要簡單的用 Widget 定義畫面細節，框架幫我們把這些複雜的邏輯簡化成易用的抽象操作，讓我們得以使用這些簡化的抽象操作迅速上手。\n\n確實在一開始，我們不需要知道這麼多就可以開發，但有時事實不如預期那樣發展，有一定經驗的開發者一定知道，若我們持續開發，總是會碰到一些不知道如何解決問題。例如：當 Container 放在 MaterialApp 的 home 時，無論 Container 寬高怎麼設定，最終 Container 最終都會跟畫面一樣大。又好比某個畫面在顯示的過程中卡頓不順暢時，我們如果對 Flutter 的渲染方式沒有一定了解，可能就沒有一個解決問題的方向。\n\n雖然框架與套件盡力的封裝複雜的操作，讓開發人員方便使用，但還是無可避免的會因為一些原因導致我們必須更深入了解實作細節，在 LeSS in Action 的課程中，老師就曾經提到這個問題，認為這是一種無可避免的抽象洩漏。所以身為一個開發人員，**我們必須持續學習，保持對事物的好奇心，探索事物的內在本質**，在未來的某一天，這些內功都會派上用場的。\n\n現在讓我們回歸正題，來一起研究 Row 的實作細節吧。\n\n## Row 的繼承關係\n\n首先打開 Row 的原始碼，我們可以發現它繼承了 Flex，Flex 有兩個實作，分別是大家都十分熟悉的 Row 與 Column，兩者差別其實只在於**方向**而已。\n\n```dart\nclass Row extends Flex {\n  const Row({\n    super.key,\n    super.mainAxisAlignment,\n    super.mainAxisSize,\n    super.crossAxisAlignment,\n    super.textDirection,\n    super.verticalDirection,\n    super.textBaseline,\n    super.children,\n  }) : super(\n    direction: Axis.horizontal,\n  );\n}\n\nclass Column extends Flex {\n  const Column({\n    super.key,\n    super.mainAxisAlignment,\n    super.mainAxisSize,\n    super.crossAxisAlignment,\n    super.textDirection,\n    super.verticalDirection,\n    super.textBaseline,\n    super.children,\n  }) : super(\n    direction: Axis.vertical,\n  );\n}\n```\n\n若是再往上延伸，就會看到 Flex 繼承了 MultiChildRenderObjectWidget，我們先前使用的 CustomMultiChildLayout 也同樣繼承了 MultiChildRenderObjectWidget。CustomMultiChildLayout 與 MultiChildRenderObjectWidget 的功能很像，前者只是把後者封裝成更簡單容易使用的 Widget。那 MultiChildRenderObjectWidget 是什麼呢？\n\n簡單來說，MultiChildRenderObjectWidget 接受一群 Widget 作為輸入，我們可以透過各種不同的實作來規劃這群 Widget 如何佈局，例如：使用 [Stack](https://api.flutter.dev/flutter/widgets/Stack-class.html) 決定每個 Widget 的位置，或是使用 [Row](https://api.flutter.dev/flutter/widgets/Row-class.html) 來橫向依序排列每個 Widget。\n\n在實作 MultiChildRenderObjectWidget 過程中， 具體實作類別會覆寫 createRenderObject 來建立各自對應的 RenderObject，用以實現剛剛提到的各種佈局邏輯。以 Flex 來說，createRenderObject 就會建立 RenderFlex，若想了解 Flex 的佈局邏輯，也就得深入研究 RenderFlex。\n\n```dart\nclass Flex extends MultiChildRenderObjectWidget {\n  @override\n  RenderFlex createRenderObject(BuildContext context) {\n    return RenderFlex(\n      direction: direction,\n      mainAxisAlignment: mainAxisAlignment,\n      mainAxisSize: mainAxisSize,\n      crossAxisAlignment: crossAxisAlignment,\n      textDirection: getEffectiveTextDirection(context),\n      verticalDirection: verticalDirection,\n      textBaseline: textBaseline,\n      clipBehavior: clipBehavior,\n    );\n  }\n}\n```\n\n註：接下來會看到許多像下方程式碼那樣的判斷方向邏輯，由於我們這邊先只有探討 Row 的行為，所以可以只看 Axis.horizontal 的邏輯即可。\n\n```dart\ndouble _getMainSize(Size size) {\n  return switch (_direction) {\n    Axis.horizontal => size.width,\n    Axis.vertical => size.height,\n  };\n}\n```\n\n## RenderFlex 如何限制子 Widget\n\n繞了一這麽大一圈，我們終於知道要去 RenderFlex 裡面找 Row 的佈局邏輯，那接著就能開始研究最初的問題：**為什麼 AnimatedSize 在 Row + Expanded 中不起作用呢？**\n\n在 RenderFlex 中，處理佈局的方法為 performLayout。在 performLayout 方法中，除去一些前置的狀態檢查邏輯之外，最先呼叫的是邏輯是 _computeSizes 方法。_computeSizes 最主要的任務就是處理「Constraints go down. Sizes go up.」，給定每個子 Widget 的限制，取回每個子 Widget 最終使用的大小。在 _computeSizes 方法中有幾段邏輯，讓我們一一細看。\n\n首先，透過 while 迴圈處理每一個子 Widget。這邊有段  if 邏輯，當子 Widget 的 flex 大於 0 的時候，並不會直接的使用 layoutChild 來決定子 Widget 的大小，而是只有在 flex 為 0 的時候，才會直接使用 layoutChild 來取得子 Widget 大小。\n\n設定 flex 的方式也就是我們熟悉的 Flexible 與 Expanded。\n\n```dart\nwhile (child != null) {\n  final FlexParentData childParentData = child.parentData! as FlexParentData;\n  final int flex = _getFlex(child);\n  if (flex > 0) {\n    totalFlex += flex;\n    lastFlexChild = child;\n  } else {\n    final BoxConstraints innerConstraints = switch ((stretched, _direction)) {\n      (true,  Axis.horizontal) => BoxConstraints.tightFor(height: constraints.maxHeight),\n      (true,  Axis.vertical)   => BoxConstraints.tightFor(width: constraints.maxWidth),\n      (false, Axis.horizontal) => BoxConstraints(maxHeight: constraints.maxHeight),\n      (false, Axis.vertical)   => BoxConstraints(maxWidth: constraints.maxWidth),\n    };\n    final Size childSize = layoutChild(child, innerConstraints);\n    allocatedSize += _getMainSize(childSize);\n    crossSize = math.max(crossSize, _getCrossSize(childSize));\n  }\n  assert(child.parentData == childParentData);\n  child = childParentData.nextSibling;\n}\n```\n\n這邊我們暫時假設 stretched 為 false，我們就能推算出：當我們使用 Row 並且沒有特別設定 flex 的話，RenderFlex 給的限制就是 BoxConstraints(maxHeight: constraints.maxHeight)。給定的 BoxConstraints 只設定了最大高度，沒有設定 maxWidth，使得子 Widget 可以在 0 到 double.infinity **之間選擇大小，簡而言之就是，愛多大就多大，甚至可能給出超過 Row 本身大小的 Size，也就會造成我們常見的跑版錯誤。\n\n## 子 Widget 加上 Flexible 時\n\n上面看到的邏輯分岔中，當 flex 大於 0 時，並不會直接使用 layoutChild 取得大小，而是只有記錄一下 totalFlex 與 lastFlexChild 就結束了，為什麼呢？原因應該也挺好想像的，因為使用了 flex 就表示我們要按比例來分配剩餘空間，我們肯定得先知道總共要**分成幾分**與**剩餘空間大小**，才能知道每個 Widget 要給多大。\n\n接著我們繼續往下看，在第二段 while 迴圈中，我們就能看到處理 flex 的邏輯了。在下方展示的邏輯中，minChildExtent 與 maxChildExtent 決定了寬度。當 fit 被設定為 FlexFit.tight 的時候，minChildExtent 也就等於 maxChildExtent，使得子 Widget 被強制為 maxChildExtent 大小。\n\n```dart\nwhile (child != null) {\n  final int flex = _getFlex(child);\n  if (flex > 0) {\n    final double maxChildExtent = switch (canFlex) {\n      true when child == lastFlexChild => freeSpace - allocatedFlexSpace,\n      true => spacePerFlex * flex,\n      false => double.infinity,\n    };\n    final double minChildExtent = switch (_getFit(child)) {\n      FlexFit.tight => maxChildExtent,\n      FlexFit.loose => 0.0,\n    };\n    assert(minChildExtent.isFinite);\n    final double minCrossSize = stretched ? _getCrossSize(constraints.biggest) : 0.0;\n    final BoxConstraints innerConstraints = switch (_direction) {\n      Axis.horizontal => constraints.copyWith(minHeight: minCrossSize, minWidth: minChildExtent, maxWidth: maxChildExtent),\n      Axis.vertical   => constraints.copyWith(minWidth: minCrossSize, minHeight: minChildExtent, maxHeight: maxChildExtent),\n    };\n    final Size childSize = layoutChild(child, innerConstraints);\n    final double childMainSize = _getMainSize(childSize);\n    assert(childMainSize <= maxChildExtent);\n    allocatedSize += childMainSize;\n    allocatedFlexSpace += maxChildExtent;\n    crossSize = math.max(crossSize, _getCrossSize(childSize));\n  }\n  final FlexParentData childParentData = child.parentData! as FlexParentData;\n  child = childParentData.nextSibling;\n}\n```\n\n那什麼時候 fit 會是 FlexFit.tight 呢？其實就是使用 Expanded 的時候。也就是說，當使用 Expanded 時，每個包了 Expanded 的子 Widget 會被強制依照 flex 比例分配剩餘空間，也就是 switch 邏輯中的 `spacePerFlex * flex`。\n\n```dart\nclass Expanded extends Flexible {\n  const Expanded({\n    super.key,\n    super.flex,\n    required super.child,\n  }) : super(fit: FlexFit.tight);\n}\n```\n\n而子 Widget 若是使用了 Flexible，並維持預設值，讓 fit 是 FlexFit.loose 時，Flex 會允許子 Widget 在 [ 0, `spacePerFlex * flex` ] 之間任意決定大小，並不像 Expanded 一樣強制撐到 flex 設定的比例。\n\n```dart\nclass Flexible extends ParentDataWidget<FlexParentData> {\n  const Flexible({\n    super.key,\n    this.flex = 1,\n    this.fit = FlexFit.loose,\n    required super.child,\n  });\n}\n```\n\n決定 flex > 0 的子 Widget 的大小之後，_computeSizes 的工作也基本完成。接下來的工作就是 Flex 如何安排每個子 Widget 的位置。到這邊我們已經基本了解 Row 如何設定子 Widget 的大小，我們也暫時獲得足夠的資訊來回答我們先前的問題，所以先讓我們暫停在這邊，剩餘的部分，有機會再讀者們分享。\n\n## 回顧 Row 的行為\n\n看到現在，讓我們快速回顧一下，當我們使用 Row 的時候，程式會優先計算沒有使用 flex 為 0 的子 Widget，並且讓這些子 Widget 想使用多大的空間就使用多大的空間。接著才是將剩餘的空間依比例分配給其他使用 Flexible 或 Expanded 設定 flex 的子 Widget。\n\n這裡其實有一件很有趣的事，假設 Row 中同時存在使用 Flexible 的子 Widget 與使用 Expanded 的子 Widget 時，如果使用 Flexible 的子 Widget 沒有用滿 flex 設定比例的空間，那剩下使用 Expanded 的子 Widget 如何分配剩餘空間呢？難道 Expanded 還得知道 Flexible 省下了多少空間沒用，進而把佔滿嗎？讓我們來實驗一下。\n\n首先是第一種情境：**Flexible 中的子 Widget 內容長到足以填滿 flex 設定的比例大小**。\n\n```dart\nRow(children: [\n  Expanded(\n    child: Container(color: Colors.red, child: const Text(\"Item 1\")),\n  ),\n  Expanded(\n    child: Container(color: Colors.green, child: const Text(\"Item 2\")),\n  ),\n  Flexible(\n    child: Container(color: Colors.blue, child: const Text(\"Long Long Long Long Long Item 3\")),\n  ),\n  Expanded(\n    child: Container(color: Colors.yellow, child: const Text(\"Item 4\")),\n  ),\n])\n```\n\n運行之後我們可以發現，畫面確實如預期一樣的平均分配了子 Widget 的空間。在這個情況中 Flexible 跟 Expanded 一起平均分配了空間。\n\n![截圖 2024-11-17 下午5.00.04.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%8E%A2%E7%B4%A2%20Row%20%E7%9A%84%E4%BD%88%E5%B1%80%E9%82%8F%E8%BC%AF/%25E6%2588%25AA%25E5%259C%2596_2024-11-17_%25E4%25B8%258B%25E5%258D%25885.00.04.png)\n\n接著是讓我們看看另外一個狀況：**Flexible 中的子 Widget 內容不足以填滿 flex 設定的比例大小**。\n\n```dart\nRow(children: [\n  Expanded(\n    child: Container(color: Colors.red, child: const Text(\"Item 1\")),\n  ),\n  Expanded(\n    child: Container(color: Colors.green, child: const Text(\"Item 2\")),\n  ),\n  Flexible(\n    child: Container(color: Colors.blue, child: const Text(\"Item 3\")),\n  ),\n  Expanded(\n    child: Container(color: Colors.yellow, child: const Text(\"Item 4\")),\n  ),\n])\n```\n\n運行之後我們就會發現，Flexible 中的 Widget 確實沒有佔滿整個 flex 設定的比例大小，但同時也發現 Expanded 並沒有去填滿 Flexible 所留下的空間，而是按照原本計算的大小來撐開而已。Flexible 沒有佔滿的部分，就真的放著沒有去使用了。\n\n![截圖 2024-11-17 下午5.00.16.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%8E%A2%E7%B4%A2%20Row%20%E7%9A%84%E4%BD%88%E5%B1%80%E9%82%8F%E8%BC%AF/%25E6%2588%25AA%25E5%259C%2596_2024-11-17_%25E4%25B8%258B%25E5%258D%25885.00.16.png)\n\n## 小結\n\n今天我們一起研究了 Row 一些佈局邏輯，也再一次認識了「Constraints go down. Sizes go up.」如何在 Flutter 框架中實踐，也發現了 Row 同時使用 Flexible 與 Expanded 可能會有的狀況。\n\n了解了 Row 的運作機制之後，根據我們看到的佈局邏輯，理論上 AnimatedSize 在 Row + Expanded 的組合中使用也要能正常出現動畫效果，那為什麼事實卻不是如此呢？我們在下一篇文章中會繼續探討這個問題，最後我們會發現 Row + Expanded 其實也能完成我們最初想要的行為，那就讓我們下次見吧。\n\n## 參考\n\n- RenderFlex 原始碼：https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/rendering/flex.dart",
      "createdAt": "November 9, 2024 9:12 AM",
      "updatedAt": "October 24, 2025 5:18 PM",
      "id": "1398303f78f780a093c6ece58bdf160d",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "自製 Flutter Tab Bar - 探索 Row 的佈局邏輯 1398303f78f780a093c6ece58bdf160d.md"
    },
    {
      "title": "自製 Flutter Tab Bar - 使用 CustomMultiChildLayout",
      "summary": "在產品開發上我們常常使用 Tab Bar 來切換不同分類的內容，使用 Tab Bar 可以讓使用者快速找到想要的內容，提升效率。一般來說，我們可以使用 Flutter 內建 TabBar 來完成，即便我們希望的樣式與預設的不同，也能透過參數調整或額外加工來調整成想要的結果。 [https://api...",
      "content": "![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/image.png)\n\n在產品開發上我們常常使用 Tab Bar 來切換不同分類的內容，使用 Tab Bar 可以讓使用者快速找到想要的內容，提升效率。一般來說，我們可以使用 Flutter 內建 TabBar 來完成，即便我們希望的樣式與預設的不同，也能透過參數調整或額外加工來調整成想要的結果。\n\n![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/image%201.png)\n\n[https://api.flutter.dev/flutter/material/TabBar-class.html](https://api.flutter.dev/flutter/material/TabBar-class.html)\n\n但是若碰上內建 TabBar 無法符合設計需求，我們通常就上 [pub.dev](http://pub.dev) 搜尋，看看有沒有人已經提供相同功能的套件。在找不到呢，我們也就只能自己做了，而這次碰到 Tab Bar 設計就剛好是最後一種狀況，這也給了筆者一個嘗試的機會。\n\n![images.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/images.png)\n\n## 了解 Tab Bar 行為\n\n首先先來簡單分析一下這個特別的 Tab Bar 的行為：\n\n1. 被選到 Tab 佔據他所需要的寬度，剩下的寬度由那些未被選到的 Tab 平均分配\n2. 被選到的 Tab 擁有不同的文字\n3. 當使用者點選其他 Tab 時，透過淡入淡與放大縮小來變化 Tab 樣式\n\n[ori.mov](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/ori.mov)\n\n分析不只讓我們更清楚要完成什麼需求，將需求拆成一個一個的小需求，我們就能解決多個簡單的小問題，最後集合解決原本的大問題。這也能讓我們優先處理最有價值的部分，用最快的時間產出最有價值的部分，這也是開發人員必備的 Divide and Conquer 技巧。\n\n## 從最重要的功能開始\n\n如果我們先不考慮動畫，我們可很容易地完成兩項要求。首先利用 Row 來放置每個一個 Tab，接著用 Expanded 包住其他沒被選到的 Tab，使得這些沒被選到的 Tab 以平均分配的形式來排列。(為了讓程式碼簡短一些些，筆者拿掉了一些例如圓角或粗體等不重要的細節)\n\n```dart\nclass MyTabBar extends StatefulWidget {\n  const MyTabBar({super.key});\n\n  @override\n  State<MyTabBar> createState() => _MyTabBarState();\n}\n\nclass _MyTabBarState extends State<MyTabBar> {\n  int currentIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    const tabLength = 4;\n    return Container(\n      padding: const EdgeInsets.all(4),\n      color: const Color(0xFFE6E6E6),\n      child: Row(\n        children: [\n          for (int index = 0; index < tabLength; index++)\n            currentIndex == index\n                ? Container(\n                    padding: const EdgeInsets.all(8),\n                    color: const Color(0xFF510E59),\n                    child: Text(\n                      \"Selected Tab $index\",\n                      style: const TextStyle(color: Colors.white),\n                    ),\n                  )\n                : Expanded(\n                    child: GestureDetector(\n                      onTap: () => setState(() => currentIndex = index),\n                      child: Container(\n                        padding: const EdgeInsets.all(8),\n                        color: const Color(0xFFE6E6E6),\n                        child: Text(\"Tab $index\", textAlign: TextAlign.center),\n                      ),\n                    ),\n                  )\n        ],\n      ),\n    );\n  }\n}\n```\n\n這個版本相當簡單，當使用者選到某個 Tab 之後，被選到的 Tab 一瞬間就換了樣式。[[Dartpad的範例](https://dartpad.dev/?id=e2b032cb7cf8392af5a1f0ea4c4a11fb)]\n\n[v1.mov](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/v1.mov)\n\n以迭代的方式完成功能，避免**一口氣花很多時間**完成最終版本。這有幾個好處，以 Tab Bar 的例子來說，我們用熟練的工具快速完成了一個非動畫版本的 Tab Bar，這時候其實最重要的功能已經完成，即便最後時間來不及直接上線的話，也不會造成功能有使用上的問題。\n\n在開發這個功能的過程中，筆者也是先完成到這邊，接著轉頭去完成其他部分的工作。等到其他更重要的工作完成的差不多之後，才又回頭來思考如何實現 Tab Bar 動畫，接著讓我們來看看怎麼完成吧。\n\n## 嘗試加上動畫\n\n當我們想加動畫時，我們除了使用 AnimationController 自定義之外，還有其他更簡單的方式。Flutter 內建提供許多好用的動畫 Widget，例如：[AnimatedSwitcher](https://api.flutter.dev/flutter/widgets/AnimatedSwitcher-class.html)、[AnimatedContainer](https://api.flutter.dev/flutter/widgets/AnimatedContainer-class.html) ……等。筆者最一開始也是打算在 Row 的基礎上加上 [AnimatedSize](https://api.flutter.dev/flutter/widgets/AnimatedSize-class.html) 來完成動畫的部分，但是天不從人願，代誌不是憨人想得那麼簡單，加上 AnimatedSize 沒有任何效果。\n\n```dart\nRow(\n  children: [\n    for (int index = 0; index < tabLength; index++)\n      currentIndex == index\n          ? AnimatedSize(\n              duration: const Duration(milliseconds: 300),\n              child: Container(\n                padding: const EdgeInsets.all(8),\n                color: const Color(0xFF510E59),\n                child: Text(\n                  \"Selected Tab $index\",\n                  style: const TextStyle(color: Colors.white),\n                ),\n              ),\n            )\n          : Expanded(\n              child: AnimatedSize(\n                duration: const Duration(milliseconds: 300),\n                child: GestureDetector(\n                  onTap: () => setState(() => currentIndex = index),\n                  child: Container(\n                    padding: const EdgeInsets.all(8),\n                    color: const Color(0xFFE6E6E6),\n                    child: Text(\n                      \"Tab $index\",\n                      textAlign: TextAlign.center,\n                    ),\n                  ),\n                ),\n              ),\n          )\n  ],\n)\n```\n\n但是我們若是再嘗試一下，加上 AnimatedSize 但拿掉 Expanded 的話，會發現其實 AnimatedSize 是有效果的，顯然是 Row 的某些機制造成了問題，~~關於為什麼沒有效果以後我們會做一期專門的影片逕行講解~~。但是我們也不能接受這個版本，因為我們需要沒被選取的 Tab 平均分配寬度。\n\n```dart\nRow(\n  children: [\n    for (int index = 0; index < tabLength; index++)\n      currentIndex == index\n          ? AnimatedSize(\n              duration: const Duration(milliseconds: 300),\n              child: Container(\n                padding: const EdgeInsets.all(8),\n                color: const Color(0xFF510E59),\n                child: Text(\n                  \"Selected Tab $index\",\n                  style: const TextStyle(color: Colors.white),\n                ),\n              ),\n            )\n          : AnimatedSize(\n              duration: const Duration(milliseconds: 300),\n              child: GestureDetector(\n                onTap: () => setState(() => currentIndex = index),\n                child: Container(\n                  padding: const EdgeInsets.all(8),\n                  color: const Color(0xFFE6E6E6),\n                  child: Text(\n                    \"Tab $index\",\n                    textAlign: TextAlign.center,\n                  ),\n                ),\n              ),\n            )\n  ],\n)\n```\n\n[v2.mov](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/v2.mov)\n\n[[Dartpad範例](https://dartpad.dev/?id=3e6285459821b93834d6bdfbd1308827)]\n\n事情到了這邊，顯然我們無法使用 Row 完成這個 Tab Bar 設計了，那我們還有什麼辦法呢？有的，我們可以用 [CustomMultiChildLayout](https://api.flutter.dev/flutter/widgets/CustomMultiChildLayout-class.html) 自製一個簡單的 Row，一個為這個特殊的 Tab Bar 佈局而生的 Row。\n\n## 使用 CustomMultiChildLayout + AnimatedSize\n\n使用 CustomMultiChildLayout 方法並不複雜，CustomMultiChildLayout 有個 children 參數可以傳入複數個 Widget，這邊我們就傳入各個包有 AnimatedSize 的 Tab，並且用 LayoutId 這個 Widget 包住 Tab 並指定 id。指定 id 的目的是為了讓等等在排列佈局的時候可以取得相對應得子 Widget。\n\n```dart\nclass MyTabBar extends StatefulWidget {\n  const MyTabBar({super.key});\n\n  @override\n  State<MyTabBar> createState() => _MyTabBarState();\n}\n\nclass _MyTabBarState extends State<MyTabBar> {\n  int currentIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    const tabLength = 4;\n    return Container(\n      padding: const EdgeInsets.all(4),\n      color: const Color(0xFFE6E6E6),\n      child: CustomMultiChildLayout(\n        delegate: _MyTabBarLayoutDelegate(\n          selectedIndex: currentIndex,\n          length: tabLength,\n        ),\n        children: <Widget>[\n          for (int index = 0; index < tabLength; index++)\n            LayoutId(\n              id: index,\n              child: GestureDetector(\n                onTap: () => setState(() => currentIndex = index),\n                child: currentIndex == index\n                    ? AnimatedSize(\n                        duration: const Duration(milliseconds: 300),\n                        child: Text(\n                          \"Selected Tab $index\",\n                          style: const TextStyle(color: Colors.white),\n                        ),\n                      )\n                    : AnimatedSize(\n                        duration: const Duration(milliseconds: 300),\n                        child: Text(\"Tab $index\", textAlign: TextAlign.center),\n                      ),\n              ),\n            ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n接著我們需要實作 MultiChildLayoutDelegate 定義各個子 Widget 的位置，這邊就需要一些簡單的數學計算了。首先，我們要實作 performLayout(Size size) 方法，我們必須在這個方法中設定子 Widget 的大小與位置。雖說是設定子 Widget 的大小，實際上是告訴子 Widget 一個**大小限制**，也就是 Constraint。\n\n## 實作 MultiChildLayoutDelegate\n\n在 Flutter 框架設計中有句話：「[**Constraints go down. Size go up. Parent sets position.**](https://docs.flutter.dev/ui/layout/constraints)」，這句話充分體現了 Flutter 的排版的核心機制，而 performLayout 方法所要處理的就恰恰是這一句話，筆者曾在社群聊天時分享過一個例子：\n\n想像一下，假設今天公司要辦員工旅遊，福委想知道總共有多少員工與員工家屬要參加，這時福委就通知每個員工說：「每個人可以帶 0 ~ 3」個家屬，而這就是 Constraints go down。當員工回家問親戚朋友，最終得到總共幾人參加後，員工把這人數回報給福委，這就是 Size go up。最後福委就能根據回報的資訊得知總共有多少人，也就能安排每個員工與家屬的梯次、機票、車位等資訊，也就是 Parent sets position。\n\n讓我們來看點實際例子。\n\n還記得我們特殊 Tab Bar 的第一個要求嗎？\n\n**被選到 Tab 佔據他所需要的寬度，剩下的寬度由那些未被選到的 Tab 平均分配**\n\n若想完成這個需求，我們首先得先知道被選到 Tab 的寬度，在 performLayout 方法的第一行，我們就呼叫了 layoutChild 並帶入被選到的 Tab 的 id 與 Constraints，這個 Constrains 告訴了被選到的 Tab 最大可以到多大。\n\n```dart\nclass _MyTabBarLayoutDelegate extends MultiChildLayoutDelegate {\n  _MyTabBarLayoutDelegate({\n    required this.selectedIndex,\n    required this.length,\n  });\n\n  final int selectedIndex;\n  final int length;\n\n  @override\n  void performLayout(Size size) {\n    final selectedSize = layoutChild(\n        selectedIndex,\n        BoxConstraints(\n          maxWidth: size.width,\n          maxHeight: size.height,\n        ));\n\n    final otherChildWidth = (size.width - selectedSize.width) / (length - 1);\n    \n    double currentWidth = 0;\n    for (int index = 0; index < length; index++) {\n      if (index == selectedIndex) {\n        positionChild(index, Offset(currentWidth, 0));\n        currentWidth += selectedSize.width;\n      } else {\n        layoutChild(\n            index,\n            BoxConstraints(\n              minWidth: otherChildWidth,\n              maxWidth: otherChildWidth,\n              maxHeight: size.height,\n            ));\n        positionChild(index, Offset(currentWidth, 0));\n        currentWidth += otherChildWidth;\n      }\n    }\n  }\n\n  @override\n  bool shouldRelayout(_MyTabBarLayoutDelegate oldDelegate) {\n    return oldDelegate.selectedIndex != selectedIndex ||\n        oldDelegate.length != length;\n  }\n}\n```\n\n得到大小之後，我們就能計算出其他沒被選到的 Tab 應該要多大，並在 layoutChild 的時候嚴格指定其寬度（把 minWidth 與 maxWidth 設定為相同值）。\n\n最後我們知道每個子 Widget 大小為多少之後，我們就能準確的設定其座標。透過 positionChild 方法指定每個子 Widget 的位置，我們也就能完成特製的 Row 了。\n\n完成之後，我們測試一個就能看到切換 Tab 時，Tab 有伸縮的動畫了。[[Dartpad範例](https://dartpad.dev/?id=52542730fde0265f1690f3b29f5b12c6)]\n\n[v4.mov](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/v4.mov)\n\n最後我們還想讓 Tab 的背景顏色也有淡入淡出的動畫效果時，我們只要簡單的把 Container 修改為 AnimatedContainer 就好，我們就能看到變大變小的同時也有淡入淡出的效果了。[[Dartpad範例](https://dartpad.dev/?id=e5d78a92bdf62adc25df2d580348c661)]\n\n[v4.mov](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/v4%201.mov)\n\n## 小結\n\n今天分享了如何在 Flutter 中自訂 Tab Bar 特效，透過分析 Tab Bar 的行為，我們展示如何逐步實現功能，包括使用 Row 和 Expanded 佈局，以及後續添加動畫效果。最終，採用 CustomMultiChildLayout 和 AnimatedSize 實現了一個符合設計需求的 Tab Bar，確保選中 Tab 的寬度動態變化，最後再加上 AnimatedContainer 實現背景顏色的淡入淡出效果。",
      "createdAt": "October 30, 2024 8:20 AM",
      "updatedAt": "October 24, 2025 5:20 PM",
      "id": "12f8303f78f7805baacbff6d139421f6",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "自製 Flutter Tab Bar - 使用 CustomMultiChildLayout 12f8303f78f7805baacbff6d139421f6.md"
    },
    {
      "title": "如何讓 ListView 自動對齊",
      "summary": "在 Flutter 中，ListView 和 PageView 都是用於顯示多個元素的 Widget，使用者可以滑動瀏覽列表中的 Widget。如果單看功能性，ListView 和 PageView 可能沒太大區別。但是實際與其互動之後，就會發現他們在畫面上的表現還是有所不同。 使用 ListVie...",
      "content": "![glenn-carstens-peters-RLw-UC03Gwc-unsplash.jpg](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/glenn-carstens-peters-RLw-UC03Gwc-unsplash.jpg)\n\n在 Flutter 中，ListView 和 PageView 都是用於顯示多個元素的 Widget，使用者可以滑動瀏覽列表中的 Widget。如果單看功能性，ListView 和 PageView 可能沒太大區別。但是實際與其互動之後，就會發現他們在畫面上的表現還是有所不同。\n\n使用 ListView，使用者可以讓 ListView 停在列表中的任意位置，可以讓它停在某個元素的開頭，也可以停在某個元素一半的位置。而 PageView 就有點不同，雖然使用者一樣可以透過滑動來把 PageView 中的元素滑到任意位置，但是只要手一放開，PageView 就會自動的把元素歸位到正中央。\n\n![list_view.gif](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/list_view.gif)\n\n![page_view.gif](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/page_view.gif)\n\n大多數情況下，我們可以用 ListView 與 PageView 來完成功能。但是有些時候，我們也會需要客製化一些特別的行為，就像是今天要介紹的：用 ListView 來達到自動對齊的效果。\n\n# **建立 SnapListView**\n\n首先我們需要一個可以水平滑動的 ListView 並先命名為 SnapListView。\n\n```dart\nclass SnapListView extends StatelessWidget {\n  const SnapListView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    const itemExtent = 200.0;\n    return ListView.builder(\n      scrollDirection: Axis.horizontal,\n      itemBuilder: (context, index) => Container(\n        width: 200,\n        alignment: Alignment.center,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.black),\n        ),\n        child: Text('Item $index', style: const TextStyle(fontSize: 30)),\n      ),\n    );\n  }\n}\n```\n\n接下來我們要如何實現自動對齊的效果呢？答案就是修改 ListView 中的 physics 參數。physics 參數定義在 ListView 祖父類別 ScrollView 中，型別為 ScrollPhysics。\n\n```dart\nconst ScrollView({\n    super.key,\n    this.scrollDirection = Axis.vertical,\n    this.reverse = false,\n    this.controller,\n    this.primary,\n    ScrollPhysics? physics,\n    this.scrollBehavior,\n    this.shrinkWrap = false,\n    this.center,\n    this.anchor = 0.0,\n    this.cacheExtent,\n    this.semanticChildCount,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,\n    this.restorationId,\n    this.clipBehavior = Clip.hardEdge,\n  })\n\n```\n\n# **ScrollPhysics**\n\nFlutter 中原本就內建許多類別繼承自 ScrollPhysics ，例如：Android 預設的 ClampingScrollPhysics 或者是 iOS 預設 BouncingScrollPhysics 。這些 ScrollPhysics 可以套在很多可滑動的 Widget，例如：CustomeScrollView 或 GridView …等，套用不同的 ScrollPhysics 可在滑動的時候產生不同效果。\n\n雖然 Flutter 提供許多不同的 ScrollPhysics，但是這些內建的 ScrollPhysics 並不能幫助我們的目標：自動對齊第一個元素。所以我們需要自定義一個 ScrollPhysics 來幫助我們達到目的。\n\n# **建立 SnapScrollPhysics**\n\n讓我們新增一個 SnapScrollPhysics 類別，並繼承 ScrollPhysics 。我們傳入 itemExtent 來表明列表中每個元素的大小，用於計算模擬滑動的最終位置，畢竟使用者不會每次都停在相同位置，所以我們必須根據停止的位置與元素大小來計算最終位置。\n\n```dart\nclass SnapScrollPhysics extends ScrollPhysics {\n  final double itemExtent;\n\n  const SnapScrollPhysics({\n    required this.itemExtent,\n    super.parent,\n  });\n\n  @override\n  SnapScrollPhysics applyTo(ScrollPhysics? ancestor) {\n    return SnapScrollPhysics(\n      itemDimension: itemExtent,\n      parent: buildParent(ancestor),\n    );\n  }\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    return null;\n  }\n}\n```\n\n在 ScrollPhysics 中有許多方法可提供覆寫。而在這個需求中，我們需要覆寫 createBallisticSimulation ，這個方法可以回傳一個 Simulation，讓使用者手指放開時，讓程式依據回傳的 Simulation，自動的把列表滾到 Simulation 所設定的位置。\n\n值得一提的是，我們也需要覆寫 applyTo 方法，讓 ScrollView 在引入效果時，可以套用到我們定義的 SnapScrollPhysics 。雖然我們只在 ListView 中只傳入了 SnapScrollPhysics ，但是其實 Flutter 底層還會繼續套用其他的 ScrollPhysics ，讓 ListView 具有多種滑動效果。\n\n# **實現 createBallisticSimulation**\n\n首先，我們先處理一些例外狀況，當使用者滑超出列表範圍時，我們呼叫 super 的 createBallisticSimulation 的方法即可，讓其他 ScrollPhysics 來處理超出列表的行為。\n\n```dart\nclass SnapScrollPhysics extends ScrollPhysics {\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    if (position.pixels <= position.minScrollExtent ||\n        position.pixels >= position.maxScrollExtent) {\n      return super.createBallisticSimulation(position, velocity);\n    }\n\n    return null;\n  }\n}\n```\n\n接著我們透過 position.pixels 取得列表當前的位置，並使用 roundToDouble 四捨五入，來決定應該要自動移動到上一個元素或下一個元素。最後建立 ScrollSpringSimulation 並指定起始位置與目標位置，讓 Flutter 在使用者手放開之後，模擬使用者滑動，讓使用者體驗更好。\n\n```dart\n\nclass SnapScrollPhysics extends ScrollPhysics {\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    if (position.pixels <= position.minScrollExtent ||\n        position.pixels >= position.maxScrollExtent) {\n      return super.createBallisticSimulation(position, velocity);\n    }\n\n    double page = position.pixels / itemExtent;\n    double target = page.roundToDouble() * itemExtent;\n    if (target != position.pixels) {\n      return ScrollSpringSimulation(\n        spring,\n        position.pixels,\n        target,\n        velocity,\n      );\n    }\n    return null;\n  }\n}\n```\n\n但是當我們實際執行後，卻會發現用起來十分不順，原因是當使用者一放開手，Flutter 就會馬上開始模擬滑動，造成滑動不順暢。在真實滑動的過程中，使用者的手指是會頻繁地離開的手機螢幕，不會一直貼在螢幕上，所以我們必須在使用者手離開螢幕時，依據使用者滑動方向與速率來微調一下目標位置。\n\n```dart\nclass SnapScrollPhysics extends ScrollPhysics {\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    if (position.pixels <= position.minScrollExtent ||\n        position.pixels >= position.maxScrollExtent) {\n      return super.createBallisticSimulation(position, velocity);\n    }\n\n    double page = position.pixels / itemExtent;\n    \n    var tolerance = toleranceFor(position);\n    if (velocity < -tolerance.velocity) {\n      page -= 1;\n    } else if (velocity > tolerance.velocity) {\n      page += 1;\n    }\n\n    double target = page.roundToDouble() * itemExtent;\n    if (target != position.pixels) {\n      return ScrollSpringSimulation(\n        spring,\n        position.pixels,\n        target,\n        velocity,\n      );\n    }\n    return null;\n  }\n}\n```\n\n當發現使用者滑動的速率大於容忍值時，表示使用者想要快速滑動。所以我們必須依照使用者快速滑動的方向，創建一個往使用者滑動方向的滑動模擬，避免使用者手指一離開，列表就往反方向滑動。最後我們把完成的 SnapScrollingPhysics 放回 ListView 中，就能得到一個比較順暢的自動對齊效果。\n\n```dart\nclass SnapListView extends StatelessWidget {\n  const SnapListView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      scrollDirection: Axis.horizontal,\n      physics: const SnapScrollPhysics(itemExtent: 200.0),\n      itemCount: 10,\n      itemBuilder: (context, index) => Container(\n        width: 200,\n        alignment: Alignment.center,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.black),\n        ),\n        child: Text('Item $index', style: const TextStyle(fontSize: 30)),\n      ),\n    );\n  }\n}\n```\n\n![snap_list_view.gif](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/snap_list_view.gif)\n\n# **最後**\n\n雖然我們完成了自動對齊的效果，但其實程式碼還是有一些 Bug。例如：滑到最後一個元素時，列表不會像預期中的自動對齊，因為它採用了其他 ScrollPhysics 而非我們設定的 SnapScrollPhysics ，有興趣的觀眾可以嘗試修改看看。\n\n除此之外，ScrollPhysics 還有許多方法可以覆寫，讓開發人員可以調整許多滑動細節，有興趣的觀眾也可以也可以參考 [ScrollPhysics](https://api.flutter.dev/flutter/widgets/ScrollPhysics-class.html) 。",
      "createdAt": "May 2, 2024 1:08 AM",
      "updatedAt": "October 24, 2025 4:48 PM",
      "id": "c33fa8d2cae0490f8a7761e388b43224",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "如何讓 ListView 自動對齊 c33fa8d2cae0490f8a7761e388b43224.md"
    },
    {
      "title": "減緩 PageView 動畫加上 Table 造成的卡頓",
      "summary": "最近我們新增了一個顯示球員詳細資訊的頁面，當我們完成第一版程式碼，開始調整細節時，我們發現了畫面滑動似乎不太順暢。 每個球員訊息彈跳視窗是靜態，外層使用了 PageView 加上一些的特效，使得畫面在滑動時會頻繁的 setState，造成了整個彈跳視窗卡頓，使用者體驗不佳，就像遊戲效能不好一樣會掉幀...",
      "content": "![mateus-campos-felipe-ebRHyE2u3X4-unsplash.jpg](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/mateus-campos-felipe-ebRHyE2u3X4-unsplash.jpg)\n\n最近我們新增了一個顯示球員詳細資訊的頁面，當我們完成第一版程式碼，開始調整細節時，我們發現了畫面滑動似乎不太順暢。\n\n![改善前_AdobeExpress.gif](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/%25E6%2594%25B9%25E5%2596%2584%25E5%2589%258D_AdobeExpress.gif)\n\n每個球員訊息彈跳視窗是靜態，外層使用了 PageView 加上一些的特效，使得畫面在滑動時會頻繁的 setState，造成了整個彈跳視窗卡頓，使用者體驗不佳，就像遊戲效能不好一樣會掉幀，嚴重一點可能會讓人不舒服。今天就來分享如何快速有效的解決這個問題吧。\n\n# 釐清問題\n\n首先，想要有效的解決問題，釐清問題是第一步。為了要了解我們畫面卡頓的問題根源，我們使用 Flutter 提供的 DevTools 並在實體手機上運行 Profile 模式，Profile 模式是讓 App 運行效能接近 Release 模式同時又能搜集運行資訊的一種模式。當我們執行程式並開起 DevTools 之後，可以觀察到 App 運行時，每一個 Frame 效能到底如何。\n\n### Dev tools\n\n在  Dev Tools 面板中，可以發現在大多數 Frame 中，UI phase 與 Raster phase 都花了很多時間，這通常表示問題可能有很多個，但是我們今天先研究 UI phase 花過久時間的問題吧。\n\n![Screen Shot 2023-07-03 at 1.23.37 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-03_at_1.23.37_PM.png)\n\n在面板中清楚看到了 Build 和 Layout 畫面的操作各花了多久時間，我們可以初步了解問題可能發生在哪邊，但是只有這些資訊，顯然不夠我們解決問題。\n\n### 啟用 Track Widget Builds\n\n為了更深入了解問題出在哪邊，我們可以在 Dev Tools 的右上角打開 Enhance Tracing，並且勾選 Track Widget Builds，這個功能可以提供更詳細的時間，提供每一個 Widget 在每一個 Frame 中所花費的時間。\n\n![Screen Shot 2023-07-03 at 1.36.51 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-03_at_1.36.51_PM.png)\n\n### 觀察 Widget Build 火焰圖\n\n當我們啟用 Track Widget Build 之後，我們再繼續操作一下手機，讓手機繼續執行幾個 Frame，我們就能這些新產生的報告找到 Timeline Events，在 Timeline Events 中， DevTools 顯示在這個 Frame 中 Build Widget 所花費的時間，能更直觀地看到時間到底花在哪個 Widget 上了。\n\n![Screen Shot 2023-07-03 at 1.24.21 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-03_at_1.24.21_PM.png)\n\n### 分析問題\n\n從火焰圖中我們可以得知，PlayerInfoGameLogView 花費的時間佔了很大一部份比例，而且每一個 Frame 都是這種狀況。這表示畫面滑動的時候，每一個 Frame 都在重新建立這個 Widget。雖然我們滑動需要頻繁的 setState，畫面其實是不變的，數值並不會在滑動過程中有變化，應該要可以使用重複使用之前已經 Build 好的 Widget，但是顯然 Flutter 不這麼認為，而是辛苦的每一個 Frame 都Rebuild 新的 Widget。\n\n# 解決問題\n\n為了更準確解決 PlayerInfoGameLogView 被頻繁建立的問題，也為了讓讀者們可以一起同樂，我們先在 Dartpad 準備有問題的範例程式 [[連結](https://dartpad.dev/?id=9bf6ba724ce6b3c62c9c490905b2fbbf)]，有興趣的讀者也可以試試看。讓我們看一下程式碼，在範例程式中，當我們滑動 PageView 時，PageView 頻繁的呼叫 itemBuilder 來更新畫面，讓 PageView 中的每一個 Item 可以隨著滑動改變大小，但是這麼做也使得 GameLogView 頻繁的被 Rebuild，即便每次傳進去的 gameLogs 是一模一樣的。\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key, required this.players});\n\n  final List<Player> players;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: PlayerPageView(\n        itemCount: players.length,\n        itemBuilder: (BuildContext context, int index) {\n          return Container(\n            padding: const EdgeInsets.symmetric(horizontal: 16),\n            alignment: Alignment.center,\n            child: GameLogView(gameLogs: players[index].gameLogs),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n讓我們看一下這段範例程式碼的效能分析，與正式程式碼的效能差不多，在 UI phase 階段所花的時間都偏高。\n\n![Screen Shot 2023-07-07 at 1.46.59 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-07_at_1.46.59_PM.png)\n\n### 只在資料變化時 Rebuild\n\n最終，我希望 Flutter 不要總是 Rebuild GameLogView，而達到這個目標，我們可以把 gameLogs 放在 Provider 中，然後需要使用 gameLogs 的地方呼叫 context.watch 去存取並監聽 gameLogs，這樣一來就能讓 Widget 不需要一層一層傳遞 gameLogs，最外層的 GameLogView 也就可以加上 const 修飾詞，讓 Flutter 知道這是一個固定的 Widget，避免 Flutter 總是 Rebuild 它。\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key, required this.players});\n\n  final List<Player> players;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: PlayerPageView(\n        itemCount: players.length,\n        itemBuilder: (BuildContext context, int index) {\n          return Container(\n            padding: const EdgeInsets.symmetric(horizontal: 16),\n            alignment: Alignment.center,\n            child: Provider<List<GameLog>>.value(\n              value: players[index].gameLogs,\n              child: const GameLogView(),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass _GameLogTable extends StatelessWidget {\n  const _GameLogTable();\n\n  @override\n  Widget build(BuildContext context) {\n    var gameLogs = context.watch<List<GameLog>>();\n    return Table(\n      ...\n    );\n  }\n}\n```\n\n當我們調整好程式碼之後，PageView 執行 setState 之後，GameLog 就不會 Rebuild，而是會重複使用已經建好的 Widget，有興趣的觀眾也可以在 GameLogView 的 build 方法印 log 觀察看看。最後讓我們看一下問題解決之後的範例程式碼的效能分析，在少數幾個 Frame 中，UI phase 花的時間是超時的，剩下大部分時間都是在標準以內。\n\n![Screen Shot 2023-07-07 at 1.44.26 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-07_at_1.44.26_PM.png)\n\n如果實際上運行解決後的範例程式之後 [[連結](https://dartpad.dev/?id=fdc0e92365fade89d5253647a4710b2d)]，可以發現滑動的過程中比較順了，但還是有一些時刻會感受到卡頓。\n\n### 尚未解決的卡頓\n\n當我們使用 Provider 提升效能之後，我們發現第一次 Build  GameLogView 的時候還是會超時，使得下一個 GameLog 顯示時，畫面會出現明顯卡頓。此時我們暫時沒有比較好的辦法可以解決問題，因為 Table 目前沒有提供 builder 的方法，當渲染比較大的 Table 時，所有欄位都會在第一時間被建立，無論他有沒有出現在畫面上，使得 UI phase 的時間還是會比較長，也就是我們上面效能分析所顯示的狀況。\n\n### 應用在產品程式碼中\n\n當我們把這個做法放回產品程式碼中，並再次檢測 App 效能，可以發現超時的 UI phase 大幅減少，更多的是超時的 Raster phase，這也表示我們方法有效這個畫面的效能。\n\n![調整後.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/%25E8%25AA%25BF%25E6%2595%25B4%25E5%25BE%258C.png)\n\n# 結論\n\n過早優化是萬惡之源，當我們發現效能問題時，透過釐清與分析問題，找到並解決瓶頸，在能花最小的力氣獲得最大的增益。如果我們再開發的時候為了使用 const 而寫了很多不必要的程式碼，除了浪費時間之外，也降低程式碼的可讀性，獲得的增益可能微乎其微。",
      "createdAt": "June 24, 2023 11:24 PM",
      "updatedAt": "October 24, 2025 5:20 PM",
      "id": "a05dbbc423404d19954fb69ebfee4496",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "減緩 PageView 動畫加上 Table 造成的卡頓 a05dbbc423404d19954fb69ebfee4496.md"
    },
    {
      "title": "Flutter Theme 切換效果研究",
      "summary": "許多 App 都會支持 Light 模式與 Dark 模式，增加使用者體驗，為了做到這個功能，我們可以使用內建 Theme 加上 StatefulWidget 或其他狀態管理套件，就可以輕鬆完成 Light 模式與 Dark 模式。讓我們看看一個簡單的例子。 ```dart main() {   r...",
      "content": "![_fd765116-9712-4098-b0e3-e0cde699eff3.jpeg](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/_fd765116-9712-4098-b0e3-e0cde699eff3.jpeg)\n\n許多 App 都會支持 Light 模式與 Dark 模式，增加使用者體驗，為了做到這個功能，我們可以使用內建 Theme 加上 StatefulWidget 或其他狀態管理套件，就可以輕鬆完成 Light 模式與 Dark 模式。讓我們看看一個簡單的例子。\n\n## 簡單的切換主題\n\n```dart\nmain() {\n  runApp(const MainApp());\n}\n\nclass MainApp extends StatefulWidget {\n  const MainApp({super.key});\n\n  @override\n  State<MainApp> createState() => _MainAppState();\n}\n\nclass _MainAppState extends State<MainApp> {\n  bool isDark = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: isDark ? ThemeData.dark() : ThemeData.light(),\n      home: Scaffold(\n        body: const Center(\n          child: Text(\"Hello World\"),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: const Icon(Icons.refresh),\n          onPressed: () => setState(() => isDark = !isDark),\n        ),\n      ),\n    );\n  }\n}\n```\n\n我們在 StatefulWidget 中維護了 isDark 變數，當使用者按下左下角按鈕時，就會更新 isDark，並設定不同模式的 ThemeData 給 MaterialApp，藉此達到切換 Light / Dark 模式的效果，而在切換過程中，Flutter 也會幫我們用漸變的方式切換主題，而不是一瞬間就切換完成，增加視覺效果。\n\n![Discuss - Theme switch.jpg](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/Discuss_-_Theme_switch.jpg)\n\n## 自定義的 ThemeExtension\n\n有些時候，當我們的設計不是遵循 Material Design 的話，Flutter 提供的 Theme 就會不足以完成我們的需求，此時我們就會使用 ThemeExtension 的功能來擴充 Theme，讓整個 App 都可以使用一致的設計。下面是一段我們自定義的 ThemeExtension，其中除了自定義的顏色設計之外，我們還需要實作 copyWith 與 lerp 方法。\n\n```dart\nclass MyThemeExtension extends ThemeExtension<MyThemeExtension> {\n  final Color backgroundColor;\n\n  MyThemeExtension(this.backgroundColor);\n\n  @override\n  ThemeExtension<MyThemeExtension> copyWith() {\n    // TODO: implement copyWith\n    throw UnimplementedError();\n  }\n\n  @override\n  ThemeExtension<MyThemeExtension> lerp(covariant MyThemeExtension other, double t) {\n    // TODO: implement lerp\n    throw UnimplementedError();\n  }\n}\n```\n\n還記得剛剛提到的，切換 Light / Dark 模式時，Flutter 會用漸變的方式，讓畫面漸漸的從 Light 模式轉變為 Dark 模式 (其實動畫時間很短，一下次就轉換完成 XD)，為了讓自定義的 ThemeExtension 也能享受到這個效果，實作 lerp 方法就很重要了。lerp 方法會傳入要轉換的 Theme 與動畫時間，讓我們可以自行決定顏色在轉換過程中如何變化，在這邊我們簡單地使用 Color.lerp 來協助做線性轉換即可。\n\n```dart\n@override\nThemeExtension<MyThemeExtension> lerp(covariant MyThemeExtension other, double t) {\n  return MyThemeExtension(\n    Color.lerp(backgroundColor, other.backgroundColor, t)!,\n  );\n}\n```\n\n當我們實作了 lerp 方法之後，再次打開 App 切換 Light / Dark 模式，會發現我們自定義的顏色也能在切換過程中有平滑的視覺效果。\n\n![Discuss - Theme Switch 2.jpg](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/Discuss_-_Theme_Switch_2.jpg)\n\n完整效果請參考[這邊](https://dartpad.dev/?id=1264772a9ffa905f346a1d2c5a8c02a6)。\n\n## 更酷炫的切換動畫\n\n在研究 Light / Dark 模式切換的過程中，發現了很特別切換效果，詳細可以參考[這邊](https://stackoverflow.com/questions/60897816/how-to-add-animation-for-theme-switching-in-flutter)。當使用者切換模式時，畫面會由左上角開始轉換，並往右下角輻射，直到所有畫面都轉換完成，讓我們直接看看下面圖片。\n\n![螢幕錄影_2023-06-24_上午12_04_38_AdobeExpress.gif](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/%25E8%259E%25A2%25E5%25B9%2595%25E9%258C%2584%25E5%25BD%25B1_2023-06-24_%25E4%25B8%258A%25E5%258D%258812_04_38_AdobeExpress.gif)\n\n與 Flutter 預設的切換方式不同，這種切換方式更令人眼睛一亮，讓我們來看看這是如何做到的。其實要做到這個效果也並不複雜，主要原理是使用 Stack + ClipPath 來完成，簡單來說就是，先在 Stack 中疊上 Light 模式 Widget，然後再疊上被 ClipPath 裁切過的 Dark 模式 Widget，最後透過動畫來慢慢放大被裁切的 Dark 模式 Widget，最後填滿的畫面。如此一來，就能完成這個酷炫的 Light / Dark 模式切換效果。\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return AnimatedBuilder(\n    animation: _animationController,\n    builder: (BuildContext context, Widget? child) {\n      return Stack(\n        children: [\n          Theme(\n            data: _getTheme(widget.isDark),\n            child: widget.builder(context),\n          ),\n          ClipPath(\n            clipper: CircularClipper(\n              1.5 * MediaQuery.of(context).size.height * _animationController.value,\n              Offset.zero,\n            ),\n            child: Theme(\n              data: _getTheme(!widget.isDark),\n              child: widget.builder(context),\n            ),\n          ),\n        ],\n      );\n    },\n  );\n}\n```\n\n完整效果請參考[這邊](https://dartpad.dev/?id=883cd4304e8f0a032d5d3a3f87dced70)。\n\n## 小結\n\n為 App 增加一些轉場特效，像是我們今天分享的 Light / Dark 模式切換，或者是 Routing 時的 Transition 效果，都能有效增加使用者體驗，讓 App 看起來更加精緻。",
      "createdAt": "June 23, 2023 11:19 PM",
      "updatedAt": "October 24, 2025 5:20 PM",
      "id": "cfabe2e638ef4210bdc9660155dcdfa5",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Flutter Theme 切換效果研究 cfabe2e638ef4210bdc9660155dcdfa5.md"
    },
    {
      "title": "用 Widget Test 測試 Routing",
      "summary": "在開發 Flutter 時，我們可以寫 Widget Test 確保功能在我們重構之後，還是保持正常運作。我們會針對許多不同的情境進行測試，其中一種情境是當使用者進行某些操作，或者當某些情況發生，把使用者導到其他頁面，今天就來分享如何使用 Widget Test 驗證 Routing。 假設我們有常...",
      "content": "![_206dd02c-3b32-4243-95a6-b8a7669e5acc.jpeg](%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%20Routing/_206dd02c-3b32-4243-95a6-b8a7669e5acc.jpeg)\n\n在開發 Flutter 時，我們可以寫 Widget Test 確保功能在我們重構之後，還是保持正常運作。我們會針對許多不同的情境進行測試，其中一種情境是當使用者進行某些操作，或者當某些情況發生，把使用者導到其他頁面，今天就來分享如何使用 Widget Test 驗證 Routing。\n\n## 舉個例子\n\n假設我們有常見的清單頁面，其中列滿了各種狗狗品種，當我們點擊了某一個品種之後，App 會把使用者導向另一個頁面，並向隨機呈現一張該品種的圖片。在這個例子中，我們使用 [DogAPI](https://dog.ceo/dog-api/)，有興趣的觀眾也可以參考看看。\n\n![Route 測試.jpg](%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%20Routing/Route_%25E6%25B8%25AC%25E8%25A9%25A6.jpg)\n\n這個需求並不複雜，經過一番操作之後，我們在相對應的 **ListTitle** 上加上 **GestureDetector** 並使用 **Navigator** 把使用者導到下一個頁面，也告訴下一個頁面要顯示哪種品種的狗狗，最後成功在畫面上隨機顯示一張該品種的狗狗圖片。\n\n```dart\nclass BreedListPage extends StatelessWidget {\n  \n\t...\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: breedList.length,\n      itemBuilder: (context, index) {\n        return GestureDetector(\n          onTap: () => Navigator.of(context).pushNamed(\n            \"/dog_image\",\n            arguments: breedList[index],\n          ),\n          child: ListTile(\n            title: Text(breedList[index]),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n但是當我們完成功能之後，可能會思考，我們該如何進行測試呢？我們該如何功能正確，並且在未來也都持續保持正確呢？\n\n## Arrange 與 Act\n\n對測試熟悉的觀眾，可能很快就能完成 Arrange 與 Act 的部分，關於測試 3A 原則可以參考[這邊](https://dotblogs.com.tw/hatelove/2012/11/07/learning-tdd-in-30-days-day3-how-to-write-a-unit-test-code)。在下面測試中，我們使用 [mocktail](https://pub.dev/packages/mocktail) 套件準備 DogAPI 的回傳結果，顯示 **BreedListPage**，接著我們點擊其中一個品種，一切都輕鬆寫意。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  MockClient mockClient = MockClient();\n  when(() => mockClient.get(Uri.parse(\"https://dog.ceo/api/breeds/list/all\"))).thenAnswer((_) async {\n    return Response('{\"message\": {\"affenpinscher\": [], \"african\": [], \"airedale\": []}, \"status\": \"success\"}', 200);\n  });\n\n  await tester.pumpWidget(\n    MaterialApp(\n      home: BreedListPage(client: mockClient)\n    ));\n  await tester.pump();\n\n\t// Act\n  await tester.tap(find.text(\"affenpinscher\"));\n\n  // How to assert routing?\n  \n});\n\nclass MockClient extends Mock implements Client {}\n```\n\n接下來的問題便是，我們如何驗證 Routing 是否成功呢？\n\n## Mock NavigatorObserver\n\n如果有使用過 [firebase_analytics](https://pub.dev/packages/firebase_analytics) 的觀眾，可能會知道可以使用套件中的 **FirebaseAnalyticsObserver** 協助我們追中使用 Routing 狀況，當 App 進行 Routing 時，會呼叫 [**NavigatorObserver.didPush](https://api.flutter.dev/flutter/widgets/NavigatorObserver/didPush.html)** 方法並透過參數告知當前 **Route** 與上一個 **Route**，此時 firebase_analytics 套件就有機會追蹤使用者的 Routing 行為。\n\n同樣地，我們也可以 mock 一個測試用的 **MockNavigatorObserver**，並驗證 didPush 方法是否有被呼叫，來達到驗證 Routing 的效果，那就讓我們使用 MockRoutingObserver 來驗證一下上述例子吧。\n\n在下面例子中，我們宣告了一個 **MockNavigatorObserver**，並把它傳給 **MaterialApp**，由此我們就能在測試中監聽 App Routing 的狀況。在 Assert 的地方中，我們使用驗證了 mockNavigatorObserver.didPush 是否有被呼叫，除此之外，我們還使用 captureAny() 來捕捉參數，驗證參數中的 **Route** 名稱是否符合預期。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\tMockNavigatorObserver mockNavigatorObserver = MockNavigatorObserver();\n  await tester.pumpWidget(\n    MaterialApp(\n      home: BreedListPage(client: mockClient),\n      navigatorObservers: [mockNavigatorObserver],\n   ));\n  await tester.pump();\n\n\t// Act\n  await tester.tap(find.text(\"affenpinscher\"));\n\n  // Assert\n  var result = verify(() => mockNavigatorObserver.didPush(captureAny(), any()));\n  expect(result.captured[1].settings.name, \"/dog_image\");\n});\n\nclass MockNavigatorObserver extends Mock implements NavigatorObserver {}\n```\n\n值得注意的是，在例子中我們使用了 captured[1] 來驗證，是因為在測試中，當我們在準備 BreedListPage 時，實際上也進行了一次 Routing，但這次 Routing 我們並不關心，我們關心的是第二次 Routing 結果，所以在上面例子中，我們驗證 captured[1] 的結果。\n\n## 找不到 Routing 錯誤\n\n當我們完成上面測試並運行後，會發現測試還是錯誤的，並在錯誤訊息中發現以下錯誤訊息。\n\n```\nCould not find a generator for route RouteSettings(\"/dog_image\", affenpinscher) in the _WidgetsAppState.\nMake sure your root app widget has provided a way to generate this route.\n```\n\n原因是我們在測試中沒有定義 /dog_image 這個 **Route**，所以當運行測試，程式走到 Navigator.of(context).pushNamed 時，就發生了錯誤。為了解決這個問題，我們只要在測試中給假的 **Route** 即可。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n  await tester.pumpWidget(\n    MaterialApp(\n      ...\n\t\t\troutes: {\"/dog_image\": (_) => const SizedBox()},\n   ));\n  await tester.pump();\n\n\t// Act\n  ...\n\n  // Assert\n\t...\n});\n```\n\n當我們加上假的 Route 之後，再次運行測試，就能通過測試得到綠燈了。\n\n## 除了驗證測試路徑之外\n\n在上面測試中，我們雖然成功驗證了 Routing 是否符合預期，但是其實還有一件事我們沒有驗證到，那就是我們少驗證了參數，我們除了把使用者導到下一個頁面之外，也會告訴下一個頁面要顯示哪一個品種的狗。在我們完成上面的測試之後，我們想再額外驗證參數其實就相對容易，我們只要加上另外一個 expect 即可。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\t// Act\n  ...\n\n  // Assert\n\tvar result = verify(() => mockNavigatorObserver.didPush(captureAny(), any()));\n  expect(result.captured[1].settings.name, DogImagePage.routeName);\n  expect(result.captured[1].settings.arguments, \"affenpinscher\");\n});\n```\n\n## 自定義 RouteMatcher\n\n當我們完成測試之後，除了重構一下程式碼之外，我們也必須重構一下測試，讓我們的測試保持簡單易懂，在驗證 Routing 的部分，我們可以自定義一個 RouteMatcher 來增加測試可讀性，讓我們不必每次都在測試中把 captured 挖出來一個一個檢查，那就讓我們來重構一下 Assert 的部分吧。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\t// Act\n  ...\n\n  // Assert\n\tverify(() => mockNavigatorObserver.didPush(\n\t  captureAny(\n\t    that: RouteMatcher(\n\t      routeName: \"/dog_image\",\n\t      arguments: \"affenpinscher\",\n\t    ),\n\t  ),\n\t  any(),\n\t));\n});\n\nclass RouteMatcher extends Matcher {\n  final String routeName;\n  final dynamic arguments;\n\n  RouteMatcher({required this.routeName, this.arguments});\n\n  @override\n  Description describe(Description description) {\n    return description.add('routeName: $routeName, arguments: $arguments');\n  }\n\n  @override\n  bool matches(item, Map matchState) {\n    return item.settings.name == routeName &&\n        item.settings.arguments == arguments;\n  }\n}\n```\n\n我們新增了一個 **RouteMatcher** 來協助比較 **Route** 是否符合預期，此後當我們閱讀 Routing 測試時，就能更直觀的在 Assert 中看到我們預期什麼路徑與參數，增加測試的可讀性，當然我們還可以利用**抽取方法**進一步的調整，讓測試真正變成容易閱讀的需求文件，像是下面程式碼那樣，這邊就不做過多贅述，~~關於這個問題，我們以後會做一集專門講解。~~\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\t// Act\n  ...\n\n  // Assert\n\trouteShouldBe(routeName: \"/dog_image\", arguments: \"affenpinscher\");\n});\n```\n\n## 一定得使用 NavigatorObserver 嗎？\n\n除了使用 **NavigatorObserver** 來測試 Routing，其實也可以直接針對整個 App 測試，我們也就不用做假的 **Route** 與 **MockNavigatorObserver** 了，聽起來好像十分省事，對吧。讓我們簡單地改寫一下測試：\n\n1. 準備兩個頁面所必須使用的資料：狗狗品種清單與隨機一張狗狗圖片\n2. 顯示 **MainApp**，而不是 **BreedListPage**\n3. 按下其中一個品種\n4. 驗證 Image 所顯示的圖片是否符合預期。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n  //Arrange\n  when(() => mockClient.get(Uri.parse(\"https://dog.ceo/api/breeds/list/all\"))).thenAnswer((_) async {\n    return Response( '{\"message\": {\"affenpinscher\": [], \"african\": [], \"airedale\": []}, \"status\": \"success\"}', 200);\n  });\n\n  when(() => mockClient.get(Uri.parse(\"https://dog.ceo/api/breed/african/images/random\"))).thenAnswer((_) async {\n    return Response( '{\"message\": \"https://images.dog.ceo/breeds/bulldog-boston/n02096585_355.jpg\", \"status\": \"success\"}', 200);\n  });\n\n  await tester.pumpWidget(MainApp(client: mockClient));\n  await tester.pump();\n\n  // Act\n  await tester.tap(find.text(\"african\"));\n  await tester.pumpAndSettle();\n\n  // Assert\n  expect(findNetworkImage(tester).url, \"https://images.dog.ceo/breeds/bulldog-boston/n02096585_355.jpg\");\n});\n\nNetworkImage findNetworkImage(WidgetTester tester) => tester.widget<Image>(find.byType(Image)).image as NetworkImage;\n```\n\n在上面例子中，測試看起來也更簡單俐落，也更貼近使用者的真實狀況，沒有 **MockNavigatorObserver** 好像看起來更好了。事實上，在這個例子中，也確實如此，使用 **MockNavigatorObserver** 反而增加了不必要的麻煩。\n\n但是在實務上，有時並非如此，當我們的 App 功能越來越多，越來越複雜時，若測試的進入點是整個  App，但是我們卻想測試某個頁面的行為，可能就得做很多準備工作，最後才能進到我們真正想測試的地方，雖然測試很貼近使用者的真實狀況，但同時也變得很難寫，變得脆弱。\n\n## 結論\n\n無論選擇使用 **MockNavigatorObserver** 協助測試，或是直接測試整個 App，我們應該依照當下情況調整，但是不管如何，我們都有義務為功能撰寫測試 ，這是開發人員必要工作之一，測試可以維護產品品質，也增加我們重構時的信心，更可以用來描述產品行為，讓後人可以透過測試案例來了解產品行為，是一石三鳥的好投資。\n\nP.S. 以上程式碼都只有片段，如果有興趣看更完整的 Demo 的觀眾，可以到[這邊](https://github.com/easylive1989/lovely_dog_app/tree/completed)。",
      "createdAt": "June 7, 2023 10:30 PM",
      "updatedAt": "October 24, 2025 5:20 PM",
      "id": "f610eefa549646aab96181e0d298a492",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "用 Widget Test 測試 Routing f610eefa549646aab96181e0d298a492.md"
    },
    {
      "title": "如何處理善變的畫面",
      "summary": "開發客戶端程式時，有些時候後端傳過來的資料根據情況變化，畫面也有所不同。舉例來說，當使用者登入系統時，後端會根據使用者的權限等級傳送不同的資料，使畫面呈現出不同的功能和選項。另一個例子是，在我們的開發的遊戲中，顯示比賽列表的畫面，也會根據不同的場次型態，顯示不同的卡片樣式。 當回傳資料不一致時，會發...",
      "content": "![hal-gatewood-tZc3vjPCk-Q-unsplash.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/hal-gatewood-tZc3vjPCk-Q-unsplash.jpg)\n\n開發客戶端程式時，有些時候後端傳過來的資料根據情況變化，畫面也有所不同。舉例來說，當使用者登入系統時，後端會根據使用者的權限等級傳送不同的資料，使畫面呈現出不同的功能和選項。另一個例子是，在我們的開發的遊戲中，顯示比賽列表的畫面，也會根據不同的場次型態，顯示不同的卡片樣式。\n\n![Screenshot_1677384908.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677384908.jpg)\n\n![Screenshot_1677384904.png](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677384904.png)\n\n當回傳資料不一致時，會發生許多 if 判斷式散佈在各個地方，這就是所謂的 Shortgun Surgery 問題。換句話說，當你需要修改一個功能時，你需要在多個地方進行修改，這樣會導致代碼的耦合性增加，並且增加了代碼的維護成本。\n\n# 舉個例子\n\n在我們的遊戲中，後端會給前端每一場比賽資料，讓前端可以顯示比賽資訊。在下圖中，我們從後端接收了一個 Json 物件，然後把 Json 物件轉換成 Contest 物件，最後一路傳到 View，給 View 決定如何顯示畫面。\n\n![Discuss - Receive contest from server.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Receive_contest_from_server.jpg)\n\n在上面的例子中，不同的 Contest 型態，有不同的卡片樣式，當 Contest 的類型不同，後端可能也會根據不同的 Contest 而給前端不同資料，假設我們使用的強型別的語言，那我們到底要如何把不同的 Json 轉成同一個物件呢？\n\n# 萬能的 Value Object\n\n最簡單解決問題的方式，我們可以在 Contest 放上所有可能的出現的資料，View 則是根據自己的需要選擇相對應的欄位使用。以 Practice Contest View 來說，他只會使用 type 與 spots，但對 Non-Pratice Contest 來說，則是所有欄位都會使用。\n\n![Discuss - Omnipotent Value Object.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Omnipotent_Value_Object.jpg)\n\n### 優點\n\n- 容易使用\n\n### 缺點\n\n- 使用端依賴了他不需要的東西，違反介面隔離的原則，以 Practice Contest 來說，他並不需要 entryFee 與 maxPrizePool\n\n# 轉接器模式\n\n另一個例子是，在下面的畫面中，可以發現大部分的畫面樣式都相同，唯一不同的是球員的資訊，不同球類的球員，顯示不同的數值來展示球員的過去表現。以板球球員來說，我們使用 Batting 與 Bowling 表示球員綜合表現，以足球來說，則是使用 Points 表示。\n\n![Screenshot_1677250687.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677250687.jpg)\n\n![Screenshot_1677248725.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677248725.jpg)\n\n此時大部分的資料都是類似的，只有少部分關於球員表現的資料略微不同，我們可以使用**轉接器模式**，把後端傳回來的資料，轉換成另一種格式，讓畫面可以用一致的方式操作資料。\n\n![Discuss - Adapter for vo.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Adapter_for_vo.jpg)\n\n以球員表現的例子來説，我們可以把新增一個 Map，用以儲存每種球員數據的 Enum 與其數字，View 在使用時，就可以顯示 Map 中的所有數據即可，而無須關心到底是板球還是足球。\n\n### 優點\n\n- 畫面可以使用一致的邏輯處理資料\n\n### 缺點\n\n- 當資料差異畫過大時，難以整理成一種共用的格式\n\n# 策略模式\n\n在我們的遊戲中，我們有許多不同的廣告，有時是單純的一張圖，有時是比賽資訊，而後端則是根據不同情況傳回不同資料。與球員數據問題類似，我們都接收來自後端不大相同的資料，但不同的是，這些資料幾乎沒有共通性，我們難以使用轉接器模式整理出一致的格式。\n\n![Screenshot_1677251104.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677251104.jpg)\n\n![Screenshot_1677425946.png](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677425946.png)\n\n為了解決這個問題，我們可以使用**策略模式**，提供一個包含 buildComponent 的方法的介面。當 AdView 從 Controller 取得 Ad 物件時，呼叫 Ad 物件身上的 buildComponent 方法取得顯示用的 Component。 當我們這樣做之後，View 再也無需關心現在到底是哪一種廣告，只需要呼叫 buildComponent 即可取得相對應的廣告畫面，並把它塞進畫面中即可。\n\n![Discuss - Strategy for vo.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Strategy_for_vo.jpg)\n\n在 GeneralAd 與 ContestAd 中，它們會各自實現 buildComponent，提供該類型廣告的 Widget 給 View 顯示。\n\n### 優點\n\n- 畫面可以使用一致的邏輯處理資料\n\n### 缺點\n\n- Value Object 會認識 View\n\n# 結論\n\n由於客戶端畫面可能會相當多變，後端可能會給一個 type，不同 type 所包含的資料格式也大不相同，如何處理這個資料與畫面的關係也沒有標準答案，即便問題相似，但是在不同的 Context 之下，也適合不同的解法，只有根據當下情況選擇適當的做法，才能讓後續開發與維護更加順利。",
      "createdAt": "February 21, 2023 11:40 PM",
      "updatedAt": "October 24, 2025 4:48 PM",
      "id": "c87c61c7fc3541378813919fd3d19efa",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "如何處理善變的畫面 c87c61c7fc3541378813919fd3d19efa.md"
    },
    {
      "title": "如何使用 Flame 開發一個小遊戲",
      "summary": "來到了 2023 年，今年就來學點不同的東西。本身興趣之一就是喜歡打電動，所以打從學寫程式以來，一直都有想自己寫遊戲的想法，但是一直都懶得去實現。自從學了 Flutter 之後，隱隱覺得 [Flutter](https://docs.flame-engine.org/1.4.0/index.html...",
      "content": "![carl-raw-m3hn2Kn5Bns-unsplash.jpg](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/carl-raw-m3hn2Kn5Bns-unsplash.jpg)\n\n來到了 2023 年，今年就來學點不同的東西。本身興趣之一就是喜歡打電動，所以打從學寫程式以來，一直都有想自己寫遊戲的想法，但是一直都懶得去實現。自從學了 Flutter 之後，隱隱覺得 [Flutter](https://docs.flame-engine.org/1.4.0/index.html) 的渲染模式其實跟遊戲十分相似，也從許多文章或影片中得知 Flame 這個基於 Flutter 的遊戲引擎，今天就來學學如何製作一個小遊戲吧 🕹️。\n\n## 引入 Flame\n\n當然第一步最重要的就是，把 flame 套件引入到我們的專案中\n\n```bash\nflutter pub add flame\n```\n\n當我們執行下面命令後，我們就能在 pubspec.yml 中發現多了 flame\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flame: ^1.5.0\n```\n\n## 使用 GameWidget\n\n開始使用 Flame 之後，第一個面對的 Widget 是 `GameWidget`，如同我們在 Flutter 中使用的各式各樣的 Widget，這個 `GameWidget` 也能直接被放在我們的 Flutter 程式中。GameWidget 有一個必要的參數：`Game`，可以想像成是整個遊戲最外層的 Component，有點類似於 Flutter 的 `MaterialApp`。\n\n```dart\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: GameWidget(\n        game: MyGame(),\n      ),\n    );\n  }\n}\n\nclass MyGame extends FlameGame {}\n```\n\n當我們執行上面這段程式碼後，會發現程式雖然可以執行，畫面卻是一片空白。這也是正常的，來為畫面加上一些東西吧。\n\n```dart\nclass MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    camera.zoom = 4;\n    await add(Knight(\n      position: size / 2,\n      anchor: Anchor.center,\n      size: Vector2(120, 80),e\n    ));\n  }\n}\n\nclass Knight extends PositionComponent {\n  Knight({super.position, super.size, super.anchor});\n\n  @override\n  Future<void> onLoad() async {\n    var animation = await SpriteAnimation.load(\n      \"knight_idle.png\",\n      SpriteAnimationData.sequenced(\n        amount: 10,\n        stepTime: 0.1,\n        textureSize: Vector2(120, 80),\n      ),\n    );\n    await add(SpriteAnimationComponent(\n      animation: animation,\n      size: size,\n    ));\n  }\n}\n```\n\n在上面我們中在 onLoad 中加入一個騎士的待機圖，當執行之後就會在畫面上看到騎士待機站立的遊戲畫面。\n\n![knight_idle.gif](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/knight_idle.gif)\n\n## 為騎士加上不同動作\n\n如果只有看著騎士在畫面上站著不動，這也不能算是個遊戲吧。為了讓他有點遊戲的感覺，我們可以加上一個行為：當點擊畫面，騎士就進行攻擊。\n\n為了讓騎士有更多動作，首先我們需要先修改一下動畫，使用 `SpriteAnimationGroupComponent` 針對不同行為，使用不同的動畫。透過設定 `SpriteAnimationGroupComponent` 的 current 變數，來決定當下要播放靜止站立的動畫，或攻擊的動畫。\n\n```dart\n@override\nFuture<void> onLoad() async {\n  var idleAnimation = await SpriteAnimation.load(\n    \"knight_idle.png\",\n    SpriteAnimationData.sequenced(\n      amount: 10,\n      stepTime: 0.1,\n      textureSize: Vector2(120, 80),\n    ),\n  );\n\n  var attackAnimation = await SpriteAnimation.load(\n    \"knight_attacking.png\",\n    SpriteAnimationData.sequenced(\n      amount: 10,\n      stepTime: 0.1,\n      textureSize: Vector2(120, 80),\n      loop: false,\n    ),\n  );\n\n  await add(_animations = SpriteAnimationGroupComponent<KnightBehavior>(\n    current: KnightBehavior.idle,\n    size: size,\n    animations: {\n      KnightBehavior.idle: idleAnimation,\n      KnightBehavior.attack: attackAnimation\n    },\n  ));\n}\n```\n\n![螢幕錄影_2023-01-02_上午10_27_10_AdobeExpress.gif](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/%25E8%259E%25A2%25E5%25B9%2595%25E9%258C%2584%25E5%25BD%25B1_2023-01-02_%25E4%25B8%258A%25E5%258D%258810_27_10_AdobeExpress.gif)\n\n## 新增點擊操作\n\n當我們的騎士可以支援多種不同的動作之後，下一步就是指定觸發條件了，讓程式知道什麼時候要播放靜止站立的動畫，什麼時候要播放攻擊動畫。當使用者點擊畫面時，騎士就播放攻擊動畫。為此，我們需要修改幾個地方，以收取點擊事件。\n\n- `MyGame` 加上 `HasTappableComponents`\n\n```dart\nclass MyGame extends FlameGame with HasTappableComponents {\n}\n```\n\n- `Knight` 加上 `TapCallbacks` 並覆寫 `onTapUp` 與 `containsLocalPoint`\n\n```dart\nclass Knight extends PositionComponent with TapCallbacks {\n\n  @override\n  Future<void> onLoad() async {}\n\n  @override\n  bool containsLocalPoint(Vector2 point) => true;\n\n  @override\n  void onTapUp(TapUpEvent event) {\n    _animations.current = KnightBehavior.attack;\n  }\n}\n```\n\n我們可以把點擊之後的行為放在 onTapUp 的方法中，指定 `SpriteAnimationGroupComponent` 的 current 變數為 KnightBehavior.attack，騎士就會在點擊之後，進入攻擊狀態。\n\n## 更進一步\n\n在我們新增點擊操作之後，我們可以紀錄騎士進行了幾次攻擊，並顯示在畫面上，變成一個簡單的點擊計數小遊戲，就像 Flutter 專案預設的 App 一樣。\n\n首先，我們在 `MyGame` 中加上 count 變數紀錄次數\n\n```dart\nclass MyGame extends FlameGame with HasTappableComponents {\n  int count = 0;\n}\n```\n\n然後在 `Knight` 加上 `HasGameRef<MyGame>` ，讓我們可以修改 `MyGame` 中的 counter\n\n```dart\nclass Knight extends PositionComponent with TapCallbacks, HasGameRef<MyGame> {\n\n  @override\n  void onTapUp(TapUpEvent event) {\n\t\tif (_animations.current == KnightBehavior.idle) {\n      _animations.current = KnightBehavior.attack;\n      gameRef.count++;\n    }\n  }\n  \n}\n```\n\n最後在 `MyGame` 的 onLoad 中加上一個 `Counter` 用來顯示次數。`Counter` 類似於 `Knight` 也是一個 Component，在 `Counter` 的 onLoad 中加上一個 `TextComponent` 顯示文字，並在複寫 update 方法，Flame 會在遊戲進行時，持續呼叫每個 Component 的 update 方法，讓我們可以更新 Component 的畫面，我們可以透過 update 方法持續更新最新計數了。\n\n```dart\nclass MyGame extends FlameGame with HasTappableComponents {\n  int count = 0;\n\n  @override\n  Future<void> onLoad() async {\n    camera.zoom = 4;\n    await add(Knight(\n      position: size / 2,\n      anchor: Anchor.center,\n      size: Vector2(120, 80),\n    ));\n    await add(Counter(\n      position: size / 2..sub(Vector2(0, 20)),\n      anchor: Anchor.center,\n    ));\n  }\n}\n\nclass Counter extends PositionComponent with HasGameRef<MyGame> {\n  Counter({super.position, super.size, super.anchor});\n\n  late TextComponent _text;\n\n  @override\n  Future<void> onLoad() async {\n    await add(_text = TextComponent(\n      anchor: anchor,\n      textRenderer: TextPaint(\n        style: const TextStyle(color: Colors.white, fontSize: 10),\n      ),\n    ));\n  }\n\n  @override\n  void update(double dt) {\n    _text.text = \"Knight has attacked ${gameRef.count} times\";\n  }\n}\n```\n\n![螢幕錄影_2023-01-02_上午10_57_43_AdobeExpress.gif](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/%25E8%259E%25A2%25E5%25B9%2595%25E9%258C%2584%25E5%25BD%25B1_2023-01-02_%25E4%25B8%258A%25E5%258D%258810_57_43_AdobeExpress.gif)\n\n## 結論\n\nFlame 是基於 Flutter 框架之上的遊戲引擎，其中我們會碰到許多各式各樣的 Component，透過組合不同的 Component 完成各式各樣的遊戲效果，感覺有點像是在 Flutter 中組合各種不同的 Widget 來製作各式各樣的畫面。為了完成這個點擊小遊戲，我們使用了許多 Component，例如：`FlameGame` 、`SpriteAnimationGroupComponent`、`TextComponent` …等等，文章中的程式放在[這邊](https://github.com/easylive1989/knight_counter_demo)，有興趣的朋友也可以參考看看。",
      "createdAt": "January 1, 2023 11:37 AM",
      "updatedAt": "October 24, 2025 4:48 PM",
      "id": "ddaa1e706f2a4949a2bbd7d19e4d7674",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "如何使用 Flame 開發一個小遊戲 ddaa1e706f2a4949a2bbd7d19e4d7674.md"
    },
    {
      "title": "用 Flutter Web 製作 Chrome Extension 待讀文章看板",
      "summary": "有一陣子沒寫文章了，趁著前陣子剛完成了[鐵人賽](https://ithelp.ithome.com.tw/users/20129825/ironman/4992)，趁著開始比較有空閒，就來更新一下最近學到的新東西XD。 在日常生活和工作中，每當看到一些不錯的文章，想要晚一點再看時，我們可以使用 N...",
      "content": "有一陣子沒寫文章了，趁著前陣子剛完成了[鐵人賽](https://ithelp.ithome.com.tw/users/20129825/ironman/4992)，趁著開始比較有空閒，就來更新一下最近學到的新東西XD。\n\n![wesley-tingey-snNHKZ-mGfE-unsplash.jpg](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/wesley-tingey-snNHKZ-mGfE-unsplash.jpg)\n\n在日常生活和工作中，每當看到一些不錯的文章，想要晚一點再看時，我們可以使用 Notion 官方推出的 Chrome Extension：[Notion Web Clipper](https://chrome.google.com/webstore/detail/notion-web-clipper/knheggckgoiihginacbkhaalnibhilkk)，快速的把文章儲存到 Notion 中的某個資料庫，等到有空閑的時間，我就能從資料庫中找到那篇想讀的文章。有時候，我們會記得回來看資料庫是否有未讀的文章，但更多是，在我們有空的時候，我們早就不記得資料庫中有一些文章正等著我們去讀，然後把這寶貴的空閒時間浪費掉了。\n\n# 難以維持習慣\n\n有時，我們學了新東西，一開始比較有熱情，可以讓新習慣維持一陣子。但是，有時候我們會忘記，有時候我們會懶惰，一次兩次的失敗，我們漸漸開始無心維持新習慣，最後就慢慢地回到舊的習慣。如同[最小阻力之路](https://www.books.com.tw/products/0010696380)中提到的，在大自然中，能量會往阻力最小的路線前進，這個道理也同樣適用於人。大多時候，我們所選做的決定，所選擇的方向，也都是自然而然地從阻力最小的方向去走。當我們嘗試建立新的習慣，總會帶來一些阻力，越是平常根本不做的事情，阻力越大，時間一長，我們自然而然的就會回到阻力最小的舊習慣。\n\n# 讓執行習慣毫不費勁\n\n那我們如何減小新習慣的阻力呢？我們可以運用[原子習慣](https://www.books.com.tw/products/0010822522)中提到的一個技巧：**習慣堆疊。**\n\n> 把新習慣放到每天已經習慣做的事情綁在一起。\n> \n\n於是我觀察我自己的原有的習慣，發現自己每天早上都一定會透過 Chrome 擴充功能的 [Google Mail Checker](https://chrome.google.com/webstore/detail/google-mail-checker/mihcahmgecmbnbcchbopgniflfhgnkff) 處理信件，並使用 [Feedly Notifier](https://chrome.google.com/webstore/detail/feedly-notifier/egikgfbhipinieabdmcpigejkaomgjgb) 看看自己訂閱的 RSS 有沒有什麼新文章。於是，我從商店中找找看是否有適用的擴充功能，看看有沒有像是 Mail Checker 一樣，可以顯示 Notion Daatabase 中還有多少待讀文章，但比較可惜的是大多擴充功能都是強化原本 Notion Web 版使用體驗。最後，我決定自己使用 Flutter Web 來做一個自用的 Chrome 擴充功能。\n\n# 建立 Chrome Extension\n\n之前我們透過 [Notion API 更新資料庫](https://easylive1989.medium.com/%E5%88%A9%E7%94%A8-notion-api-%E8%87%AA%E5%8B%95%E6%9B%B4%E6%96%B0%E6%AC%84%E4%BD%8D-318eac43008e?source=your_stories_page-------------------------------------)，這次也同樣需要使用 Notion API 來幫助我們取得待讀清單，再加上用 Flutter Web 建立 Chrome 擴充功能，把所有未讀文章放在擴充功能畫面上。\n\n首先我們得先建立一個 Flutter Project\n\n```bash\nflutter create notion_assistant\n```\n\n在 web 資料夾放入 manifest.json，和加上 index.html 取代原本檔案\n\n```bash\n{\n    \"name\": \"Notion Assistant\",\n    \"version\": \"0.1\",\n    \"manifest_version\": 2,\n    \"browser_action\" :{\n        \"default_popup\": \"index.html\",\n        \"default_icon\" : \"icons/Icon-192.png\"\n    },\n    \"icons\": {\n        \"16\": \"icons/Icon-192.png\"\n    }\n}\n```\n\n```html\n<html style=\"height: 300px; width: 300px\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Notion Assistant</title>\n</head>\n<body>\n<script src=\"main.dart.js\" type=\"application/javascript\"></script>\n</body>\n</html>\n```\n\n當我們用 flutter  build 出 web app 時，flutter 會把畫面的部分建成 main.dart.js，同時使用 —[web-renderer](https://docs.flutter.dev/development/platform-integration/web/renderers) 讓 flutter 用 html + css 來渲染畫面。\n\n```html\nflutter build web --web-renderer html\n```\n\n最後我們打開 Chrome 擴充功能設定 ( chrome://extensions )，從右上角開啟開發人員模式並載入未封裝項目，選擇 build/web 資料夾中的建置結果，我們就能在 Chrome 擴充功能中看到 Flutter 預設的 counter app。\n\n![截圖 2022-11-06 下午12.13.39.png](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/%25E6%2588%25AA%25E5%259C%2596_2022-11-06_%25E4%25B8%258B%25E5%258D%258812.13.39.png)\n\n此時，我們就能開始針對自己的需求製作畫面了擴充功能的畫面了，之後就是根據個人需求整畫面與 API 的使用了，以我自己來說，就是顯示待讀文章列表。\n\n![截圖 2022-11-06 上午10.42.04.png](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/%25E6%2588%25AA%25E5%259C%2596_2022-11-06_%25E4%25B8%258A%25E5%258D%258810.42.04.png)\n\n# 畫面以外的功能\n\n當我們只想知道還有多少未讀文章，每次都要點開擴充功能才能知道，不免有些麻煩，此時，我們可以使用 Chrome 擴充功能的 Background Job 幫我們定期呼叫 API，並更新 count 到 badge 上。第一步我們得先稍微修改一個 manifest.json，增加 background 的設定。\n\n```json\n{\n    \"background\": {\n        \"persistent\": true,\n        \"scripts\": [\"background.js\"]\n    },\n}\n```\n\n接下來我們就得想辦法產生 background.js 了。如果稍微會寫 Javascript 的朋友，這邊可以考慮根據自己的需求，直接使用 Javascript 實作 background.js。但是在這邊，讓我們嘗試用 Dart 來製作 background.js 吧，也因為同樣是使用 Dart ，所以我們可以共用製作畫面時 Dart 程式碼，讓我們省一點功夫。\n\n# 用 Dart 製作 background.js\n\nDart SDK 中，有提供[工具](https://dart.dev/tools/dart2js)讓我們能把 Dart 轉換成 Javascript，用這個工具我們就能先寫一份 background.dart，再透過他幫我轉成 Javascript。在 background.dart 中，import dart:js 之後，我們可以拿到 context，並用 context 呼叫到 [Chrome API](https://developer.chrome.com/docs/extensions/reference/browserAction/#badge)，並透過其設定 Badge 的上的文字與顏色。\n\n```bash\nimport 'dart:async';\nimport 'dart:js';\n\nvoid main() {\n  _setBadge(1);\n  Timer.periodic(const Duration(seconds: 300), (timer) async {\n    _setBadge(2);\n  });\n}\n\nvoid _setBadge(int count) {\n  var badgeText = JsObject.jsify({\"text\": \"$count\"});\n  var badgeBackgroundColor = JsObject.jsify({\"color\": \"#D00218\"});\n  context[\"chrome\"][\"browserAction\"].callMethod(\"setBadgeText\", [badgeText]);\n  context[\"chrome\"][\"browserAction\"].callMethod(\"setBadgeBackgroundColor\", [badgeBackgroundColor]);\n}\n```\n\n上面示範程式碼只有展示如何設定 Badge，實際則是需要根據自身需求，決定設定什麼文字到 Badge 上，我們這邊就不過多展示，有興趣有可以直接到 [https://github.com/easylive1989/notion_assistant](https://github.com/easylive1989/notion_assistant) 中查看。\n\n當寫完 background.dart 之後，最後在呼叫指令產生 background.js 即可。\n\n```bash\ndart compile js lib/background.dart -o background.js\n```\n\n最後我們就能成功的在 Chrome 擴充功能的圖示上看到 Badge 了。\n\n![截圖 2022-11-06 下午10.53.05.png](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/%25E6%2588%25AA%25E5%259C%2596_2022-11-06_%25E4%25B8%258B%25E5%258D%258810.53.05.png)\n\n# 結論\n\n當我們從書上或他人身上學到新的方法，通常無法直接的複製到自己身上，畢竟自身的環境或習慣與他人並不完全一樣。想要讓新方法融入自己的生活，必定得耐心思考與嘗試一番，經過不斷地調整與實驗，最終才能找到適合自己的工作方式，讓我們花費最少心力，把重要的注意力放在更重要的事情上。\n\n# 參考\n\n- Repository：[https://github.com/easylive1989/notion_assistant](https://github.com/easylive1989/notion_assistant)",
      "createdAt": "November 5, 2022 11:13 PM",
      "updatedAt": "October 24, 2025 5:20 PM",
      "id": "1baca95d3dd34180a74bc918af8f500c",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "用 Flutter Web 製作 Chrome Extension 待讀文章看板 1baca95d3dd34180a74bc918af8f500c.md"
    },
    {
      "title": "畫面莫名其妙地重 build 了",
      "summary": "Flutter 自帶各式各樣的 Widget，能透過改變 Widget 的參數，讓畫面符合開發者想要的設計。在大部分的時間裏，能有效減低開發者的開發時間。但是如果開發者使用方式不正確的話，往往會造成不預期的結果，今天就來分享一個問題。 假設我們有一個簡單的應用，總共有兩個頁面：第一個頁面會顯示一組隨...",
      "content": "![image.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/image.png)\n\nFlutter 自帶各式各樣的 Widget，能透過改變 Widget 的參數，讓畫面符合開發者想要的設計。在大部分的時間裏，能有效減低開發者的開發時間。但是如果開發者使用方式不正確的話，往往會造成不預期的結果，今天就來分享一個問題。\n\n## 舉個例子\n\n假設我們有一個簡單的應用，總共有兩個頁面：第一個頁面會顯示一組隨機繁體中文數字，然後使用者需要記下該數字，並且在第二頁輸入結果。Submit 之後，會在第一個頁面的底部顯示答案是否正確。\n\n![rebuild_by_media_query.drawio.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/rebuild_by_media_query.drawio.png)\n\n第一個頁面的程式碼\n\n```dart\nclass FirstPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    String randomNumber = _getRandomNumber();\n    return Scaffold(\n      body: Column(\n        children: [\n          Container(\n            alignment: Alignment.center,\n            height: MediaQuery.of(context).size.height * 0.6,\n            child: Text(\n              \"What's the number: ${NumberConvertor.toText(randomNumber)}\",\n            ),\n          ),\n          OutlinedButton(\n            child: const Text(\"Go to answer\"),\n            onPressed: () async {\n              var result = await Navigator.of(context).pushNamed(\"/second\");\n              ScaffoldMessenger.of(context).showSnackBar(SnackBar(\n                content: Text(\"Answer is ${result == randomNumber ? \"correct\" : \"wrong\"}\"),\n              ));\n            },\n          ),\n        ],\n      ),\n    );\n  }\n\n  String _getRandomNumber() {\n    return Random().nextInt(100).toString();\n  }\n}\n```\n\n第二個頁面的程式碼\n\n```dart\nclass SecondPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Container(\n          alignment: Alignment.center,\n          width: 300,\n          child: TextFormField(\n            keyboardType: TextInputType.number,\n            onFieldSubmitted: (text) => Navigator.of(context).pop(text),\n            decoration: const InputDecoration(\n              border: OutlineInputBorder(),\n              label: Text(\"Answer\"),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 發生了不預期狀況\n\n當使用者在第二個頁面填完答案回到第一頁面時，會發現雖然訊息顯示答案正確，但是原本的題目卻已經變成另外一組了\n\n![unknown_situation.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/unknown_situation.png)\n\n## 發生了什麼事\n\n如果我們 debug 了一下程式，就會發現一個神奇的狀況：當使用者在第二的頁面點開鍵盤時，第一個頁面就會重新 build 了一次，導致畫面又重新取了一次亂數，新的數字就出現在畫面上。\n\n![1654349336823.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/1654349336823.png)\n\n為什麼麼第二個頁面的動作會影響到第一個頁面呢？讓我們回到第一個頁面的程式碼，仔細觀察與實驗就會發現，是 MediaQuery.of(context) 在搞的鬼。\n\n```dart\nContainer(\n  alignment: Alignment.center,\n  height: MediaQuery.of(context).size.height * 0.6,\n  child: Text(\n    \"What's the number: ${NumberConvertor.toText(randomNumber)}\",\n  ),\n),\n```\n\n如果我們把 MediaQuery.of(context).size.height * 0.6 置換成固定值。\n\n```dart\nContainer(\n  alignment: Alignment.center,\n  height: 500,\n  child: Text(\n    \"What's the number: ${NumberConvertor.toText(randomNumber)}\",\n  ),\n),\n```\n\n當輸入答案回來之後，題目還是維持的原來的題目。\n\n![consistant_result.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/consistant_result.png)\n\n## MediaQuery.of(context) 做了什麼？\n\n如果我們查看 MediaQuery.of(context) 的原始碼，會發現其中有段 context.dependOnInheritedWidgetOfExtractType，如果再往裡面查，會發現這不過是 BuildContext 這個介面上的一個方法。\n\n```dart\nstatic MediaQueryData of(BuildContext context) {\n  assert(context != null);\n  assert(debugCheckHasMediaQuery(context));\n  return context.dependOnInheritedWidgetOfExactType<MediaQuery>()!.data;\n}\n```\n\n實作則需要找到 Element 這個類別。\n\n```dart\n@override\nT? dependOnInheritedWidgetOfExactType<T extends InheritedWidget>({Object? aspect}) {\n  assert(_debugCheckStateIsActiveForAncestorLookup());\n  final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T];\n  if (ancestor != null) {\n    return dependOnInheritedElement(ancestor, aspect: aspect) as T;\n  }\n  _hadUnsatisfiedDependencies = true;\n  return null;\n}\n\n@override\nInheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) {\n  assert(ancestor != null);\n  _dependencies ??= HashSet<InheritedElement>();\n  _dependencies!.add(ancestor);\n  ancestor.updateDependencies(this, aspect);\n  return ancestor.widget;\n}\n```\n\n當執行 dependOnInheritedWidgetOfExactType 時，會把 MediaQuery 的 InheritedElement 塞到 Element 身上的 _dependencies 中，同時也會呼叫 ancestor.updateDependencies，把自己也塞到 InheritedElement 的 _dependents 中。\n\n當 InheritedElement 發生改變時，就會呼叫身上的 notifyClients，從而更新所有的 dependents。\n\n```dart\n@override\nvoid notifyClients(InheritedWidget oldWidget) {\n  assert(_debugCheckOwnerBuildTargetExists('notifyClients'));\n  for (final Element dependent in _dependents.keys) {\n    assert(() {\n      // check that it really is our descendant\n      Element? ancestor = dependent._parent;\n      while (ancestor != this && ancestor != null)\n        ancestor = ancestor._parent;\n      return ancestor == this;\n    }());\n    // check that it really depends on us\n    assert(dependent._dependencies!.contains(this));\n    notifyDependent(oldWidget, dependent);\n  }\n}\n```\n\n回到例子上，也就是當第一個頁面呼叫 MediaQuery.of(context) 時，就已經向 MediaQuery 註冊了一個觀察者，當 MediaQuery 因為鍵盤的出現導致畫面高度發生改變時，第一頁面也就跟著一起重 build 了。\n\n## 如何解決問題\n\n回到我們的問題上，如何讓第一個頁面不要重 build 呢？以上面這個例子來看，目的只是想依照固定高度比例來設計畫面，可以簡單的使用 Column + Expanded 解決。\n\n## 小結\n\n我自己覺得 Flutter 把 Widget 設計得十分方便，讓使用者可以用比較少的程式碼就完成功能，但是其中比較困難的就是許多細節被隱藏在框架之中。像是一般情況下，我們幾乎不會碰到 InheritedWidget，更多的是直接使用他的衍生類別或 Wrapper，在這種情況下，我們就很難知道這行程式碼究竟會帶來什麼影響，進而造成一些不預期的狀況。除了明白如何使用框架，有時也需要深入理解框架做了什麼，才能更有效地使用框架。\n\n## 參考\n\n- 範例程式碼：[https://github.com/easylive1989/chinese_number_validator](https://github.com/easylive1989/chinese_number_validator)\n- Flutter framework.dart：[https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart)",
      "createdAt": "May 10, 2022 11:33 PM",
      "updatedAt": "October 24, 2025 5:21 PM",
      "id": "7073aa4ed07d42d8929752e25fbf71fa",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "畫面莫名其妙地重 build 了 7073aa4ed07d42d8929752e25fbf71fa.md"
    },
    {
      "title": "使用 Nested Navigation 簡化路由設計",
      "summary": "Flutter 習慣在最頂層的 MaterialApp 或 CupertinoApp 中統一定義整個 app 的路由管理。當我們把所有頁面的路由管理都放在最頂層時，就會讓它變得很長，不容易維護。或許應該適時思考，是否某些頁面的路由不應該被管理在最頂層。今天就來分享工作上遇到的一個情境，以及它存在什麼...",
      "content": "Flutter 習慣在最頂層的 MaterialApp 或 CupertinoApp 中統一定義整個 app 的路由管理。當我們把所有頁面的路由管理都放在最頂層時，就會讓它變得很長，不容易維護。或許應該適時思考，是否某些頁面的路由不應該被管理在最頂層。今天就來分享工作上遇到的一個情境，以及它存在什麼問題，而我們又是如何解決的。\n\n## 舉個例子\n\n假設我們需要實作一個搜尋附近裝置並傳輸檔案到該裝置的需求，一開始我們會搜尋附近裝置，完成之後，畫面會顯示可選擇的裝置清單給使用者進行選擇，當使用者完成選擇之後，畫面會列出檔案清單讓使用者選擇，當使用者選完檔案並按下 Transfer 按鈕後進行傳輸工作。當傳輸工作完成時，回到最一開始的頁面，並顯示 Transfer success 的訊息讓使用者知道。\n\n![nested navigation.drawio.png](%E4%BD%BF%E7%94%A8%20Nested%20Navigation%20%E7%B0%A1%E5%8C%96%E8%B7%AF%E7%94%B1%E8%A8%AD%E8%A8%88/nested_navigation.drawio.png)\n\n## 用 Top-Level Navigation 方式實作\n\n我們設計了三個頁面，分別是 SearchDevicesPage、SelectDevicePage 和 SelectFilePage，三個頁面的工作分別是搜尋裝置、讓使用者選擇裝置和 讓使用者選擇檔案，每個頁面都是定義在頂層的路由。為此，我們在路由管理中有了起始頁面 Home 與傳輸檔案所需要的三個頁面。\n\n```dart\nRoute _onGenerateRoute(RouteSettings routeSettings) {\n  if (routeSettings.name == HomePage.routeName) {\n    return MaterialPageRoute(builder: (BuildContext context) => const HomePage());\n  } else if (routeSettings.name == SearchDevicesPage.routeName) {\n    return MaterialPageRoute<TransferResult>(\n      builder: (BuildContext context) => const SearchDevicesPage(),\n      settings: routeSettings,\n    );\n  } else if (routeSettings.name == SelectDevicePage.routeName) {\n    return MaterialPageRoute<TransferResult>(\n      builder: (BuildContext context) => const SelectDevicePage(),\n      settings: routeSettings,\n    );\n  } else if (routeSettings.name == SelectFilePage.routeName) {\n    return MaterialPageRoute<TransferResult>(\n      builder: (BuildContext context) => const SelectFilePage(),\n      settings: routeSettings,\n    );\n  }\n  throw RouteNotFoundException(\"Need to implement ${routeSettings.name}\");\n}\n```\n\n當使用者在 Home 頁面中按下 + 按鈕，想要傳輸檔案時，程式會先打開 SearchDevicesPage 並開始搜尋附近的裝置。當搜尋完成並且使用者按下 Next 按鈕後，程式會開啟下一個頁面：SelectDevicePage，並把搜尋到的裝置清單傳給下一個頁面顯示。\n\n```dart\nFuture _openSelectDevicePage(BuildContext context, List<Device> devices) async {\n  Navigator.of(context).pushNamed(SelectDevicePage.routeName, arguments: devices);\n}\n```\n\n在 SelectDevicePage 中，畫面會顯示裝置清單。當使用者選擇任一裝置後按下 Next，程式就會開啟下一個頁面：SelectFilePage，並且把使用者選擇的裝置傳給它。\n\n```dart\nFuture _openSelectFilePage(BuildContext context) async {\n  Navigator.of(context).pushNamed(SelectFilePage.routeName, arguments: selectedDevice);\n}\n```\n\n當使用者來來到 SelectFilePage 時，畫面會顯示檔案清單。當使用者選擇任一檔案後按下 Next，程式會使用上一個頁面給的裝置與這個頁面選擇的檔案進行傳輸工作。當傳輸工作完成之後，把傳輸結果往回傳遞。\n\n```dart\nawait _transfer(selectedDevice, selectedFile!);\nNavigator.pop(context, TransferResult.success);\n```\n\n當 Navigator.pop 執行後，首先回到的是 SelectDevicePage 的 _openSelectDevicePage 方法中。我們需要修改這個方法，讓他可以取得從 SelectFilePage 得到傳輸的結果，並把他回傳給上一頁。\n\n```dart\nFuture _openSelectFilePage(BuildContext context) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(SelectFilePage.routeName, arguments: selectedDevice);\n  Navigator.pop(context, transferResult);\n}\n```\n\n同樣的 SearchDevicesPage 也需要進行修改，同樣的讓他可以把結果帶回給 HomePage。\n\n```dart\nFuture _openSelectDevicePage(BuildContext context, List<Device> devices) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(SelectDevicePage.routeName, arguments: devices);\n  Navigator.of(context).pop(transferResult);\n}\n```\n\n在 HomePage 中，當程式從 SearchDevicesPage 回來時，就可以取得傳輸檔案的結果，並決定畫面如何顯示。以下面程式碼來說，當傳輸成功時，我們會在畫面上顯示一個 Snackbar 訊息提示傳輸成功。\n\n```dart\nFuture _openSearchDevicePage(BuildContext context) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(SearchDevicesPage.routeName);\n  if (transferResult == TransferResult.success) {\n    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text(\"Transfer success\")));\n  }\n}\n```\n\n[完整程式碼](https://github.com/easylive1989/transfer_file/tree/pop_with_result)\n\n## 作法分析\n\n這種設計可能存在一些問題\n\n- 頁面會被強迫知道他不需要的資訊\n\n以上面的例子來說，SelectFilePage 本身的工作應該是讓使用者選擇檔案，但是他卻也同時必須儲存使用者選擇的裝置，只為了完成傳輸的工作。或許我們可以把傳輸的工作移到 HomePage，但是這樣一來，我們也會需要把使用者選擇的裝置和檔案往回傳，同樣的造成 SelectDevicePage 也需要知道檔案的資訊，兩種做法都無可避免的導致某些頁面知道他不需要知道的資訊。\n\n```dart\nFuture _openTransferFilePage(BuildContext context) async {\n  File? file = await Navigator.of(context).pushNamed<File>(SelectFilePage.routeName);\n  if (file != null) {\n    Navigator.pop(context, TransferAction(selectedDevice!, file));\n  }\n}\n```\n\n- 流程路徑上的每個頁面都需要知道如何處理結果\n\n在上面例子中，每個頁面都會需要接回 TransferFileResult，並在 Navigator.pop() 中往回帶，這也表示每個頁面都需要知道 TransferResult 的存在，以及決定如何處理它。但實際上只有 HomePage 是真正需要的人，決定這個結果的是 SelectFilePage，它跟 HomePage 隔了兩個頁面，導致中間的頁面需要幫忙傳遞它們不需要的資訊。 \n\n```dart\nTransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(...);\nNavigator.pop(context, transferResult);\n```\n\n這些問題容易導致這些頁面無法重複使用，假設今天多了一種需求：同樣的選擇 Device，同樣的選擇檔案，最後卻是要傳送檔案資訊的文字，而不是傳送檔案本身。如果依照原本的設計修改的話，就會變成需要把最後的行為抽成方法或類別，把他從第一個頁面一路往下一個頁面傳，直到最後一個頁面，但是這個傳遞參數跟中間過程的頁面的工作毫無關係，他只是為了最後一個頁面需要而幫忙傳遞，提高了頁面之間的耦合度。\n\n## 用 Nested Navigation 實作\n\n為了解決這個問題，我們使用 [Nest Navigation](https://docs.flutter.dev/cookbook/effects/nested-nav) 來處理，讓頁面只知道自己需要的訊息，並且輸出他工作後的結果，至於如何使用就讓使用方來決定。\n\n我們使用上面的例子進行修改，先創建一個 TransferFileFlow，並在其中使用 Navigator Widget，給定一個 GlobalKey 放進 Navigator 中，我們需要使用 GlobalKey 來進行 Nested Navigator 的頁面切換。\n\n```dart\nclass TransferFileFlow extends StatefulWidget {\n  static const String routeName = \"transfer-file-flow\";\n\n  const TransferFileFlow({Key? key}) : super(key: key);\n\n  @override\n  State<TransferFileFlow> createState() => _TransferFileFlowState();\n}\n\nclass _TransferFileFlowState extends State<TransferFileFlow> {\n  final GlobalKey<NavigatorState> _nestedNavigatorKey = GlobalKey<NavigatorState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Navigator(\n        key: _nestedNavigatorKey,\n        initialRoute: SearchDevicesPage.routeName,\n        onGenerateRoute: _onGenerateRoute,\n      ),\n    );\n  }\n}\n```\n\n在 Navigator 中傳入 _onGenerateRoute，定義 TransferFileFlow 各個頁面的路由與實際頁面的關係。並把相對應的 callback 傳入實際頁面中，讓每一個頁面完成工作時可以通知 TransferFileFlow，讓 TransferFileFlow 可以切換到下一個頁面。比如說 SelectDevicePage 就傳入了 _onDeviceSelected，當使用者選擇了任一裝置後，就會呼叫 _onDeviceSelected，而 TransferFileFlow 就進行流程的下一步了。\n\n```dart\nRoute _onGenerateRoute(RouteSettings routeSettings) {\n  if (routeSettings.name == SearchDevicesPage.routeName) {\n    return MaterialPageRoute(\n      builder: (BuildContext context) => SearchDevicesPage(\n        onBack: _onSearchDevicesPageClose,\n        onDevicesSearched: _onDevicesSearched,\n      ),\n    );\n  } else if (routeSettings.name == SelectDevicePage.routeName) {\n    return MaterialPageRoute(\n      builder: (BuildContext context) => SelectDevicePage(\n        searchedDevices: searchedDevices,\n        onDeviceSelected: _onDeviceSelected,\n      ),\n    );\n  } else if (routeSettings.name == SelectFilePage.routeName) {\n    return MaterialPageRoute(\n      builder: (BuildContext context) => SelectFilePage(\n        onFileSelected: _onFileSelected,\n      ),\n    );\n  }\n  throw RouteNotFoundException(\"Need to implement ${routeSettings.name}\");\n}\n```\n\n在每個 callback 中，TransferFileFlow 接收每一個頁面的輸出，並暫存在自己身上。在最後一個頁面完成之後，就進行傳輸檔案的動作。\n\n```dart\nvoid _onDevicesSearched(List<Device> devices) {\n  searchedDevices = devices;\n  _nestedNavigatorKey.currentState?.pushNamed(SelectDevicePage.routeName);\n}\n\nvoid _onDeviceSelected(Device device) {\n  selectedDevice = device;\n  _nestedNavigatorKey.currentState?.pushNamed(SelectFilePage.routeName);\n}\n\nFuture _onFileSelected(File file) async {\n  selectedFile = file;\n  await _transfer(selectedDevice, selectedFile);\n  Navigator.of(context).pop(TransferResult.success);\n}\n```\n\n當整個 TransferFileFlow 的流程完成之後，TransferFileFlow 就會回傳 TransferResult 給 HomePage。中間也不存在任何頁面幫忙傳遞結果，而是 TransferFileFlow 送出結果，HomePage 下一秒收到後就馬上使用。\n\n```dart\nFuture _openTransferFileFlow(BuildContext context) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(TransferFileFlow.routeName);\n  if (transferResult != null) {\n    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text(\"Transfer success\")));\n  }\n}\n```\n\n至於原本頂層路由管理就會只剩下 HomePage 與 TransferFlow，也會變得簡單一些。\n\n```dart\nRoute _onGenerateRoute(RouteSettings routeSettings) {\n  if (routeSettings.name == HomePage.routeName) {\n    return MaterialPageRoute(builder: (BuildContext context) => const HomePage());\n  } else if (routeSettings.name == TransferFileFlow.routeName) {\n    return MaterialPageRoute<TransferResult>(builder: (BuildContext context) => const TransferFileFlow());\n  }\n  throw RouteNotFoundException(\"Need to implement ${routeSettings.name}\");\n}\n```\n\n[完整程式碼](https://github.com/easylive1989/transfer_file/tree/nested_navigator)\n\n## 作法分析\n\n- 傳遞給頁面的參數恰好是頁面所需要的\n\n使用 Nested Navigation，把控制流程的的工作轉交給 TransferFileFlow，由 TransferFileFlow 把頁面需要的參數直接傳給它，頁面再也不需要幫忙傳遞任何參數。以上面的例子來說，我們再也不需要把使用者選擇的 Device 傳給 SelectFilePage 了，讓 SelectDevicePage 處理完之後傳給 TransferFileFlow，SelectFilePage 只要專注地處理使用者選擇的 File，並把使用者選擇的 File 傳給 TransferFileFlow，最後由 TransferFileFlow 組合資訊並完成工作。\n\n- 頁面無須處理與流程相關的邏輯\n\n頁面做完工作之後，也只需要專注的輸出結果給 Flow，由 Flow 來蒐集必要資訊，用以完成傳輸工作，並決定傳輸結果。當今天多了另一個類似需求，我們就可以創建另一個 Flow，該 Flow 可以根據需求來組合需要的頁面，最後再進行不同的操作，讓頁面不會因為與前後頁面之間的耦合導致難以重複使用。\n\n## 結論\n\nNested Navigation 十分適合使用在這種固定流程的工作上，如果頁面沒辦法單獨提供功能，而是需要多個頁面共同組合出一個功能的話，就很適合使用 Nested Navigation 這種做法。當一個頁面能提供完整的功能，例如顯示比賽資訊，顯示裝置詳細資訊，或者是更新使用暱稱這種單一頁面就可以完成的，或許就不太需要特別使用 Nested Navigation。\n\n## 參考\n\n- [https://docs.flutter.dev/cookbook/effects/nested-nav](https://docs.flutter.dev/cookbook/effects/nested-nav)",
      "createdAt": "April 23, 2022 10:41 AM",
      "updatedAt": "October 24, 2025 4:50 PM",
      "id": "b715b9e2fdc541bca3d6d234664eda2d",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "使用 Nested Navigation 簡化路由設計 b715b9e2fdc541bca3d6d234664eda2d.md"
    },
    {
      "title": "深入瞭解 GetX 的 Obx 與 Rx",
      "summary": "最近在做畫面時，滿常使用 GetX 的 Obx + Rx 變數，讓畫面可以根據狀態變化即時更新。過程中有時會碰到一些錯誤，在建置 Widget 的過程中，因為 Obx 找不到可以被監聽的目標，導致 Obx 認為使用者錯誤的使用了 Obx，所以透過 Exception 來提醒使用者。 Obx 的使用方...",
      "content": "![image.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/image.png)\n\n最近在做畫面時，滿常使用 GetX 的 Obx + Rx 變數，讓畫面可以根據狀態變化即時更新。過程中有時會碰到一些錯誤，在建置 Widget 的過程中，因為 Obx 找不到可以被監聽的目標，導致 Obx 認為使用者錯誤的使用了 Obx，所以透過 Exception 來提醒使用者。\n\n![截圖 2021-12-16 下午9.58.38.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%889.58.38.png)\n\nObx 的使用方法是把一個 builder 方法傳給 Obx 這個 Widget，不需要任何 Rx 變數做為參數。像是下面的這個簡單的 count 例子中，Obx 傳入一個 builder 方法，只要 builder 在建置 Widget 的過程中使用 Rx 變數，Obx 就能進行監聽。\n\n![截圖 2021-12-16 下午11.33.43.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.33.43.png)\n\n這就讓我自己十分好奇，Obx 到底是如何找到 builder 方法中的 Rx 變數，然後對這個 Rx 變數進行監聽呢？自己花了一些時間研究和實驗，今天就來分享一下，到底 GetX 中的 Obx 是如何完成他的工作的。\n\n## 兩位主角\n\n在  Counter 例子中，有兩個重要的物件，一個是 Obx，另一個則是存放 count 的 Rx 變數。其中 Obx 身上有一個型態為 RxNotifier 的 _observer 變數，主要用來監聽 Rx 變數並更新畫面的。而存放 count 的 Rx 變數的爺爺也是 RxNotifier。\n\n![3.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/3.png)\n\nRxNotifier 本身沒有任何實作，實作都是集中 NotifyManager 這個 mixin 身上。NotifyManger 身上主要有兩個方法 \n\n1. addListener：用來決定監聽什麼事件\n2. listen：用來決定監聽到事件後，要做什麼事\n\n## Obx 如何更新畫面\n\n當開始 build GetCountView 的畫面並 build 到 Obx 時，程式會先執行 ObxWidget initState() 方法。在 initState() 中執行 _observer.listen，並傳入 _updateTree，讓 _observer 監聽到事件時，可以呼叫 setState 更新畫面。\n\n![截圖 2021-12-20 上午12.57.02.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-20_%E4%B8%8A%E5%8D%8812.57.02.png)\n\n再來程式會走進 ObxWidget 的 build 方法。可以發現 ObxWidget 的 build 方法也就只是轉頭呼叫 RxInterface 的 notifyChildren 靜態方法，並傳入 ObxWidget 身上的 _observer 和 [widget.build](http://widget.build) 。\n\n![截圖 2021-12-16 下午11.36.31.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.36.31.png)\n\n此時的 widget.build 也就是我們在 GetCountView 中傳給 Obx 的那段印出 count 的 builder。\n\n![截圖 2021-12-16 下午11.34.41.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.34.41.png)\n\n當我們在深入 RxInterface.notifyChildren 之後，可以發現在程式會把 ObxWidget 身上的 _observer 塞到一個全域變數 RxInterface.proxy 中。然後繼續執行 builder 並 build 出顯示 count 數的 Text Widget。最後把 RxInterface.proxy 還原成原本的值，然後就回傳結果了。\n\n![截圖 2021-12-16 下午11.21.26.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.21.26.png)\n\n看到這邊好像還是不知道 Obx 到底是如何發現 builder 之中的 RxInt 的，我們只有看到 _observer 被賦予了他要觸發 setState 的工作，但是 _observer 是如何監聽 count 事件呢？\n\n## 在 Getter 中註冊監聽\n\n其實關鍵就在 builder 中。我們回頭看一下使用 Obx 那段程式碼，Text 中使用了 count.value，而關鍵就在這個 value getter 中。\n\n![截圖 2021-12-16 下午11.34.41.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.34.41.png)\n\n讓我們深入看一下 value 這個 getter 是如何被實作的。\n\n![截圖 2021-12-16 下午11.41.09.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.41.09.png)\n\n在使用 value getter 時，程式會向 RxInterface.proxy 這個全域變數註冊一個 subject，還記得先前 RxInterface.notifyChildren 做了什麼嗎，它把 ObxWidget 身上的 _observer 塞給 RxInterface.proxy，此時 value getter 中用的對象就是 ObxWidget 身上的 _observer。最後，當 value 發生變化時， Rx 變數就會透過 subject 通知 _observer。\n\n簡單來說，Obx 與 Rx 變數是透過 RxInterface 這個全域變數作為橋樑，讓兩者可以在 build 的時候建立觀察者模式。當 Rx 變數透過 value setter 賦值時，就能成功通知 ObxWidget 身上的 _observer，_observer 接收到事件之後就觸發 setState()，讓畫面根據新的狀態更新。\n\n## 整理流程\n\n1. GetCounterView 開始建置，隨後呼叫 ObxWidget 的 build 方法\n2. ObxＷidget 的 build 方法被呼叫後，轉頭直接把工作轉交給 RxInterface.notifyChildren，並且傳入 _observer 與 builder\n3. RxInterface 先是把 _observer 放進 RxInterface.proxy 中\n4. RxInterface.notifyChildren 呼叫 builder，建置 builder 中的 Widget\n5. builder 在建置的過程中會使用 count 這個 Rx 變數取得 count 值\n6. 取得 count 值過程中，Rx 也會呼叫 RxInterface.proxy?.addListener，讓 _observer 可以監聽\n\n![GetX 研究.drawio.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/GetX_%E7%A0%94%E7%A9%B6.drawio.png)\n\nps. 實際上並不是由 GetCountView 直接呼叫 [ObxWidget.build](http://Obx.build) 的，這邊只是簡化一下呼叫流程。實際上是由 GetCountView 的 Element 去呼叫的。\n\n## 小結\n\nGetX 作為熱門的 Flutter 狀態管理套件之一，有許多容易使用的 API，其中也大量的使用全域變數 。使用的時候還需要多加考慮一下，用得太多容易導致產品程式碼與套件緊緊相依，不只測試難寫，想抽換狀態管理的套件也會十分麻煩，使用的時候需要多多思考。",
      "createdAt": "December 12, 2021 9:41 PM",
      "updatedAt": "October 24, 2025 5:21 PM",
      "id": "9b167e815ad042cb85b02e7d3639e782",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "深入瞭解 GetX 的 Obx 與 Rx 9b167e815ad042cb85b02e7d3639e782.md"
    },
    {
      "title": "在 Flutter App 中整合 Google play In-App-Billing",
      "summary": "想在 App 上賺錢有兩種方式，一種是讓 App 本身是付費下載，另一種則是應用程式內購買。如果選擇應用程式內購買的話，在 iOS 上需要整合 Apple In App Purchase，而在 Google Play 上的話，則是需要整合 Google In App Billing，以下簡稱 Goo...",
      "content": "想在 App 上賺錢有兩種方式，一種是讓 App 本身是付費下載，另一種則是應用程式內購買。如果選擇應用程式內購買的話，在 iOS 上需要整合 Apple In App Purchase，而在 Google Play 上的話，則是需要整合 Google In App Billing，以下簡稱 Google IAB，本篇主要紀錄一下整合 Google IAB 的過程。\n\n# 後台設定\n\n在開始整合 Google IAB 之前，需要先準備一個 Google 開發者帳號。當準備好之後，就能使用該開發者帳號登入 Google Play Console ，進入到**應用程式內產品**的的選單中，點選建立產品，然後就可以新增可購買項目。設定完成後並啟用產品，表示這個產品已經上架販售。\n\n![截圖 2021-11-18 上午12.01.53.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-18_%E4%B8%8A%E5%8D%8812.01.53.png)\n\n當購買項目設定完成後，重新整理該頁面就會看到剛剛設定好的購買項目的列表。其中的產品 ID 是表示該購買項目的唯一 ID，稍後也會在程式碼使用中，用以獲取購買項目的詳細資訊。\n\n![截圖 2021-11-18 上午12.05.52.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-18_%E4%B8%8A%E5%8D%8812.05.52.png)\n\n值得注意的是，在設定購買項目之前，需要先上傳包含內購權限的 apk 到 Google Play 上。沒有完成這一步，在設定購買項目的頁面出會發現下面這個訊息，Google Play 提醒你需要上傳有內購權限的 apk。若是 App 還沒有準備要上架，可以先上傳 apk 到內部測試群組。\n\n![截圖 2021-11-17 上午8.47.18.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-17_%E4%B8%8A%E5%8D%888.47.18.png)\n\n除了自己手動到 Google Play 的後台去設定產品，開發人員也可以透過 [Google In App Products API](https://developers.google.com/android-publisher/api-ref/rest/v3/inappproducts) 對產品列表做新增修改刪除，方便開發者客製化自己的後台產品上架流程。\n\n# 整合 Google Play In App Billing\n\n### 安裝套件\n\n在 pub.dev 上，與應用程式內購買的相關的套件有不少，我們選擇使用 Flutter 官方提供的 in_app_purchase。這個套件除了可以用來整合 Google IAB，也同時包含了 Apple IAP。\n\n[**in_app_purchase | Flutter Package***A storefront-independent API for purchases in Flutter apps. This plugin supports in-app purchases ( IAP) through an…*pub.dev](https://pub.dev/packages/in_app_purchase)\n\nin_app_purchase 在 Google IAB 功能實作是基於 Android BillingClient。所以在整合的時候，可以適時參考 [整合 Android BillingClient](https://developer.android.com/google/play/billing/integrate) 的文章，有助於更了解 Google IAB 的核心流程。\n\n### 啟用 PendingPurchase\n\n在 2019 年的 Google I/O 上，Google 宣布 Google Play 將提供 Pending Transactions 功能，讓使用者擁有更多樣的付款方式。在整合 Google IAB 時，我們需要在 main 方法中加上 enablePendingPurchase 的程式碼，讓 App 支援 Pending Transactions 功能。\n\n```dart\nvoid main() {\n  if (defaultTargetPlatform == TargetPlatform.android) {\n    InAppPurchaseAndroidPlatformAddition.enablePendingPurchases();\n  }\n  runApp(MyApp());\n}\n```\n\n### 確保與 Google Play 正常連線\n\nApp 透過這個 API 來確保與 Google Play 正常連線。當手機上沒有 Google Play 或者 Google Play 尚未登入之類的情況，這個 API 回傳的就會是 false。而回傳 false 時，App 也就無法正常購買產品，甚至連產品列表都無法獲得。\n\n```dart\nawait InAppPurchase.instance.isAvailable();\n```\n\n### 獲取產品列表\n\n透過這個 API，App 可以獲取產品的詳細資訊，像是價格與貨幣資訊 ...等。其中需要把產品 ID 列表做為參數傳給這個 API，這個產品 ID 列表需要與 Google Play Console 中設定的一致。取得的回傳值 ProductDetails 也會是稍後購買產品 API 的參數。\n\n```dart\nvar productIds = [\"prodcut_1\", \"product_2\"];\nProductDetailsResponse response =\n    await InAppPurchase.instance.queryProductDetails(productIds);\nif (response.notFoundIDs.isNotEmpty) {\n  // Handle the error.\n}\nList<ProductDetails> products = response.productDetails;\n```\n\n### 購買產品\n\nin_app_purchase 套件提供兩個 API 讓開發者實現購買功能： buyConsumable 和 buyNonConsumable。如何選擇要使用哪個方法，需要開發人員根據產品販售策略來決定。以下是一些比較簡單的原則提供大家參考。\n\n- 當產品會重複販售給使用者多次，使用 buyConsumable。\n- 當產品只能販售給每個使用一次，使用 buyNonConsumable。\n\n```dart\nfinal PurchaseParam purchaseParam = PurchaseParam(productDetails: productDetails);\nif (_isConsumable(productDetails)) {\n  InAppPurchase.instance.buyConsumable(purchaseParam: purchaseParam);\n} else {\n\tInAppPurchase.instance.buyNonConsumable(purchaseParam: purchaseParam);\n}\n```\n\n除此之外，這兩個方法在實作購買流程上會有些許不同，如果是使用 buyNonConsumable 購買產品後，購買成功後需要呼叫 completePurchase，讓 Google Play 知道此次購買已經完成，而 buyConsumable 則不強制。\n\n```dart\nawait InAppPurchase.instance.completePurchase(purchaseDetails);\n```\n\n若是使用 buyNonConsumable 後未呼叫 completePurchase，則會造成 Google Play 認為此筆購買未完成，將導致該筆付款在 3 天後退還給使用者。\n\n### 等待完成購買流程\n\n當呼叫了購買 API 之後，就需要透過 purchaseStream 來監聽購買的狀態，無論是使用者取消購買、購買成功、付款失敗 ...等，都會透過 purchaseStream 來通知 App 購買的狀態。\n\n```dart\n_subscription = InAppPurchase.instance.purchaseStream.listen((purchaseDetailsList) {\n  _listenToPurchaseUpdated(purchaseDetailsList);\n}\n```\n\n而我們能從 PurchaseDetail 中的 status 確認購買狀態並決定 App 相應的行為，例如：處於 PurchaseStatus.pending 時要顯示等待畫面、處於 PurchaseStatus.purchased 時顯示購買成功 ...等，開發者需要依照實際需求實作。\n\n```dart\nvoid _listenToPurchaseUpdated(List<PurchaseDetails> purchaseDetailsList) {\n  purchaseDetailsList.forEach((PurchaseDetails purchaseDetails) async {\n    if (purchaseDetails.status == PurchaseStatus.pending) {\n      // handle pending\n    } \n\n    if (purchaseDetails.status == PurchaseStatus.error) {\n      // handle error\n    } \n\n    if(purchaseDetails.status == PurchaseStatus.purchased || \n       purchaseDetails.status == PurchaseStatus.restored) {\n      // handle purchased\n    }\n  });\n}\n```\n\nGoogle 在整合 BillingClient 的文章中有提到，當購買成功時，建議把購買成功時的 Purchase Token 送到後端，後端能夠透過 [Google Purchase API](https://developers.google.com/android-publisher/api-ref/rest/v3/purchases.products/get) 驗證訂單是否合法，在合法的狀況才把產品交付給使用者。\n\n```dart\nif (purchaseDetails.status == PurchaseStatus.purchased || \n    purchaseDetails.status == PurchaseStatus.restored) {\n  bool valid = await _verifyPurchase(purchaseDetails);\n  if (valid) {\n    _deliverProduct(purchaseDetails);\n  } else {\n    _handleInvalidPurchase(purchaseDetails);\n  }\n}\n```\n\n以上講解的是從 App 端接收訂單資訊並處理，而 Google Play 也提供了另一種從後端處理訂單資訊方式。Google Play 可以透過 Google Pub / Sub 傳送訂單資訊給後端，讓後端接收訂單資訊並驗證訂單，App 則可以省去呼叫後端驗證的工作，更詳細的實作可以參考[這邊](https://developer.android.com/google/play/billing/getting-ready#configure-rtdn)。\n\n# 測試購買流程\n\n當寫完程式碼之後，我們理所當然地需要在測試機裝 Debug 版本測試一下。為了讓 Google Play 允許 Debug 版本也可以測試 Google IAB，我們必須在 Google Play 後台設定**授權測試**，在設定中的帳號使用測試信用卡付費，能夠避免實際付費。透過這個方法，我們就不必頻繁的上傳 App 到 Google Play 上測試，能夠增加開發速度。\n\n![截圖 2021-11-17 上午10.00.43.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-17_%E4%B8%8A%E5%8D%8810.00.43.png)\n\n當授權測試帳號設定完成後，需要先到測試機上的 Google Play 登入該帳號。測試付款流程時，就會看到付款選項中出現 Test Card 的選單。點開之後有更多付款選項，可以用來測試不同的情境，像是 Slow test card 的選項就可以用來測試 Pending 的情況。\n\n![Screenshot_20211117_101352-2.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/Screenshot_20211117_101352-2.png)\n\n![Screenshot_20211117_101442-2.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/Screenshot_20211117_101442-2.png)\n\n最後要提醒的是，如果是使用模擬器來測試，請確保模擬器上有 Google Play 且登入想要用來測試的帳號，這樣才能夠正常測試。否則在確保與 Google Play 連線的步驟會不成功，導致後續流程無法進行。開發人員可以在 AVD Manager 中確認模擬器是否含有 Google Play。\n\n# 結論\n\n本篇紀錄了在 Flutter 上整合 Google IAB 的過程，從商店設定、簡化的流程處理到如何測試付費。其中在流程處理的部分，實際應用上可能會有許多場景需要特別處理，例如：不同支付方式的 Pending 處理、退款的後續處理流程、例外狀況的處理 ...等，需要開發者根據實際情況中思考如何處理。\n\n# 參考\n\n- 整合 Android BillingClient：[https://developer.android.com/google/play/billing/integrate](https://developer.android.com/google/play/billing/integrate)\n- 測試 Google IAB：[https://developer.android.com/google/play/billing/test](https://developer.android.com/google/play/billing/test)",
      "createdAt": "November 15, 2021 10:23 AM",
      "updatedAt": "October 24, 2025 4:48 PM",
      "id": "74e04f6b90ed4369855df505c99dd0ab",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "在 Flutter App 中整合 Google play In-App-Billing 74e04f6b90ed4369855df505c99dd0ab.md"
    },
    {
      "title": "如何在 Flutter 中製作漂浮 Widget",
      "summary": "今天在工作中碰到一個需求，需要顯示漂浮 Widget，類似於 Dialog 那樣漂浮於畫面之上，但是需要客製自己的 Widget。於是自己做了一些研究，研究如何製作這種漂浮於畫面最上層的 Widget，本篇就來分享一下兩種製作漂浮 Widget 的方式。 自己一開始想到最簡單的辦法是，透過在外層使用...",
      "content": "![image.png](%E5%A6%82%E4%BD%95%E5%9C%A8%20Flutter%20%E4%B8%AD%E8%A3%BD%E4%BD%9C%E6%BC%82%E6%B5%AE%20Widget/image.png)\n\n今天在工作中碰到一個需求，需要顯示漂浮 Widget，類似於 Dialog 那樣漂浮於畫面之上，但是需要客製自己的 Widget。於是自己做了一些研究，研究如何製作這種漂浮於畫面最上層的 Widget，本篇就來分享一下兩種製作漂浮 Widget 的方式。\n\n## 使用 Stack\n\n自己一開始想到最簡單的辦法是，透過在外層使用 Stack，並在 Stack 放入 child 與漂浮 Widget，讓漂浮 Widget 蓋在 child 之上，達到漂浮 Widget 可以漂浮在 child 之上，最後提供一個控制顯示的方法，讓使用端可以傳入客製化 Widget。\n\n```dart\nclass FloatingWidgetState extends State<FloatingWidget> {\n  Widget? _floatingWidget;\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        widget.child,\n        if (_floatingWidget != null)\n          Center(\n            child: _floatingWidget,\n          ),\n      ],\n    );\n  }\n\n  void show(Widget child) {\n    setState(() {\n      _floatingWidget = child;\n    });\n  }\n}\n```\n\n在 Widget 中提供 of 方法讓使用端更方便使用\n\n```dart\nclass FloatingWidget extends StatefulWidget {\n  final Widget child;\n\n  const FloatingWidget({Key? key, required this.child}) : super(key: key);\n\n  @override\n  FloatingWidgetState createState() => FloatingWidgetState();\n}\n```\n\n使用端則是可以透過 context 找到 FloatingWidget，並呼叫 show() 傳入客製化 Widget 並顯示畫面上層。\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: FloatingWidget(\n        child: Scaffold(\n          appBar: AppBar(title: Text(\"Floating Widget Example\")),\n          body: Builder(\n            builder: (context) {\n              return ElevatedButton(\n                onPressed: () {\n                  FloatingWidget.of(context).show(\n                    Card(\n                      elevation: 5.0,\n                      child: Padding(\n                          padding: EdgeInsets.all(8),\n                          child: Text(\"My Floating Widget\")),\n                      color: Colors.blue,\n                    ),\n                  );\n                },\n                child: Text(\"Click Me\"),\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n使用 Stack 的做法有個缺點，根據放置 FloatingWidget 的地方不同，它能蓋住的層級也會不同。如果想讓所有 Route 都能使用 FloatingWidget，就需要把 FloatingWidget 放在 MaterialApp 之上。但是若把 Stack 直接放在 MaterialApp 之外，執行時就會報錯，會需要額外處理。\n\n## 使用 Overlay\n\nFlutter 定義好的 MaterialApp 中包了很多東西，其中就包含了 Overlay 這個 Widget，透過這個 Widget，我們可以客製我們想要的 Widget，並使之漂浮於畫面最上層。\n\n```dart\nOverlay.of(context)?.insert(\n  OverlayEntry(\n    builder: (context) {\n      return Text(\"My Floating Widget\");\n    },\n  ),\n);\n```\n\n當要移除時，則需要使用剛剛 insert 進去的 OverlayEntry，所以使用端需要暫存 OverlayEntry。\n\n```dart\nclass MyApp extends StatelessWidget {\n  final OverlayEntry _overlayEntry = OverlayEntry(\n    builder: (context) {\n      return Center(\n        child: Card(\n          elevation: 5.0,\n          child: Padding(\n            padding: EdgeInsets.all(8),\n            child: Text(\"My Floating Widget\"),\n          ),\n          color: Colors.blue,\n        ),\n      );\n    },\n  );\n\n  MyApp({Key? key}) : super(key: key);\n\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(\"Floating Widget Example\")),\n      body: Builder(\n        builder: (context) {\n          return ElevatedButton(\n            onPressed: () {\n              if (_overlayEntry.mounted) {\n                _overlayEntry.remove();\n              } else {\n                Overlay.of(context)!.insert(_overlayEntry);\n              }\n            },\n            child: Text(\"Click Me\"),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n使用 Overlay 做法相對於 Stack 作法來說，使用上比較方便一點。但免不了還是有一些缺點。使用 OverlayEntry 所產生的 Floating Widget 會漂浮於畫面最上層，甚至是所有 route 之上。當使用端 insert 了一個 Floating Widget，如果沒有先移除這個 Floating Widget 就 route 到其他頁面，就會發現 Floating Widget 仍舊漂浮於新頁面之上。所以使用 Overlay 做法時，會需要花一些心思控制 Floating Widget 的顯示與隱藏時機，讓 UI 顯示邏輯更合理。\n\n## 小結\n\n其實在 [pub.dev](http://pub.dev) 上已經有不少套件能顯示客製的漂浮 Widget 了，我自己最後也是直接使用套件。畢竟套件若能完美貼合自己的需求，那就沒有必要再自己造一個輪子了。但是經過一些研究，才發現還有 Overlay 這個 Widget 存在，也對 Flutter 更瞭解了一些。",
      "createdAt": "October 11, 2021 9:51 PM",
      "updatedAt": "October 24, 2025 5:22 PM",
      "id": "16d979fd41d74ed3b30deb840cd3df87",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "如何在 Flutter 中製作漂浮 Widget 16d979fd41d74ed3b30deb840cd3df87.md"
    },
    {
      "title": "跳過 Widget 直接渲染畫面",
      "summary": "大家都知道 Flutter 是一套 UI 框架，透過 dart:ui 與底層 API 互動，最終呈現在手機螢幕上或接收點擊事件。使用的時候，都是透過已經定義好的 Widget 決定畫面，並不會直接與 dart:ui 互動。但是實際上，我們也是可以跳過 Widget，直接操作 dart:ui 的 AP...",
      "content": "![image.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/image.png)\n\n大家都知道 Flutter 是一套 UI 框架，透過 dart:ui 與底層 API 互動，最終呈現在手機螢幕上或接收點擊事件。使用的時候，都是透過已經定義好的 Widget 決定畫面，並不會直接與 dart:ui 互動。但是實際上，我們也是可以跳過 Widget，直接操作 dart:ui 的 API 來幫我們畫出我們想樣的畫面\n\n![archdiagram.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/archdiagram.png)\n\n而 Widget、 Element、RenderObject 等等我們比較常互動的物件，則更多是讓我們更方面的使用 Flutter，讓我們可以輕鬆在畫面畫出想要的結果，而不用自己一筆一劃決定，也不需要自己決定何時重新渲染畫面。\n\n## 畫一個圓\n\n下面這段代碼直接操作 Picture、Scene、Window ...等物件，在畫面上畫出一個藍色的原型。\n\n1. 一開始創建了 PictureRecorder 與 Canvas，並利用 Paint 在 Canvas 上畫出一個圓，與在 CustomPainter 畫圖的做法相當類似。\n2. 當畫完之後，呼叫 PictureRecording.endRecording()，並取得一張 Picture\n3. 接著我們就能把這張 Picture 透過 SceneBuilder 放進 Scene 中\n4. 最後用 window 來這一幀的畫面\n\n```dart\nvoid main() {\n\tPictureRecorder recorder = PictureRecorder();\n  Canvas canvas = Canvas(recorder);\n\n  Paint circlePaint = Paint();\n  circlePaint.color = Colors.blue;\n  canvas.drawCircle(Offset(400, 400), 300, circlePaint);\n\n  Picture picture = recorder.endRecording();\n\n  SceneBuilder sceneBuilder = SceneBuilder();\n  sceneBuilder.addPicture(Offset(0, 0), picture);\n\n  Scene scene = sceneBuilder.build();\n  window.onDrawFrame = () {\n    window.render(scene);\n  };\n  window.scheduleFrame();\n}\n```\n\n當執行上面這段代碼後，我們在畫面上看到一個藍色圓形，向下方左圖一樣。同樣的方法也可以用來畫出向下方右圖那樣的複雜圖形。\n\n![Screenshot_20210926_173637.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/Screenshot_20210926_173637.png)\n\n![Screenshot_20210926_174545.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/Screenshot_20210926_174545.png)\n\n## 小結\n\n雖然我們可以直接使用 dart:ui 在畫面上直接作畫，但實際上在絕大多數的狀況下不會這麼做，目前我自己也想不到一樣狀況會需要這樣做。畢竟除了繪製，Flutter 實際上還做了許許多多事，不管是狀態管理或者是效能優化，透過 Widget、Element 和 RenderObject 去操作還是推薦的做法。\n\n## 參考\n\n- [https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/](https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/)",
      "createdAt": "September 26, 2021 9:25 AM",
      "updatedAt": "October 24, 2025 5:22 PM",
      "id": "3248bae84f984870bdc4d05b3dbc569e",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "跳過 Widget 直接渲染畫面 3248bae84f984870bdc4d05b3dbc569e.md"
    },
    {
      "title": "Flutter Notification 事件機制研究",
      "summary": "當 CustomScrollView 或 ListView 開始滑動時，可以使用 NotificationListener 捕捉  ScrollStartNotification 的 Notification 事件。這些 Widget 會在滾動開始、進行中、結束時，發出各式各的 Notificati...",
      "content": "![image.png](Flutter%20Notification%20%E4%BA%8B%E4%BB%B6%E6%A9%9F%E5%88%B6%E7%A0%94%E7%A9%B6/image.png)\n\n## 什麼是 Notification 事件\n\n當 CustomScrollView 或 ListView 開始滑動時，可以使用 NotificationListener 捕捉  ScrollStartNotification 的 Notification 事件。這些 Widget 會在滾動開始、進行中、結束時，發出各式各的 Notification 事件。\n\n```dart\nScrollStartNotification(metrics: metrics, context: context);\n\nScrollUpdateNotification(metrics: metrics, context: context, scrollDelta: scrollDelta);\n\nScrollEndNotification(metrics: metrics, context: context);\n```\n\n## 如何送出 Notification 事件\n\n送 Notification 事件的方式很簡單，以上面的 ScrollEndNotification 事件為例，只要呼叫 Notification 身上的 dispatch 方法，Notification 就會以同步的方式往上傳遞 Notification 事件。\n\n```dart\nScrollEndNotification(metrics: metrics, context: context).dispatch(context);\n```\n\n## Dispatch Notification 事件\n\ndispatch 是 Notification 這個抽象類別身上的一個方法，主要功能是送通知給上層 Widget。當 dispatch 被呼叫時，它沿著 Element Tree 一路往上，遇到 NotificationListener 時，就會呼叫 NotificationListener 的 _dispatch。（這邊的 _dispatch 不同於 Notification 身上的 dispatch）\n\n```dart\nabstract class Notification {\n\n  @protected\n  @mustCallSuper\n  bool visitAncestor(Element element) {\n    if (element is StatelessElement) {\n      final StatelessWidget widget = element.widget;\n      if (widget is NotificationListener<Notification>) {\n        if (widget._dispatch(this, element)) // that function checks the type dynamically\n          return false;\n      }\n    }\n    return true;\n  }\n\n  void dispatch(BuildContext? target) {\n    // The `target` may be null if the subtree the notification is supposed to be\n    // dispatched in is in the process of being disposed.\n    target?.visitAncestorElements(visitAncestor);\n  }\n\n  ...\n}\n```\n\n## Notification 事件傳遞\n\n當 _dispatch 被呼叫時，它嘗試呼叫傳入的 onNotification 的 callback。onNotification callback 會回傳 bool 值，用以決定這個 Notification 事件是否繼續往上通知，如果回傳 true，表示阻斷這個 Notification 事件繼續往上，這個 Notification 就不會被更外層的 NotificationListener 收到了。相反的，如果回傳 false，則會繼續往上傳遞這個 Notification 事件。\n\n```dart\nclass NotificationListener<T extends Notification> extends StatelessWidget {\n  \n\t...\n\t\n  final NotificationListenerCallback<T>? onNotification;\n\n  bool _dispatch(Notification notification, Element element) {\n    if (onNotification != null && notification is T) {\n      final bool result = onNotification!(notification);\n      return result == true; // so that null and false have the same effect\n    }\n    return false;\n  }\n\n}\n```\n\n比方說以下面這段代碼為例，當使用者按下 Click me 按鈕送出 MyNotification 之後，最靠近 Button  的 NotificationListener 會收到 Notification，並印出 \"Receive notification inside\"，隨即回傳了 true，也終止了事件繼續往上傳遞，外層 NotificationListener 也就收不到 Notification，在 Console 就只會印出 \"Receive notification inside\"，而沒有印出 \"Receive notification outside\"。\n\n```dart\nclass MyNotificationWidget extends StatelessWidget {\n  const MyNotificationWidget({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return NotificationListener<MyNotification>(\n      onNotification: (notification) {\n        print(\"Receive notification outside\");\n        return false;\n      },\n      child: NotificationListener<MyNotification>(\n        onNotification: (notification) {\n          print(\"Receive notification inside\");\n          return true;\n        },\n        child: Builder(\n          builder: (context) {\n            return TextButton(\n              child: Text(\"Click me\"),\n              onPressed: () {\n                MyNotification().dispatch(context);\n              },\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 客製化 Notification 事件\n\n除了 Scroll 的 Notification 事件，我們也可以定義自己的 Notification 事件\n\n```dart\nclass MyNotifcation extends Notification {}\n```\n\n在需要的時候，使用 Notification 身上的 dispatch 發送事件\n\n```dart\nMyNotifcation().dispatch(context);\n```\n\n最後在 Widget 中使用 NotificationListener 接收事件\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return NotificationListener<MyNotification>(\n    onNotification: (notification) {\n      setState(() {\n        _count++;\n      });\n      return false;\n    },\n    child: Text(\n      'count: $_count',\n      style: Theme.of(context).textTheme.headline4,\n    ),\n  );\n}\n```\n\n## 小結\n\nNotification 事件提供了一種機制讓子層 Widget 通知父層 Widget，用法也相當的簡單，且可以通知多個 NotificationListener，不過需要注意的是，Notification 事件通知的方式是同步的，所以盡量不要再 onNotification 中執行耗時的操作，否則可能會影響畫面更新。",
      "createdAt": "August 31, 2021 1:46 PM",
      "updatedAt": "October 24, 2025 5:22 PM",
      "id": "349055b3e6dc43c5976af586d01cbe81",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Flutter Notification 事件機制研究 349055b3e6dc43c5976af586d01cbe81.md"
    },
    {
      "title": "如何用 Github Action 建置 Flutter Android App",
      "summary": "手動建置與上傳 app 是一件滿麻煩的事情，在最理想的狀況下，我們希望當我們確保程式沒有問題之後，合併回主線就可以開始自動建置並上傳到 google play 上。為了達到這個目的，我使用 Github Action 來幫我建置 flutter app，今天就來分享一下我如何自動化這些麻煩事。 透過...",
      "content": "手動建置與上傳 app 是一件滿麻煩的事情，在最理想的狀況下，我們希望當我們確保程式沒有問題之後，合併回主線就可以開始自動建置並上傳到 google play 上。為了達到這個目的，我使用 Github Action 來幫我建置 flutter app，今天就來分享一下我如何自動化這些麻煩事。\n\n## 加入建置 Flutter 的 Step\n\n透過使用第三方的 action：[subosito/flutter-action](https://github.com/subosito/flutter-action)，我們就可以使用 flutter 的命令來建置 flutter app。\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-java@v1\n        with:\n          java-version: '12.x'\n \t  - uses: subosito/flutter-action@v1\n        with:\n          channel: 'stable'\n      - run: flutter pub get\n      - run: flutter test\n      - run: flutter build appbundle\n```\n\n當用這上面這段代碼去建置時，會發現因為缺少 keystore 檔案與 google-service.json 而建置失敗。這些檔案因為需要保密的緣故，所以並沒有上傳到 Github 的 repository 中。為此，我們必須想個辦法讓 Github 可以保存這些保密的檔案。\n\n## 保密 keystore 與 google-service.json\n\n由於這些 keystore 檔案和 google-service.json 裡面放著重要的資料，不能放在直接 git repository，以防被其他人拿到並盜用你的名義簽署 app 或者使用 google 服務。但是當你建構你的自動化 app 建置流程，這些檔案又是必不可少的，否則就會建置失敗。\n\n為了在 github 上保密這些資料，github 也向其他各式各樣的 CI 工具一樣，提供了 secret 讓我們可以放一些重要的資料，例如：DB 的連線字串、API 的 token ...等等。但是 secret 目前是提供以文字形式的方式儲存這些保密資料，所以我們必須把 keystore 檔案和 google-services.json 檔轉換成文字形式，然後才能放到 secret 中。\n\n1. 在 local 端把檔案轉換成 base64 的格式\n    \n    ```bash\n    openssl base64 -in your-input-file -out your-output-file\n    ```\n    \n2. 把轉換出來的 base64 文字加到 Github Secret 中，同時也把\n    \n    ![截圖 2021-08-15 下午1.47.30.png](%E5%A6%82%E4%BD%95%E7%94%A8%20Github%20Action%20%E5%BB%BA%E7%BD%AE%20Flutter%20Android%20App/%E6%88%AA%E5%9C%96_2021-08-15_%E4%B8%8B%E5%8D%881.47.30.png)\n    \n3. 把 base64 文字在 step 中轉回檔案，如此一來，建置時就能拿到這些重要檔案\n    \n    ```yaml\n    jobs:\n      build:\n        runs-on: ubuntu-latest\n        steps:\n    \t  ...\n    \t  - run: echo $ANDROID_KEY_STORE | base64 -di > android/app/key.jks\n      \t\tenv:\n        \t\tANDROID_KEY_STORE: ${{ secrets.ANDROID_KEY_STORE }}\n    \t  - run: echo $GOOGLE_SERVICE | base64 -di > android/app/google-services.jon\n      \t\tenv:\n        \t\tGOOGLE_SERVICE: ${{ secrets.GOOGLE_SERVICE }}\n    \t  ...\n    ```\n    \n\n## 保密其他重要資料\n\n除了 keystore 外，還有重要的資料，像是 store password, key password, key alias，我們也需要一起放進 secret 中，讓建置時可以從 secret 中拿到這些資料。\n\n![Pasted image 20210815142324.png](%E5%A6%82%E4%BD%95%E7%94%A8%20Github%20Action%20%E5%BB%BA%E7%BD%AE%20Flutter%20Android%20App/Pasted_image_20210815142324.png)\n\n修改 github action，在建置時把這些 secret 放進環境變數中\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      ...\n      - run: flutter build appbundle\n\t  \tenv:\n  \t\t  KEY_ALIAS: ${{ secrets.KEY_ALIAS }}\n  \t\t  KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}\n  \t\t  STORE_PASSWORD: ${{ secrets.STORE_PASSWORD }}\n\n```\n\n最後修改 build.gradle，build.gradle 從環境變數中使用這些資料。\n\n```\nsigningConfigs {\n\trelease {\n \t\tstoreFile = file(\"key.jks\")\n \t\tstorePassword System.getenv(\"STORE_PASSWORD\")\n \t\tkeyAlias System.getenv(\"KEY_ALIAS\")\n \t\tkeyPassword System.getenv(\"KEY_PASSWORD\")\n \t}\n}\n```\n\n當以上都做完之後，Github Action 就能正常的建置出 flutter android app 了。\n\n## 下載建置出來的 app\n\n當建置完成後，檔案實際上還是存在 Github Action 的 Runner 中。為了拿到最後建置出來的檔案，我們必須再加上一個 step，把檔案上傳到 artifact 中。這樣我們就在建置完成之後，就能從 Github 網頁上下載到剛剛建置的檔案。\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      ...\n\t  - name: upload appbundle\n  \t\tuses: actions/upload-artifact@v2\n  \t\twith:\n    \t  name: app bundle\n    \t  path: build/app/outputs/bundle/release/app-release.aab\n\n```\n\n## 下一步\n\n把 app 建置出來並放到 artifact 後，我們就能從 github 上下載到 app，把這個 app 上傳到 google play 的後台，讓 user 可以下載。可以發現後面我們還是需要手動上傳到 google play，為了也把這段自動化，我會在下一篇中紀錄如何把 app 自動上傳到 google play 上。\n\n## 參考\n\n- [完整的 workflow](https://github.com/easylive1989/LittleFlowerApp/blob/master/.github/workflows/build.yml)\n- [Github Action Doc](https://docs.github.com/en/actions/guides/storing-workflow-data-as-artifacts#uploading-build-and-test-artifacts)",
      "createdAt": "August 15, 2021 2:58 PM",
      "updatedAt": "October 24, 2025 5:24 PM",
      "id": "b95a311f7549498ca192c4dd9a4538e8",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "如何用 Github Action 建置 Flutter Android App b95a311f7549498ca192c4dd9a4538e8.md"
    },
    {
      "title": "BuildContext in Flutter",
      "summary": "BuildContext在flutter開發中很常出現，是build方法的唯一參數。我們時常需要透過of方法取得某些Widget時，此時就會使用到context，例如： ```dart MediaQuery.of(context).size // 取得畫面寬高 Scaffold.of(context...",
      "content": "![image.png](BuildContext%20in%20Flutter/image.png)\n\nBuildContext在flutter開發中很常出現，是build方法的唯一參數。我們時常需要透過of方法取得某些Widget時，此時就會使用到context，例如：\n\n```dart\nMediaQuery.of(context).size // 取得畫面寬高\nScaffold.of(context).showSnackBar(snackBar); // 顯示Snack Bar\n```\n\n但是實際上context到底是什麼呢？今天就來聊聊這個話題吧。\n\n## Flutter的三棵樹\n\n如果有稍微研究過Flutter的話，多多少少都知道Flutter有三顆樹，分別是Widget Tree, Element Tree, RenderObject Tree。而當中的Element Tree是由各式各樣的Element組成的，例如:SatelessElement、StatefulElement、InheritedElement...等，每個Widget都有他自己相對應的element。\n\nElement主要職責是橫向連接Widget與RenderObject，縱向連結parent Element與child Element，並在Widget發生變化時，根據情況更新RenderObject或重新建立子樹。如果追著這些Element的繼承一路往上，會發現最終Element實作了BuildContext這個抽象類別。\n\n![](BuildContext%20in%20Flutter/_2021-01-19_1.34.08.png)\n\n## 各式各樣的找祖先方法\n\nElement實作BuildContext，並實作了BuildContext裡的眾多方法。在這些方法中，有一系列找祖先的方法，讓我們可以透過context找到往上好幾層的Widget或State。\n\n```dart\nabstract class BuildContext {\n\n  ...\n\n  T findAncestorWidgetOfExactType<T extends Widget>();\n\n  T findAncestorStateOfType<T extends State>();\n\n  T findRootAncestorStateOfType<T extends State>();\n\n  T findAncestorRenderObjectOfType<T extends RenderObject>();\n\n  void visitAncestorElements(bool visitor(Element element));\n\n  void visitChildElements(ElementVisitor visitor);\n\n  ...\n\n}\n```\n\n這些找祖先方法被廣泛的運用在各種of方法中，例如Scaffold.of(context)就是透過context.findAncestorStateOfType<T>()來取得ScaffoldState的。\n\n![](BuildContext%20in%20Flutter/_2021-01-24_9.14.25.png)\n\n## Build方法中的唯一參數\n\n為了讓我們能更靈活的控制UI，BuildContext作為build方法唯一參數，讓我們可以透過它取得祖先Widget，並應用在一些常見的場景中\n\n1. 取得祖先Widget的狀態，來做相對應的顯示，例如：我們需要根據手機的寬高來顯示不一樣的UI設計。\n2. 操作祖先Widget並改變他的狀態，例如：當我們想顯示自訂訊息在SnackBar時，我們必須透過BuildContext取得ScaffoldState，才能用它顯示SnackBar。\n\n## 小結\n\n我們都會從StackOverflow上找某個UI如何實作，這些解答中多多少少會用到BuildContext。BuildContext作為Flutter核心設計之一，理解BuildContext能有效讓我們更清楚Flutter是如何運作的，也能在發生error時，更清楚其背後的根本原因。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:26 PM",
      "id": "512453b346714c74ac7c102844711624",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "BuildContext in Flutter 512453b346714c74ac7c102844711624.md"
    },
    {
      "title": "Context that does not contains ...",
      "summary": "在開發Flutter的時候，多多少少都會遇到一些error。在眾多error中，多多少少都會遇到的一種error是context中找不到想要的東西，讓我們舉個例子來看看這個錯誤。 以下面這段代碼為例，當按下FloatingActionButton時，畫面顯示\"Worlds!\"在SnackBar上。當...",
      "content": "![image.png](Context%20that%20does%20not%20contains/image.png)\n\n在開發Flutter的時候，多多少少都會遇到一些error。在眾多error中，多多少少都會遇到的一種error是context中找不到想要的東西，讓我們舉個例子來看看這個錯誤。\n\n## context中找不到Scaffold\n\n以下面這段代碼為例，當按下FloatingActionButton時，畫面顯示\"Worlds!\"在SnackBar上。當程式執行onPressed callback時，透過Scaffold.of(context)找到ScaffoldState，並呼叫其showSnackBar方法來顯示SnackBar。\n\n![](Context%20that%20does%20not%20contains/_2021-01-31_7.58.31.png)\n\n實際執行並按下FloatingActionButton後會噴error，訊息中提示context不包含Scaffold。\n\n```dart\nScaffold.of() called with a context that does not contain a Scaffold.\n```\n\n![](Context%20that%20does%20not%20contains/_2021-01-24_8.41.24.png)\n\n可以發現錯誤是發生在嘗試呼叫Scaffold.of()取得Scaffold的時候，初學者容易在這個地方覺得奇怪，因為Scaffold確實是FloatingActionButton的parent，那為什麼會找不到呢？\n\n## 發生原因\n\n在上一篇BuildContext的文章中提到，of方法會從parent開始一層一層往上找，但是此時的context是這個MyHomePage的context，並非FloatingActionButton的context，所以會找不到Scaffold，以上面的代碼為例，此時畫面的結構是\n\n![](Context%20that%20does%20not%20contains/_2021-01-31_8.24.08.png)\n\n所以當呼叫Scaffold.of()時，程式循著MyHomePage的context往parent一層一層往上找，理所當然是找不到任何ScaffoldState，因為想要的ScaffoldState在child（Context of Scaffold）中。\n\n## 如何解決\n\n1. 把目標UI抽取Widget，並為其取一個合適的名稱。\n    \n    ![](Context%20that%20does%20not%20contains/_2021-01-31_8.19.05.png)\n    \n    但是當目標UI沒有重複利用的需求且本身已經夠小的時候，或許可以考慮使用Builder來解決\n    \n2. 用Builder把Widget包起來\n    \n    ![](Context%20that%20does%20not%20contains/_2021-01-31_8.11.58.png)\n    \n    此時就能用Builder中的context來正確取得ScaffoldState。\n    \n\n## 不只Scaffold\n\n在開發過程中，我們也常常會用到MediaQuery.of(context)來幫助我們取得畫面的寬高，但是當我們的Widget Tree中沒有MediaQuery時，也同樣的會噴錯。\n\n![](Context%20that%20does%20not%20contains/_2021-02-02_2.02.44.png)\n\n如果在自己的Widget中實作了of方法，也同樣需要在使用的時注意是否有正確的使用，否則就會造成系統出錯而畫面無法正常顯示。\n\n## 小結\n\n如果第一次看到這個錯誤，對初學者的人來說，可能會上網搜尋解法。找到解法貼上來後也可能會一頭霧水，不知道錯誤的原因是什麼，也不知道為什麼這樣寫就會好，改起來總是不安心。希望這篇文章能幫助大家更好地瞭解Flutter，讓代碼寫起來更有信心。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:26 PM",
      "id": "6b3707dc2af34e82a203ba90279b70c2",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Context that does not contains 6b3707dc2af34e82a203ba90279b70c2.md"
    },
    {
      "title": "Dart 非同步介紹(一) - Event Loop",
      "summary": "寫Flutter的時候，如果我們需要從後端api拿回資料時，我們會使用一些network相關的package來幫忙，例如：[http](https://pub.dev/packages/http)。我們透過await http.get來讓代碼停在這一行，釋放Thread去做其他工作，直到後端resp...",
      "content": "![image.png](Dart%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%B4%B9(%E4%B8%80)%20-%20Event%20Loop/image.png)\n\n寫Flutter的時候，如果我們需要從後端api拿回資料時，我們會使用一些network相關的package來幫忙，例如：[http](https://pub.dev/packages/http)。我們透過await http.get來讓代碼停在這一行，釋放Thread去做其他工作，直到後端response傳回來後，Thread再從之後的代碼繼續執行，這種非同步的操作只是用在存取api，在很多其他場景中也都會用到，今天就來講講Dart的非同步操作是如何運作的。\n\n## Event Loop與單執行緒\n\n在預設的情況下，Dart只使用一條Thread來執行代碼，Dart用三個東西來完成這件事情：**Event**, **Event Loop**, **Event Queue**。我們可以想像Dart把一段一段的代碼包成Event放在Event Queue的中，當中不管是渲染畫面的代碼、點擊按鈕的callback代碼，或者http response callback代碼。\n\n![](Dart%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%B4%B9(%E4%B8%80)%20-%20Event%20Loop/_2021-03-01_3.08.29.png)\n\n所有Event都會放在Event Queue中，然後Event Loop從Event Queue中把Event拿出來執行。我們可以把Event Loop想像成一條Thread裡頭跑著一個無窮迴圈，它會一直不斷的檢查Queue中有沒有Event，有的話就把它拿出來執行，如果沒有的話就一直等待下一個Event的出現。\n\n我們舉一些簡單的例子來看看\n\n```dart\nFlatButton(\n  onPressed: () => {\n\tprint('Hello World!');\n  },\n  child: Text(\"Click me\"),\n),\n```\n\n當FlatButton被宣告的時，onPress不會直接被執行，而是使用者按下FlatButton時，Flutter會在Event Queue中加入一個Click的Event，等待Event Loop處理它。順帶一提，宣告FlatButton的代碼也曾經被放在某個Event中，並被Event Loop執行。\n\n**http範例代碼：**\n\n```dart\nvar url = 'https://example.com/whatsit/create';\nvar response = await http.post(url, body: {'name': 'doodle', 'color': 'blue'});\nprint('Response status: ${response.statusCode}');\nprint('Response body: ${response.body}');\n```\n\n這段代碼執行到 await http.post且送出request之後，Event Loop轉去處理下一個Event。等到成功接收response之後，Dart就會加入剩餘部分代碼的Event到Event Queue中（也就是print的部分\n），等待Event Loop處理它。\n\n## await是一種語法糖\n\n在Dart中，await是一種then方法的語法糖，也就是說編譯器會在編譯過程中幫你把await轉換成then的寫法。以上面http範例代碼來說，就會變成下面這樣。\n\n```dart\nvar url = 'https://example.com/whatsit/create';\nhttp.post(url, body: {'name': 'doodle', 'color': 'blue'})\n\t\t.then((response) => {\n\t\t\tprint('Response status: ${response.statusCode}');\n\t\t\tprint('Response body: ${response.body}');\n\t\t}); \n```\n\n## 小心耗時工作\n\nEvent Loop會把正在處理的Event處理完以後，才會繼續從Queue中拿下一個Event。當我們在Queue中放入了耗時工作的Event時，例如：壓縮圖片、加密解密..等等，就會造成下一個UI遲遲無法被處理。如果今天下一個Event剛好是渲染UI Event，就會發現畫面開始卡頓，甚至沒有反應，直到Event Loop處理完手上的工作。\n\n但是實際應用場景中難免會有這樣的需求，此時我們可以使用Isolate來解決這類問題，避免占用到渲染UI的時間或者是Click事件的處理，我下次會繼續介紹Isolate如何使用，感謝你耐心的看這邊。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:25 PM",
      "id": "fad780524ae04e6fbadb7c6c280e0f2b",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Dart 非同步介紹(一) - Event Loop fad780524ae04e6fbadb7c6c280e0f2b.md"
    },
    {
      "title": "Dart 非同步介紹(三) - Stream",
      "summary": "在 Dart 非同步的使用情境中，除了常用的 Future 以外，還有 Stream 也是常常被用到的一個元件，相對於 Future 來說，Stream 是一個比較難理解的元件，今天就來研究一下 Stream 是什麼，以及如何建立與使用。 根據 [Flutter 官方影片](https://www....",
      "content": "![image.png](Dart%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%B4%B9(%E4%B8%89)%20-%20Stream/image.png)\n\n在 Dart 非同步的使用情境中，除了常用的 Future 以外，還有 Stream 也是常常被用到的一個元件，相對於 Future 來說，Stream 是一個比較難理解的元件，今天就來研究一下 Stream 是什麼，以及如何建立與使用。\n\n## **什麼是 Stream**\n\n根據 [Flutter 官方影片](https://www.youtube.com/watch?v=nQBpOIHE4eE)提到的，Stream 是非同步元件的 Iterator 形式。白話一點來說，可以想像成一個由多個 Future 組成的 List。 我們可以用 awiat 等待一個 Future 的結果，在 Iterator 形式中，可以用 await for 等待 Stream 中的每一個非同步結果。\n\n```csharp\nvoid main() async {\n    // 等待一個 Future\n    await Future.delayed(Duration(seconds: 1), \n    () => print(\"Hello World!!\"));\n  \n    // 等待一個 Stream\n    await for(var value in helloWorld()) {\n        print(value);\n    }\n}\n\nStream<String> helloWorld() async* {\n    yield \"Hello\";\n    yield \"World\";\n    yield \"!!\";\n}\n```\n\n## **如何建立 Stream**\n\n1. 使用 async* 方法如同上面範例中寫的，我們可以寫一個方法，回傳 Stream 並標註為 async*，這樣就能透過 yield 回傳想要的值。\n    \n    ```csharp\n    Stream<String> helloWorld() async* {\n        yield \"Hello\";\n        yield \"World\";\n        yield \"!!\";\n    }\n    ```\n    \n2. 使用 StreamController除了使用 async* 方法之外，還可以使用 StreamController 來建立 Stream，建立完後可以透過 StreamController 的 add() 發送 Event（也等同於使用 StreamController.sink.add())。\n    \n    ```csharp\n    StreamController<String> streamController =  \n        new StreamController<String>();  \n      \n    void helloWorld() {  \n        streamController.add(\"Hello\");  \n        streamController.add(\"World\");  \n        streamController.add(\"!!\");  \n    }\n    ```\n    \n3. 從其他 Stream 轉換最後一個方法則是從現有的 Stream 中創建，比較常見的例子像是 map、where..等方法。\n    \n    ```csharp\n    void main() async {  \n        var firstChars = helloWorld().map<String>((data) => data[0]);  \n            await for (var value in firstChars) {  \n            print(value);  \n        }  \n    }\n    \n    Stream<String> helloWorld() async* {\n        yield \"Hello\";\n        yield \"World\";\n        yield \"!!\";\n    }\n    ```\n    \n\n## **監聽 Stream 並獲取 Event**\n\n在前面的例子中，我們使用了 await for 來等待 Stream 中的所有 Event 回來，這樣會使得程式碼卡在 await for 那邊。在實際應用中，更多是使用 listen() ，以非同步的方式取得 Stream 的值。\n\n```csharp\nStream<String> helloWorld() async* {  \n    yield \"Hello\";  \n    yield \"World\";  \n    yield \"!!\";  \n}  \n  \nvoid main() {  \n    helloWorld().listen((event) {  \n        print(event);  \n    });  \n}\n```\n\n## **常見的 Stream 操作**\n\n除了 listen 之外，我們也可以透過 Stream 的各式各樣 API 來操作 Stream，例如\n\n- 使用 map 把 Stream 中的每一個 Event 轉成其他物件\n- 使用 where 把預期的 Event 從 Stream 中過濾出來\n- 使用 distinct 忽略相同的 Event，值得注意的是，distinct 是比較當前的 Event 與 上一個 Event 是否一樣，如果一樣就忽略掉。Stream 還有其他許多類似陣列的操作，這邊就不特別列出來，有興趣的人可以參考 [Stream API](https://api.dart.dev/stable/2.13.4/dart-async/Stream-class.html)。\n\n## 在 UI 中使用 Stream\n\n跟 FutureBuilder 一樣，如果需要根據 Stream 回傳的 Event 來影響畫面的話，可以使用 Flutter 提供的 StreamBuilder。我們可以傳入一個 Stream 到 StreamBuilder 中，當新的 Event 進來時，就可以根據 Event 重新呼叫 builder 方法渲染畫面。\n\n```dart\nclass HelloWorld extends StatelessWidget {\n \tconst HelloWorld({Key? key}) : super(key: key);\n\n \t@override\n \tWidget build(BuildContext context) {\n \t\treturn StreamBuilder<String>(\n \t\t\tstream: helloWorld(),\n \t\t\tbuilder: (context, snapShot) {\n \t\t\t\tvar text = snapShot.hasData ? snapShot.data! : \"Loading\";\n\t\t\t\treturn Text(text);\n \t\t\t},\n \t\t);\n \t}\n\n \tStream<String> helloWorld() async* {\n \t\tyield \"Hello\";\n \t\tyield \"World\";\n \t\tyield \"!!\";\n \t}\n}\n\n```\n\n## 無用小知識\n\nQ: Stream 如果是 Future 的 List 版本，那 Stream.first 是否會回傳 Future？\nA: 答案：是，確實會回傳 Future，但實際上 Stream 並非真的是 Future 的陣列，first 是透過 Stream.listen 取得第一個 Event 並把它包裝成 Future，然後才回傳給呼叫端。\n\n![](Dart%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%B4%B9(%E4%B8%89)%20-%20Stream/stream_first_impl.png)\n\n## 參考\n\n- [Creating streams in Dart](https://dart.dev/articles/libraries/creating-streams)",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:27 PM",
      "id": "dbd16c50a0cc425aa313a3552758683d",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Dart 非同步介紹(三) - Stream dbd16c50a0cc425aa313a3552758683d.md"
    },
    {
      "title": "Dart 非同步介紹(二) - Future",
      "summary": "在寫 Dart 的過程中，一定會碰到許多需要非同步的情境，例如：打 Web Api 從 Server 端讀寫資料、存取 local storage、sqlite...等等。Future 讓非同步操作用起來很容易，但若不清楚其執行邏輯，有些時候難免會造成一些 bug，而非同步的 bug 又比較難以除錯...",
      "content": "在寫 Dart 的過程中，一定會碰到許多需要非同步的情境，例如：打 Web Api 從 Server 端讀寫資料、存取 local storage、sqlite...等等。Future 讓非同步操作用起來很容易，但若不清楚其執行邏輯，有些時候難免會造成一些 bug，而非同步的 bug 又比較難以除錯。所以今天就來用個簡單的例子，來聊聊 Future 的執行邏輯。\n\n```dart\nvoid main() async {\n  print(\"1\");\n  await loadData();\n  print(\"4\");\n}\n\nFuture loadData() async {\n  print(\"2\");\n  await Future.delayed(Duration(seconds:1), () => \"data\");\n  print(\"3\");\n}\n```\n\n上面這段代碼執行結果是\n\n```dart\n1\n2\n3\n4\n```\n\n因為每一段非同步都用了await來等待，會等到結果回傳了才會往下一步前進。執行過程如下：\n\n1. 執行 print(\"1\") 並印出 1\n2. 進入 loadData() 方法中\n3. 執行 print(\"2\") 並印出 2\n4. 執行 Future.delayed() 並回傳 Future\n5. await 接到 Future.delayed 回傳的 Future 後，發現 Future 尚未執行完成，loadData() 也從 await 處回傳 Future，程式控制權從 loadData() 回到 main() 中\n6. 同理，main 方法中的 await 發現 loadData() 回傳的 Future 尚未執行完成，所以 main() 也從 await 處回傳 Future，程式控制權也從 main() 回到呼叫 main() 的 framework 中\n7. Future.delayed() 執行完成，並從 loadData() 中的 await 處繼續往下執行\n8. 執行 print(\"3\") 並印出 3\n9. loadData() 執行完成，並回傳完成執行的 Future 到 main() 中\n10. 回到 main() 後，從 await 處往下執行\n11. 執行 print(\"4\") 並印出 4\n\n## 移除 main 中的 await\n\n把呼叫 loadData() 時的 await拿掉以後並在執行一次\n\n```dart\nvoid main() async {\n  print(\"1\");\n  loadData();\n  print(\"4\");\n\n\t// 讓程式不要太快結束，避免來不及印出 3\n  await Future.delayed(Duration(seconds: 5), () => {});\n}\n\nFuture loadData() async {\n  print(\"2\");\n  await Future.delayed(Duration(seconds:1), () => \"data\");\n  print(\"3\");\n}\n```\n\n執行結果變成\n\n```dart\n1\n2\n4\n3\n```\n\n與第一個例子不同的是，當 loadData() 回傳未完成的 Future 後，main() 並沒有用 await 等待，所以程式就繼續往下執行，並印出 4。過了一秒之後，Future.delayed 完成並從 loadData() 的 await 處往下執行，並印出 3。\n\n## 移除 loadData 中的 await\n\n我們稍微修改一下例子，讓 main() 同樣 await loadData()，但是 loadData() 不 await Future.delayed()\n\n```dart\nvoid main() async {\n  print(\"1\");\n  await loadData();\n  print(\"4\");\n}\n\nFuture loadData() async {\n  print(\"2\");\n  Future.delayed(Duration(seconds:1), () => \"data\");\n  print(\"3\");\n}\n```\n\n執行結果回到\n\n```dart\n1\n2\n3\n4\n```\n\n與第一個例子不同的是，當 loadData() 執行到 Future.delayed() 時，此處沒有使用 await 來中斷執行，而是繼續往下執行並印出 3。當loadData() 執行完 print(\"3\") 回傳 Future 到 main() 中，此時 main() 中的 await 發現 Future 已經執行完成，所以也就已同步的方式往下執行並印出 4。\n\n## 執行 await 後的工作\n\n如同之前提到的 Dart 非同步會使用 queue 來安排工作，從 await 處往下執行的這項工作也同樣會被排進 queue 中，也就是說在當前工作未完成之前，即使 await 處的工作已經完成，也無法繼續往下執行，讓我們來看看另外一個例子\n\n```dart\nvoid main() async {\n  print(\"1\");\n  loadData();\n  sleep(Duration(seconds: 2));\n  print(\"4\");\n\n\t// 讓程式不要太快結束，避免來不及印出 3\n  await Future.delayed(Duration(seconds: 5), () => {});\n}\n\nFuture loadData() async {\n  print(\"2\");\n  await Future.delayed(Duration(seconds: 1), () => \"data\");\n  print(\"3\");\n}\n```\n\n執行結果是\n\n```dart\n1\n2\n4\n3\n```\n\n執行完 main() 需要兩秒，而Future.delayed() 的工作只需要一秒，但是結果還是先印出4，再印出 3，因為一次只能有一項工作在執行，此時已經被 main() 方法佔住了，所以即便 Future.delayed() 已經執行完成，它也只能乖乖在 queue 中等待 main() 把 sleep() 和 print(\"4\") 執行完，然後才輪到 print(\"3\")。\n\n## 小結\n\n看了上面幾個例子之後，我們可以歸納一些結論\n\n1. 沒有 await 的 async 方法等於同步方法\n2. 當程式執行到 await 時，是否往下執行取決於當下 Future 的狀態\n3. 非同步的 Future 執行結束後會排入 queue 中等待執行",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 4:48 PM",
      "id": "106987e499184351b18378ccef8a722b",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Dart 非同步介紹(二) - Future 106987e499184351b18378ccef8a722b.md"
    },
    {
      "title": "Widget Test的14種find方法",
      "summary": "[https://www.notion.so](https://www.notion.so) 上禮拜介紹了一個Widget Test所包含的流程，過程中用到Finder、Tester、和Matcher的部分方法...等，但是實際上這些元件都還有許多不同的操作，今天先介紹Finder的各種方法。 1....",
      "content": "[https://www.notion.so](https://www.notion.so)\n\n上禮拜介紹了一個Widget Test所包含的流程，過程中用到Finder、Tester、和Matcher的部分方法...等，但是實際上這些元件都還有許多不同的操作，今天先介紹Finder的各種方法。\n\n## find的方法們\n\n1. **text：**找到一個顯示特定字串的Text Widget\n    \n    ```dart\n    find.text(\"Hello World\");\n    ```\n    \n2. **textContaining**：找到一個顯示文字中包含特定字串的Text Widget\n    - 當文字可能不是固定字串時，例如：在一個棋局中顯示黑棋或白棋獲勝時，因為有可能會是\"Black Wins\"或\"White Wins\"，此時就會需要使用到textContaining做部分比較\n    \n    ```dart\n    find.textContaining(\"Wins\");\n    ```\n    \n    - 除了直接使用字串以外，也可使用正規表達式([RegExp](https://api.flutter.dev/flutter/dart-core/RegExp-class.html))來找尋\n    \n    ```dart\n    find.textContaining(RegExp(r\"Wins$\"));\n    ```\n    \n3. **widgetWithText**：找到一個包含特定字串Text Widget的Widget\n    - 假設有一個文字按鈕使用FlatButton，在FlatButton的child再放上Text，此時我們就可以用這個方法來找到FlatButton\n    \n    ```dart\n    find.widgetWithText(FlatButton, \"Hello World\")\n    ```\n    \n    - 以上面的例子來說，假設畫面中有兩個Widget包含Text(\"Hello World\")，一個是FlatButton，一個是Container，此時就會找到FlatButton，因為它符合第一個參數中的條件。\n    \n    ```dart\n    Column(\n    \tchildren: <Widget>[\n    \t\tFlatButton(\n    \t\t\tonPressed: _incrementCounter,\n    \t\t\tchild: Text(\"Hello World\"),\n    \t\t),      \n    \t\tContainer(\n    \t\t  child: Text(\"Hello World\"),\n    \t\t),\n    \t],\n    )\n    ```\n    \n4. **byKey**：找到一個符合Key值的Widget\n    \n    ```dart\n    find.byKey(ValueKey(\"First Hello World\"))\n    ```\n    \n    - 以上面的例子來說，假設有兩個一樣的Text，就能正確找到Key值符合的Widget\n    \n    ```dart\n    Column(\n    \tchildren: <Widget>[\n    \t\tText(\n    \t\t\t\"Increase\",\n    \t\t  key: ValueKey(\"First Hello World\"),\n    \t\t),\n    \t\tText(\n    \t\t\t\"Increase\",\n    \t\t),\n    \t],\n    )\n    ```\n    \n    ⇒ 如果是用UniqueKey這類的Key，因為無法在測試中產生一模一樣的Key，此時可以考慮使用其他find方法解決或者由外部注入Key的方式解決。\n    \n5. **byIcon：**找到一個Icon符合的Icon Widget\n    \n    ```dart\n    find.byIcon(Icons.add);\n    ```\n    \n6. **widgetWithIcon：**與widgetWithText類似，同樣是找到一個包含特定Icon Widget的Widget\n    \n    ```dart\n    find.widgetWithIcon(FlatButton, Icons.add);\n    ```\n    \n7. **byType**：找到一個類別符合的Widget\n    \n    ```dart\n    find.byType(FlatButton);\n    ```\n    \n8. **byWidget：**找到與傳入的Widget傳入Widget同一實例的Widget\n    \n    ```dart\n    find.byWidget(Text(\"Hello World\"))\n    ```\n    \n    - 假設我們想測試MyContainer是否有正常渲染child時，就可以使用byWidget找到預期的Widget並檢查\n    \n    ```dart\n    testWidgets('test my container', (WidgetTester tester) async {\n    \tvar text = Text(\"Hello World\");\n    \n      await tester.pumpWidget(\n        createTestingWidget(MyContainer(child: text)),\n      );\n    \n      await tester.pump();\n    \n      expect(find.byWidget(text), findsOneWidget);\n    });\n    ```\n    \n    ```dart\n    class MyContainer extends StatelessWidget {\n      final Widget child;\n    \n      MyContainer({this.child});\n    \n      @override\n      Widget build(BuildContext context) {\n        return Column(\n          children: [\n            Text(\"Header\"),\n            child,\n            Text(\"Footer\"),\n          ],\n        );\n      }\n    }\n    ```\n    \n9. **byWidgetPredicate：**找到一個符合predicate回傳true的Widget\n    - 參數是一個predicate方法，在方法中可以比較很多東西，例如類別或Widget中的資料，透過比較Widget中的屬性，並回傳boolean值表示這個widget是否是目標Widget，是一個十分泛用的方法\n    \n    ```dart\n    find.byWidgetPredicate(\n              (widget) => widget is Text && widget.data == \"Hello World\")\n    ```\n    \n10. **byTooltip：**找到符合message的[Tooltip](https://api.flutter.dev/flutter/material/Tooltip-class.html) Widget \n    \n    ```dart\n    find.byTooltip(\"Hello World\");\n    ```\n    \n    ⇒ 這個方法實際上是透過byWidgetPredicate實作的\n    \n11. **byElementType：**與byType相似，不同的這個方法會找的是符合類別的Element\n    \n    ```dart\n    find.byElementType(InheritedElement);\n    ```\n    \n12. **byElementPredicate：**與byWidgetPredicate相似，不同的是他的predicate參數傳入的是Element\n    - 這個方法可以用來比較Element中的屬性，例如自己做了一個MyCheckbox的StatefulWidget，就能用這個方法找出已選取的MyCheckbox\n    \n    ```dart\n    find.byElementPredicate((element) {\n    \tif(element is StatefulElement) {\n    \t  var state = element.state;\n        return state is MyCheckboxState && state.isChecked;\n      }\n      return false;\n    });\n    ```\n    \n    ```dart\n    class MyCheckbox extends StatefulWidget {\n    \n      @override\n      MyCheckboxState createState() => MyCheckboxState();\n    }\n    \n    class MyCheckboxState extends State<MyCheckbox> {\n      bool isChecked;\n    \n      @override\n      Widget build(BuildContext context) {\n        ...\n      }\n    }\n    ```\n    \n13. **ancestor：**在某個Widget的祖先中，找尋符合條件的Widget\n    - 從符合of參數的Widget開始往祖先找，直到找到符合matching參數的Widget，這兩個參數都可以使用前幾個find方法來決定條件\n    \n    ```dart\n    find.ancestor(of: find.byType(MyContainer), matching: find.byWidget(text));\n    ```\n    \n    ⇒ widgetWithText, widgetWithIcon也是用這個方法實作\n    \n14. **descendant：**在某個Widget的子孫中，找尋符合條件的Widget。\n    - 參數基本上與ancestor相似，只是搜尋的方向不同\n    \n    ```dart\n    find.descendant(of: find.byWidget(text), matching: find.byType(MyContainer));\n    ```\n    \n\n## **小結**\n\nFinder中有各式各樣的方法，在不同情境下使用不同的方法來找到想要的Widget，然後才能測試中正確的操作或驗證這些Widget，讓測試保護我們的產品代碼。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:26 PM",
      "id": "44325fd7e7ab4b4a93c1c06164398150",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Widget Test的14種find方法 44325fd7e7ab4b4a93c1c06164398150.md"
    },
    {
      "title": "初探Flutter Widget Test",
      "summary": "Flutter可以使用 [test](https://pub.dev/packages/test) 來幫助我們寫單元測試，透過單元測試來幫忙檢查我們的核心邏輯是否正確。在我們實作需求或者是重構代碼時，常常會修改到過去已經寫好的代碼，當我們改壞邏輯時時，單元測試也能發出警訊，提醒我們改動可能有問題。 ...",
      "content": "![image.png](%E5%88%9D%E6%8E%A2Flutter%20Widget%20Test/image.png)\n\nFlutter可以使用 [test](https://pub.dev/packages/test) 來幫助我們寫單元測試，透過單元測試來幫忙檢查我們的核心邏輯是否正確。在我們實作需求或者是重構代碼時，常常會修改到過去已經寫好的代碼，當我們改壞邏輯時時，單元測試也能發出警訊，提醒我們改動可能有問題。\n\nFlutter是個前端框架，需求常常是需要表現在畫面上，在這種情境中，我們比較難使用單元測試來驗證畫面是否正確，為了解決這個問題，我們可以使用Flutter提供的Widget Test來幫助我們寫一些可以驗證畫面的測試。\n\n## Counter Ｗidget範例\n\n當使用 flutter create 創建一個project，裡面會自帶一個counter範例。在這個範例中，畫面中央會有當前的counter，每當我們按下 + 按鈕後，counter就會加1，如下圖所示。\n\n![](%E5%88%9D%E6%8E%A2Flutter%20Widget%20Test/widget_test.png)\n\n## 第一個Widget Test\n\n在剛剛創建出來的flutter proejct中，裡頭也包含了一個Widget Test，測試的正是按下 ＋ 按鈕後並在畫面上把 0 變成 1 ，也就是這個範例的核心邏輯。\n\n```dart\nvoid main() {\n  testWidgets('Counter increments smoke test', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n  });\n}\n```\n\n在main中，testWidgets表示一個測試，第一個參數是測試敘述，第二個參數則是實際的測試內容。在這個測試內容中，呼叫pumpWidget來建立與渲染ＭyApp。\n\n```dart\nawait tester.pumpWidget(MyApp());\n```\n\n當MyApp建立起來之後，就可以使用find方法來幫助找到想要的Widget。透過 find.text()來找到畫面中的包含 0 和 1 文字的Widget，透過expect驗證結果是否符合預期。以這個範例來說，當MyApp剛開起來時，因為還沒點下 + 按鈕，所以畫面應該是 0 而不是 1，所以能夠使用find.text()找到一個 0 的 Text Widget，找不到 1 的Text Widget。\n\n```dart\nexpect(find.text('0'), findsOneWidget);\nexpect(find.text('1'), findsNothing);\n```\n\n同樣地，也能透過 find.byIcon()來找到icon widget，找到之後就能用tester.tap來按下它。除了find.text()與find.byIcon()，find中還提供各式各樣的方法來幫助我們容易的找到我們想要的Widget，例如：find.byKey()、find.byWidget()… 等。\n\n```dart\nawait tester.tap(find.byIcon(Icons.add));\n```\n\n在這邊值得一提的是Widget Test不會幫我們自動rebuild widget，所以按下 + 按鈕後，State裡頭的 _counter 已經成功變成 1 了，但是MyApp也不會把 1 顯示在畫面上，此時需要呼叫test.pump()來觸發rebuild。\n\n```dart\nawait tester.pump();\n```\n\n最後就是驗證畫面上存在包含 1 的Text Widget，而不是 0 的Text Widget\n\n```dart\nexpect(find.text('0'), findsNothing);\nexpect(find.text('1'), findsOneWidget);\n```\n\n## 複雜的情境\n\nCounter範例是一個簡單的情境，相對的我們要對他寫Widget Test也不會太過困難。但在實際的開發過程中，我們會碰到各式各樣的狀況，例如：如何隔離網路讓測試可以總是使用我們想要的資料測試，又或者是如何在畫面切換情境中測試。未來我會跟大家分享一些自己在實際情境中碰到的一些例子，與我的處理方式。\n\n## 結論\n\n單元測試可以幫我們驗證狀態是否符合預期，Widget Test則是可以幫我們驗證畫面是否符合預期。雖然Widget Test除了驗證畫面，也同時驗證了邏輯。但是並不代表我們可以用Widget Test取代單元測試，反而是我們應該要用Widget Test專注在畫面上的驗證，更多是關注在給定狀態後畫面是否符合預期，減少驗證邏輯上的變化，讓單元測試專注在測試核心邏輯上面，兩者應該是相輔相成。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:26 PM",
      "id": "3c907ffe50cd4a81b82b52ffb7d309ec",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "初探Flutter Widget Test 3c907ffe50cd4a81b82b52ffb7d309ec.md"
    },
    {
      "title": "在 Null safety mockito 使用 any",
      "summary": "前陣子 Google release了 Dart 2.12，加入 null safety 特性，不可避免地，升級過後的產品代碼需要進行一些調整，除此之外，測試代碼也必須進行相對應的調整。在測試之中，如果有使用 mockito 中的 any 來 mock 物件方法與回傳，可能會碰到像是下面這種 err...",
      "content": "前陣子 Google release了 Dart 2.12，加入 null safety 特性，不可避免地，升級過後的產品代碼需要進行一些調整，除此之外，測試代碼也必須進行相對應的調整。在測試之中，如果有使用 mockito 中的 any 來 mock 物件方法與回傳，可能會碰到像是下面這種 error。\n\n```dart\ntype 'Null' is not subtype of type 'your class type' of 'type'\n```\n\n為此，官方給出[解決辦法](https://github.com/dart-lang/mockito/blob/master/NULL_SAFETY_README.md#problems-with-typical-mocking-and-stubbing)，讓我們的測試可以繼續使用 any 來進行 mock。\n\n## 解決辦法\n\n1. 在 pubspec.yaml 加入 build_runner\n    \n    ```dart\n    dev_dependencies:\n      build_runner: ^1.10.0\n    ```\n    \n2. 在測試中加入 GenerateMock 這個 annotation，並傳入想要 mock 的類別\n    \n    ```dart\n    import 'package:mockito/annotations.dart';\n    \n    @GenerateMocks([UserApi])\n    void main() {\n    \t...\n    }\n    ```\n    \n3. 在專案目錄中執行 build_runner\n    \n    ```dart\n    flutter pub run build_runner build\n    ```\n    \n\n當做完成以上步驟後，會在測試目錄中看到一個 xxx_test.mock.dart 的 mock 檔案，在原本的測試中 import 這個 mock 檔案後，就可以不在需要自己宣告 mock 類別，並且也可再次使用 any 了。\n\n```dart\nimport 'package:mockito/annotations.dart';\n\n@GenerateMocks([UserApi])\nvoid main() {\n\ttest('my test', () {\n\t\tvar mockUserApi = MockUserApi();\n\t\twhen(mockUserApi.getProfile(any)).thenReturn(Profile());\n\n\t\t...\n\t});\n}\n```\n\n## 作法解釋\n\n以原本的 mockito 的做法，mock 類別實作了目標類別，在 nullable 環境中，可以正常的把 any 當成方法參數，但是在 null safety 的環境中，想把 any 傳入 non-nullable 的參數就會造成編譯問題，因為 any 實際回傳的是 null。為了解決這個問題，所以必須透過 build_runner 來產生 mock 檔，透過 build_runner 產生出來的 mock 類別會把原本 non-nullable 的參數拓展成 nullable，以支持傳入 any。\n\nbuild_runner 這個套件會去偵測 test 中的 @GenerateMock，並取得需要 mock 的目標類別，然後就自動產生對應的 mock 類別，最後在原本測試中引用產生出來的 mock 檔，就能像之前一樣的操作 mock 類別，與之前不同的是，不需要在自己宣告 mock 類別了。\n\n## 自行產生 Mock 類別\n\n除了使用 build_runner 來幫忙產生 mock 類別，其實也是可以自己寫，不一定要使用 build_runner來幫忙產生。當有兩個測試檔案都使用了相同的 mock 類別時，在兩個檔案分別用 GenerateMocks mock 一樣的類別時，build_runner 會產生兩個測試的 mock 檔 ，並包含一樣的 mock 類別，如果自己寫的話，可以使用一份共用的 mock 檔，讓測試代碼稍微乾淨一點。\n\n```dart\nclass MockUserApi extends Mock implements UserApi {\n  @override\n  void getProfile(int? userId) =>\n      super.noSuchMethod(Invocation.method(#getProfile, [userId]));\n}\n```\n\n## 更改預設 mock 類別名稱\n\n預設 mock 類別名稱是在原本的類別前面加上 Mock 的前綴，但是想要客製化名稱，則不能使用第一個參數，而是需要改使用 @GenerateMock 的 customMocks 參數。\n\n```dart\nimport 'package:mockito/annotations.dart';\n\n@GenerateMocks([], customMocks: [MockSpec<UserApi>(as: #OtherMockUserApi)])\nvoid main() {\n\t...\n}\n```\n\n## 小結\n\n整體來說，在 null safety 中用 mockito 來 mock 類別的作法還是跟之前差不多，多了一個步驟要使用 build_runner 來幫忙產生 mock 類別。如果自己實作 mock 類別的話，則是需要在 mock 的時候，針對 mock 方法多寫一些代碼。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 4:57 PM",
      "id": "4df501b643a04bb29c701f53db896d45",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "在 Null safety mockito 使用 any 4df501b643a04bb29c701f53db896d45.md"
    },
    {
      "title": "改善迴圈的可讀性（一）",
      "summary": "不管是練習寫Kata或者是工作中，迴圈都是最常使用的語法之一。而在迴圈中很常出現一種Aggregation Pattern，例如：合計集合中的所有數字。 這種Pattern會大量的存在產品代碼中，雖然這些代碼行數通常不會太多，但是每次閱讀到都需要重新理解的話，就會顯得有點浪費時間。花些時間讓這些代碼...",
      "content": "![image.png](%E6%94%B9%E5%96%84%E8%BF%B4%E5%9C%88%E7%9A%84%E5%8F%AF%E8%AE%80%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89/image.png)\n\n## 情境介紹\n\n不管是練習寫Kata或者是工作中，迴圈都是最常使用的語法之一。而在迴圈中很常出現一種Aggregation Pattern，例如：合計集合中的所有數字。\n\n這種Pattern會大量的存在產品代碼中，雖然這些代碼行數通常不會太多，但是每次閱讀到都需要重新理解的話，就會顯得有點浪費時間。花些時間讓這些代碼更簡潔，更具可讀性是十分值得。\n\n## 簡單的情境\n\n例如下面這段代碼：合計集合中的所有數字，最容易想到的作法就是利用一個變數暫存合計數值，等到迴圈跑完就能得到所有數字的合計值。\n\n```csharp\nint sum = 0;\nfor (int i = 0; i < numbers.Length; i++) \n{\n\t\tsum += numbers[i];\n}\n```\n\n若是對語言或框架比較熟悉的人，可能就會用一些語言或框架提供的Aggregation方法來簡化代碼。例如：C#有Linq的Sum()能用，或者是Dart也有reduce()可以用。\n\n```csharp\nnumbers.Sum(); // C#\n\nnumbers.reduce((acc, number) => acc + number); //Dart\n```\n\n## 稍微複雜一點\n\n假設今天使用情境不是數字集合，而是物件集合，C#能透過Linq的Aggregate()、Dart也能使用fold()來簡化。例如要把一個產品訂單集合合併成一個購物車物件，把所有Order的屬性總和到ShoppingCart的屬性中。\n\n```csharp\norders.Aggregate(new ShoppingCart(), (shoppingCart, order) {\n\t\tshoppingCart.TotalPrice += order.Price;\n\t\tshoppingCart.OrderIds.Add(order.Id);\n\t\t...\n}); // C#\n\n```\n\n```dart\norders.fold(ShoppingCart(), (shoppingCart, order) {\n\t\tshoppingCart.totalPrice += order.price;\n\t\tshoppingCart.orderIds.add(order.id);\n\t\t...\n}); // Dart\n```\n\n利用語言提供的Aggregation方法來簡化代碼能滿有效的增加可讀性，一看到Aggregation方法就會知道這段代碼是要累計某些東西。上面這兩個例子中都是比較容易利用語言的Aggregation方法來簡化寫法。\n\n## 更多變的情境\n\n在實際產品代碼中，有一些情境讓人比較難想到可以使用Aggregation方法，還有另外一些情境則是不容易用Aggregation方法處理，下禮拜我會在整理這些情境並分享給大家，感謝大家耐心閱讀到這邊🤤。\n\n## 相關連結\n\n- [https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/supported-and-unsupported-linq-methods-linq-to-entities?redirectedfrom=MSDN](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/supported-and-unsupported-linq-methods-linq-to-entities?redirectedfrom=MSDN)\n- [https://api.dart.dev/stable/2.10.4/dart-core/List-class.html](https://api.dart.dev/stable/2.10.4/dart-core/List-class.html)",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:24 PM",
      "id": "69b4aa1a13df436794b511e5afe91f43",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "改善迴圈的可讀性（一） 69b4aa1a13df436794b511e5afe91f43.md"
    },
    {
      "title": "改善迴圈的可讀性（二）",
      "summary": "在一些迴圈使用情境，我們比較難使用Aggregation方法來簡化。有一種使用情境是需要透過暫存變數來保存每一輪的狀態，並帶到下一輪計算，此時就會讓代碼變得複雜。 在下面這段[Josephus Survivor](https://www.codewars.com/kata/555624b601231...",
      "content": "![image.png](%E6%94%B9%E5%96%84%E8%BF%B4%E5%9C%88%E7%9A%84%E5%8F%AF%E8%AE%80%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89/image.png)\n\n在一些迴圈使用情境，我們比較難使用Aggregation方法來簡化。有一種使用情境是需要透過暫存變數來保存每一輪的狀態，並帶到下一輪計算，此時就會讓代碼變得複雜。\n\n## 舉個例子\n\n在下面這段[Josephus Survivor](https://www.codewars.com/kata/555624b601231dc7a400017a/)的Kata例子中，迴圈中會計算每一輪要移除受害者的位置，並把倖存者帶進下一輪迴圈中計算並找出下一輪的受害者。每一輪的迴圈中都需要把上一個受害者的位址紀錄在start裡。\n\n```csharp\npublic int Play(int count, int step)\n{\n    var candidates = Enumerable.Range(1, count).ToList();\n\n    int start = 0;\n    while (!HasSurvivor(candidates))\n    {\n        var victim = FindVictim(step, start, candidates);\n        candidates = NextCandidates(candidates, victim);\n        start = victim;\n    }\n\n    return candidates.First();\n}\n```\n\n此時可以發現迴圈中的代碼雖然不多，卻也不好理解。在這個例子中，start不只是最一開始的初始位置，而是迴圈中的每一輪的初始位置，這個資訊必須要來回反覆的閱讀才能夠理解。\n\n在累加數字的例子中，sum也是相似的情境，sum表示在每一輪迴圈中的暫時合計值。但是我們可以透過Aggregation方法讓sum這個暫存變數消失。與sum不同的是，start無法使用Aggregation方法簡化。\n\n雖然無法使用Aggregation方法，但是我們可以使用**遞迴**來隱藏start。\n\n```csharp\npublic int Play(int count, int step)\n{\n    var candidates = Enumerable.Range(1, count).ToList();\n\n    return FindSurvivor(candidates, 0, step);\n}\n\nprivate int FindSurvivor(List<int> candidates, int start, int step)\n{\n    if (HasSurvivor(candidates))\n    {\n        return candidates.First();\n    }\n\n    var victim = FindVictim(start, step, candidates.Count());\n\t\tvar nextCandiates = NextCandidates(candidates, victim);\n    return FindSurvivor(nextCandidates, victim, step);\n}\n```\n\n當透過遞迴來重構這個例子中，我們可消去迴圈並把start隱藏在參數中，並且只表示初始位址這個意義，讓代碼更容易閱讀。\n\n## 實際情況...\n\n在實際情況中，這種使用情境並不常見，多數是在演算法的情境下會比較常使用到，例如：在Quick Sort演算法中紀錄pivot、在多個商品與多種打折策略中計算最優惠的折扣組合。\n\n---\n\n迴圈最常使用到的語法之一，用起來也相當的容易，但是要如何寫得讓人容易理解，就不是一件容易的事情。所幸的是很多語言都支援好用的Aggregation方法，讓我們更容易從把一些常見的迴圈形式簡化，使代碼更專注在其職責，而不是迴圈本身。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:24 PM",
      "id": "ff23b70b497448d7addaae55200ed3af",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "改善迴圈的可讀性（二） ff23b70b497448d7addaae55200ed3af.md"
    },
    {
      "title": "閱讀 IDE 給的提示",
      "summary": "現代的 IDE 很方便，當工程師編輯代碼時，IDE 會即時檢查代碼，並根據一些預設的規則，提示哪部分的代碼可能需要調整。不同的語言，不同的 IDE 提示狀況都不太一樣，但是或多或少都會有這個功能，提醒工程師可能要注意某段代碼是否有問題。 如果代碼總是穿插著不同顏色的提示，可能會讓工程師不想去處理這群...",
      "content": "![image.png](%E9%96%B1%E8%AE%80%20IDE%20%E7%B5%A6%E7%9A%84%E6%8F%90%E7%A4%BA/image.png)\n\n現代的 IDE 很方便，當工程師編輯代碼時，IDE 會即時檢查代碼，並根據一些預設的規則，提示哪部分的代碼可能需要調整。不同的語言，不同的 IDE 提示狀況都不太一樣，但是或多或少都會有這個功能，提醒工程師可能要注意某段代碼是否有問題。\n\n## 到處都是的提示和警告\n\n如果代碼總是穿插著不同顏色的提示，可能會讓工程師不想去處理這群成堆的提示，也不在乎自己寫的代碼是否多了一條提示，形成破窗效應。每種提示和警告都有不同的意義，有些是提醒拼錯字，有些是提示代碼存在 Side Effect。如果放任這些提示與警告蔓延在代碼中，除了會讓代碼品質日益下降，甚至會讓工程師忽略掉真正潛在的危險。\n\n![](%E9%96%B1%E8%AE%80%20IDE%20%E7%B5%A6%E7%9A%84%E6%8F%90%E7%A4%BA/sqknRNu.png)\n\n## 提示與警告的功用\n\n1. 提示不符合規則的寫法\n    - **拼字錯誤：**當變數名稱對不上某個英文單字時，IDE 就會提示你可能拼錯字。但是當單字是領域特有單字時，為了避免這種不必要的提示，就需要把這個單字加到 IDE 的預設字典中，讓提示可以認得這個單字。\n    - **語言的命名規則**，例如：以方法名稱為例，C# 預設方法名稱命名規則是開頭大寫的大駝峰命名法，而 Java 則是開頭小寫的小駝峰式命名法。當不符合這些規則時，IDE 就會提示你需要修改它。\n2. 更好的做法的提示\n    - 除了檢查拼字或命名規則，有些 IDE 還會建議更好的做法，例如：在 Rider 中，如果寫了下面這段代碼，一段由 for 處理的邏輯\n        \n        ```dart\n        var duplicateCount = 0;\n        foreach (var entry in cnt)\n        {\n            if (entry.Value > 1) duplicateCount++;\n        }\n        \n        return duplicateCount;\n        ```\n        \n        Rider 就會在 foreach 的部分提示使用 LINQ 改寫\n        \n        ```csharp\n        cnt.Count(entry => entry.Value > 1);\n        ```\n        \n        大多時候仔細閱讀這類型的提示，可以了解到什麼是更好的做法。尤其當自己是初學者的時候，這些提示都能幫助自己更好的了解這個語言的一些特性。\n        \n3. 潛在的風險的警告\n    - 有些時候，工程師可能寫出一寫有 Side Effect 的代碼，寫的時候沒有，以下面這段 C# 代碼為例，IDE 就提示了 gameResults 有重複執行多次的可能性，如果今天傳入這個方法的參數不是 List，而是 LINQ，就會導致 gameResults 跑了兩次迴圈，計算的卻是相同的東西。\n    \n    ![](%E9%96%B1%E8%AE%80%20IDE%20%E7%B5%A6%E7%9A%84%E6%8F%90%E7%A4%BA/CrCrOw8.png)\n    \n\n## **團隊特有的規則**\n\n這些提示都是根據每個語言的預設規則提示的，只要代碼不符合規則，IDE就會在代碼下方標註。但是有一種情況是開發團隊有自己一套規則，以 C# 為例，有些團隊習慣宣告變數時使用確定型別，讓閱讀代碼的人可以清楚知道這個變數是什麼型別。但是 IDE 會提示使用 var，因為 C# 能夠透過型別論來推斷變數型別，所以預設規則傾向於用更簡潔的寫法。\n\n```csharp\nCustomer customer = customerApi.Get(id);\n```\n\n在這種情況，就會產生團隊規則與 IDE 規則不同，導致代碼上出現不必要的提示。這時我們不應該放任警告與提示的存在畫面上，而是應該去調整自己的 IDE 設定，讓 IDE 不要因為這些命名規則持續地跳出警告。\n\n## 小結\n\n保持代碼沒有任何提示與警告，沒有無謂的波浪線與虛線，能讓閱讀代碼時能更專注，也能在真正需要的時候，讓 IDE 來提示你。除此之外，團隊的規則應該凌駕於所有寫法之上，畢竟代碼是團隊的，共同的寫法更是團隊協作的基礎，基本上除了可能造成 Side Effect 的提示之外，剩下的寫法優先度應該是以團隊共識為優先。\n\n## 題外話\n\n這篇原本是在鐵人賽的時候寫的，那是我第一次比較有系統地寫文章，也寫的比較倉促，所而有些凌亂。發在 Medium 的這篇則是整理一下原文，調整架構，並加上更多解釋。未來其他我覺得比較有意義文章整理到 Medium 這邊。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:23 PM",
      "id": "3471f9df45444649a98266ce3842f52e",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "閱讀 IDE 給的提示 3471f9df45444649a98266ce3842f52e.md"
    }
  ],
  "tags": [
    "AI Coding",
    "Flutter",
    "極限編程"
  ],
  "sideProjects": [
    {
      "name": "今彩 539 開獎資訊",
      "description": "用 Github Action + 爬蟲達成無後端式資訊收集與統計",
      "tags": [
        "React",
        "Python",
        "AI"
      ],
      "date": "2025/06",
      "websiteUrl": "https://easylive1989.github.io/ito539_analytics/",
      "sourceUrl": "https://github.com/easylive1989/ito539_analytics",
      "preview": "images/ito539_analytics.png"
    },
    {
      "name": "Breakout",
      "description": "按照教程練習 Flame，實作經典遊戲：打磚塊",
      "tags": [
        "Flutter",
        "Flame"
      ],
      "date": "2023/02",
      "websiteUrl": "https://easylive1989.github.io/flutter_breakout",
      "sourceUrl": "https://github.com/easylive1989/flutter_breakout",
      "preview": "images/breakout.png"
    },
    {
      "name": "NS-SHAFT",
      "description": "練習 Flame 開發，搭配 Firebase Hosting 部署，實作經典遊戲：小朋友下樓梯",
      "tags": [
        "Flutter",
        "Flame",
        "Firebase Hosting"
      ],
      "date": "2022/12",
      "websiteUrl": "https://playernsshaft.web.app/#/",
      "sourceUrl": "https://github.com/easylive1989/player_ns_shaft",
      "preview": "images/ns-shaft.png"
    },
    {
      "name": "Gomoku",
      "description": "嘗試用 Flutter 開發五子棋小遊戲，並且使用 Github Action 自動化部署到 Google Play",
      "tags": [
        "Flutter",
        "CI/CD"
      ],
      "date": "2021/03",
      "websiteUrl": "https://easylive1989.github.io/LittleFlowerApp/",
      "sourceUrl": "https://github.com/easylive1989/LittleFlowerApp",
      "preview": "images/gomoku.png"
    },
    {
      "name": "小遊戲 Line Bot",
      "description": "嘗試用 .Net Core + LINE 讓朋友們可用 Line 玩小遊戲，例如：猜數字、井字遊戲、五子棋",
      "tags": [
        ".Net Core",
        "Line Notify"
      ],
      "date": "2020/05",
      "websiteUrl": "",
      "sourceUrl": "https://github.com/easylive1989/LittleFlowerBot",
      "preview": "images/game_bot.png"
    }
  ],
  "generatedAt": "2025-10-24T09:33:56.781Z"
}
{
  "articles": [
    {
      "title": "這個 Flutter 小技巧，讓你看懂 Widget Test 到底哪裡壞了",
      "summary": "在 Flutter 開發中，我們除了寫程式之外，也會需要寫一些測試來確保功能沒有問題。Flutter SDK 內建提供了 Unit Test、Widget Test 與 Integration Test 三種測試工具供開發人員使用。這三種工具分別有些不同特性，Unit Test 無論是執行速度或是錯...",
      "content": "![](https://images.unsplash.com/photo-1501163109389-abf37ca1276a?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n在 Flutter 開發中，我們除了寫程式之外，也會需要寫一些測試來確保功能沒有問題。Flutter SDK 內建提供了 Unit Test、Widget Test 與 Integration Test 三種測試工具供開發人員使用。這三種工具分別有些不同特性，Unit Test 無論是執行速度或是錯誤訊息清晰度，都要比 Integration Test 要來得好很多。\n\n在 Flutter 開發中，除了撰寫功能程式碼之外，撰寫測試也是確保應用穩定性的重要一環。Flutter SDK 內建提供了三種測試工具：**Unit Test**、**Widget Test** 與 **Integration Test**。這三者的主要差異在於測試的層級與執行效能，其中 **Unit Test** 速度最快、錯誤訊息最清晰；而 **Integration Test**\n\n涵蓋範圍最廣，但速度最慢、維護成本也最高。\n\n![[https://docs.flutter.dev/testing/overview](https://docs.flutter.dev/testing/overview)](%E9%80%99%E5%80%8B%20Flutter%20%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%AE%93%E4%BD%A0%E7%9C%8B%E6%87%82%20Widget%20Test%20%E5%88%B0%E5%BA%95%E5%93%AA%E8%A3%A1%E5%A3%9E%E4%BA%86/image.png)\n\n[https://docs.flutter.dev/testing/overview](https://docs.flutter.dev/testing/overview)\n\n相較之下，**Widget Test** 的執行速度僅略慢於 Unit Test，但其錯誤訊息往往不夠直覺。例如，下列訊息僅指出某個 Widget 找不到，卻無法明確告訴我們原因：\n\n```bash\nExpected: no matching candidates\n  Actual: _TextWidgetFinder:<Found 1 widget with text \"1\": [\n            Text(\"1\", debugLabel: (englishLike headlineMedium 2021).merge((blackMountainView\nheadlineMedium).apply), inherit: false, color: Color(alpha: 1.0000, red: 0.1137, green: 0.1059,\nblue: 0.1255, colorSpace: ColorSpace.sRGB), family: Roboto, size: 28.0, weight: 400, letterSpacing:\n0.0, baseline: alphabetic, height: 1.3x, leadingDistribution: even, decoration: Color(alpha: 1.0000,\nred: 0.1137, green: 0.1059, blue: 0.1255, colorSpace: ColorSpace.sRGB) TextDecoration.none,\ndependencies: [DefaultSelectionStyle, DefaultTextStyle, MediaQuery]),\n```\n\n造成測試失敗的原因可能很多：邏輯錯誤、畫面未刷新、Widget 被遮擋 ……單靠這樣的訊息，很難快速定位問題，也因此 Widget Test 維護成本較高。\n\n## 使用 debugDumpApp 顯示 Widget Tree\n\n若上網搜尋「如何除錯 Widget Test」，很容易找到 Flutter 提供的 `debugDumpApp` API。這個工具可以輸出整個 Widget Tree，理論上可協助我們檢查畫面結構是否正確（[完整範例在這裡](https://dartpad.dev/?id=97d3dae3a802cc1d3076998ca6c43772)）。\n\n```bash\nAutomatedTestWidgetsFlutterBinding - DEBUG MODE\n[root]\n└View(state: _ViewState#f6410)\n └RawView\n  └_RawViewInternal-[_DeprecatedRawViewKey TestFlutterView#36943](renderObject: _ReusableRenderView#62b88)\n   └_ViewScope\n    └_PipelineOwnerScope\n     └_MediaQueryFromView(state: _MediaQueryFromViewState#8f554)\n      └MediaQuery(MediaQueryData(size: Size(800.0, 600.0), devicePixelRatio: 3.0, textScaler: no scaling, platformBrightness: Brightness.light, padding: EdgeInsets.zero, viewPadding: EdgeInsets.zero, viewInsets: EdgeInsets.zero, systemGestureInsets: EdgeInsets.zero, alwaysUse24HourFormat: false, accessibleNavigation: false, highContrast: false, onOffSwitchLabels: false, disableAnimations: false, invertColors: false, boldText: false, navigationMode: traditional, gestureSettings: DeviceGestureSettings(touchSlop: null), displayFeatures: [], supportsShowingSystemContextMenu: false))\n       └FocusTraversalGroup(policy: ReadingOrderTraversalPolicy#9bb45, state: _FocusTraversalGroupState#c8c8d)\n        └Focus(debugLabel: \"FocusTraversalGroup\", focusNode: _FocusTraversalGroupNode#1ee5d(FocusTraversalGroup [IN FOCUS PATH]), state: _FocusState#deea3)\n         └_FocusInheritedScope\n          └_FocusScopeWithExternalFocusNode(debugLabel: \"View Scope\", focusNode: FocusScopeNode#98f92(View Scope [IN FOCUS PATH]), dependencies: [_FocusInheritedScope], state: _FocusScopeState#7ba60)\n           └_FocusInheritedScope\n            └MyApp\n     \n```\n\n但實際使用後會發現，這份輸出往往冗長又難以閱讀。即使是一個簡單的 Counter App，Widget Tree 也可能超過兩百行，每行還充滿細節資訊。因此，透過 `debugDumpApp` 來排查畫面問題在實務上並不方便。\n\n那麼，我們該怎麼辦？在介紹解法之前，先來認識另一種測試方式——**Golden Test**。\n\n## 什麼是 Golden Test\n\n除了常見的 Unit Test、Widget Test 與 Integration Test 之外，Flutter 還有第四種測試：**Golden Test**。它不是用程式邏輯比對結果，而是透過**畫面比對**的方式確認 UI 是否異動。\n\nGolden Test 的原理很簡單：\n\n1. 先將正確的畫面狀態儲存為基準圖（snapshot）。\n2. 下次執行測試時，再將目前畫面與基準圖比較。\n3. 若畫面有任何變化，就會自動產生差異圖檔，讓開發者快速檢查變動位置。\n\n使用方式也很直觀：\n\n```dart\nexpect(find.byType(MaterialApp), matchesGoldenFile(\"snapshot.png\"));\n```\n\n若結果不同，Flutter 會在 snapshot.png 旁邊自動產生比較結果，使用者就能確認變動是否預期：\n\n```bash\ntest\n├── failures\n│   ├── snapshot_isolatedDiff.png\n│   ├── snapshot_maskedDiff.png\n│   ├── snapshot_masterImage.png\n│   ├── snapshot_testImage.png\n├── snapshot.png\n└── widget_test.dart\n```\n\n如果確認畫面變動是預期內的修改，只需執行以下指令即可更新基準圖：\n\n```dart\nflutter test --update-goldens\n```\n\n聰明的你可能已經想到：我們能否利用 Golden Test 的特性，讓 Widget Test 也能快速檢查畫面呢？\n\n## 使用 matchesGoldenFile 直接顯示畫面\n\n在 Widget Test 中，我們雖然不是真的在做 Golden Test，但其實還是可以使用 `matchesGoldenFile` 來將當前的畫面結果印出來。印出來之後，我們就能更快的檢查畫面是不是符合預期，而不用看 `debugDumpApp` 的那一長串資料了。\n\n雖然在 Widget Test 中我們並非真正執行 Golden Test，但仍可透過 `matchesGoldenFile` 來**輸出當前畫面結果**。\n\n這樣一來，我們就能以圖像的方式檢查畫面是否如預期，而不必苦讀 `debugDumpApp` 的長篇輸出。\n\n![snapshot.png](%E9%80%99%E5%80%8B%20Flutter%20%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%AE%93%E4%BD%A0%E7%9C%8B%E6%87%82%20Widget%20Test%20%E5%88%B0%E5%BA%95%E5%93%AA%E8%A3%A1%E5%A3%9E%E4%BA%86/snapshot.png)\n\n儘管測試環境中使用的字型可能與真實 App 不同（例如無法顯示文字或 Icon），但大部分畫面元素仍足以協助我們判斷 UI 是否正常。\n\n下次當 Widget Test 報錯卻不知從何下手時，試著加入 `matchesGoldenFile`，你可能能立刻看出問題所在。\n\n**注意事項**：`matchesGoldenFile` 在 Widget Test 只是一種用來 Debug 的手段，不適合一直放在測試中，務必在問題解決之後移除。\n\n## 小結\n\nWidget Test 是在速度與真實性之間取得平衡的測試方式，能快速驗證 App 的行為並提升測試覆蓋率。然而，它的除錯難度也較高。\n\n在進行逐步除錯（debug）之前，不妨先透過 `matchesGoldenFile` 生成畫面快照，快速比對結果。這個簡單的技巧，常能讓你瞬間發現問題根源。",
      "createdAt": "October 5, 2025 4:39 PM",
      "updatedAt": "October 5, 2025 8:28 PM",
      "id": "2838303f78f780a19f9eed48ccc9f2c6",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "這個 Flutter 小技巧，讓你看懂 Widget Test 到底哪裡壞了 2838303f78f780a19f9eed48ccc9f2c6.md"
    },
    {
      "title": "單元測試介紹",
      "summary": "--- - 每一個單元測試通常會focus在class的method上。若class相依於其他class，測試應該模擬外部class。若你寫的測試不是這樣，很有可能你的測試是整合測試，而非單元測試。 <aside> ❓ 為什麼我們要寫單元測試？試想一個情況，我們在寫好產品代碼後，為什麼要寫測試？我可...",
      "content": "## 什麼是單元測試\n\n---\n\n- 每一個單元測試通常會focus在class的method上。若class相依於其他class，測試應該模擬外部class。若你寫的測試不是這樣，很有可能你的測試是整合測試，而非單元測試。\n\n<aside>\n❓ 為什麼我們要寫單元測試？試想一個情況，我們在寫好產品代碼後，為什麼要寫測試？我可大可直接在本地環境或者Staging環境手動測試就好。\n\n</aside>\n\n<aside>\n💡 為了保護我們的產品代碼被改壞的時，我們可以即時發現。假設之後調整產品代碼或者增加需求時，確保我們可以透過單元測試確保原本的功能是正常的。\n\n</aside>\n\n<aside>\n🚫 單元測試並不是要拿來驗證新寫的產品代碼。\n\n</aside>\n\n## 單元測試的特性\n\n---\n\n- **快速**：正常情況下，寫完一段code或refactor完都會跑一下測試，確保原本的功能沒有壞掉\n- 準則\n    1. 一個測試案例只測一種方法\n    2. 最小的測試單位\n    3. 不與外部（包括檔案、資料庫、網路、服務、物件、類別）直接相依\n        - 以下面代碼為例，測試時應該把repository的部分mock掉\n        \n        ```csharp\n        public bool IsAllUserOnline() \n        {\n        \t\tvar userList = _repository.GetAllUser();\n        \n            return userList.All(user => user.IsOnline);\n        }\n        ```\n        \n    4. 不具備邏輯\n        \n        ```csharp\n        [Test]\n        public void Online_User_When_All_Online() \n        {\n            GivenUser(true);\n        \n            var result = _onlineService.IsAllUserOnline();\n        \n            Assert.AreEqual(true, result);\n        }\n        \n        [Test]\n        public void Online_User_When_Part_Online() \n        {\n            GivenUser(false);\n        \n            var result = _onlineService.IsAllUserOnline();\n        \n            Assert.AreEqual(false, result);\n        }\n        \n        private void GivenUser(bool isOnline)\n        {\n            var userList = new List<User>();\n            userList.Add(new User(){\n                Id = 123,\n                IsOnline = true\n            });\n            userList.Add(new User()\n            {\n                Id = 124,\n                IsOnline = false\n            });\n        \n            // Should Not Exist Logic In Tests\n            var onlineUserList = userList.Where(user => user.IsOnline == isOnline).ToList();\n            \n            _onlineRepository.GetAllUser().Returns(onlineUserList);\n        }\n        ```\n        \n    5. 測試案例之間相依性為零\n- 相較於其他種類的測試，單元測試的數量通常比較多，且執行成本較低\n\n<aside>\n❓ 試想一下為什麼執行成本較低？\n\n</aside>\n\n<aside>\n💡 因為執行速度比較快。假設每次改一次動都跑E2E Tests，等待web driver啟動、等待UI反饋的時間、等待Server回覆的時間，每一次的等待都是浪費。\n\n</aside>\n\n![](%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E4%BB%8B%E7%B4%B9.jpeg)\n\n## 單元測試的基本結構\n\n---\n\n- 3A\n    - Arrange：準備測試資料\n    - Act：執行待測方法\n    - Assert：驗證結果\n\n## 單元測試的可讀性\n\n---\n\n如果單元測試寫得夠完整的話，他是可以看成是一種產品的規格書。因為測試會表達出輸入什麼在什麼情況下應該輸出什麼，可以表達出這個物件的行為。理想上當看code時，如果有測試的話，我們可以從測試去了解這段code的行為。所以測試也需要一些重構，讓看的人可以比較容易看懂這段測試想表達的意思。\n\n- 測試的命名：有底線的命名方式閱讀起來比較容易一些，不過還是以團隊共識為主\n    \n    ```csharp\n    public void Query_Budget_Full_Month()\n    {\n    \t\t...\n    }\n    \n    public void QueryBudgetFullMonth()\n    {\n        ...\n    }\n    ```\n    \n- 測試內容：3A是分類了測試的三的部分，但是實務上還是以可讀性為主\n    \n    ```csharp\n    [Test]\n    public void QueryBudgetFullMonth()\n    {\n    \t\t// Arrange\n    \t\tvar budgetList = new List<Budget>();\n    \t\tbudgetlist.Add(new Budget() {\n    \t\t\t\tAmount = 3100,\n    \t\t\t\tYearMonth = \"202012\"\n        });\n    \t\tbudgetlist.Add(new Budget() {\n    \t\t\t\tAmount = 310,\n    \t\t\t\tYearMonth = \"202001\"\n        });\n    \t\t_fakeRepo.GetAll().Returns(budgetList);\n    \n    \t\t// Act\n    \t\tvar startDate = DateTime.Parse(\"2019/12/1\");\n        var endDate = DateTime.Parse(\"2019/12/31\");\n    \n        var actual = _accounting.QueryBudget(startDate, endDate);\n    \n    \t\t// Assert\n        Assert.AreEqual(3100, actual);\n    }\n    ```\n    \n    ```csharp\n    private budgetList;\n    ..\n    \n    [Setup]\n    public void Setup()\n    {\n        budgetList = new List<Budget>();\n    \t\t_fakeRepo.GetAll().Returns(budgetList);\n    \n    \t\t...\n    }\n    \n    [Test]\n    public void Query_Budget_Full_Month()\n    {\n    \t\tGivenBudget(new Budget() {\n    \t\t\t\tAmount = 3100,\n    \t\t\t\tYearMonth = \"202012\"\n        });\n    \t\tGivenBudget(new Budget() {\n    \t\t\t\tAmount = 310,\n    \t\t\t\tYearMonth = \"202001\"\n        });\n    \n    \t\tBudgetShouldBe(\"2019/12/1\", \"2019/12/31\" 3100);\n    }\n    \n    private void GiveBudget(Budget budget) \n    {\n    \t\tbudgetList.Add(budget);\n    }\n    \n    private void BudgetShouldBe(string startDate, string endDate, int expected) \n    {\n    \n    \t\tvar startDate = DateTime.Parse(startDate);\n        var endDate = DateTime.Parse(endDate);\n    \n        var actual = _accounting.QueryBudget(startDate, endDate);\n    \t\t\n        Assert.AreEqual(expected, actual);\n    }\n    ```\n    \n\n## 其他\n\n---\n\n- 寫測試時最好測試一下你測試是否會壞\n- 只會測試 public 的方法",
      "createdAt": "June 24, 2021 10:04 AM",
      "updatedAt": "October 3, 2025 4:57 PM",
      "id": "14c339451eb94a2b883a59127b4f2ae7",
      "type": "Medium",
      "tag": "軟體開發",
      "filename": "單元測試介紹 14c339451eb94a2b883a59127b4f2ae7.md"
    },
    {
      "title": "用 Widget Test 測試 Routing",
      "summary": "在開發 Flutter 時，我們可以寫 Widget Test 確保功能在我們重構之後，還是保持正常運作。我們會針對許多不同的情境進行測試，其中一種情境是當使用者進行某些操作，或者當某些情況發生，把使用者導到其他頁面，今天就來分享如何使用 Widget Test 驗證 Routing。 假設我們有常...",
      "content": "![_206dd02c-3b32-4243-95a6-b8a7669e5acc.jpeg](%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%20Routing/_206dd02c-3b32-4243-95a6-b8a7669e5acc.jpeg)\n\n在開發 Flutter 時，我們可以寫 Widget Test 確保功能在我們重構之後，還是保持正常運作。我們會針對許多不同的情境進行測試，其中一種情境是當使用者進行某些操作，或者當某些情況發生，把使用者導到其他頁面，今天就來分享如何使用 Widget Test 驗證 Routing。\n\n## 舉個例子\n\n假設我們有常見的清單頁面，其中列滿了各種狗狗品種，當我們點擊了某一個品種之後，App 會把使用者導向另一個頁面，並向隨機呈現一張該品種的圖片。在這個例子中，我們使用 [DogAPI](https://dog.ceo/dog-api/)，有興趣的觀眾也可以參考看看。\n\n![Route 測試.jpg](%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%20Routing/Route_%25E6%25B8%25AC%25E8%25A9%25A6.jpg)\n\n這個需求並不複雜，經過一番操作之後，我們在相對應的 **ListTitle** 上加上 **GestureDetector** 並使用 **Navigator** 把使用者導到下一個頁面，也告訴下一個頁面要顯示哪種品種的狗狗，最後成功在畫面上隨機顯示一張該品種的狗狗圖片。\n\n```dart\nclass BreedListPage extends StatelessWidget {\n  \n\t...\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: breedList.length,\n      itemBuilder: (context, index) {\n        return GestureDetector(\n          onTap: () => Navigator.of(context).pushNamed(\n            \"/dog_image\",\n            arguments: breedList[index],\n          ),\n          child: ListTile(\n            title: Text(breedList[index]),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n但是當我們完成功能之後，可能會思考，我們該如何進行測試呢？我們該如何功能正確，並且在未來也都持續保持正確呢？\n\n## Arrange 與 Act\n\n對測試熟悉的觀眾，可能很快就能完成 Arrange 與 Act 的部分，關於測試 3A 原則可以參考[這邊](https://dotblogs.com.tw/hatelove/2012/11/07/learning-tdd-in-30-days-day3-how-to-write-a-unit-test-code)。在下面測試中，我們使用 [mocktail](https://pub.dev/packages/mocktail) 套件準備 DogAPI 的回傳結果，顯示 **BreedListPage**，接著我們點擊其中一個品種，一切都輕鬆寫意。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  MockClient mockClient = MockClient();\n  when(() => mockClient.get(Uri.parse(\"https://dog.ceo/api/breeds/list/all\"))).thenAnswer((_) async {\n    return Response('{\"message\": {\"affenpinscher\": [], \"african\": [], \"airedale\": []}, \"status\": \"success\"}', 200);\n  });\n\n  await tester.pumpWidget(\n    MaterialApp(\n      home: BreedListPage(client: mockClient)\n    ));\n  await tester.pump();\n\n\t// Act\n  await tester.tap(find.text(\"affenpinscher\"));\n\n  // How to assert routing?\n  \n});\n\nclass MockClient extends Mock implements Client {}\n```\n\n接下來的問題便是，我們如何驗證 Routing 是否成功呢？\n\n## Mock NavigatorObserver\n\n如果有使用過 [firebase_analytics](https://pub.dev/packages/firebase_analytics) 的觀眾，可能會知道可以使用套件中的 **FirebaseAnalyticsObserver** 協助我們追中使用 Routing 狀況，當 App 進行 Routing 時，會呼叫 [**NavigatorObserver.didPush](https://api.flutter.dev/flutter/widgets/NavigatorObserver/didPush.html)** 方法並透過參數告知當前 **Route** 與上一個 **Route**，此時 firebase_analytics 套件就有機會追蹤使用者的 Routing 行為。\n\n同樣地，我們也可以 mock 一個測試用的 **MockNavigatorObserver**，並驗證 didPush 方法是否有被呼叫，來達到驗證 Routing 的效果，那就讓我們使用 MockRoutingObserver 來驗證一下上述例子吧。\n\n在下面例子中，我們宣告了一個 **MockNavigatorObserver**，並把它傳給 **MaterialApp**，由此我們就能在測試中監聽 App Routing 的狀況。在 Assert 的地方中，我們使用驗證了 mockNavigatorObserver.didPush 是否有被呼叫，除此之外，我們還使用 captureAny() 來捕捉參數，驗證參數中的 **Route** 名稱是否符合預期。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\tMockNavigatorObserver mockNavigatorObserver = MockNavigatorObserver();\n  await tester.pumpWidget(\n    MaterialApp(\n      home: BreedListPage(client: mockClient),\n      navigatorObservers: [mockNavigatorObserver],\n   ));\n  await tester.pump();\n\n\t// Act\n  await tester.tap(find.text(\"affenpinscher\"));\n\n  // Assert\n  var result = verify(() => mockNavigatorObserver.didPush(captureAny(), any()));\n  expect(result.captured[1].settings.name, \"/dog_image\");\n});\n\nclass MockNavigatorObserver extends Mock implements NavigatorObserver {}\n```\n\n值得注意的是，在例子中我們使用了 captured[1] 來驗證，是因為在測試中，當我們在準備 BreedListPage 時，實際上也進行了一次 Routing，但這次 Routing 我們並不關心，我們關心的是第二次 Routing 結果，所以在上面例子中，我們驗證 captured[1] 的結果。\n\n## 找不到 Routing 錯誤\n\n當我們完成上面測試並運行後，會發現測試還是錯誤的，並在錯誤訊息中發現以下錯誤訊息。\n\n```\nCould not find a generator for route RouteSettings(\"/dog_image\", affenpinscher) in the _WidgetsAppState.\nMake sure your root app widget has provided a way to generate this route.\n```\n\n原因是我們在測試中沒有定義 /dog_image 這個 **Route**，所以當運行測試，程式走到 Navigator.of(context).pushNamed 時，就發生了錯誤。為了解決這個問題，我們只要在測試中給假的 **Route** 即可。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n  await tester.pumpWidget(\n    MaterialApp(\n      ...\n\t\t\troutes: {\"/dog_image\": (_) => const SizedBox()},\n   ));\n  await tester.pump();\n\n\t// Act\n  ...\n\n  // Assert\n\t...\n});\n```\n\n當我們加上假的 Route 之後，再次運行測試，就能通過測試得到綠燈了。\n\n## 除了驗證測試路徑之外\n\n在上面測試中，我們雖然成功驗證了 Routing 是否符合預期，但是其實還有一件事我們沒有驗證到，那就是我們少驗證了參數，我們除了把使用者導到下一個頁面之外，也會告訴下一個頁面要顯示哪一個品種的狗。在我們完成上面的測試之後，我們想再額外驗證參數其實就相對容易，我們只要加上另外一個 expect 即可。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\t// Act\n  ...\n\n  // Assert\n\tvar result = verify(() => mockNavigatorObserver.didPush(captureAny(), any()));\n  expect(result.captured[1].settings.name, DogImagePage.routeName);\n  expect(result.captured[1].settings.arguments, \"affenpinscher\");\n});\n```\n\n## 自定義 RouteMatcher\n\n當我們完成測試之後，除了重構一下程式碼之外，我們也必須重構一下測試，讓我們的測試保持簡單易懂，在驗證 Routing 的部分，我們可以自定義一個 RouteMatcher 來增加測試可讀性，讓我們不必每次都在測試中把 captured 挖出來一個一個檢查，那就讓我們來重構一下 Assert 的部分吧。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\t// Act\n  ...\n\n  // Assert\n\tverify(() => mockNavigatorObserver.didPush(\n\t  captureAny(\n\t    that: RouteMatcher(\n\t      routeName: \"/dog_image\",\n\t      arguments: \"affenpinscher\",\n\t    ),\n\t  ),\n\t  any(),\n\t));\n});\n\nclass RouteMatcher extends Matcher {\n  final String routeName;\n  final dynamic arguments;\n\n  RouteMatcher({required this.routeName, this.arguments});\n\n  @override\n  Description describe(Description description) {\n    return description.add('routeName: $routeName, arguments: $arguments');\n  }\n\n  @override\n  bool matches(item, Map matchState) {\n    return item.settings.name == routeName &&\n        item.settings.arguments == arguments;\n  }\n}\n```\n\n我們新增了一個 **RouteMatcher** 來協助比較 **Route** 是否符合預期，此後當我們閱讀 Routing 測試時，就能更直觀的在 Assert 中看到我們預期什麼路徑與參數，增加測試的可讀性，當然我們還可以利用**抽取方法**進一步的調整，讓測試真正變成容易閱讀的需求文件，像是下面程式碼那樣，這邊就不做過多贅述，~~關於這個問題，我們以後會做一集專門講解。~~\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\t// Act\n  ...\n\n  // Assert\n\trouteShouldBe(routeName: \"/dog_image\", arguments: \"affenpinscher\");\n});\n```\n\n## 一定得使用 NavigatorObserver 嗎？\n\n除了使用 **NavigatorObserver** 來測試 Routing，其實也可以直接針對整個 App 測試，我們也就不用做假的 **Route** 與 **MockNavigatorObserver** 了，聽起來好像十分省事，對吧。讓我們簡單地改寫一下測試：\n\n1. 準備兩個頁面所必須使用的資料：狗狗品種清單與隨機一張狗狗圖片\n2. 顯示 **MainApp**，而不是 **BreedListPage**\n3. 按下其中一個品種\n4. 驗證 Image 所顯示的圖片是否符合預期。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n  //Arrange\n  when(() => mockClient.get(Uri.parse(\"https://dog.ceo/api/breeds/list/all\"))).thenAnswer((_) async {\n    return Response( '{\"message\": {\"affenpinscher\": [], \"african\": [], \"airedale\": []}, \"status\": \"success\"}', 200);\n  });\n\n  when(() => mockClient.get(Uri.parse(\"https://dog.ceo/api/breed/african/images/random\"))).thenAnswer((_) async {\n    return Response( '{\"message\": \"https://images.dog.ceo/breeds/bulldog-boston/n02096585_355.jpg\", \"status\": \"success\"}', 200);\n  });\n\n  await tester.pumpWidget(MainApp(client: mockClient));\n  await tester.pump();\n\n  // Act\n  await tester.tap(find.text(\"african\"));\n  await tester.pumpAndSettle();\n\n  // Assert\n  expect(findNetworkImage(tester).url, \"https://images.dog.ceo/breeds/bulldog-boston/n02096585_355.jpg\");\n});\n\nNetworkImage findNetworkImage(WidgetTester tester) => tester.widget<Image>(find.byType(Image)).image as NetworkImage;\n```\n\n在上面例子中，測試看起來也更簡單俐落，也更貼近使用者的真實狀況，沒有 **MockNavigatorObserver** 好像看起來更好了。事實上，在這個例子中，也確實如此，使用 **MockNavigatorObserver** 反而增加了不必要的麻煩。\n\n但是在實務上，有時並非如此，當我們的 App 功能越來越多，越來越複雜時，若測試的進入點是整個  App，但是我們卻想測試某個頁面的行為，可能就得做很多準備工作，最後才能進到我們真正想測試的地方，雖然測試很貼近使用者的真實狀況，但同時也變得很難寫，變得脆弱。\n\n## 結論\n\n無論選擇使用 **MockNavigatorObserver** 協助測試，或是直接測試整個 App，我們應該依照當下情況調整，但是不管如何，我們都有義務為功能撰寫測試 ，這是開發人員必要工作之一，測試可以維護產品品質，也增加我們重構時的信心，更可以用來描述產品行為，讓後人可以透過測試案例來了解產品行為，是一石三鳥的好投資。\n\nP.S. 以上程式碼都只有片段，如果有興趣看更完整的 Demo 的觀眾，可以到[這邊](https://github.com/easylive1989/lovely_dog_app/tree/completed)。",
      "createdAt": "June 7, 2023 10:30 PM",
      "updatedAt": "October 3, 2025 4:56 PM",
      "id": "f610eefa549646aab96181e0d298a492",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "用 Widget Test 測試 Routing f610eefa549646aab96181e0d298a492.md"
    },
    {
      "title": "架設小遊戲機器人（下）",
      "summary": "延續上一篇，這篇繼續補完實作小遊戲機器人中碰到的各種問題，有些是為了學習，有些是為了繞過限制，有些則是為了自己奇怪的目的？無論如何，隨著機器人的功能越來越多，也陸續在不同的時間點上碰上不同的問題，前前後後為了解決這些問題，花了不少時間，也是一段充滿樂趣的過程，就讓我在這篇文章中把剩下問題在這篇介紹完...",
      "content": "延續上一篇，這篇繼續補完實作小遊戲機器人中碰到的各種問題，有些是為了學習，有些是為了繞過限制，有些則是為了自己奇怪的目的？無論如何，隨著機器人的功能越來越多，也陸續在不同的時間點上碰上不同的問題，前前後後為了解決這些問題，花了不少時間，也是一段充滿樂趣的過程，就讓我在這篇文章中把剩下問題在這篇介紹完吧。\n\n## 訊息推送失敗？？\n\n當使用機器人一陣子之後，某一天開始，訊息無法正常推送，仔細看了log才發現，原來訊息推送次數已達上限，因為 LINE 的免費方案有推送訊息的次數限制。知道這個限制之後，本來是想放棄機器人了，畢竟一個機器人的使用頻率不高，但是 LINE 付費方案又需要每個月幾百塊，自己覺得不是很划算。\n\n後來經過朋友推薦，得知 LINE Notify 這個服務，這是一個可以透過 LINE Notify 幫忙推送訊息的服務，Server 端只要實作 OAuth 2.0 去對接 LINE Notify，就能夠透過 LINE Notify 來免費送訊息。機器人只要取得群組的發送訊息用的 LINE Notify token，就能使用這個 token 經由 LINE Notify 來轉傳訊息。使用了 LINE Notify 來傳送訊息，雖然可以實現免費無限制推送訊息，使用時會需要在群組中加入機器人與 LINE Notify，不免有些不便，但是為了免費，只好犧牲了方便性。\n\n## 想要 Public Repository\n\n由於專案是放在 Github 且是公開的，所以一些像是 DB、Redis 的位置或是 LINE 的 Token，這些比較私密的資訊不能直接放在 appsetting.json 中。為了解決這個問題，我把這些資訊移進 Github 的 Secret 中，並且在 Github Actions 執行時，從 Secret 中把這些資訊拿出來，再透過 Docker 的 ARG 參數傳入，讓 Server 在 Docker 中啟動時可以取得這些重要資訊。\n\n## Heroku 的套件\n\n除了 Redis 之外，Heroku 也還有許多 Add-on 可以增加 App 功能，像是 PostgreQL 來做為 Server 的 DB，或者是 Papertrail 來看 Log。使用上也建議看完 Heroku 的官方說明文件，不然像我一樣碰到 Redis 的位置每隔一小段時間就會改變，導致 Server 無法正常運行。\n\n## 小結\n\n在寫這個機器人的過程當中，很多事情都是從零開始，邊學邊使用自己完全沒碰過的技術，所以一路建起來也是坑坑洞洞，最後進化成一個可以帶來樂趣的機器人，也因此學到了很多，謝謝看到這邊的大家，最後附上我的 [Github Repository](https://github.com/easylive1989/LittleFlowerBot)。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 3, 2025 4:32 PM",
      "id": "aaa8ecd43cce459ab8fd2adb6f2cd499",
      "type": "Medium",
      "tag": "C# / .NET",
      "filename": "架設小遊戲機器人（下） aaa8ecd43cce459ab8fd2adb6f2cd499.md"
    },
    {
      "title": "掌握知識的過程",
      "summary": "最近剛寫完[三十天的 IThome 鐵人賽](https://ithelp.ithome.com.tw/users/20129825/ironman/5974)，在寫的過程中，忽然在思考知識學習是什麼，想著想著腦海中突然有一個知識建構的畫面，今天就來寫一篇文章講講我心中的知識學習過程吧。 那什麼是知...",
      "content": "最近剛寫完[三十天的 IThome 鐵人賽](https://ithelp.ithome.com.tw/users/20129825/ironman/5974)，在寫的過程中，忽然在思考知識學習是什麼，想著想著腦海中突然有一個知識建構的畫面，今天就來寫一篇文章講講我心中的知識學習過程吧。\n\n## 什麼是知識？\n\n那什麼是知識呢？觀眾們肯定都知道什麼是知識，但是這邊我們還是來複習一下定義。在劍橋字典定義中，知識是**透過經驗或研究獲得的關於某一主題的理解或訊息，可以由一個人或一般大眾所知。**\n\n> **understanding of or information about a subject that you get by experience or study, either known by one person or by people generally\n- Cambridge Dictionary**\n> \n\n從定義中可以發現，知識就是某一個主題的理解或訊息。我認為一個主題知識對於我們就像一團雲霧，雲霧間每一個點都是一個知識點，越靠近邊緣的知識點，越難確認是不是屬於這個主題，同時我們也很難定義這個主題知識的邊界在哪邊，那我們都是怎麼認識知識的呢？\n\n![IMG_0039.jpeg](%E6%8E%8C%E6%8F%A1%E7%9F%A5%E8%AD%98%E7%9A%84%E9%81%8E%E7%A8%8B/IMG_0039.jpeg)\n\n想像一下我們會在心中蓋一間一間的房子，這個房子有邊有角，邊界明確，在房子的知識點就屬於這個主題的知識，房子外的則不屬於。\n\n![IMG_0040.jpeg](%E6%8E%8C%E6%8F%A1%E7%9F%A5%E8%AD%98%E7%9A%84%E9%81%8E%E7%A8%8B/IMG_0040.jpeg)\n\n每個人學習知識的路徑不同，蓋出來的房子大小位置也不同，大多數情況下，每個人蓋出來的房子與其他人多少都會有重疊，重疊的部分的知識點也暗示了這個知識點明確屬於某個主題。\n\n![IMG_0041.jpeg](%E6%8E%8C%E6%8F%A1%E7%9F%A5%E8%AD%98%E7%9A%84%E9%81%8E%E7%A8%8B/IMG_0041.jpeg)\n\n## 學習知識\n\n在學習知識個過程中，就像在蓋房子一樣，我們不可能一瞬間就把房子蓋好，而是會一根柱子一根柱子的立起來，每根柱子標示了一個知識點。\n\n![IMG_0042.jpeg](%E6%8E%8C%E6%8F%A1%E7%9F%A5%E8%AD%98%E7%9A%84%E9%81%8E%E7%A8%8B/IMG_0042.jpeg)\n\n我們學習一個主題的知識，會透過各種途徑，例如：上課、看書、與他人交流 …等方式來學習，每次學會一件事，我們就會在知識雲霧中立下一根柱子，表示我們對於這個知識點有比較穩固的認識。\n\n![IMG_0044.jpeg](%E6%8E%8C%E6%8F%A1%E7%9F%A5%E8%AD%98%E7%9A%84%E9%81%8E%E7%A8%8B/IMG_0044.jpeg)\n\n隨著我們柱子越立越多，知識邊界也越來越明確。\n\n![IMG_0043.jpeg](%E6%8E%8C%E6%8F%A1%E7%9F%A5%E8%AD%98%E7%9A%84%E9%81%8E%E7%A8%8B/IMG_0043.jpeg)\n\n## 學習途徑\n\n不同的學習途徑，對於知識的學習也有至關重要的差別，從好的老師身上學習，我們可能一開始就能在雲霧的正中央立下第一根柱子，我們也會從比較好的點開始蓋房子。\n\n![IMG_0044.jpeg](%E6%8E%8C%E6%8F%A1%E7%9F%A5%E8%AD%98%E7%9A%84%E9%81%8E%E7%A8%8B/IMG_0044%201.jpeg)\n\n倘若今天學習途徑不夠優秀，讓我們一開始學到的訊息有偏差，我們的第一根柱子可能就會立在雲霧的邊邊，蓋起來的房子就可能偏離雲霧中心，學到的知識就容易與他人有偏差。\n\n![IMG_0045.jpeg](%E6%8E%8C%E6%8F%A1%E7%9F%A5%E8%AD%98%E7%9A%84%E9%81%8E%E7%A8%8B/IMG_0045.jpeg)\n\n所以我們需要多方學習參考，把柱子越立越多，避免抱著一根錯誤的柱子，以為就是全部。\n\n## 穩固知識\n\n就像蓋房子一樣，只有柱子，是不夠的，只有柱子的房子不穩固，別人輕輕一碰就倒了，所以我們需要加上樑。那在學習知識的過程中的樑又是什麼呢？在學習知識的過程中，當別人問爲什麼時候，我們發現總是答不上來，又或者是只能感覺來形容，很可能就是知識不夠穩固，不了解前因後股，來龍去脈。\n\n那如何為知識點加上樑呢？簡單來說就是**思考**，但是我們很難平白無故地就開始思考知識點之間的關係。所以為了促進思考，我們最常做的方式就是**輸出**，透過部落格，錄教學影片，把知識運用在實務上 …等方式，在輸出的過程中，我們肯定會碰到一些問題，這些問題就會反過來引導我們思考，知識之間開始產生連結，房子的樑也由此而生。\n\n![IMG_0046.PNG](%E6%8E%8C%E6%8F%A1%E7%9F%A5%E8%AD%98%E7%9A%84%E9%81%8E%E7%A8%8B/IMG_0046.png)\n\n我們可以寫 blog，錄影片，教別人，來更穩固我們的知識，隨著越做越多，對於這個領域的知識也越來越穩固，最終\n\n![IMG_0047.PNG](%E6%8E%8C%E6%8F%A1%E7%9F%A5%E8%AD%98%E7%9A%84%E9%81%8E%E7%A8%8B/IMG_0047.png)\n\n最後我們的房子有樑有柱，也象徵著我們對於這個主題知識有一定了解了。\n\n## 最後\n\n蓋完房子並不是終點，我們會持續學習，可能往外把房子越蓋越大，也可能往內把房子越蓋越穩固。",
      "createdAt": "September 20, 2023 10:13 AM",
      "updatedAt": "October 3, 2025 4:26 PM",
      "id": "de8bcb20c8094f03ae4484a9ce9d5349",
      "type": "Medium",
      "tag": "思維進化",
      "filename": "掌握知識的過程 de8bcb20c8094f03ae4484a9ce9d5349.md"
    },
    {
      "title": "架設小遊戲機器人（上）",
      "summary": "這篇文章主要是紀錄一下自己的 Side Project ：小遊戲機器人的演進過程 這個 Side Project 啟動於三年前，剛好那陣子聽到或學到比較多自己沒用過的技術，LINE BOT、ASP.NET Core、Docker ...等，於是就想練習一下這些新技術，看看能不能用這些技術做出一些好玩...",
      "content": "這篇文章主要是紀錄一下自己的 Side Project ：小遊戲機器人的演進過程\n\n這個 Side Project 啟動於三年前，剛好那陣子聽到或學到比較多自己沒用過的技術，LINE BOT、ASP.NET Core、Docker ...等，於是就想練習一下這些新技術，看看能不能用這些技術做出一些好玩的東西。\n\n啟發於上個時代的通訊軟體MSN Messager、Yahoo Messager，當時這些通訊軟體上有一些小遊戲，讓同一個群組的人可以透過這些遊戲互動，當時覺得這個功能很有趣。如今自己最常用的通訊軟體就是LINE，於是想到可以在 LINE 上面做一些簡單的小遊戲，讓群組的朋友無聊的時候可以一起互動，一起玩個小遊戲增加趣味，也可以藉此增加一些聊天的話題。\n\n## Hello World? Bot?\n\n一開始自己跟著 [LINE 官方教學](https://developers.line.biz/zh-hant/docs/messaging-api/building-sample-bot-with-heroku/#deploy-the-kitchensink-sample-bot-app)開始，把 LINE BOT Server 架設在 Heroku 上。Heroku 是一個滿方便的雲端服務平台，可以在 Heroku 上開設一個免費方案的 app。在 Heroku app 設定完成後，把官方提供的 example 部署上去，就馬上得到一個會重複上一句話的 echo LINE BOT，自己也對著這個範例修修改改的，稍微玩了一下。\n\n當完成官方範例後，雖然機器人已經可以正常運作，但是跟當初想練習的技術不太一樣，所以就開啟了用 C# 寫 LINE BOT 之旅。\n\n## 用 [ASP.NET](http://asp.NET) Core 實作 LINE BOT\n\n因為自己想練習的是 [ASP.NET](http://asp.NET) Core，但是 LINE 官方提供的範例都不是 C# 的，所以自己就用 ASP.NET Core 做了一個簡單的 Web API Server，寫了一個 API 給 LINE BOT Webhook 使用。當有人傳訊息給 LINE BOT 時，LINE 就會呼叫我們提供的 API 並傳入訊息內容。\n\nLINE BOT 傳過來資料的是 Json 格式，裡頭包含訊息內容、送訊息的使用者ID、訊息格式、回覆用的 token ...等，所以我自己是用了 [LineBotSDK](https://www.nuget.org/packages/LineBotSDK/) 套件來幫忙把資料轉成物件，除了轉換資料物件之外，這個套件也能用來回覆或推送訊息。\n\n當做好一個 Web API Server 之後，是該把程式部署到 Heroku 上了。\n\n## Heroku 不支援 ASP.NET\n\n當我開始研究如何部署時，赫然發現 Heroku 不支援 C#，如果是直接把代碼放到 Heroku git，就會出現不支援的錯誤。當時也找到一些答案可以解決這個問題的，例如在 Heroku 上安裝第三方的 buildpack，透過這個 buildpack 來建置部署 C# 的程式。而另外一個解法，也是我現在使用的解法，就是使用 Docker，透過 Docker 來 build 出 [ASP.NET](http://asp.NET) 的應用，然後部署 image 到 Heroku image registry 上，最後 Heroku 就能執行這個 image 來啟動服務。\n\n至此，小遊戲機器人已經可以開始使用了，在機器人所在的群組中，送出一些固定命令，然後機器人就會根據狀況來回覆訊息。\n\n## 自動化部屬\n\n每次修改完代碼之後，除了要把代碼 push 到 Github 之外，還要手動在本機 build 出 image，然後再透過 docker 命令把 image 上傳到 Heroku 的 registry 上。為了解決太多手動操作的問題，自己就開始研究 Github Action，期望透過它達到自動化部署，省去手動部署的麻煩。當每次 commit 到 Github 時，Github Action 就會抓取最新的代碼，嘗試建置和測試，通過之後就開始 build image 和把 image 傳到 Heroku 的 registry 中，透過自動化來避免每次部署都要手動操作。\n\n完成 Github Action 後，每一次 commit 都能自動的建置、測試與部署，讓整體開發更為順暢。\n\n## 每次部署資料都會消失\n\n在最一開始版本中，所有遊戲的狀態都是存在記憶體中，當 Server 重新部署後，所有玩到一半的遊戲都會消失。一開始的遊戲只有井字遊戲和猜數字，這些遊戲很快就能結束，所以不至於產生太大的問題。隨著後來加入五子棋後，這個問題就開始變得嚴重，因為沒有限制下棋的時間，當玩到一半就離開處理事情，過一陣子處理完後才走下一步，甚至等到隔天才想起來要走下一步，若中間有修改代碼，commit 後的自動部署就會導致遊戲狀態的消失。\n\n為了解決這個問題，也為了學習如何使用 Redis，所以在 Heroku 上加上了一個 Redis 的 Add-on，並讓 Container 裡的機器人連到這個 Redis。在 C# 的部分，自己使用了[StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis) 來處理 Redis 的連線與操作，在 Redis 中儲存正在進行的遊戲的狀態，當 Server 重新部署後，只要從 Redis 讀取進行中的遊戲狀態，就可以避免遊戲狀態因為重新部署而消失。\n\n當機器人開始用 Redis 時，終於可以達到隨時都可以部署的狀態了。\n\n## 未完待續...\n\n做這個機器人的過程中碰到了許多問題，也產生了許多學習的機會，除了上面提到問題之外，還有其他關於資料庫、LINE BOT的限制...等，會在下一篇文章中補完，因為這篇文章主要是紀錄一下整個專案的歷程，所以沒有過多地講述細節，如果有人有興趣其中某一個部分，可以聯繫我讓我知道，我會再找時間寫得更詳細的，也謝謝大家努力看到這邊，最後附上我的 [Github Repository](https://github.com/easylive1989/LittleFlowerBot)。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 3, 2025 3:27 PM",
      "id": "c983d0576de644aa94599960f24e0ec6",
      "type": "Medium",
      "tag": "C# / .NET",
      "filename": "架設小遊戲機器人（上） c983d0576de644aa94599960f24e0ec6.md"
    },
    {
      "title": "跳過 Widget 直接渲染畫面",
      "summary": "大家都知道 Flutter 是一套 UI 框架，透過 dart:ui 與底層 API 互動，最終呈現在手機螢幕上或接收點擊事件。使用的時候，都是透過已經定義好的 Widget 決定畫面，並不會直接與 dart:ui 互動。但是實際上，我們也是可以跳過 Widget，直接操作 dart:ui 的 AP...",
      "content": "大家都知道 Flutter 是一套 UI 框架，透過 dart:ui 與底層 API 互動，最終呈現在手機螢幕上或接收點擊事件。使用的時候，都是透過已經定義好的 Widget 決定畫面，並不會直接與 dart:ui 互動。但是實際上，我們也是可以跳過 Widget，直接操作 dart:ui 的 API 來幫我們畫出我們想樣的畫面\n\n![archdiagram.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/archdiagram.png)\n\n而 Widget、 Element、RenderObject 等等我們比較常互動的物件，則更多是讓我們更方面的使用 Flutter，讓我們可以輕鬆在畫面畫出想要的結果，而不用自己一筆一劃決定，也不需要自己決定何時重新渲染畫面。\n\n## 畫一個圓\n\n下面這段代碼直接操作 Picture、Scene、Window ...等物件，在畫面上畫出一個藍色的原型。\n\n1. 一開始創建了 PictureRecorder 與 Canvas，並利用 Paint 在 Canvas 上畫出一個圓，與在 CustomPainter 畫圖的做法相當類似。\n2. 當畫完之後，呼叫 PictureRecording.endRecording()，並取得一張 Picture\n3. 接著我們就能把這張 Picture 透過 SceneBuilder 放進 Scene 中\n4. 最後用 window 來這一幀的畫面\n\n```dart\nvoid main() {\n\tPictureRecorder recorder = PictureRecorder();\n  Canvas canvas = Canvas(recorder);\n\n  Paint circlePaint = Paint();\n  circlePaint.color = Colors.blue;\n  canvas.drawCircle(Offset(400, 400), 300, circlePaint);\n\n  Picture picture = recorder.endRecording();\n\n  SceneBuilder sceneBuilder = SceneBuilder();\n  sceneBuilder.addPicture(Offset(0, 0), picture);\n\n  Scene scene = sceneBuilder.build();\n  window.onDrawFrame = () {\n    window.render(scene);\n  };\n  window.scheduleFrame();\n}\n```\n\n當執行上面這段代碼後，我們在畫面上看到一個藍色圓形，向下方左圖一樣。同樣的方法也可以用來畫出向下方右圖那樣的複雜圖形。\n\n![Screenshot_20210926_173637.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/Screenshot_20210926_173637.png)\n\n![Screenshot_20210926_174545.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/Screenshot_20210926_174545.png)\n\n## 小結\n\n雖然我們可以直接使用 dart:ui 在畫面上直接作畫，但實際上在絕大多數的狀況下不會這麼做，目前我自己也想不到一樣狀況會需要這樣做。畢竟除了繪製，Flutter 實際上還做了許許多多事，不管是狀態管理或者是效能優化，透過 Widget、Element 和 RenderObject 去操作還是推薦的做法。\n\n## 參考\n\n- [https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/](https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/)",
      "createdAt": "September 26, 2021 9:25 AM",
      "updatedAt": "October 3, 2025 12:59 PM",
      "id": "3248bae84f984870bdc4d05b3dbc569e",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "跳過 Widget 直接渲染畫面 3248bae84f984870bdc4d05b3dbc569e.md"
    },
    {
      "title": "Widget Test的14種find方法",
      "summary": "上禮拜介紹了一個Widget Test所包含的流程，過程中用到Finder、Tester、和Matcher的部分方法...等，但是實際上這些元件都還有許多不同的操作，今天先介紹Finder的各種方法。 1. **text：**找到一個顯示特定字串的Text Widget     ```dart   ...",
      "content": "上禮拜介紹了一個Widget Test所包含的流程，過程中用到Finder、Tester、和Matcher的部分方法...等，但是實際上這些元件都還有許多不同的操作，今天先介紹Finder的各種方法。\n\n## find的方法們\n\n1. **text：**找到一個顯示特定字串的Text Widget\n    \n    ```dart\n    find.text(\"Hello World\");\n    ```\n    \n2. **textContaining**：找到一個顯示文字中包含特定字串的Text Widget\n    - 當文字可能不是固定字串時，例如：在一個棋局中顯示黑棋或白棋獲勝時，因為有可能會是\"Black Wins\"或\"White Wins\"，此時就會需要使用到textContaining做部分比較\n    \n    ```dart\n    find.textContaining(\"Wins\");\n    ```\n    \n    - 除了直接使用字串以外，也可使用正規表達式([RegExp](https://api.flutter.dev/flutter/dart-core/RegExp-class.html))來找尋\n    \n    ```dart\n    find.textContaining(RegExp(r\"Wins$\"));\n    ```\n    \n3. **widgetWithText**：找到一個包含特定字串Text Widget的Widget\n    - 假設有一個文字按鈕使用FlatButton，在FlatButton的child再放上Text，此時我們就可以用這個方法來找到FlatButton\n    \n    ```dart\n    find.widgetWithText(FlatButton, \"Hello World\")\n    ```\n    \n    - 以上面的例子來說，假設畫面中有兩個Widget包含Text(\"Hello World\")，一個是FlatButton，一個是Container，此時就會找到FlatButton，因為它符合第一個參數中的條件。\n    \n    ```dart\n    Column(\n    \tchildren: <Widget>[\n    \t\tFlatButton(\n    \t\t\tonPressed: _incrementCounter,\n    \t\t\tchild: Text(\"Hello World\"),\n    \t\t),      \n    \t\tContainer(\n    \t\t  child: Text(\"Hello World\"),\n    \t\t),\n    \t],\n    )\n    ```\n    \n4. **byKey**：找到一個符合Key值的Widget\n    \n    ```dart\n    find.byKey(ValueKey(\"First Hello World\"))\n    ```\n    \n    - 以上面的例子來說，假設有兩個一樣的Text，就能正確找到Key值符合的Widget\n    \n    ```dart\n    Column(\n    \tchildren: <Widget>[\n    \t\tText(\n    \t\t\t\"Increase\",\n    \t\t  key: ValueKey(\"First Hello World\"),\n    \t\t),\n    \t\tText(\n    \t\t\t\"Increase\",\n    \t\t),\n    \t],\n    )\n    ```\n    \n    ⇒ 如果是用UniqueKey這類的Key，因為無法在測試中產生一模一樣的Key，此時可以考慮使用其他find方法解決或者由外部注入Key的方式解決。\n    \n5. **byIcon：**找到一個Icon符合的Icon Widget\n    \n    ```dart\n    find.byIcon(Icons.add);\n    ```\n    \n6. **widgetWithIcon：**與widgetWithText類似，同樣是找到一個包含特定Icon Widget的Widget\n    \n    ```dart\n    find.widgetWithIcon(FlatButton, Icons.add);\n    ```\n    \n7. **byType**：找到一個類別符合的Widget\n    \n    ```dart\n    find.byType(FlatButton);\n    ```\n    \n8. **byWidget：**找到與傳入的Widget傳入Widget同一實例的Widget\n    \n    ```dart\n    find.byWidget(Text(\"Hello World\"))\n    ```\n    \n    - 假設我們想測試MyContainer是否有正常渲染child時，就可以使用byWidget找到預期的Widget並檢查\n    \n    ```dart\n    testWidgets('test my container', (WidgetTester tester) async {\n    \tvar text = Text(\"Hello World\");\n    \n      await tester.pumpWidget(\n        createTestingWidget(MyContainer(child: text)),\n      );\n    \n      await tester.pump();\n    \n      expect(find.byWidget(text), findsOneWidget);\n    });\n    ```\n    \n    ```dart\n    class MyContainer extends StatelessWidget {\n      final Widget child;\n    \n      MyContainer({this.child});\n    \n      @override\n      Widget build(BuildContext context) {\n        return Column(\n          children: [\n            Text(\"Header\"),\n            child,\n            Text(\"Footer\"),\n          ],\n        );\n      }\n    }\n    ```\n    \n9. **byWidgetPredicate：**找到一個符合predicate回傳true的Widget\n    - 參數是一個predicate方法，在方法中可以比較很多東西，例如類別或Widget中的資料，透過比較Widget中的屬性，並回傳boolean值表示這個widget是否是目標Widget，是一個十分泛用的方法\n    \n    ```dart\n    find.byWidgetPredicate(\n              (widget) => widget is Text && widget.data == \"Hello World\")\n    ```\n    \n10. **byTooltip：**找到符合message的[Tooltip](https://api.flutter.dev/flutter/material/Tooltip-class.html) Widget \n    \n    ```dart\n    find.byTooltip(\"Hello World\");\n    ```\n    \n    ⇒ 這個方法實際上是透過byWidgetPredicate實作的\n    \n11. **byElementType：**與byType相似，不同的這個方法會找的是符合類別的Element\n    \n    ```dart\n    find.byElementType(InheritedElement);\n    ```\n    \n12. **byElementPredicate：**與byWidgetPredicate相似，不同的是他的predicate參數傳入的是Element\n    - 這個方法可以用來比較Element中的屬性，例如自己做了一個MyCheckbox的StatefulWidget，就能用這個方法找出已選取的MyCheckbox\n    \n    ```dart\n    find.byElementPredicate((element) {\n    \tif(element is StatefulElement) {\n    \t  var state = element.state;\n        return state is MyCheckboxState && state.isChecked;\n      }\n      return false;\n    });\n    ```\n    \n    ```dart\n    class MyCheckbox extends StatefulWidget {\n    \n      @override\n      MyCheckboxState createState() => MyCheckboxState();\n    }\n    \n    class MyCheckboxState extends State<MyCheckbox> {\n      bool isChecked;\n    \n      @override\n      Widget build(BuildContext context) {\n        ...\n      }\n    }\n    ```\n    \n13. **ancestor：**在某個Widget的祖先中，找尋符合條件的Widget\n    - 從符合of參數的Widget開始往祖先找，直到找到符合matching參數的Widget，這兩個參數都可以使用前幾個find方法來決定條件\n    \n    ```dart\n    find.ancestor(of: find.byType(MyContainer), matching: find.byWidget(text));\n    ```\n    \n    ⇒ widgetWithText, widgetWithIcon也是用這個方法實作\n    \n14. **descendant：**在某個Widget的子孫中，找尋符合條件的Widget。\n    - 參數基本上與ancestor相似，只是搜尋的方向不同\n    \n    ```dart\n    find.descendant(of: find.byWidget(text), matching: find.byType(MyContainer));\n    ```\n    \n\n## **小結**\n\nFinder中有各式各樣的方法，在不同情境下使用不同的方法來找到想要的Widget，然後才能測試中正確的操作或驗證這些Widget，讓測試保護我們的產品代碼。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 3, 2025 12:05 AM",
      "id": "44325fd7e7ab4b4a93c1c06164398150",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "Widget Test的14種find方法 44325fd7e7ab4b4a93c1c06164398150.md"
    },
    {
      "title": "使用 bloc_test 進行單元測試",
      "summary": "Flutter 有需多狀態管理的套件，包括：Providerd、Redux, Bloc...等。如果想針對這些狀態管理套件寫測試，我們可以使用 test 套件。在寫 Bloc 的測試時，除了可以使用 test 套件之外，還可以使用 [bloc_test](https://pub.dev/packag...",
      "content": "Flutter 有需多狀態管理的套件，包括：Providerd、Redux, Bloc...等。如果想針對這些狀態管理套件寫測試，我們可以使用 test 套件。在寫 Bloc 的測試時，除了可以使用 test 套件之外，還可以使用 [bloc_test](https://pub.dev/packages/bloc_test/example)，今天就來介紹一下 [bloc_test](https://pub.dev/packages/bloc_test/example) 吧。\n\n假設有一個 CounterBloc 會維護 counter 的狀態，並且能送給它 CounterIncreased 的 event 來遞增counter\n\n```dart\nclass CounterBloc extends Bloc<CounterEvent, CounterState> {\n  CounterBloc() : super(CounterInitial(0));\n\n  @override\n  Stream<CounterState> mapEventToState(\n    CounterEvent event,\n  ) async* {\n    if(event is CounterIncreased) {\n      var newCount = state.count + 1;\n      yield CounterIncreasedSuccess(newCount);\n    }\n  }\n}\n```\n\n我們先用 [test](https://pub.dev/packages/test) 進行來針對這個 Bloc 測試，在測試之中依照單元測試3A：Arrange, Act, Assert 分成了三個部分，測試 CounterBloc 收到 CounterIncreased 能正常加一，並輸出 CounterIncreasedSuccess 的狀態\n\n```dart\ntest('counter increase', () {\n    var counterBloc = CounterBloc();\n\n    counterBloc.add(CounterIncreased());\n\n    expectLater(counterBloc.stream, emits(CounterIncreasedSuccess(1)));\n});\n```\n\n## 改寫成 bloc_test\n\n使用 bloc_test 提供的 blocTest 方法進行測試，blocTest 提供了 build, act , expect的接口，分別對應到上述的單元測試3A\n\n```dart\nblocTest<CounterBloc, CounterState>(\n    'counter increase',\n    build: () => CounterBloc(),\n    act: (bloc) => bloc.add(CounterIncreased()),\n    expect: () => [CounterIncreasedSuccess(1)],\n);\n```\n\n相對於使用 test 來測試，bloc_test 幫我們隱藏了一些不必要的細節，例如 [counterBloc.stream](http://counterbloc.stream) 和 emits() 這些與待測邏輯不相關的代碼。讓我們能更專注在 bloc 的操作與狀態驗證。\n\n## 一個 Event 產生多個狀態\n\n假設 counter increase 是一個複雜的功能且執行速度慢時，我們通常會需要一個 in progress 的狀態，UI 可以針對這個狀態來顯示 Loading 畫面，讓使用者知道操作正在執行。\n\n```dart\nclass CounterBloc extends Bloc<CounterEvent, CounterState> {\n  CounterBloc() : super(CounterInitial(0));\n\n  @override\n  Stream<CounterState> mapEventToState(\n    CounterEvent event,\n  ) async* {\n    if (event is CounterIncreased) {\n      yield CounterIncreaseInProgress(state.count);\n      var newCount = state.count + 1;\n      yield CounterIncreasedSuccess(newCount);\n    }\n  }\n}\n```\n\n當 CounterBloc 收到 CounterIncreased 時，會先輸出一個 CounterIncreaseInProgress 的狀態，當 CounterBloc 完成 counter 加一後，再次輸出 CounterIncreasedSuccess 的狀態。\n\n此時我們也需要針對測試進行修改，分別在 test 和 blocTest 的方法中增加 CounterIncreaseInProgress 的驗證。\n\n```dart\nblocTest<CounterBloc, CounterState>(\n    'counter increase',\n    build: () => CounterBloc(),\n    act: (bloc) => bloc.add(CounterIncreased()),\n    expect: () => [\n      CounterIncreaseInProgress(0),\n      CounterIncreasedSuccess(1),\n    ],\n);\n```\n\n## 非必要驗證的狀態\n\n好的測試代碼是包含跟待測邏輯相關的代碼，其他不相關的細節應該要盡量隱藏，讓測試意圖直接暴露測試方法中。而 in porgress 的狀態可能會頻繁出現在每個操作之中，我們可以針對驗證 in progess 狀態寫一個測試，但是如果每一個測試都需要驗證 in progress 的狀態就顯得多餘，而且容易混淆測試意圖。\n\n在驗證 counter increase 的測試中，我們可以透過 blocTest 中的忽略 in progress 狀態，藉此來凸顯我們的測試意圖\n\n```dart\nblocTest<CounterBloc, CounterState>(\n    'counter increase',\n    build: () => CounterBloc(),\n    act: (bloc) => bloc.add(CounterIncreased()),\n    expect: () => [\n      CounterIncreasedSuccess(1),\n    ],\n\t\tskip: 1,\n  );\n```\n\n## 小結\n\n使用 bloc_test 隱藏了一些不必要的細節，比起使用 test 來進行單元測試，bloc_test 增加了一些測試的可讀性，讓測試意圖可以更清晰，避免測試壞掉時，我們還要從一大堆細節中找出測試的目的是什麼。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 3, 2025 12:05 AM",
      "id": "e2e1fcbde1974b80ad40fd3674a7341a",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "使用 bloc_test 進行單元測試 e2e1fcbde1974b80ad40fd3674a7341a.md"
    },
    {
      "title": "在 Null safety mockito 使用 any",
      "summary": "前陣子 Google release了 Dart 2.12，加入 null safety 特性，不可避免地，升級過後的產品代碼需要進行一些調整，除此之外，測試代碼也必須進行相對應的調整。在測試之中，如果有使用 mockito 中的 any 來 mock 物件方法與回傳，可能會碰到像是下面這種 err...",
      "content": "前陣子 Google release了 Dart 2.12，加入 null safety 特性，不可避免地，升級過後的產品代碼需要進行一些調整，除此之外，測試代碼也必須進行相對應的調整。在測試之中，如果有使用 mockito 中的 any 來 mock 物件方法與回傳，可能會碰到像是下面這種 error。\n\n```dart\ntype 'Null' is not subtype of type 'your class type' of 'type'\n```\n\n為此，官方給出[解決辦法](https://github.com/dart-lang/mockito/blob/master/NULL_SAFETY_README.md#problems-with-typical-mocking-and-stubbing)，讓我們的測試可以繼續使用 any 來進行 mock。\n\n## 解決辦法\n\n1. 在 pubspec.yaml 加入 build_runner\n    \n    ```dart\n    dev_dependencies:\n      build_runner: ^1.10.0\n    ```\n    \n2. 在測試中加入 GenerateMock 這個 annotation，並傳入想要 mock 的類別\n    \n    ```dart\n    import 'package:mockito/annotations.dart';\n    \n    @GenerateMocks([UserApi])\n    void main() {\n    \t...\n    }\n    ```\n    \n3. 在專案目錄中執行 build_runner\n    \n    ```dart\n    flutter pub run build_runner build\n    ```\n    \n\n當做完成以上步驟後，會在測試目錄中看到一個 xxx_test.mock.dart 的 mock 檔案，在原本的測試中 import 這個 mock 檔案後，就可以不在需要自己宣告 mock 類別，並且也可再次使用 any 了。\n\n```dart\nimport 'package:mockito/annotations.dart';\n\n@GenerateMocks([UserApi])\nvoid main() {\n\ttest('my test', () {\n\t\tvar mockUserApi = MockUserApi();\n\t\twhen(mockUserApi.getProfile(any)).thenReturn(Profile());\n\n\t\t...\n\t});\n}\n```\n\n## 作法解釋\n\n以原本的 mockito 的做法，mock 類別實作了目標類別，在 nullable 環境中，可以正常的把 any 當成方法參數，但是在 null safety 的環境中，想把 any 傳入 non-nullable 的參數就會造成編譯問題，因為 any 實際回傳的是 null。為了解決這個問題，所以必須透過 build_runner 來產生 mock 檔，透過 build_runner 產生出來的 mock 類別會把原本 non-nullable 的參數拓展成 nullable，以支持傳入 any。\n\nbuild_runner 這個套件會去偵測 test 中的 @GenerateMock，並取得需要 mock 的目標類別，然後就自動產生對應的 mock 類別，最後在原本測試中引用產生出來的 mock 檔，就能像之前一樣的操作 mock 類別，與之前不同的是，不需要在自己宣告 mock 類別了。\n\n## 自行產生 Mock 類別\n\n除了使用 build_runner 來幫忙產生 mock 類別，其實也是可以自己寫，不一定要使用 build_runner來幫忙產生。當有兩個測試檔案都使用了相同的 mock 類別時，在兩個檔案分別用 GenerateMocks mock 一樣的類別時，build_runner 會產生兩個測試的 mock 檔 ，並包含一樣的 mock 類別，如果自己寫的話，可以使用一份共用的 mock 檔，讓測試代碼稍微乾淨一點。\n\n```dart\nclass MockUserApi extends Mock implements UserApi {\n  @override\n  void getProfile(int? userId) =>\n      super.noSuchMethod(Invocation.method(#getProfile, [userId]));\n}\n```\n\n## 更改預設 mock 類別名稱\n\n預設 mock 類別名稱是在原本的類別前面加上 Mock 的前綴，但是想要客製化名稱，則不能使用第一個參數，而是需要改使用 @GenerateMock 的 customMocks 參數。\n\n```dart\nimport 'package:mockito/annotations.dart';\n\n@GenerateMocks([], customMocks: [MockSpec<UserApi>(as: #OtherMockUserApi)])\nvoid main() {\n\t...\n}\n```\n\n## 小結\n\n整體來說，在 null safety 中用 mockito 來 mock 類別的作法還是跟之前差不多，多了一個步驟要使用 build_runner 來幫忙產生 mock 類別。如果自己實作 mock 類別的話，則是需要在 mock 的時候，針對 mock 方法多寫一些代碼。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 3, 2025 12:05 AM",
      "id": "4df501b643a04bb29c701f53db896d45",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "在 Null safety mockito 使用 any 4df501b643a04bb29c701f53db896d45.md"
    },
    {
      "title": "如何用 Github Action 建置 Flutter Android App",
      "summary": "手動建置與上傳 app 是一件滿麻煩的事情，在最理想的狀況下，我們希望當我們確保程式沒有問題之後，合併回主線就可以開始自動建置並上傳到 google play 上。為了達到這個目的，我使用 Github Action 來幫我建置 flutter app，今天就來分享一下我如何自動化這些麻煩事。 透過...",
      "content": "手動建置與上傳 app 是一件滿麻煩的事情，在最理想的狀況下，我們希望當我們確保程式沒有問題之後，合併回主線就可以開始自動建置並上傳到 google play 上。為了達到這個目的，我使用 Github Action 來幫我建置 flutter app，今天就來分享一下我如何自動化這些麻煩事。\n\n## 加入建置 Flutter 的 Step\n\n透過使用第三方的 action：[subosito/flutter-action](https://github.com/subosito/flutter-action)，我們就可以使用 flutter 的命令來建置 flutter app。\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-java@v1\n        with:\n          java-version: '12.x'\n \t  - uses: subosito/flutter-action@v1\n        with:\n          channel: 'stable'\n      - run: flutter pub get\n      - run: flutter test\n      - run: flutter build appbundle\n```\n\n當用這上面這段代碼去建置時，會發現因為缺少 keystore 檔案與 google-service.json 而建置失敗。這些檔案因為需要保密的緣故，所以並沒有上傳到 Github 的 repository 中。為此，我們必須想個辦法讓 Github 可以保存這些保密的檔案。\n\n## 保密 keystore 與 google-service.json\n\n由於這些 keystore 檔案和 google-service.json 裡面放著重要的資料，不能放在直接 git repository，以防被其他人拿到並盜用你的名義簽署 app 或者使用 google 服務。但是當你建構你的自動化 app 建置流程，這些檔案又是必不可少的，否則就會建置失敗。\n\n為了在 github 上保密這些資料，github 也向其他各式各樣的 CI 工具一樣，提供了 secret 讓我們可以放一些重要的資料，例如：DB 的連線字串、API 的 token ...等等。但是 secret 目前是提供以文字形式的方式儲存這些保密資料，所以我們必須把 keystore 檔案和 google-services.json 檔轉換成文字形式，然後才能放到 secret 中。\n\n1. 在 local 端把檔案轉換成 base64 的格式\n    \n    ```bash\n    openssl base64 -in your-input-file -out your-output-file\n    ```\n    \n2. 把轉換出來的 base64 文字加到 Github Secret 中，同時也把\n    \n    ![截圖 2021-08-15 下午1.47.30.png](%E5%A6%82%E4%BD%95%E7%94%A8%20Github%20Action%20%E5%BB%BA%E7%BD%AE%20Flutter%20Android%20App/%E6%88%AA%E5%9C%96_2021-08-15_%E4%B8%8B%E5%8D%881.47.30.png)\n    \n3. 把 base64 文字在 step 中轉回檔案，如此一來，建置時就能拿到這些重要檔案\n    \n    ```yaml\n    jobs:\n      build:\n        runs-on: ubuntu-latest\n        steps:\n    \t  ...\n    \t  - run: echo $ANDROID_KEY_STORE | base64 -di > android/app/key.jks\n      \t\tenv:\n        \t\tANDROID_KEY_STORE: ${{ secrets.ANDROID_KEY_STORE }}\n    \t  - run: echo $GOOGLE_SERVICE | base64 -di > android/app/google-services.jon\n      \t\tenv:\n        \t\tGOOGLE_SERVICE: ${{ secrets.GOOGLE_SERVICE }}\n    \t  ...\n    ```\n    \n\n## 保密其他重要資料\n\n除了 keystore 外，還有重要的資料，像是 store password, key password, key alias，我們也需要一起放進 secret 中，讓建置時可以從 secret 中拿到這些資料。\n\n![Pasted image 20210815142324.png](%E5%A6%82%E4%BD%95%E7%94%A8%20Github%20Action%20%E5%BB%BA%E7%BD%AE%20Flutter%20Android%20App/Pasted_image_20210815142324.png)\n\n修改 github action，在建置時把這些 secret 放進環境變數中\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      ...\n      - run: flutter build appbundle\n\t  \tenv:\n  \t\t  KEY_ALIAS: ${{ secrets.KEY_ALIAS }}\n  \t\t  KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}\n  \t\t  STORE_PASSWORD: ${{ secrets.STORE_PASSWORD }}\n\n```\n\n最後修改 build.gradle，build.gradle 從環境變數中使用這些資料。\n\n```\nsigningConfigs {\n\trelease {\n \t\tstoreFile = file(\"key.jks\")\n \t\tstorePassword System.getenv(\"STORE_PASSWORD\")\n \t\tkeyAlias System.getenv(\"KEY_ALIAS\")\n \t\tkeyPassword System.getenv(\"KEY_PASSWORD\")\n \t}\n}\n```\n\n當以上都做完之後，Github Action 就能正常的建置出 flutter android app 了。\n\n## 下載建置出來的 app\n\n當建置完成後，檔案實際上還是存在 Github Action 的 Runner 中。為了拿到最後建置出來的檔案，我們必須再加上一個 step，把檔案上傳到 artifact 中。這樣我們就在建置完成之後，就能從 Github 網頁上下載到剛剛建置的檔案。\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      ...\n\t  - name: upload appbundle\n  \t\tuses: actions/upload-artifact@v2\n  \t\twith:\n    \t  name: app bundle\n    \t  path: build/app/outputs/bundle/release/app-release.aab\n\n```\n\n## 下一步\n\n把 app 建置出來並放到 artifact 後，我們就能從 github 上下載到 app，把這個 app 上傳到 google play 的後台，讓 user 可以下載。可以發現後面我們還是需要手動上傳到 google play，為了也把這段自動化，我會在下一篇中紀錄如何把 app 自動上傳到 google play 上。\n\n## 參考\n\n- [完整的 workflow](https://github.com/easylive1989/LittleFlowerApp/blob/master/.github/workflows/build.yml)\n- [Github Action Doc](https://docs.github.com/en/actions/guides/storing-workflow-data-as-artifacts#uploading-build-and-test-artifacts)",
      "createdAt": "August 15, 2021 2:58 PM",
      "updatedAt": "October 3, 2025 12:05 AM",
      "id": "b95a311f7549498ca192c4dd9a4538e8",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "如何用 Github Action 建置 Flutter Android App b95a311f7549498ca192c4dd9a4538e8.md"
    },
    {
      "title": "如何自動上傳 apk / aab 到 Google Play Console",
      "summary": "延續[上一篇](https://easylive1989.medium.com/%E5%A6%82%E4%BD%95%E7%94%A8-github-action-%E5%BB%BA%E7%BD%AE-flutter-android-app-98211d894e07)展示了如何自動建置 app bu...",
      "content": "延續[上一篇](https://easylive1989.medium.com/%E5%A6%82%E4%BD%95%E7%94%A8-github-action-%E5%BB%BA%E7%BD%AE-flutter-android-app-98211d894e07)展示了如何自動建置 app bundle，這篇主要想記錄一下如何用 Google Play Developer Api 上傳 app bundle 到測試環境或生產環境。主要是利用 google 提供的 python 套件，搭配 Google Play Developer Api，完成上傳 app bundle 並調整釋出相關的設定。 \n\n## 第一步\n\n在開始使用 Api 之前，我們需要先取得 Api 的使用權限。從 Google Play Console 建立 Service Account，並授與相關權限，讓 script 可以存取 Google Play Developer API。\n\n![截圖_2021-08-22_下午4_20_21.png](%E5%A6%82%E4%BD%95%E8%87%AA%E5%8B%95%E4%B8%8A%E5%82%B3%20apk%20aab%20%E5%88%B0%20Google%20Play%20Console/%E6%88%AA%E5%9C%96_2021-08-22_%E4%B8%8B%E5%8D%884_20_21.png)\n\n在建立 Service Account 的過程中，需要給 Service Account User 這個 Role。最後再新增一個 json key 並下載，我們會在下一步透過這個 json key 存取 Google Play Developer Api。\n\n![截圖 2021-08-19 上午7.38.53.png](%E5%A6%82%E4%BD%95%E8%87%AA%E5%8B%95%E4%B8%8A%E5%82%B3%20apk%20aab%20%E5%88%B0%20Google%20Play%20Console/%E6%88%AA%E5%9C%96_2021-08-19_%E4%B8%8A%E5%8D%887.38.53.png)\n\n![截圖 2021-08-22 下午4.28.43.png](%E5%A6%82%E4%BD%95%E8%87%AA%E5%8B%95%E4%B8%8A%E5%82%B3%20apk%20aab%20%E5%88%B0%20Google%20Play%20Console/%E6%88%AA%E5%9C%96_2021-08-22_%E4%B8%8B%E5%8D%884.28.43.png)\n\n最後記得回到 Google Play Console 授予剛剛建立的 Account 存取權\n\n![截圖_2021-08-22_下午4_32_10.png](%E5%A6%82%E4%BD%95%E8%87%AA%E5%8B%95%E4%B8%8A%E5%82%B3%20apk%20aab%20%E5%88%B0%20Google%20Play%20Console/%E6%88%AA%E5%9C%96_2021-08-22_%E4%B8%8B%E5%8D%884_32_10.png)\n\n## 第二步\n\n取得 key.json 檔後，就可以開始寫上傳 app 的 script 了。\n\n### 安裝 python 套件\n\n```bash\npip install google-api-python-client\npip install oauth2client\n```\n\n### 建立 Service\n\n使用 ServiceAccountCredentials.from_json_keyfile_name() 並傳入剛剛下載的 json 建立 credential。最後組合用 google-api-python-client 傳入 credential 建立 service。\n\n```python\nimport httplib2\nfrom apiclient.discovery import build\nfrom oauth2client.service_account import ServiceAccountCredentials, client\n\ncredentials = ServiceAccountCredentials.from_json_keyfile_name(\n      'key.json',\n      scopes=['https://www.googleapis.com/auth/androidpublisher'])\nhttp = httplib2.Http()\nhttp = credentials.authorize(http)\n\nservice = build('androidpublisher', 'v3', http=http)\n```\n\n### 透過 Service 操作 Google Play Developer API 上傳 app bundle\n\n設定想操作的 package\n\n```python\nedit_request = service.edits().insert(body={}, packageName=\"com.example.your_app\")\nresult = edit_request.execute()\nedit_id = result['id']\n```\n\n上傳 app bundle\n\n```python\napk_response = service.edits().bundles().upload(\n    editId=edit_id, packageName=package_name, media_body=bundle_file).execute()\n```\n\n設定 Deploy 的狀態\n\n```python\ntrack_response = service.edits().tracks().update(\n    editId=edit_id,\n    track=track,\n    packageName=\"com.example.your_app\",\n    body={\n\t\t\t\tu'releases': [{\n\t\t        u'name': \"My First Release\",\n\t          u'versionCodes': [str(apk_response['versionCode'])],\n\t          u'status': u'completed',\n    }]}).execute()\n```\n\ntrack 參數有許多種選擇，需要根據需求調整，可以支援釋出到內部測試、Alpha 測試、Beta 測試、或生產環境，可以參考[這邊](https://developers.google.com/android-publisher/tracks)。\n\nstatus 參數也有許多種選擇，可以設定釋出給一定百分比的使用者，或直接開放給所有使用者下載，更詳細的設定可以參考[這邊](https://developers.google.com/android-publisher/api-ref/rest/v3/edits.tracks#Status)。\n\n完成所有步驟後，需要呼叫 commit，完成一系列的操作\n\n```python\ncommit_request = service.edits().commit(\n        editId=edit_id, packageName=\"com.example.your_app\").execute()\n```\n\n完整的程式請參考[這邊](https://github.com/easylive1989/LittleFlowerApp/blob/develop/script/deploy.py)\n\n## 更多操作\n\n上面展示的代碼是上傳 app bundle，如果想要上傳的是 apk，則需要使用 edits.apks 系列的 api。另外其他可以用的操作，像是下面這段代碼，可以取得已經上傳的 app bundle 列表。\n\n```python\nedit_request = service.edits().insert(body={}, packageName=package_name)\nresult = edit_request.execute()\nedit_id = result['id']\n\nbundles_result = service.edits().bundles().list(\n    editId=edit_id, packageName=package_name).execute()\n\nfor bundle in bundles_result['bundles']:\n  print ('versionCode: %s, binary.sha1: %s' % (\n      bundle['versionCode'], bundle['sha1']))\n```\n\n還有各式不一樣的 api ，像是修改測試人員的列表之類的，需要的朋友可以參考[這邊](https://developers.google.com/android-publisher/api-ref/rest)。\n\n## 參考\n\n- [googlesamples/android-play-publisher-api](https://github.com/googlesamples/android-play-publisher-api/tree/master/v3/python)\n- [Google Play Developer Api](https://developers.google.com/android-publisher/api-ref/rest)",
      "createdAt": "August 22, 2021 4:10 PM",
      "updatedAt": "October 3, 2025 12:05 AM",
      "id": "7e32ca98f06d463cae2fd83e57178d90",
      "type": "Medium",
      "tag": "Android",
      "filename": "如何自動上傳 apk aab 到 Google Play Console 7e32ca98f06d463cae2fd83e57178d90.md"
    },
    {
      "title": "初探Flutter Widget Test",
      "summary": "Flutter可以使用 [test](https://pub.dev/packages/test) 來幫助我們寫單元測試，透過單元測試來幫忙檢查我們的核心邏輯是否正確。在我們實作需求或者是重構代碼時，常常會修改到過去已經寫好的代碼，當我們改壞邏輯時時，單元測試也能發出警訊，提醒我們改動可能有問題。 ...",
      "content": "Flutter可以使用 [test](https://pub.dev/packages/test) 來幫助我們寫單元測試，透過單元測試來幫忙檢查我們的核心邏輯是否正確。在我們實作需求或者是重構代碼時，常常會修改到過去已經寫好的代碼，當我們改壞邏輯時時，單元測試也能發出警訊，提醒我們改動可能有問題。\n\nFlutter是個前端框架，需求常常是需要表現在畫面上，在這種情境中，我們比較難使用單元測試來驗證畫面是否正確，為了解決這個問題，我們可以使用Flutter提供的Widget Test來幫助我們寫一些可以驗證畫面的測試。\n\n## Counter Ｗidget範例\n\n當使用 flutter create 創建一個project，裡面會自帶一個counter範例。在這個範例中，畫面中央會有當前的counter，每當我們按下 + 按鈕後，counter就會加1，如下圖所示。\n\n![](%E5%88%9D%E6%8E%A2Flutter%20Widget%20Test/widget_test.png)\n\n## 第一個Widget Test\n\n在剛剛創建出來的flutter proejct中，裡頭也包含了一個Widget Test，測試的正是按下 ＋ 按鈕後並在畫面上把 0 變成 1 ，也就是這個範例的核心邏輯。\n\n```dart\nvoid main() {\n  testWidgets('Counter increments smoke test', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n  });\n}\n```\n\n在main中，testWidgets表示一個測試，第一個參數是測試敘述，第二個參數則是實際的測試內容。在這個測試內容中，呼叫pumpWidget來建立與渲染ＭyApp。\n\n```dart\nawait tester.pumpWidget(MyApp());\n```\n\n當MyApp建立起來之後，就可以使用find方法來幫助找到想要的Widget。透過 find.text()來找到畫面中的包含 0 和 1 文字的Widget，透過expect驗證結果是否符合預期。以這個範例來說，當MyApp剛開起來時，因為還沒點下 + 按鈕，所以畫面應該是 0 而不是 1，所以能夠使用find.text()找到一個 0 的 Text Widget，找不到 1 的Text Widget。\n\n```dart\nexpect(find.text('0'), findsOneWidget);\nexpect(find.text('1'), findsNothing);\n```\n\n同樣地，也能透過 find.byIcon()來找到icon widget，找到之後就能用tester.tap來按下它。除了find.text()與find.byIcon()，find中還提供各式各樣的方法來幫助我們容易的找到我們想要的Widget，例如：find.byKey()、find.byWidget()… 等。\n\n```dart\nawait tester.tap(find.byIcon(Icons.add));\n```\n\n在這邊值得一提的是Widget Test不會幫我們自動rebuild widget，所以按下 + 按鈕後，State裡頭的 _counter 已經成功變成 1 了，但是MyApp也不會把 1 顯示在畫面上，此時需要呼叫test.pump()來觸發rebuild。\n\n```dart\nawait tester.pump();\n```\n\n最後就是驗證畫面上存在包含 1 的Text Widget，而不是 0 的Text Widget\n\n```dart\nexpect(find.text('0'), findsNothing);\nexpect(find.text('1'), findsOneWidget);\n```\n\n## 複雜的情境\n\nCounter範例是一個簡單的情境，相對的我們要對他寫Widget Test也不會太過困難。但在實際的開發過程中，我們會碰到各式各樣的狀況，例如：如何隔離網路讓測試可以總是使用我們想要的資料測試，又或者是如何在畫面切換情境中測試。未來我會跟大家分享一些自己在實際情境中碰到的一些例子，與我的處理方式。\n\n## 結論\n\n單元測試可以幫我們驗證狀態是否符合預期，Widget Test則是可以幫我們驗證畫面是否符合預期。雖然Widget Test除了驗證畫面，也同時驗證了邏輯。但是並不代表我們可以用Widget Test取代單元測試，反而是我們應該要用Widget Test專注在畫面上的驗證，更多是關注在給定狀態後畫面是否符合預期，減少驗證邏輯上的變化，讓單元測試專注在測試核心邏輯上面，兩者應該是相輔相成。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 3, 2025 12:04 AM",
      "id": "3c907ffe50cd4a81b82b52ffb7d309ec",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "初探Flutter Widget Test 3c907ffe50cd4a81b82b52ffb7d309ec.md"
    },
    {
      "title": "在測試中使用 Fluent Interface",
      "summary": "寫單元測試的時候，我們常常會需要mock輸入資料，這其中有可能是從參數或者是相依物件傳入。而傳入資料結構也是各式各樣的，例如簡單的int, string到複雜的雙層Dictionary都是有可能的。 假設有一個翻譯機類別，建構子傳入翻譯文字，翻譯機則是負責接受輸入、檢查並輸出相對應的翻譯。 ```c...",
      "content": "寫單元測試的時候，我們常常會需要mock輸入資料，這其中有可能是從參數或者是相依物件傳入。而傳入資料結構也是各式各樣的，例如簡單的int, string到複雜的雙層Dictionary都是有可能的。\n\n假設有一個翻譯機類別，建構子傳入翻譯文字，翻譯機則是負責接受輸入、檢查並輸出相對應的翻譯。\n\n```csharp\npublic class Translator\n{\n    private readonly Dictionary<string, string> _translationLookup;\n\n    public Translator(Dictionary<string, string> translationLookup)\n    {\n        _translationLookup = translationLookup;\n    }\n    \n    public string Translate(string key)\n    {\n        if (!_translationLookup.ContainsKey(key))\n        {\n            throw new TranslationNotFoundException();\n        }\n        \n        return _translationLookup[key];\n    }\n}\n```\n\n針對Translate方法寫了一個單元測試\n\n```csharp\n[Test]\npublic void Correct_Translate_When_Translation_Exist()\n{\n    var translator = new Translator(new Dictionary<string, string>\n    {\n        {\"morning\",\"good morning\"},\n        {\"bye\", \"good bye\"}\n    });\n    Assert.AreEqual(\"good morning\", translator.Translate(\"morning\"));\n}\n```\n\n在這個情境很容易透過建構子設定測試輸入\n\n重構一下測試\n\n```csharp\npublic class Tests\n{\n    private Dictionary<string, string> _translationLookup;\n\n    [Test]\n    public void Correct_Translate_When_Translation_Exist()\n    {\n        GivenTranslationLookup(new Dictionary<string, string>\n        {\n            {\"morning\", \"good morning\"},\n            {\"bye\", \"good bye\"}\n        });\n        TranslationShouldBe(\"good morning\", \"morning\");\n    }\n\n    private void GivenTranslationLookup(Dictionary<string, string> translationLookup)\n    {\n        _translationLookup = translationLookup;\n    }\n\n    private void TranslationShouldBe(string expected, string key)\n    {\n        Assert.AreEqual(expected, new Translator(_translationLookup).Translate(key));\n    }\n}\n```\n\n假設今天Translator的商業邏輯更複雜一點，不只是翻譯，而是需要考慮多語系\n\n```csharp\npublic class Translator\n{\n    private readonly Dictionary<string, Dictionary<Language, string>> _translationLookup;\n\n    public Translator(Dictionary<string, Dictionary<Language, string>> translationLookup)\n    {\n        _translationLookup = translationLookup;\n    }\n    \n    public string Translate(string key, Language language)\n    {\n        if (!_translationLookup.ContainsKey(key))\n        {\n            throw new TranslationNotFoundException();\n        }\n        \n        if (!_translationLookup[key].ContainsKey(language))\n        {\n            throw new LanguageNotFoundException();\n        }\n        \n        return _translationLookup[key][language];\n    }\n}\n```\n\n此時測試入輸入就會變得很長一串，當中包含很多與測試邏輯本身沒有關係的new Dictionary<...>\n\n```csharp\npublic class Tests\n{\n    private Dictionary<string, Dictionary<Language, string>> _translationLookup;\n\n    [Test]\n    public void Correct_Translate_When_Translation_Exist()\n    {\n        GivenTranslationLookup(new Dictionary<string, Dictionary<Language, string>>\n        {\n            {\"morning\", new Dictionary<Language, string>()\n            {\n                {Language.EN, \"good morning\"},\n                {Language.ZH_TW, \"早安\"}\n            }},\n            {\"bye\", new Dictionary<Language, string>()\n            {\n                {Language.EN, \"good bye\"},\n                {Language.ZH_TW, \"再見\"}\n            }}\n        });\n        \n        TranslationShouldBe(\"good morning\", \"morning\", Language.EN);\n    }\n\n    private void GivenTranslationLookup(Dictionary<string, Dictionary<Language, string>> translationLookup)\n    {\n        _translationLookup = translationLookup;\n    }\n\n    private void TranslationShouldBe(string expected, string key, Language language)\n    {\n        Assert.AreEqual(expected, new Translator(_translationLookup).Translate(key, language));\n    }\n}\n```\n\n此時我們可以透過Fluent Interface來改善測試代碼的可讀性\n\n```csharp\npublic class Tests\n{\n    private Dictionary<string, Dictionary<Language, string>> _translationLookup;\n    private Dictionary<Language, string> _languageMap;\n\n    [SetUp]\n    public void SetUp()\n    {\n        _translationLookup = new Dictionary<string, Dictionary<Language, string>>();\n    }\n    \n    [Test]\n    public void Correct_Translate_When_Translation_Exist()\n    {\n        GivenKey(\"morning\")\n            .GivenTranslation(Language.EN,\"good morning\")\n            .GivenTranslation(Language.ZH_TW, \"早安\");\n        \n        GivenKey(\"bye\")\n            .GivenTranslation(Language.EN,\"good bye\")\n            .GivenTranslation(Language.ZH_TW, \"再見\");\n        \n        TranslationShouldBe(\"good morning\", \"morning\", Language.EN);\n    }\n\n    private Tests GivenKey(string key)\n    {\n        _languageMap = new Dictionary<Language, string>();\n        _translationLookup.Add(key, _languageMap);\n        return this;\n    }\n    \n    private Tests GivenTranslation(Language language, string translation)\n    {\n        _languageMap.Add(language, translation);\n        return this;\n    }\n\n    private void TranslationShouldBe(string expected, string key, Language language)\n    {\n        Assert.AreEqual(expected, new Translator(_translationLookup).Translate(key, language));\n    }\n}\n```",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 3, 2025 12:04 AM",
      "id": "3a966bd2ce1c4a4cb50da30e9b69b2b6",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "在測試中使用 Fluent Interface 3a966bd2ce1c4a4cb50da30e9b69b2b6.md"
    },
    {
      "title": "清理 IDE 給的提示",
      "summary": "現代的 IDE 很方便，當工程師編輯代碼時，IDE 會即時檢查代碼，並根據一些預設的規則，提示哪部分的代碼可能需要調整。不同的語言，不同的 IDE 提示狀況都不太一樣，但是或多或少都會有這個功能，提醒工程師可能要注意某段代碼是否有問題。 如果代碼總是穿插著不同顏色的提示，可能會讓工程師不想去處理這群...",
      "content": "現代的 IDE 很方便，當工程師編輯代碼時，IDE 會即時檢查代碼，並根據一些預設的規則，提示哪部分的代碼可能需要調整。不同的語言，不同的 IDE 提示狀況都不太一樣，但是或多或少都會有這個功能，提醒工程師可能要注意某段代碼是否有問題。\n\n## 到處都是的提示和警告\n\n如果代碼總是穿插著不同顏色的提示，可能會讓工程師不想去處理這群成堆的提示，也不在乎自己寫的代碼是否多了一條提示，形成破窗效應。每種提示和警告都有不同的意義，有些是提醒拼錯字，有些是提示代碼存在 Side Effect。如果放任這些提示與警告蔓延在代碼中，除了會讓代碼品質日益下降，甚至會讓工程師忽略掉真正潛在的危險。\n\n![](%E6%B8%85%E7%90%86%20IDE%20%E7%B5%A6%E7%9A%84%E6%8F%90%E7%A4%BA/sqknRNu.png)\n\n## 提示與警告的功用\n\n1. 提示不符合規則的寫法\n    - **拼字錯誤：**當變數名稱對不上某個英文單字時，IDE 就會提示你可能拼錯字。但是當單字是領域特有單字時，為了避免這種不必要的提示，就需要把這個單字加到 IDE 的預設字典中，讓提示可以認得這個單字。\n    - **語言的命名規則**，例如：以方法名稱為例，C# 預設方法名稱命名規則是開頭大寫的大駝峰命名法，而 Java 則是開頭小寫的小駝峰式命名法。當不符合這些規則時，IDE 就會提示你需要修改它。\n2. 更好的做法的提示\n    - 除了檢查拼字或命名規則，有些 IDE 還會建議更好的做法，例如：在 Rider 中，如果寫了下面這段代碼，一段由 for 處理的邏輯\n        \n        ```dart\n        var duplicateCount = 0;\n        foreach (var entry in cnt)\n        {\n            if (entry.Value > 1) duplicateCount++;\n        }\n        \n        return duplicateCount;\n        ```\n        \n        Rider 就會在 foreach 的部分提示使用 LINQ 改寫\n        \n        ```csharp\n        cnt.Count(entry => entry.Value > 1);\n        ```\n        \n        大多時候仔細閱讀這類型的提示，可以了解到什麼是更好的做法。尤其當自己是初學者的時候，這些提示都能幫助自己更好的了解這個語言的一些特性。\n        \n3. 潛在的風險的警告\n    - 有些時候，工程師可能寫出一寫有 Side Effect 的代碼，寫的時候沒有，以下面這段 C# 代碼為例，IDE 就提示了 gameResults 有重複執行多次的可能性，如果今天傳入這個方法的參數不是 List，而是 LINQ，就會導致 gameResults 跑了兩次迴圈，計算的卻是相同的東西。\n    \n    ![](%E6%B8%85%E7%90%86%20IDE%20%E7%B5%A6%E7%9A%84%E6%8F%90%E7%A4%BA/CrCrOw8.png)\n    \n\n## **團隊特有的規則**\n\n這些提示都是根據每個語言的預設規則提示的，只要代碼不符合規則，IDE就會在代碼下方標註。但是有一種情況是開發團隊有自己一套規則，以 C# 為例，有些團隊習慣宣告變數時使用確定型別，讓閱讀代碼的人可以清楚知道這個變數是什麼型別。但是 IDE 會提示使用 var，因為 C# 能夠透過型別論來推斷變數型別，所以預設規則傾向於用更簡潔的寫法。\n\n```csharp\nCustomer customer = customerApi.Get(id);\n```\n\n在這種情況，就會產生團隊規則與 IDE 規則不同，導致代碼上出現不必要的提示。這時我們不應該放任警告與提示的存在畫面上，而是應該去調整自己的 IDE 設定，讓 IDE 不要因為這些命名規則持續地跳出警告。\n\n## 小結\n\n保持代碼沒有任何提示與警告，沒有無謂的波浪線與虛線，能讓閱讀代碼時能更專注，也能在真正需要的時候，讓 IDE 來提示你。除此之外，團隊的規則應該凌駕於所有寫法之上，畢竟代碼是團隊的，共同的寫法更是團隊協作的基礎，基本上除了可能造成 Side Effect 的提示之外，剩下的寫法優先度應該是以團隊共識為優先。\n\n## 題外話\n\n這篇原本是在鐵人賽的時候寫的，那是我第一次比較有系統地寫文章，也寫的比較倉促，所而有些凌亂。發在 Medium 的這篇則是整理一下原文，調整架構，並加上更多解釋。未來其他我覺得比較有意義文章整理到 Medium 這邊。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 3, 2025 12:01 AM",
      "id": "3471f9df45444649a98266ce3842f52e",
      "type": "Medium",
      "tag": "軟體開發",
      "filename": "清理 IDE 給的提示 3471f9df45444649a98266ce3842f52e.md"
    },
    {
      "title": "Clean Architecture 讀後感",
      "summary": "Uncle Bob在2017年寫了Clean Architecture，在2018年博碩也出版了中文翻譯版，自己也趁著公司同事在團購時也一起入手了一本，但是自己卻沒在收到的時候馬上來讀，反而是最近才出來看。書一開始從語言設計的歷史開始講起，講述SOLID和元件，此時還不是很清楚這一切與架構關係，到後...",
      "content": "Uncle Bob在2017年寫了Clean Architecture，在2018年博碩也出版了中文翻譯版，自己也趁著公司同事在團購時也一起入手了一本，但是自己卻沒在收到的時候馬上來讀，反而是最近才出來看。書一開始從語言設計的歷史開始講起，講述SOLID和元件，此時還不是很清楚這一切與架構關係，到後來談架構時才把一切串了起來，看完有一種任督二脈被打通的感覺。\n\n## SOLID\n\n學寫Web Api的時候，會拆分Controller、Service、Repository、Model...等，會分別把Request/Response的轉換放在Controller中，Service/Model則是專注於處理商業邏輯，而Repository則是從DB取資料...等，在看這本書以前都會覺得拆分這幾個Component是為了**單一職責**，讓不同的物件專注於處理各自的職責。\n\n除了單一職責之外，其實還有一個很重要原因：**依賴反轉 →** 高層次的模組不依賴於低層次的模組的實現細節。書中把這架構分成了四類元件，一圈一類元件，外層相依於裡層，最裡層也是最高層次的元件則不相依於任何元件，通常也是最核心的商業邏輯，最外層也最細節的元件則相依於裡層的元件，通常就是處理Request/Response或是操作DB的代碼。\n\n![](Clean%20Architecture%20%E8%AE%80%E5%BE%8C%E6%84%9F/1_O4pMWCi5kZi20SNOR6V33Q.png)\n\n商業邏輯可能會關心資料會不會被儲存，但是通常不關心資料如何被儲存，比如是存在DB或存在Memory裡。DbRepository需要知道哪些資料要被儲存，所以DbRepository會依賴於Use Cases或Entities，但是Use Cases則是不需要依賴於DbRepository，而是依賴於介面，讓外層的DbRepository去實作這個介面。\n\n同樣的，商業邏輯可能會關心哪些資料是要給User看，但是不關心資料如何顯示給User，有可能是透過GUI顯示給User，也有可能是透過Web Api傳出去。所以ApiController會需要知道裏層，但是裏層的商業邏輯卻不需要知道Response是如何包裝這些資料。\n\n當架構遵循著依賴反轉的原則在設計時，什麼功能的代碼要寫在哪一層就清楚了許多，這麼做的好處是當外層改動的時候不容易影響內層，代碼就比較不容易因為畫面一改，然後牽一髮而動全身。越內層元件改動的時候，則是會很大層度影響外層元件，這也表示最核心的商業邏輯改動了，所有東西包括使用者操作行為和畫面都得跟著改動。\n\n## 讓測試變好寫了\n\n越內層的元件也扮演著越重要的商業邏輯，也越需要為它寫單元測試，因為我們希望在未來新增需求或重構的時候，單元測試能即時幫我們檢測到這些邏輯是否被改壞，又剛好內層的元件相依較少，也讓單元測試變得好寫了，我們不需要Fake一大堆底層的細節，不需要Fake某個DbRepository或Request/Respone，所以越內層的元件可測試性也越高。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 2, 2025 11:59 PM",
      "id": "1566c8d2bd7d4bc1a4a6d73483151ebd",
      "type": "Medium",
      "tag": "軟體開發",
      "filename": "Clean Architecture 讀後感 1566c8d2bd7d4bc1a4a6d73483151ebd.md"
    },
    {
      "title": "Rename 也會造成 Issue",
      "summary": "今天稍微紀錄一下自己重構Side Project踩坑的過程，因為重構導致application系統狀態不正確而一直噴error。 這一段[重構](https://github.com/easylive1989/LittleFlowerBot/commit/fb2a76b6e3b8201ea02a04...",
      "content": "今天稍微紀錄一下自己重構Side Project踩坑的過程，因為重構導致application系統狀態不正確而一直噴error。\n\n## 出問題的commit\n\n這一段[重構](https://github.com/easylive1989/LittleFlowerBot/commit/fb2a76b6e3b8201ea02a04a1f38de6fc570838cf)主要是把KiPlayerMap重新命名成PlayerMap\n\n![](Rename%20%E4%B9%9F%E6%9C%83%E9%80%A0%E6%88%90%20Issue/_2021-02-14_3.10.17.png)\n\n這是一段單純的重構，也是透過Rider的重構工具幫忙Rename的，但是還是造成了問題，為什麼呢？\n\n## 發生原因\n\n這個被Rename的field是放在GameBoard物件中，而GameBoard本身的所有field都是用來儲存一盤五子棋局的狀態，例如：Player A拿黑棋、棋盤上現在有哪些棋子...等等。\n\n![](Rename%20%E4%B9%9F%E6%9C%83%E9%80%A0%E6%88%90%20Issue/_2021-02-14_3.42.48.png)\n\n當玩家做了一些走了一步棋，application就會改變GameBoard的狀態並把它存回Redis中。儲存的過程中，application會用[BinaryFormatter](https://docs.microsoft.com/zh-tw/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=net-5.0)把GameBoard轉成byte array並使用StackExchangeRedis寫回Redis中。相反的，拿出來的過程也是把byte array讀回application中並轉回GameBoard。\n\n![](Rename%20%E4%B9%9F%E6%9C%83%E9%80%A0%E6%88%90%20Issue/_2021-02-14_3.45.55.png)\n\n然而問題就發生在byte array與GameBoard的轉換過程中，因為Rename，導致原本已經存在Redis中的資料無法正常被讀回。被Rename那個field無法正常被讀回並變成null，程式繼續執行下去就會發生問題。\n\n![](Rename%20%E4%B9%9F%E6%9C%83%E9%80%A0%E6%88%90%20Issue/_2021-02-14_4.06.19.png)\n\n## 壞的設計\n\n這個問題發生主要是因為把資料原封不動的存起來，不止變數的值，甚至是類別的名稱和變數的名稱，這就導致application與redis直接耦合。像是Rename或者move field等重構手法就無法使用在這些DTO中。\n\n還有其他相似的問題，例如：把Enumeration直接用string的形式存在db，而不是用int，這也會造成Rename Enumeration上的不方便。\n\n我們應該要把狀態的值存在db或redis，但是不應該把application的變數名稱也存在db中，因為這會造成application與db直接耦合。當需求發生變化時，要不是造成產品問題，就是改動很耗費時間。\n\n## 如何改進設計\n\n以上面的例子來說，應該要把GameBoard把轉成Json並儲存，這種做法能解開application的變數名稱與db的欄位名稱的耦合。雖然還是有一些缺點，但比起application與db的相依來說，以這一些代價換來application的彈性，算是很划算的。\n\n- 優點：當有rename或改架構時，可以透過attribute來指定對應的欄位名稱\n- 缺點：預設json序列化只會序列化public屬性，如果需要有non-public屬性就只能自己客製化序列化的rule，\n\n![](Rename%20%E4%B9%9F%E6%9C%83%E9%80%A0%E6%88%90%20Issue/_2021-02-14_4.35.20.png)\n\n## 小結\n\n最近在重構自己的Side Project專案時，意外遇到了這個bug，也讓自己對設計有重新思考的機會。在實作需求時，很多時候都是這樣寫也可以，那樣寫也可以，不管是哪一種寫法都有他的優缺點，如果能在這些時候多想一些作法，多比較一下優缺點，就能讓我們的代碼更乾淨，也更少bug。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 2, 2025 11:59 PM",
      "id": "19160f8d93b0475e90a493b6ec76bc78",
      "type": "Medium",
      "tag": "軟體開發",
      "filename": "Rename 也會造成 Issue 19160f8d93b0475e90a493b6ec76bc78.md"
    },
    {
      "title": "利用 Notion API 自動更新欄位",
      "summary": "由於 Notion 有各式各樣的 template，以及十分強大資料庫功能，我自己習慣用它來管理 side project 狀況、筆記和各種事情。再加上最近上了 [Notion 實戰課程：打造專屬數位工作術](https://hahow.in/courses/6059aee039f2512548c1...",
      "content": "由於 Notion 有各式各樣的 template，以及十分強大資料庫功能，我自己習慣用它來管理 side project 狀況、筆記和各種事情。再加上最近上了 [Notion 實戰課程：打造專屬數位工作術](https://hahow.in/courses/6059aee039f2512548c187c6/main?item=606f317b12f65e2269207344) ，學到了很多新的技巧，這次就結合學到技巧再加上 Notion API 來完成一些只有 Notion 本身做不到的事情。\n\n因為自己本身有寫筆記的習慣，學到了一些新的知識、看了一些書、或者紀錄一些實戰的技巧時，我就會把這些知識記錄下來寫成筆記，甚至是分享到部落格中。我也運用課程中所學的，把筆記依照領域分門別類，並另用另一個資料庫來設定領域，把筆記和領域關聯起來。\n\n## 筆記資料庫設計\n\n以我自己的情況為例，我有一個筆記資料庫，在這資料庫中，每個筆記都會關聯到一個領域。在領域的資料庫中則是會統計該領域有多少筆記，還有該領域的筆記數量的百分比：**領域筆記數量 / 總筆記數量**，自己藉由筆記數量的百分比來了解自己的知識組成，也能看出自己在哪些領域相對比較有心得，下圖是我簡化過的範例。\n\n![](%E5%88%A9%E7%94%A8%20Notion%20API%20%E8%87%AA%E5%8B%95%E6%9B%B4%E6%96%B0%E6%AC%84%E4%BD%8D/_2021-07-05_8.42.16.png)\n\n![](%E5%88%A9%E7%94%A8%20Notion%20API%20%E8%87%AA%E5%8B%95%E6%9B%B4%E6%96%B0%E6%AC%84%E4%BD%8D/_2021-07-05_8.48.51.png)\n\n在製作**筆記數量百分比**這個欄位時，我遇到了一個困難，那就是無法取得**總筆記數量。**雖然 Notion 有 Formula 可以根據多個欄位值來計算一些結果，但是 Formula 卻無法取得欄位總和數量。為了解決這個困擾，我想到利用腳本搭配 Notion API 來幫我更新這個欄位。 \n\n## 腳本呼叫 Notion API\n\n在腳本撰寫的部分，我選用 python 來做，但其實這個部分使用 shell script、javascript、甚至是 C# 也都是可以的，只能是能呼叫 Notion API 的任何方式都可以。在開始寫腳本之前，我們需要到 [Notion Integrations](https://www.notion.so/my-integrations) 建立一個 instance，並取得呼叫 API 需要使用到的 Token。\n\n取得 Token 之後，就可以開始寫腳本來更新**筆記數量百分比**了，整個腳本可以分成三個部分。\n\n1. ，取得領域資料庫中的的關聯筆記數量與筆記 ID\n    - 在這個步驟，我們可以利用 Notion API 的 [Query a database](https://developers.notion.com/reference/post-database-query) 取得資料庫中的資料。在開始打 API 之前需要注意的是，**領域資料庫**和**筆記資料庫**都需要 Invite 剛剛建立的 Notion Integration，讓這個 Integration 有權限可以存取，否則會呼叫 API 會發生錯誤。\n        \n        ![](%E5%88%A9%E7%94%A8%20Notion%20API%20%E8%87%AA%E5%8B%95%E6%9B%B4%E6%96%B0%E6%AC%84%E4%BD%8D/_2021-07-05_9.05.46.png)\n        \n2. 計算筆記數量百分比\n    - 在這個步驟需要讀取每一筆資料中的筆記數量，藉此計算所有筆記數量。值得一提的是 Notion 中的 rollup 欄位並不會出現在 API 中，因為這個欄位實際上是 Client 端計算的。像是領域資料庫中的筆記數量欄位屬性就是 rollup，但是實際上呼叫 API 後，回傳的資料中卻沒有這個欄位。\n3. 更新領域資料庫中的**筆記數量百分比**\n    - 在 Notion 中，資料庫的每一筆資料也是一個 page，所以我們可以使用 [Update page properties](https://developers.notion.com/reference/patch-page) 這個 API 來更新資料，透過第一個步驟中取得的筆記 ID 來更新相對應的筆記中的**筆記數量百分比**。Notion 目前似乎還不提供一次更新多個 page 的 API，所以在這個步驟中，我們只能一筆一筆資料更新。\n\n另外，我自己使用 python requests 呼叫 Notion API，但是已經有其他人把 Notion API 操作包成一個 python module：[notion-py](https://github.com/jamalex/notion-py) 讓 Notion 操作更容易，有興趣的人也可以試試看。\n\n## 用 Github Action 來定期更新\n\n完成上面的步驟後我們會得到一個可以更新的腳本，手動執行就可以更新**筆記數量百分比**，但是如果每次新增筆記都要自己手動執行一次就變得有點麻煩，而且容易忘記。為了解決這個問題，我利用 GIthub Action 的定期觸發的功能來幫我每天更新。\n\n![](%E5%88%A9%E7%94%A8%20Notion%20API%20%E8%87%AA%E5%8B%95%E6%9B%B4%E6%96%B0%E6%AC%84%E4%BD%8D/_2021-07-05_9.15.47.png)\n\n不過值得注意的是，Github Action 的定期觸發功能並不保證時間一到就馬上觸發，可能會因為 Github 自己的資源狀況而有所延遲，如果想拿來做即時觸發的應用，可能需要三思。\n\n## 小結\n\n在上課之前，本身就有在使用 Notion，也有做一些知識管理的簡單系統，但是怎麼用好像都有點不方便。上課之後學到了許多 Notion 上面的技巧，也實際應用在自己的管理系統中，感覺好像比較順暢一點，目前也還在逐步地調整當中。但是只透過 Notion 本身提供的功能，有時候會達不到自己想要的目的，透過 Notion API，我們就能夠隨意讀取資料庫中的資料，用這些資料來完成很多原本做不到的事情。\n\n## 相關資料\n\n- Notion API：[https://developers.notion.com/reference/intro](https://developers.notion.com/reference/intro)\n- Github Action Workflow：[https://docs.github.com/en/actions/reference/events-that-trigger-workflows](https://docs.github.com/en/actions/reference/events-that-trigger-workflows)\n- Notion Integration：[https://www.notion.so/my-integrations](https://www.notion.so/my-integrations)\n- 我的 Github Project：[https://github.com/easylive1989/notion_cron_job](https://github.com/easylive1989/notion_cron_job)\n\n## 範例\n\n[領域](%E5%88%A9%E7%94%A8%20Notion%20API%20%E8%87%AA%E5%8B%95%E6%9B%B4%E6%96%B0%E6%AC%84%E4%BD%8D/%E9%A0%98%E5%9F%9F%203097759c7e6643cfbd7d21cab678b9ed.csv)\n\n[我的筆記](%E5%88%A9%E7%94%A8%20Notion%20API%20%E8%87%AA%E5%8B%95%E6%9B%B4%E6%96%B0%E6%AC%84%E4%BD%8D/%E6%88%91%E7%9A%84%E7%AD%86%E8%A8%98%2091803de06daa499686c45070aeafc5a0.csv)",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 2, 2025 11:59 PM",
      "id": "c177a2eb6d274aa3a826d105408cc160",
      "type": "Medium",
      "tag": "Notion",
      "filename": "利用 Notion API 自動更新欄位 c177a2eb6d274aa3a826d105408cc160.md"
    },
    {
      "title": "改善迴圈的可讀性（一）",
      "summary": "不管是練習寫Kata或者是工作中，迴圈都是最常使用的語法之一。而在迴圈中很常出現一種Aggregation Pattern，例如：合計集合中的所有數字。 這種Pattern會大量的存在產品代碼中，雖然這些代碼行數通常不會太多，但是每次閱讀到都需要重新理解的話，就會顯得有點浪費時間。花些時間讓這些代碼...",
      "content": "不管是練習寫Kata或者是工作中，迴圈都是最常使用的語法之一。而在迴圈中很常出現一種Aggregation Pattern，例如：合計集合中的所有數字。\n\n這種Pattern會大量的存在產品代碼中，雖然這些代碼行數通常不會太多，但是每次閱讀到都需要重新理解的話，就會顯得有點浪費時間。花些時間讓這些代碼更簡潔，更具可讀性是十分值得。\n\n## 簡單的情境\n\n例如下面這段代碼：合計集合中的所有數字，最容易想到的作法就是利用一個變數暫存合計數值，等到迴圈跑完就能得到所有數字的合計值。\n\n```csharp\nint sum = 0;\nfor (int i = 0; i < numbers.Length; i++) \n{\n\t\tsum += numbers[i];\n}\n```\n\n若是對語言或框架比較熟悉的人，可能就會用一些語言或框架提供的Aggregation方法來簡化代碼。例如：C#有Linq的Sum()能用，或者是Dart也有reduce()可以用。\n\n```csharp\nnumbers.Sum(); // C#\n\nnumbers.reduce((acc, number) => acc + number); //Dart\n```\n\n## 稍微複雜一點\n\n假設今天使用情境不是數字集合，而是物件集合，C#能透過Linq的Aggregate()、Dart也能使用fold()來簡化。例如要把一個產品訂單集合合併成一個購物車物件，把所有Order的屬性總和到ShoppingCart的屬性中。\n\n```csharp\norders.Aggregate(new ShoppingCart(), (shoppingCart, order) {\n\t\tshoppingCart.TotalPrice += order.Price;\n\t\tshoppingCart.OrderIds.Add(order.Id);\n\t\t...\n}); // C#\n\n```\n\n```dart\norders.fold(ShoppingCart(), (shoppingCart, order) {\n\t\tshoppingCart.totalPrice += order.price;\n\t\tshoppingCart.orderIds.add(order.id);\n\t\t...\n}); // Dart\n```\n\n利用語言提供的Aggregation方法來簡化代碼能滿有效的增加可讀性，一看到Aggregation方法就會知道這段代碼是要累計某些東西。上面這兩個例子中都是比較容易利用語言的Aggregation方法來簡化寫法。\n\n## 更多變的情境\n\n在實際產品代碼中，有一些情境讓人比較難想到可以使用Aggregation方法，還有另外一些情境則是不容易用Aggregation方法處理，下禮拜我會在整理這些情境並分享給大家，感謝大家耐心閱讀到這邊🤤。\n\n## 相關連結\n\n- [https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/supported-and-unsupported-linq-methods-linq-to-entities?redirectedfrom=MSDN](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/supported-and-unsupported-linq-methods-linq-to-entities?redirectedfrom=MSDN)\n- [https://api.dart.dev/stable/2.10.4/dart-core/List-class.html](https://api.dart.dev/stable/2.10.4/dart-core/List-class.html)",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 2, 2025 11:59 PM",
      "id": "69b4aa1a13df436794b511e5afe91f43",
      "type": "Medium",
      "tag": "軟體開發",
      "filename": "改善迴圈的可讀性（一） 69b4aa1a13df436794b511e5afe91f43.md"
    },
    {
      "title": "改善迴圈的可讀性（二）",
      "summary": "在一些迴圈使用情境，我們比較難使用Aggregation方法來簡化。有一種使用情境是需要透過暫存變數來保存每一輪的狀態，並帶到下一輪計算，此時就會讓代碼變得複雜。 在下面這段[Josephus Survivor](https://www.codewars.com/kata/555624b601231...",
      "content": "在一些迴圈使用情境，我們比較難使用Aggregation方法來簡化。有一種使用情境是需要透過暫存變數來保存每一輪的狀態，並帶到下一輪計算，此時就會讓代碼變得複雜。\n\n## 舉個例子\n\n在下面這段[Josephus Survivor](https://www.codewars.com/kata/555624b601231dc7a400017a/)的Kata例子中，迴圈中會計算每一輪要移除受害者的位置，並把倖存者帶進下一輪迴圈中計算並找出下一輪的受害者。每一輪的迴圈中都需要把上一個受害者的位址紀錄在start裡。\n\n```csharp\npublic int Play(int count, int step)\n{\n    var candidates = Enumerable.Range(1, count).ToList();\n\n    int start = 0;\n    while (!HasSurvivor(candidates))\n    {\n        var victim = FindVictim(step, start, candidates);\n        candidates = NextCandidates(candidates, victim);\n        start = victim;\n    }\n\n    return candidates.First();\n}\n```\n\n此時可以發現迴圈中的代碼雖然不多，卻也不好理解。在這個例子中，start不只是最一開始的初始位置，而是迴圈中的每一輪的初始位置，這個資訊必須要來回反覆的閱讀才能夠理解。\n\n在累加數字的例子中，sum也是相似的情境，sum表示在每一輪迴圈中的暫時合計值。但是我們可以透過Aggregation方法讓sum這個暫存變數消失。與sum不同的是，start無法使用Aggregation方法簡化。\n\n雖然無法使用Aggregation方法，但是我們可以使用**遞迴**來隱藏start。\n\n```csharp\npublic int Play(int count, int step)\n{\n    var candidates = Enumerable.Range(1, count).ToList();\n\n    return FindSurvivor(candidates, 0, step);\n}\n\nprivate int FindSurvivor(List<int> candidates, int start, int step)\n{\n    if (HasSurvivor(candidates))\n    {\n        return candidates.First();\n    }\n\n    var victim = FindVictim(start, step, candidates.Count());\n\t\tvar nextCandiates = NextCandidates(candidates, victim);\n    return FindSurvivor(nextCandidates, victim, step);\n}\n```\n\n當透過遞迴來重構這個例子中，我們可消去迴圈並把start隱藏在參數中，並且只表示初始位址這個意義，讓代碼更容易閱讀。\n\n## 實際情況...\n\n在實際情況中，這種使用情境並不常見，多數是在演算法的情境下會比較常使用到，例如：在Quick Sort演算法中紀錄pivot、在多個商品與多種打折策略中計算最優惠的折扣組合。\n\n---\n\n迴圈最常使用到的語法之一，用起來也相當的容易，但是要如何寫得讓人容易理解，就不是一件容易的事情。所幸的是很多語言都支援好用的Aggregation方法，讓我們更容易從把一些常見的迴圈形式簡化，使代碼更專注在其職責，而不是迴圈本身。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 2, 2025 11:59 PM",
      "id": "ff23b70b497448d7addaae55200ed3af",
      "type": "Medium",
      "tag": "軟體開發",
      "filename": "改善迴圈的可讀性（二） ff23b70b497448d7addaae55200ed3af.md"
    },
    {
      "title": "用 Espresso 測試 Android (一)",
      "summary": "Add the following dependency to app/build.gradle ``` androidTestCompile 'com.android.support.test.espresso:espresso-core:3.0.1' ``` Espresso提供了十分簡潔的AP...",
      "content": "# **Import Espresso**\n\nAdd the following dependency to app/build.gradle\n\n```\nandroidTestCompile 'com.android.support.test.espresso:espresso-core:3.0.1'\n```\n\n# **Espresso Basic Usage**\n\nEspresso提供了十分簡潔的API，幾乎是一行程式碼就能代表一個UI操作。\n\n假設我們有一個id為R.id.button的Button與R.id.text的TextView。當Button被按下時，TextView會顯示Hello World。我們可以針對這個功能寫一個簡單的測試。\n\n```\n//按下 R.id.button\nonView(withId(R.id.button)).perform(click());\n\n//確認 R.id.text上顯示Hello World\nonView(withId(R.id.text)).check(matches(withText(\"Hello World\")));\n```\n\n觀察上面的例子，我們發現程式碼可以分成三個部分 :\n\n## **1. Find a View :**\n\n```\nonView(withId(R.id.button)).perform(click());\n```\n\n透過onView(Matcher<View>)找到一個ViewInteraction。之後我們便可以透過ViewInteraction去操作這個View或者是Check他的狀態。\n\n我們在找View時，可以透過許多方式去獲得一個唯一的View，例如:\n\n- withId(int)指定Resource id\n- withText(String)指定View中的文字\n\n## **2. Perform a Action**\n\n```\nonView(with(R.id.button)).perform(click());\n```\n\n找到View對應的ViewInteraction之後，透過ViewInteraction.perform(ViewAction)去操作View，例如 :\n\n- click()模擬點擊View\n- typeText(String)模擬輸入文字到View上\n- scrollTo()模擬滑動螢幕直到View出現\n\n## **3. Check**\n\n```\nonView(withId(R.id.text)).check(matches(withText(\"Hello World\")));\n```\n\n當我們模擬了一系列的UI操作之後，我們就得確認App的UI是否如我們預期。透過ViewInteraction.check(matches(Matcher<? **super** View>))，我們便可以驗證UI的狀態。\n\n## **Reference**\n\n1. [https://developer.android.com/training/testing/espresso/index.html](https://developer.android.com/training/testing/espresso/index.html)",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 2, 2025 11:59 PM",
      "id": "f7e1882cc73c435da357805b9793fd1e",
      "type": "Medium",
      "tag": "Android",
      "filename": "用 Espresso 測試 Android (一) f7e1882cc73c435da357805b9793fd1e.md"
    },
    {
      "title": "用 Espresso 測試 Android (二)",
      "summary": "在 Test Android App by Use Espresso (一) 中，提到 Espresso API 的操作的流程 Find View、Perform Action和Check。觀察程式後，可以發現不管是Perform a Action還是Check，都需要先找到View。 ``` on...",
      "content": "在 Test Android App by Use Espresso (一) 中，提到 Espresso API 的操作的流程 Find View、Perform Action和Check。觀察程式後，可以發現不管是Perform a Action還是Check，都需要先找到View。\n\n## **1. Find View by Other Attribute**\n\n```\nonView(withId(R.id.button))\n```\n\n這裡演示了onView()最基本的例子，找到一個id為R.id.button的View\n\n```\nonView(withText(\"MyButton\"))\n```\n\n但是有時候並非所有View都有設定id，此時我們可以使用上面這種方式。透過指定View上的文字來找到對應的View。\n\n這時你可能會有疑問，若我有很多button都有相同的文字呢?\n\n## **2. Find View by Multiple Matcher**\n\n在這種情況，如果還是使用withText(String)來搜尋View的話，測試就會發出[AmbiguousViewMatcherExceptio](https://stackoverflow.com/questions/29656562/espresso-ambiguousviewmatcherexception-when-trying-to-click-a-navigation-button)n導致測試失敗。\n\n此時我們就需要更多的條件，用來更明確的指出我們需要某一個特定的View。\n\n```\nonView(allOf(withId(R.id.button), withText(\"MyButton\")))\n```\n\n透過allOf(Matcher<? **super** T>… matchers)，我們可以指定更多的條件來獲取我們所需要的那個唯一的View。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 2, 2025 11:59 PM",
      "id": "ea58cfb881aa40f6b085d73d89c79b0d",
      "type": "Medium",
      "tag": "Android",
      "filename": "用 Espresso 測試 Android (二) ea58cfb881aa40f6b085d73d89c79b0d.md"
    },
    {
      "title": "如何使用 Flame 開發一個小遊戲",
      "summary": "來到了 2023 年，今年就來學點不同的東西。本身興趣之一就是喜歡打電動，所以打從學寫程式以來，一直都有想自己寫遊戲的想法，但是一直都懶得去實現。自從學了 Flutter 之後，隱隱覺得 [Flutter](https://docs.flame-engine.org/1.4.0/index.html...",
      "content": "![carl-raw-m3hn2Kn5Bns-unsplash.jpg](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/carl-raw-m3hn2Kn5Bns-unsplash.jpg)\n\n來到了 2023 年，今年就來學點不同的東西。本身興趣之一就是喜歡打電動，所以打從學寫程式以來，一直都有想自己寫遊戲的想法，但是一直都懶得去實現。自從學了 Flutter 之後，隱隱覺得 [Flutter](https://docs.flame-engine.org/1.4.0/index.html) 的渲染模式其實跟遊戲十分相似，也從許多文章或影片中得知 Flame 這個基於 Flutter 的遊戲引擎，今天就來學學如何製作一個小遊戲吧 🕹️。\n\n## 引入 Flame\n\n當然第一步最重要的就是，把 flame 套件引入到我們的專案中\n\n```bash\nflutter pub add flame\n```\n\n當我們執行下面命令後，我們就能在 pubspec.yml 中發現多了 flame\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flame: ^1.5.0\n```\n\n## 使用 GameWidget\n\n開始使用 Flame 之後，第一個面對的 Widget 是 `GameWidget`，如同我們在 Flutter 中使用的各式各樣的 Widget，這個 `GameWidget` 也能直接被放在我們的 Flutter 程式中。GameWidget 有一個必要的參數：`Game`，可以想像成是整個遊戲最外層的 Component，有點類似於 Flutter 的 `MaterialApp`。\n\n```dart\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: GameWidget(\n        game: MyGame(),\n      ),\n    );\n  }\n}\n\nclass MyGame extends FlameGame {}\n```\n\n當我們執行上面這段程式碼後，會發現程式雖然可以執行，畫面卻是一片空白。這也是正常的，來為畫面加上一些東西吧。\n\n```dart\nclass MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    camera.zoom = 4;\n    await add(Knight(\n      position: size / 2,\n      anchor: Anchor.center,\n      size: Vector2(120, 80),e\n    ));\n  }\n}\n\nclass Knight extends PositionComponent {\n  Knight({super.position, super.size, super.anchor});\n\n  @override\n  Future<void> onLoad() async {\n    var animation = await SpriteAnimation.load(\n      \"knight_idle.png\",\n      SpriteAnimationData.sequenced(\n        amount: 10,\n        stepTime: 0.1,\n        textureSize: Vector2(120, 80),\n      ),\n    );\n    await add(SpriteAnimationComponent(\n      animation: animation,\n      size: size,\n    ));\n  }\n}\n```\n\n在上面我們中在 onLoad 中加入一個騎士的待機圖，當執行之後就會在畫面上看到騎士待機站立的遊戲畫面。\n\n![knight_idle.gif](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/knight_idle.gif)\n\n## 為騎士加上不同動作\n\n如果只有看著騎士在畫面上站著不動，這也不能算是個遊戲吧。為了讓他有點遊戲的感覺，我們可以加上一個行為：當點擊畫面，騎士就進行攻擊。\n\n為了讓騎士有更多動作，首先我們需要先修改一下動畫，使用 `SpriteAnimationGroupComponent` 針對不同行為，使用不同的動畫。透過設定 `SpriteAnimationGroupComponent` 的 current 變數，來決定當下要播放靜止站立的動畫，或攻擊的動畫。\n\n```dart\n@override\nFuture<void> onLoad() async {\n  var idleAnimation = await SpriteAnimation.load(\n    \"knight_idle.png\",\n    SpriteAnimationData.sequenced(\n      amount: 10,\n      stepTime: 0.1,\n      textureSize: Vector2(120, 80),\n    ),\n  );\n\n  var attackAnimation = await SpriteAnimation.load(\n    \"knight_attacking.png\",\n    SpriteAnimationData.sequenced(\n      amount: 10,\n      stepTime: 0.1,\n      textureSize: Vector2(120, 80),\n      loop: false,\n    ),\n  );\n\n  await add(_animations = SpriteAnimationGroupComponent<KnightBehavior>(\n    current: KnightBehavior.idle,\n    size: size,\n    animations: {\n      KnightBehavior.idle: idleAnimation,\n      KnightBehavior.attack: attackAnimation\n    },\n  ));\n}\n```\n\n![螢幕錄影_2023-01-02_上午10_27_10_AdobeExpress.gif](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/%25E8%259E%25A2%25E5%25B9%2595%25E9%258C%2584%25E5%25BD%25B1_2023-01-02_%25E4%25B8%258A%25E5%258D%258810_27_10_AdobeExpress.gif)\n\n## 新增點擊操作\n\n當我們的騎士可以支援多種不同的動作之後，下一步就是指定觸發條件了，讓程式知道什麼時候要播放靜止站立的動畫，什麼時候要播放攻擊動畫。當使用者點擊畫面時，騎士就播放攻擊動畫。為此，我們需要修改幾個地方，以收取點擊事件。\n\n- `MyGame` 加上 `HasTappableComponents`\n\n```dart\nclass MyGame extends FlameGame with HasTappableComponents {\n}\n```\n\n- `Knight` 加上 `TapCallbacks` 並覆寫 `onTapUp` 與 `containsLocalPoint`\n\n```dart\nclass Knight extends PositionComponent with TapCallbacks {\n\n  @override\n  Future<void> onLoad() async {}\n\n  @override\n  bool containsLocalPoint(Vector2 point) => true;\n\n  @override\n  void onTapUp(TapUpEvent event) {\n    _animations.current = KnightBehavior.attack;\n  }\n}\n```\n\n我們可以把點擊之後的行為放在 onTapUp 的方法中，指定 `SpriteAnimationGroupComponent` 的 current 變數為 KnightBehavior.attack，騎士就會在點擊之後，進入攻擊狀態。\n\n## 更進一步\n\n在我們新增點擊操作之後，我們可以紀錄騎士進行了幾次攻擊，並顯示在畫面上，變成一個簡單的點擊計數小遊戲，就像 Flutter 專案預設的 App 一樣。\n\n首先，我們在 `MyGame` 中加上 count 變數紀錄次數\n\n```dart\nclass MyGame extends FlameGame with HasTappableComponents {\n  int count = 0;\n}\n```\n\n然後在 `Knight` 加上 `HasGameRef<MyGame>` ，讓我們可以修改 `MyGame` 中的 counter\n\n```dart\nclass Knight extends PositionComponent with TapCallbacks, HasGameRef<MyGame> {\n\n  @override\n  void onTapUp(TapUpEvent event) {\n\t\tif (_animations.current == KnightBehavior.idle) {\n      _animations.current = KnightBehavior.attack;\n      gameRef.count++;\n    }\n  }\n  \n}\n```\n\n最後在 `MyGame` 的 onLoad 中加上一個 `Counter` 用來顯示次數。`Counter` 類似於 `Knight` 也是一個 Component，在 `Counter` 的 onLoad 中加上一個 `TextComponent` 顯示文字，並在複寫 update 方法，Flame 會在遊戲進行時，持續呼叫每個 Component 的 update 方法，讓我們可以更新 Component 的畫面，我們可以透過 update 方法持續更新最新計數了。\n\n```dart\nclass MyGame extends FlameGame with HasTappableComponents {\n  int count = 0;\n\n  @override\n  Future<void> onLoad() async {\n    camera.zoom = 4;\n    await add(Knight(\n      position: size / 2,\n      anchor: Anchor.center,\n      size: Vector2(120, 80),\n    ));\n    await add(Counter(\n      position: size / 2..sub(Vector2(0, 20)),\n      anchor: Anchor.center,\n    ));\n  }\n}\n\nclass Counter extends PositionComponent with HasGameRef<MyGame> {\n  Counter({super.position, super.size, super.anchor});\n\n  late TextComponent _text;\n\n  @override\n  Future<void> onLoad() async {\n    await add(_text = TextComponent(\n      anchor: anchor,\n      textRenderer: TextPaint(\n        style: const TextStyle(color: Colors.white, fontSize: 10),\n      ),\n    ));\n  }\n\n  @override\n  void update(double dt) {\n    _text.text = \"Knight has attacked ${gameRef.count} times\";\n  }\n}\n```\n\n![螢幕錄影_2023-01-02_上午10_57_43_AdobeExpress.gif](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/%25E8%259E%25A2%25E5%25B9%2595%25E9%258C%2584%25E5%25BD%25B1_2023-01-02_%25E4%25B8%258A%25E5%258D%258810_57_43_AdobeExpress.gif)\n\n## 結論\n\nFlame 是基於 Flutter 框架之上的遊戲引擎，其中我們會碰到許多各式各樣的 Component，透過組合不同的 Component 完成各式各樣的遊戲效果，感覺有點像是在 Flutter 中組合各種不同的 Widget 來製作各式各樣的畫面。為了完成這個點擊小遊戲，我們使用了許多 Component，例如：`FlameGame` 、`SpriteAnimationGroupComponent`、`TextComponent` …等等，文章中的程式放在[這邊](https://github.com/easylive1989/knight_counter_demo)，有興趣的朋友也可以參考看看。",
      "createdAt": "January 1, 2023 11:37 AM",
      "updatedAt": "October 2, 2025 11:57 PM",
      "id": "ddaa1e706f2a4949a2bbd7d19e4d7674",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "如何使用 Flame 開發一個小遊戲 ddaa1e706f2a4949a2bbd7d19e4d7674.md"
    },
    {
      "title": "用 Flutter Web 製作 Chrome Extension 待讀文章看板",
      "summary": "有一陣子沒寫文章了，趁著前陣子剛完成了[鐵人賽](https://ithelp.ithome.com.tw/users/20129825/ironman/4992)，趁著開始比較有空閒，就來更新一下最近學到的新東西XD。 在日常生活和工作中，每當看到一些不錯的文章，想要晚一點再看時，我們可以使用 N...",
      "content": "有一陣子沒寫文章了，趁著前陣子剛完成了[鐵人賽](https://ithelp.ithome.com.tw/users/20129825/ironman/4992)，趁著開始比較有空閒，就來更新一下最近學到的新東西XD。\n\n![wesley-tingey-snNHKZ-mGfE-unsplash.jpg](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/wesley-tingey-snNHKZ-mGfE-unsplash.jpg)\n\n在日常生活和工作中，每當看到一些不錯的文章，想要晚一點再看時，我們可以使用 Notion 官方推出的 Chrome Extension：[Notion Web Clipper](https://chrome.google.com/webstore/detail/notion-web-clipper/knheggckgoiihginacbkhaalnibhilkk)，快速的把文章儲存到 Notion 中的某個資料庫，等到有空閑的時間，我就能從資料庫中找到那篇想讀的文章。有時候，我們會記得回來看資料庫是否有未讀的文章，但更多是，在我們有空的時候，我們早就不記得資料庫中有一些文章正等著我們去讀，然後把這寶貴的空閒時間浪費掉了。\n\n# 難以維持習慣\n\n有時，我們學了新東西，一開始比較有熱情，可以讓新習慣維持一陣子。但是，有時候我們會忘記，有時候我們會懶惰，一次兩次的失敗，我們漸漸開始無心維持新習慣，最後就慢慢地回到舊的習慣。如同[最小阻力之路](https://www.books.com.tw/products/0010696380)中提到的，在大自然中，能量會往阻力最小的路線前進，這個道理也同樣適用於人。大多時候，我們所選做的決定，所選擇的方向，也都是自然而然地從阻力最小的方向去走。當我們嘗試建立新的習慣，總會帶來一些阻力，越是平常根本不做的事情，阻力越大，時間一長，我們自然而然的就會回到阻力最小的舊習慣。\n\n# 讓執行習慣毫不費勁\n\n那我們如何減小新習慣的阻力呢？我們可以運用[原子習慣](https://www.books.com.tw/products/0010822522)中提到的一個技巧：**習慣堆疊。**\n\n> 把新習慣放到每天已經習慣做的事情綁在一起。\n> \n\n於是我觀察我自己的原有的習慣，發現自己每天早上都一定會透過 Chrome 擴充功能的 [Google Mail Checker](https://chrome.google.com/webstore/detail/google-mail-checker/mihcahmgecmbnbcchbopgniflfhgnkff) 處理信件，並使用 [Feedly Notifier](https://chrome.google.com/webstore/detail/feedly-notifier/egikgfbhipinieabdmcpigejkaomgjgb) 看看自己訂閱的 RSS 有沒有什麼新文章。於是，我從商店中找找看是否有適用的擴充功能，看看有沒有像是 Mail Checker 一樣，可以顯示 Notion Daatabase 中還有多少待讀文章，但比較可惜的是大多擴充功能都是強化原本 Notion Web 版使用體驗。最後，我決定自己使用 Flutter Web 來做一個自用的 Chrome 擴充功能。\n\n# 建立 Chrome Extension\n\n之前我們透過 [Notion API 更新資料庫](https://easylive1989.medium.com/%E5%88%A9%E7%94%A8-notion-api-%E8%87%AA%E5%8B%95%E6%9B%B4%E6%96%B0%E6%AC%84%E4%BD%8D-318eac43008e?source=your_stories_page-------------------------------------)，這次也同樣需要使用 Notion API 來幫助我們取得待讀清單，再加上用 Flutter Web 建立 Chrome 擴充功能，把所有未讀文章放在擴充功能畫面上。\n\n首先我們得先建立一個 Flutter Project\n\n```bash\nflutter create notion_assistant\n```\n\n在 web 資料夾放入 manifest.json，和加上 index.html 取代原本檔案\n\n```bash\n{\n    \"name\": \"Notion Assistant\",\n    \"version\": \"0.1\",\n    \"manifest_version\": 2,\n    \"browser_action\" :{\n        \"default_popup\": \"index.html\",\n        \"default_icon\" : \"icons/Icon-192.png\"\n    },\n    \"icons\": {\n        \"16\": \"icons/Icon-192.png\"\n    }\n}\n```\n\n```html\n<html style=\"height: 300px; width: 300px\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Notion Assistant</title>\n</head>\n<body>\n<script src=\"main.dart.js\" type=\"application/javascript\"></script>\n</body>\n</html>\n```\n\n當我們用 flutter  build 出 web app 時，flutter 會把畫面的部分建成 main.dart.js，同時使用 —[web-renderer](https://docs.flutter.dev/development/platform-integration/web/renderers) 讓 flutter 用 html + css 來渲染畫面。\n\n```html\nflutter build web --web-renderer html\n```\n\n最後我們打開 Chrome 擴充功能設定 ( chrome://extensions )，從右上角開啟開發人員模式並載入未封裝項目，選擇 build/web 資料夾中的建置結果，我們就能在 Chrome 擴充功能中看到 Flutter 預設的 counter app。\n\n![截圖 2022-11-06 下午12.13.39.png](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/%25E6%2588%25AA%25E5%259C%2596_2022-11-06_%25E4%25B8%258B%25E5%258D%258812.13.39.png)\n\n此時，我們就能開始針對自己的需求製作畫面了擴充功能的畫面了，之後就是根據個人需求整畫面與 API 的使用了，以我自己來說，就是顯示待讀文章列表。\n\n![截圖 2022-11-06 上午10.42.04.png](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/%25E6%2588%25AA%25E5%259C%2596_2022-11-06_%25E4%25B8%258A%25E5%258D%258810.42.04.png)\n\n# 畫面以外的功能\n\n當我們只想知道還有多少未讀文章，每次都要點開擴充功能才能知道，不免有些麻煩，此時，我們可以使用 Chrome 擴充功能的 Background Job 幫我們定期呼叫 API，並更新 count 到 badge 上。第一步我們得先稍微修改一個 manifest.json，增加 background 的設定。\n\n```json\n{\n    \"background\": {\n        \"persistent\": true,\n        \"scripts\": [\"background.js\"]\n    },\n}\n```\n\n接下來我們就得想辦法產生 background.js 了。如果稍微會寫 Javascript 的朋友，這邊可以考慮根據自己的需求，直接使用 Javascript 實作 background.js。但是在這邊，讓我們嘗試用 Dart 來製作 background.js 吧，也因為同樣是使用 Dart ，所以我們可以共用製作畫面時 Dart 程式碼，讓我們省一點功夫。\n\n# 用 Dart 製作 background.js\n\nDart SDK 中，有提供[工具](https://dart.dev/tools/dart2js)讓我們能把 Dart 轉換成 Javascript，用這個工具我們就能先寫一份 background.dart，再透過他幫我轉成 Javascript。在 background.dart 中，import dart:js 之後，我們可以拿到 context，並用 context 呼叫到 [Chrome API](https://developer.chrome.com/docs/extensions/reference/browserAction/#badge)，並透過其設定 Badge 的上的文字與顏色。\n\n```bash\nimport 'dart:async';\nimport 'dart:js';\n\nvoid main() {\n  _setBadge(1);\n  Timer.periodic(const Duration(seconds: 300), (timer) async {\n    _setBadge(2);\n  });\n}\n\nvoid _setBadge(int count) {\n  var badgeText = JsObject.jsify({\"text\": \"$count\"});\n  var badgeBackgroundColor = JsObject.jsify({\"color\": \"#D00218\"});\n  context[\"chrome\"][\"browserAction\"].callMethod(\"setBadgeText\", [badgeText]);\n  context[\"chrome\"][\"browserAction\"].callMethod(\"setBadgeBackgroundColor\", [badgeBackgroundColor]);\n}\n```\n\n上面示範程式碼只有展示如何設定 Badge，實際則是需要根據自身需求，決定設定什麼文字到 Badge 上，我們這邊就不過多展示，有興趣有可以直接到 [https://github.com/easylive1989/notion_assistant](https://github.com/easylive1989/notion_assistant) 中查看。\n\n當寫完 background.dart 之後，最後在呼叫指令產生 background.js 即可。\n\n```bash\ndart compile js lib/background.dart -o background.js\n```\n\n最後我們就能成功的在 Chrome 擴充功能的圖示上看到 Badge 了。\n\n![截圖 2022-11-06 下午10.53.05.png](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/%25E6%2588%25AA%25E5%259C%2596_2022-11-06_%25E4%25B8%258B%25E5%258D%258810.53.05.png)\n\n# 結論\n\n當我們從書上或他人身上學到新的方法，通常無法直接的複製到自己身上，畢竟自身的環境或習慣與他人並不完全一樣。想要讓新方法融入自己的生活，必定得耐心思考與嘗試一番，經過不斷地調整與實驗，最終才能找到適合自己的工作方式，讓我們花費最少心力，把重要的注意力放在更重要的事情上。\n\n# 參考\n\n- Repository：[https://github.com/easylive1989/notion_assistant](https://github.com/easylive1989/notion_assistant)",
      "createdAt": "November 5, 2022 11:13 PM",
      "updatedAt": "October 2, 2025 11:57 PM",
      "id": "1baca95d3dd34180a74bc918af8f500c",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "用 Flutter Web 製作 Chrome Extension 待讀文章看板 1baca95d3dd34180a74bc918af8f500c.md"
    },
    {
      "title": "flutter_bloc 6.1.0 多了什麼",
      "summary": "把flutter_bloc更新到6.1.0以上時，會發現專案出現很多context.bloc的warning。 提示訊息會指明context.bloc()和context.repository()被已經deprecated，並預計在flutter_bloc 7.0.0時停止支援，建議改成contex...",
      "content": "### bloc 6.1.0的變化\n\n把flutter_bloc更新到6.1.0以上時，會發現專案出現很多context.bloc的warning。\n\n![](flutter_bloc%206%201%200%20%E5%A4%9A%E4%BA%86%E4%BB%80%E9%BA%BC/_2020-12-30_9.52.35.png)\n\n提示訊息會指明context.bloc()和context.repository()被已經deprecated，並預計在flutter_bloc 7.0.0時停止支援，建議改成context.read()或context.watch()。\n\n如果查看[flutter_bloc](https://pub.dev/packages/flutter_bloc/changelog)的Change log，會發現從6.1.0新增method中，除了context.read()和context.watch()之外，還有context.select()。今天就來講講這三個新增的method如何使用。\n\n### 為什麼要移除bloc\n\n作者Felix發現許多人對state的誤用，直接在build使用context.bloc<CounterBloc>().state來決定畫面，而不是使用BlocBuilder，導致state發生改變時，畫面沒有跟著變化。為了減少這種情況，所以新增了watch和read來改善。為減少這樣的狀況，所以開了一些新的api，並在該api中限制使用方式來減少這些狀況的發生。\n\n---\n\n### 新增的三個方法\n\n**watch**\n\n- 只能在build中使用\n- 當state改變時會重新build\n\n```dart\n@override\nWidget build(BuildContext context) {\n  int count = context.watch<CounterBloc>().state.count;\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(widget.title),\n    ),\n    body: Text(\n      '$count',\n    ),\n  );\n}\n```\n\n**select**\n\n- 與只能在build中使用\n- 當selector中的狀態改變時會重新build\n\n```dart\n@override\nWidget build(BuildContext context) {\n  int count = context.select<CounterBloc, int>((bloc) => bloc.state.count);\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(widget.title),\n    ),\n    body: Text(\n      '$count',\n    ),\n  );\n}\n```\n\n**read**\n\n- 不能在build中使用\n- 當state改變時不會重新build\n\n```dart\n@override\nWidget build(BuildContext context) {\n  int count = context.watch<CounterBloc>().state.count;\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(widget.title),\n    ),\n    body: Text(\n      '$count',\n    ),\n    floatingActionButton: FloatingActionButton(\n      onPressed: () {\n        context.read<CounterBloc>().add(CounterEvent());\n      },\n      child: Icon(Icons.add),\n    ),\n  );\n}\n```\n\n### 延伸思考\n\n- 如何在build中取用bloc，但是又不在狀態改變時觸發rebuild\n    - 也就是原本context.bloc的做法\n    \n    ```dart\n    BlocProvider.of<CounterBloc>(context).add(CounterEvent())\n    ```\n    \n- watch適合用在需要觸發整個widget的rebuild\n    - 通常會使得widget越拆越細\n\n### 參考\n\n[https://github.com/felangel/bloc/issues/1902](https://github.com/felangel/bloc/issues/1902)\n\n[https://www.youtube.com/watch?v=TNVxDuSJ00I&t=599s](https://www.youtube.com/watch?v=TNVxDuSJ00I&t=599s)",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 2, 2025 11:56 PM",
      "id": "b169dd8feb96405ca5f2e9859a091c43",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "flutter_bloc 6 1 0 多了什麼 b169dd8feb96405ca5f2e9859a091c43.md"
    },
    {
      "title": "使用 Nested Navigation 簡化路由設計",
      "summary": "Flutter 習慣在最頂層的 MaterialApp 或 CupertinoApp 中統一定義整個 app 的路由管理。當我們把所有頁面的路由管理都放在最頂層時，就會讓它變得很長，不容易維護。或許應該適時思考，是否某些頁面的路由不應該被管理在最頂層。今天就來分享工作上遇到的一個情境，以及它存在什麼...",
      "content": "Flutter 習慣在最頂層的 MaterialApp 或 CupertinoApp 中統一定義整個 app 的路由管理。當我們把所有頁面的路由管理都放在最頂層時，就會讓它變得很長，不容易維護。或許應該適時思考，是否某些頁面的路由不應該被管理在最頂層。今天就來分享工作上遇到的一個情境，以及它存在什麼問題，而我們又是如何解決的。\n\n## 舉個例子\n\n假設我們需要實作一個搜尋附近裝置並傳輸檔案到該裝置的需求，一開始我們會搜尋附近裝置，完成之後，畫面會顯示可選擇的裝置清單給使用者進行選擇，當使用者完成選擇之後，畫面會列出檔案清單讓使用者選擇，當使用者選完檔案並按下 Transfer 按鈕後進行傳輸工作。當傳輸工作完成時，回到最一開始的頁面，並顯示 Transfer success 的訊息讓使用者知道。\n\n![nested navigation.drawio.png](%E4%BD%BF%E7%94%A8%20Nested%20Navigation%20%E7%B0%A1%E5%8C%96%E8%B7%AF%E7%94%B1%E8%A8%AD%E8%A8%88/nested_navigation.drawio.png)\n\n## 用 Top-Level Navigation 方式實作\n\n我們設計了三個頁面，分別是 SearchDevicesPage、SelectDevicePage 和 SelectFilePage，三個頁面的工作分別是搜尋裝置、讓使用者選擇裝置和 讓使用者選擇檔案，每個頁面都是定義在頂層的路由。為此，我們在路由管理中有了起始頁面 Home 與傳輸檔案所需要的三個頁面。\n\n```dart\nRoute _onGenerateRoute(RouteSettings routeSettings) {\n  if (routeSettings.name == HomePage.routeName) {\n    return MaterialPageRoute(builder: (BuildContext context) => const HomePage());\n  } else if (routeSettings.name == SearchDevicesPage.routeName) {\n    return MaterialPageRoute<TransferResult>(\n      builder: (BuildContext context) => const SearchDevicesPage(),\n      settings: routeSettings,\n    );\n  } else if (routeSettings.name == SelectDevicePage.routeName) {\n    return MaterialPageRoute<TransferResult>(\n      builder: (BuildContext context) => const SelectDevicePage(),\n      settings: routeSettings,\n    );\n  } else if (routeSettings.name == SelectFilePage.routeName) {\n    return MaterialPageRoute<TransferResult>(\n      builder: (BuildContext context) => const SelectFilePage(),\n      settings: routeSettings,\n    );\n  }\n  throw RouteNotFoundException(\"Need to implement ${routeSettings.name}\");\n}\n```\n\n當使用者在 Home 頁面中按下 + 按鈕，想要傳輸檔案時，程式會先打開 SearchDevicesPage 並開始搜尋附近的裝置。當搜尋完成並且使用者按下 Next 按鈕後，程式會開啟下一個頁面：SelectDevicePage，並把搜尋到的裝置清單傳給下一個頁面顯示。\n\n```dart\nFuture _openSelectDevicePage(BuildContext context, List<Device> devices) async {\n  Navigator.of(context).pushNamed(SelectDevicePage.routeName, arguments: devices);\n}\n```\n\n在 SelectDevicePage 中，畫面會顯示裝置清單。當使用者選擇任一裝置後按下 Next，程式就會開啟下一個頁面：SelectFilePage，並且把使用者選擇的裝置傳給它。\n\n```dart\nFuture _openSelectFilePage(BuildContext context) async {\n  Navigator.of(context).pushNamed(SelectFilePage.routeName, arguments: selectedDevice);\n}\n```\n\n當使用者來來到 SelectFilePage 時，畫面會顯示檔案清單。當使用者選擇任一檔案後按下 Next，程式會使用上一個頁面給的裝置與這個頁面選擇的檔案進行傳輸工作。當傳輸工作完成之後，把傳輸結果往回傳遞。\n\n```dart\nawait _transfer(selectedDevice, selectedFile!);\nNavigator.pop(context, TransferResult.success);\n```\n\n當 Navigator.pop 執行後，首先回到的是 SelectDevicePage 的 _openSelectDevicePage 方法中。我們需要修改這個方法，讓他可以取得從 SelectFilePage 得到傳輸的結果，並把他回傳給上一頁。\n\n```dart\nFuture _openSelectFilePage(BuildContext context) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(SelectFilePage.routeName, arguments: selectedDevice);\n  Navigator.pop(context, transferResult);\n}\n```\n\n同樣的 SearchDevicesPage 也需要進行修改，同樣的讓他可以把結果帶回給 HomePage。\n\n```dart\nFuture _openSelectDevicePage(BuildContext context, List<Device> devices) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(SelectDevicePage.routeName, arguments: devices);\n  Navigator.of(context).pop(transferResult);\n}\n```\n\n在 HomePage 中，當程式從 SearchDevicesPage 回來時，就可以取得傳輸檔案的結果，並決定畫面如何顯示。以下面程式碼來說，當傳輸成功時，我們會在畫面上顯示一個 Snackbar 訊息提示傳輸成功。\n\n```dart\nFuture _openSearchDevicePage(BuildContext context) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(SearchDevicesPage.routeName);\n  if (transferResult == TransferResult.success) {\n    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text(\"Transfer success\")));\n  }\n}\n```\n\n[完整程式碼](https://github.com/easylive1989/transfer_file/tree/pop_with_result)\n\n## 作法分析\n\n這種設計可能存在一些問題\n\n- 頁面會被強迫知道他不需要的資訊\n\n以上面的例子來說，SelectFilePage 本身的工作應該是讓使用者選擇檔案，但是他卻也同時必須儲存使用者選擇的裝置，只為了完成傳輸的工作。或許我們可以把傳輸的工作移到 HomePage，但是這樣一來，我們也會需要把使用者選擇的裝置和檔案往回傳，同樣的造成 SelectDevicePage 也需要知道檔案的資訊，兩種做法都無可避免的導致某些頁面知道他不需要知道的資訊。\n\n```dart\nFuture _openTransferFilePage(BuildContext context) async {\n  File? file = await Navigator.of(context).pushNamed<File>(SelectFilePage.routeName);\n  if (file != null) {\n    Navigator.pop(context, TransferAction(selectedDevice!, file));\n  }\n}\n```\n\n- 流程路徑上的每個頁面都需要知道如何處理結果\n\n在上面例子中，每個頁面都會需要接回 TransferFileResult，並在 Navigator.pop() 中往回帶，這也表示每個頁面都需要知道 TransferResult 的存在，以及決定如何處理它。但實際上只有 HomePage 是真正需要的人，決定這個結果的是 SelectFilePage，它跟 HomePage 隔了兩個頁面，導致中間的頁面需要幫忙傳遞它們不需要的資訊。 \n\n```dart\nTransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(...);\nNavigator.pop(context, transferResult);\n```\n\n這些問題容易導致這些頁面無法重複使用，假設今天多了一種需求：同樣的選擇 Device，同樣的選擇檔案，最後卻是要傳送檔案資訊的文字，而不是傳送檔案本身。如果依照原本的設計修改的話，就會變成需要把最後的行為抽成方法或類別，把他從第一個頁面一路往下一個頁面傳，直到最後一個頁面，但是這個傳遞參數跟中間過程的頁面的工作毫無關係，他只是為了最後一個頁面需要而幫忙傳遞，提高了頁面之間的耦合度。\n\n## 用 Nested Navigation 實作\n\n為了解決這個問題，我們使用 [Nest Navigation](https://docs.flutter.dev/cookbook/effects/nested-nav) 來處理，讓頁面只知道自己需要的訊息，並且輸出他工作後的結果，至於如何使用就讓使用方來決定。\n\n我們使用上面的例子進行修改，先創建一個 TransferFileFlow，並在其中使用 Navigator Widget，給定一個 GlobalKey 放進 Navigator 中，我們需要使用 GlobalKey 來進行 Nested Navigator 的頁面切換。\n\n```dart\nclass TransferFileFlow extends StatefulWidget {\n  static const String routeName = \"transfer-file-flow\";\n\n  const TransferFileFlow({Key? key}) : super(key: key);\n\n  @override\n  State<TransferFileFlow> createState() => _TransferFileFlowState();\n}\n\nclass _TransferFileFlowState extends State<TransferFileFlow> {\n  final GlobalKey<NavigatorState> _nestedNavigatorKey = GlobalKey<NavigatorState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Navigator(\n        key: _nestedNavigatorKey,\n        initialRoute: SearchDevicesPage.routeName,\n        onGenerateRoute: _onGenerateRoute,\n      ),\n    );\n  }\n}\n```\n\n在 Navigator 中傳入 _onGenerateRoute，定義 TransferFileFlow 各個頁面的路由與實際頁面的關係。並把相對應的 callback 傳入實際頁面中，讓每一個頁面完成工作時可以通知 TransferFileFlow，讓 TransferFileFlow 可以切換到下一個頁面。比如說 SelectDevicePage 就傳入了 _onDeviceSelected，當使用者選擇了任一裝置後，就會呼叫 _onDeviceSelected，而 TransferFileFlow 就進行流程的下一步了。\n\n```dart\nRoute _onGenerateRoute(RouteSettings routeSettings) {\n  if (routeSettings.name == SearchDevicesPage.routeName) {\n    return MaterialPageRoute(\n      builder: (BuildContext context) => SearchDevicesPage(\n        onBack: _onSearchDevicesPageClose,\n        onDevicesSearched: _onDevicesSearched,\n      ),\n    );\n  } else if (routeSettings.name == SelectDevicePage.routeName) {\n    return MaterialPageRoute(\n      builder: (BuildContext context) => SelectDevicePage(\n        searchedDevices: searchedDevices,\n        onDeviceSelected: _onDeviceSelected,\n      ),\n    );\n  } else if (routeSettings.name == SelectFilePage.routeName) {\n    return MaterialPageRoute(\n      builder: (BuildContext context) => SelectFilePage(\n        onFileSelected: _onFileSelected,\n      ),\n    );\n  }\n  throw RouteNotFoundException(\"Need to implement ${routeSettings.name}\");\n}\n```\n\n在每個 callback 中，TransferFileFlow 接收每一個頁面的輸出，並暫存在自己身上。在最後一個頁面完成之後，就進行傳輸檔案的動作。\n\n```dart\nvoid _onDevicesSearched(List<Device> devices) {\n  searchedDevices = devices;\n  _nestedNavigatorKey.currentState?.pushNamed(SelectDevicePage.routeName);\n}\n\nvoid _onDeviceSelected(Device device) {\n  selectedDevice = device;\n  _nestedNavigatorKey.currentState?.pushNamed(SelectFilePage.routeName);\n}\n\nFuture _onFileSelected(File file) async {\n  selectedFile = file;\n  await _transfer(selectedDevice, selectedFile);\n  Navigator.of(context).pop(TransferResult.success);\n}\n```\n\n當整個 TransferFileFlow 的流程完成之後，TransferFileFlow 就會回傳 TransferResult 給 HomePage。中間也不存在任何頁面幫忙傳遞結果，而是 TransferFileFlow 送出結果，HomePage 下一秒收到後就馬上使用。\n\n```dart\nFuture _openTransferFileFlow(BuildContext context) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(TransferFileFlow.routeName);\n  if (transferResult != null) {\n    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text(\"Transfer success\")));\n  }\n}\n```\n\n至於原本頂層路由管理就會只剩下 HomePage 與 TransferFlow，也會變得簡單一些。\n\n```dart\nRoute _onGenerateRoute(RouteSettings routeSettings) {\n  if (routeSettings.name == HomePage.routeName) {\n    return MaterialPageRoute(builder: (BuildContext context) => const HomePage());\n  } else if (routeSettings.name == TransferFileFlow.routeName) {\n    return MaterialPageRoute<TransferResult>(builder: (BuildContext context) => const TransferFileFlow());\n  }\n  throw RouteNotFoundException(\"Need to implement ${routeSettings.name}\");\n}\n```\n\n[完整程式碼](https://github.com/easylive1989/transfer_file/tree/nested_navigator)\n\n## 作法分析\n\n- 傳遞給頁面的參數恰好是頁面所需要的\n\n使用 Nested Navigation，把控制流程的的工作轉交給 TransferFileFlow，由 TransferFileFlow 把頁面需要的參數直接傳給它，頁面再也不需要幫忙傳遞任何參數。以上面的例子來說，我們再也不需要把使用者選擇的 Device 傳給 SelectFilePage 了，讓 SelectDevicePage 處理完之後傳給 TransferFileFlow，SelectFilePage 只要專注地處理使用者選擇的 File，並把使用者選擇的 File 傳給 TransferFileFlow，最後由 TransferFileFlow 組合資訊並完成工作。\n\n- 頁面無須處理與流程相關的邏輯\n\n頁面做完工作之後，也只需要專注的輸出結果給 Flow，由 Flow 來蒐集必要資訊，用以完成傳輸工作，並決定傳輸結果。當今天多了另一個類似需求，我們就可以創建另一個 Flow，該 Flow 可以根據需求來組合需要的頁面，最後再進行不同的操作，讓頁面不會因為與前後頁面之間的耦合導致難以重複使用。\n\n## 結論\n\nNested Navigation 十分適合使用在這種固定流程的工作上，如果頁面沒辦法單獨提供功能，而是需要多個頁面共同組合出一個功能的話，就很適合使用 Nested Navigation 這種做法。當一個頁面能提供完整的功能，例如顯示比賽資訊，顯示裝置詳細資訊，或者是更新使用暱稱這種單一頁面就可以完成的，或許就不太需要特別使用 Nested Navigation。\n\n## 參考\n\n- [https://docs.flutter.dev/cookbook/effects/nested-nav](https://docs.flutter.dev/cookbook/effects/nested-nav)",
      "createdAt": "April 23, 2022 10:41 AM",
      "updatedAt": "October 2, 2025 11:53 PM",
      "id": "b715b9e2fdc541bca3d6d234664eda2d",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "使用 Nested Navigation 簡化路由設計 b715b9e2fdc541bca3d6d234664eda2d.md"
    },
    {
      "title": "回顧三份工作的歷程",
      "summary": "從開始出社會工作到現在，總共也八年快九年，總共待了三間不同的公司。待過的公司一間比一間小，每一份工作中也都學到不同的東西。從熟悉一個領域，到全端開發整個產品，到熟悉一個領域且維持一定全端開發的能力。三份工作剛好維持了一個循序漸進的結構。 第一份工作選擇了一間軟體大公司，抱著大部分新人都會有的心態，以...",
      "content": "從開始出社會工作到現在，總共也八年快九年，總共待了三間不同的公司。待過的公司一間比一間小，每一份工作中也都學到不同的東西。從熟悉一個領域，到全端開發整個產品，到熟悉一個領域且維持一定全端開發的能力。三份工作剛好維持了一個循序漸進的結構。\n\n## 有什麼做什麼，唯一選擇的是軟體\n\n第一份工作選擇了一間軟體大公司，抱著大部分新人都會有的心態，以學習心態來工作。工作是負責某個產品的 Android App，公司是傳統一點的軟體大公司，有完善的規章制度和層層分級的管理制度。我負責也就是一個產品的 Android App 的部分，完成功能後，然後會交由 QA 進行測試，然後解決 Bug，有人負責後端，有人負責產品規劃，有人負責時程規劃，有人處理 DevOps 的部分，可以說是把工作內容分得比較的細，像工廠流水線一樣，每個人處理好自己的部分，流水線就會持續有產出。\n\n我覺得在這個過程中，只負責一個 Android App 讓我有機會把程式的基本功練好，從語言特性到框架行為，可以有一段相對連續且漸進的學習過程。公司內部也會有一些大神，能幫助解決開發上的一些問題，自己也能側面了解如何解決並學習。在這份工作上，比較少機會直接花大量時間與他人學習如何寫程式。工作之外，自己雖然會看一些設計相關的書，例如重構，設計模式，但是除了簡單的重構，其他的只能是有看沒有懂，更別談會用了。以現在的角度來看，在沒有人指點的狀況下，有點不得其門而入的感覺。\n\n以上都是五六年前記憶中的樣子，很有可能有已經有許多地方不同了，畢竟軟體開發是個變化快速產業，公司也會隨之發生變化。\n\n## 進行開腦手術的過程\n\n第二份工作，公司規模相對小一些，公司組織扁平化非常多，工作方式採用敏捷開發。公司有許多產品，而每個產品是由一個一個小而精壯5~7團隊組成，從前段端後端，CI/CD，軟體測試都需要由這 5~7 人全端的負責。相比之上一份工作，公司的風格可以說是完全相反的。也是在這個階段，我開始需要了解 Web 前端，後端與 CI/CD，了解軟體的完整開發流程，不像之前一樣可以在單一的領域鑽研到比較深入，而是需要廣泛的了解整體概況。\n\n公司鼓勵開發人員持續學習，有許多預算讓開發人員去買書上課，甚至直接請教練來公司與開發人員進行 Pair Programming。自己也是在這個時候才開始頻繁上課與看書，認識許多大師。也是從這個階段開始，開始知道什麼叫做開發人員，從認識 Code Smell，知道 SOLID、 KISS、DRY …等諸多軟體設計原則，知道如何善用  IDE，能在開發過程中重構和寫單元測試，與團隊成員 Pair Programming、Code Review、分享經驗和共同成長。\n\n在這份工作上，我知道如何從一個碼農變成一個開發人員。聽起來第二份工作似乎相當完美，但是最終我還是離開了。\n\n## 世上沒有完美的解法\n\n在第三份工作中，我來到了一間更小的公司，雖然工作方式與上一份工作差不多，但是制度與資源上還是有一些不同。在上一份工作中，大部分的開發團隊都不會區分前端開發人員與後端開發人員，每個人都是全端的開發人員。在這份工作中，團隊有比較明顯的前端與後端開發人員，只是前端開發人員也會需要具備一些後端開發技能，在後端負擔相對較重的時候，前端開發人員可以協助開發。開發過程也與上一份工作一樣，會 Pair Programming、Code Review，公司也同樣鼓勵並提供預算讓開發人員持續學習，就本質上來說與上一份工作區別不大。\n\n聽到這邊好像沒什麼差別，就工作方式來說也確實沒什麼差別，唯一差別在於細節程度上的不同。由於上一份工作中，我所在的團隊的成員都相對年輕，也較缺乏實務經驗，在開發的過程中，比較難討論出有效且合理的做法，好像這個做法也可以，那個做法也可以，沒有花時間去研究並評斷解法之間的優缺點。在 Code Review 的做法也比較不講究，對於程式碼的品質也不會要求到極致，也不是每一個功能都會加上單元測試。重構沒有測試的程式碼時，也有時會出現 bug。\n\n在這份工作中，Code Review 時，我們會嚴謹的審視程式碼，從變數命名到架構設計，讓程式在每一個時間點都保持一定的可維護性。若是在 Code Review 過程中，如果設計經過討論後發現可以調整，也會即時的調整，讓程式碼維持一定品質。聽起來好像常常在修改已經做好的東西，也確實是常常在修改已經做好的東西，這也是十分正常的，畢竟程式不是天生的，是演化而來的。為此我們會打磨自己的開發工具，熟練重構工具與 IDE 快捷鍵，加速修改程式碼的速度。我們也會為每一個功能加上完整的單元測試，測試各種預期程式行為，讓產品保持一定的品質。\n\n在這份工作上，我學習如何變成一個更專業的開發人員。\n\n## 結論\n\n我覺得每間公司都有優點與缺點，有時候本來的優點也會變成缺點，缺點也可能變成優點，完全在於你從什麼角度來看。只有知道自己的需要的是什麼，才有可能找到自己需要的。我自認為自己很幸運，可以在不同階段遇到的合適工作方式，也十分感謝遇到每個人事物與機會。\n\n======= 以下是工商時間 =======\n\n公司正在尋找前端、後端、App 的開發人員，歡迎有興趣的朋友履歷投起來",
      "createdAt": "July 3, 2022 9:17 AM",
      "updatedAt": "October 2, 2025 11:53 PM",
      "id": "8e35d3fa024746588e1389c0410f6c46",
      "type": "Medium",
      "tag": "思維進化",
      "filename": "回顧三份工作的歷程 8e35d3fa024746588e1389c0410f6c46.md"
    },
    {
      "title": "畫面莫名其妙地重 build 了",
      "summary": "Flutter 自帶各式各樣的 Widget，能透過改變 Widget 的參數，讓畫面符合開發者想要的設計。在大部分的時間裏，能有效減低開發者的開發時間。但是如果開發者使用方式不正確的話，往往會造成不預期的結果，今天就來分享一個問題。 假設我們有一個簡單的應用，總共有兩個頁面：第一個頁面會顯示一組隨...",
      "content": "Flutter 自帶各式各樣的 Widget，能透過改變 Widget 的參數，讓畫面符合開發者想要的設計。在大部分的時間裏，能有效減低開發者的開發時間。但是如果開發者使用方式不正確的話，往往會造成不預期的結果，今天就來分享一個問題。\n\n## 舉個例子\n\n假設我們有一個簡單的應用，總共有兩個頁面：第一個頁面會顯示一組隨機繁體中文數字，然後使用者需要記下該數字，並且在第二頁輸入結果。Submit 之後，會在第一個頁面的底部顯示答案是否正確。\n\n![rebuild_by_media_query.drawio.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/rebuild_by_media_query.drawio.png)\n\n第一個頁面的程式碼\n\n```dart\nclass FirstPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    String randomNumber = _getRandomNumber();\n    return Scaffold(\n      body: Column(\n        children: [\n          Container(\n            alignment: Alignment.center,\n            height: MediaQuery.of(context).size.height * 0.6,\n            child: Text(\n              \"What's the number: ${NumberConvertor.toText(randomNumber)}\",\n            ),\n          ),\n          OutlinedButton(\n            child: const Text(\"Go to answer\"),\n            onPressed: () async {\n              var result = await Navigator.of(context).pushNamed(\"/second\");\n              ScaffoldMessenger.of(context).showSnackBar(SnackBar(\n                content: Text(\"Answer is ${result == randomNumber ? \"correct\" : \"wrong\"}\"),\n              ));\n            },\n          ),\n        ],\n      ),\n    );\n  }\n\n  String _getRandomNumber() {\n    return Random().nextInt(100).toString();\n  }\n}\n```\n\n第二個頁面的程式碼\n\n```dart\nclass SecondPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Container(\n          alignment: Alignment.center,\n          width: 300,\n          child: TextFormField(\n            keyboardType: TextInputType.number,\n            onFieldSubmitted: (text) => Navigator.of(context).pop(text),\n            decoration: const InputDecoration(\n              border: OutlineInputBorder(),\n              label: Text(\"Answer\"),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 發生了不預期狀況\n\n當使用者在第二個頁面填完答案回到第一頁面時，會發現雖然訊息顯示答案正確，但是原本的題目卻已經變成另外一組了\n\n![unknown_situation.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/unknown_situation.png)\n\n## 發生了什麼事\n\n如果我們 debug 了一下程式，就會發現一個神奇的狀況：當使用者在第二的頁面點開鍵盤時，第一個頁面就會重新 build 了一次，導致畫面又重新取了一次亂數，新的數字就出現在畫面上。\n\n![1654349336823.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/1654349336823.png)\n\n為什麼麼第二個頁面的動作會影響到第一個頁面呢？讓我們回到第一個頁面的程式碼，仔細觀察與實驗就會發現，是 MediaQuery.of(context) 在搞的鬼。\n\n```dart\nContainer(\n  alignment: Alignment.center,\n  height: MediaQuery.of(context).size.height * 0.6,\n  child: Text(\n    \"What's the number: ${NumberConvertor.toText(randomNumber)}\",\n  ),\n),\n```\n\n如果我們把 MediaQuery.of(context).size.height * 0.6 置換成固定值。\n\n```dart\nContainer(\n  alignment: Alignment.center,\n  height: 500,\n  child: Text(\n    \"What's the number: ${NumberConvertor.toText(randomNumber)}\",\n  ),\n),\n```\n\n當輸入答案回來之後，題目還是維持的原來的題目。\n\n![consistant_result.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/consistant_result.png)\n\n## MediaQuery.of(context) 做了什麼？\n\n如果我們查看 MediaQuery.of(context) 的原始碼，會發現其中有段 context.dependOnInheritedWidgetOfExtractType，如果再往裡面查，會發現這不過是 BuildContext 這個介面上的一個方法。\n\n```dart\nstatic MediaQueryData of(BuildContext context) {\n  assert(context != null);\n  assert(debugCheckHasMediaQuery(context));\n  return context.dependOnInheritedWidgetOfExactType<MediaQuery>()!.data;\n}\n```\n\n實作則需要找到 Element 這個類別。\n\n```dart\n@override\nT? dependOnInheritedWidgetOfExactType<T extends InheritedWidget>({Object? aspect}) {\n  assert(_debugCheckStateIsActiveForAncestorLookup());\n  final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T];\n  if (ancestor != null) {\n    return dependOnInheritedElement(ancestor, aspect: aspect) as T;\n  }\n  _hadUnsatisfiedDependencies = true;\n  return null;\n}\n\n@override\nInheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) {\n  assert(ancestor != null);\n  _dependencies ??= HashSet<InheritedElement>();\n  _dependencies!.add(ancestor);\n  ancestor.updateDependencies(this, aspect);\n  return ancestor.widget;\n}\n```\n\n當執行 dependOnInheritedWidgetOfExactType 時，會把 MediaQuery 的 InheritedElement 塞到 Element 身上的 _dependencies 中，同時也會呼叫 ancestor.updateDependencies，把自己也塞到 InheritedElement 的 _dependents 中。\n\n當 InheritedElement 發生改變時，就會呼叫身上的 notifyClients，從而更新所有的 dependents。\n\n```dart\n@override\nvoid notifyClients(InheritedWidget oldWidget) {\n  assert(_debugCheckOwnerBuildTargetExists('notifyClients'));\n  for (final Element dependent in _dependents.keys) {\n    assert(() {\n      // check that it really is our descendant\n      Element? ancestor = dependent._parent;\n      while (ancestor != this && ancestor != null)\n        ancestor = ancestor._parent;\n      return ancestor == this;\n    }());\n    // check that it really depends on us\n    assert(dependent._dependencies!.contains(this));\n    notifyDependent(oldWidget, dependent);\n  }\n}\n```\n\n回到例子上，也就是當第一個頁面呼叫 MediaQuery.of(context) 時，就已經向 MediaQuery 註冊了一個觀察者，當 MediaQuery 因為鍵盤的出現導致畫面高度發生改變時，第一頁面也就跟著一起重 build 了。\n\n## 如何解決問題\n\n回到我們的問題上，如何讓第一個頁面不要重 build 呢？以上面這個例子來看，目的只是想依照固定高度比例來設計畫面，可以簡單的使用 Column + Expanded 解決。\n\n## 小結\n\n我自己覺得 Flutter 把 Widget 設計得十分方便，讓使用者可以用比較少的程式碼就完成功能，但是其中比較困難的就是許多細節被隱藏在框架之中。像是一般情況下，我們幾乎不會碰到 InheritedWidget，更多的是直接使用他的衍生類別或 Wrapper，在這種情況下，我們就很難知道這行程式碼究竟會帶來什麼影響，進而造成一些不預期的狀況。除了明白如何使用框架，有時也需要深入理解框架做了什麼，才能更有效地使用框架。\n\n## 參考\n\n- 範例程式碼：[https://github.com/easylive1989/chinese_number_validator](https://github.com/easylive1989/chinese_number_validator)\n- Flutter framework.dart：[https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart)",
      "createdAt": "May 10, 2022 11:33 PM",
      "updatedAt": "October 2, 2025 11:53 PM",
      "id": "7073aa4ed07d42d8929752e25fbf71fa",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "畫面莫名其妙地重 build 了 7073aa4ed07d42d8929752e25fbf71fa.md"
    },
    {
      "title": "在 Flutter App 中整合 Google play In-App-Billing",
      "summary": "想在 App 上賺錢有兩種方式，一種是讓 App 本身是付費下載，另一種則是應用程式內購買。如果選擇應用程式內購買的話，在 iOS 上需要整合 Apple In App Purchase，而在 Google Play 上的話，則是需要整合 Google In App Billing，以下簡稱 Goo...",
      "content": "想在 App 上賺錢有兩種方式，一種是讓 App 本身是付費下載，另一種則是應用程式內購買。如果選擇應用程式內購買的話，在 iOS 上需要整合 Apple In App Purchase，而在 Google Play 上的話，則是需要整合 Google In App Billing，以下簡稱 Google IAB，本篇主要紀錄一下整合 Google IAB 的過程。\n\n# 後台設定\n\n在開始整合 Google IAB 之前，需要先準備一個 Google 開發者帳號。當準備好之後，就能使用該開發者帳號登入 Google Play Console ，進入到**應用程式內產品**的的選單中，點選建立產品，然後就可以新增可購買項目。設定完成後並啟用產品，表示這個產品已經上架販售。\n\n![截圖 2021-11-18 上午12.01.53.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-18_%E4%B8%8A%E5%8D%8812.01.53.png)\n\n當購買項目設定完成後，重新整理該頁面就會看到剛剛設定好的購買項目的列表。其中的產品 ID 是表示該購買項目的唯一 ID，稍後也會在程式碼使用中，用以獲取購買項目的詳細資訊。\n\n![截圖 2021-11-18 上午12.05.52.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-18_%E4%B8%8A%E5%8D%8812.05.52.png)\n\n值得注意的是，在設定購買項目之前，需要先上傳包含內購權限的 apk 到 Google Play 上。沒有完成這一步，在設定購買項目的頁面出會發現下面這個訊息，Google Play 提醒你需要上傳有內購權限的 apk。若是 App 還沒有準備要上架，可以先上傳 apk 到內部測試群組。\n\n![截圖 2021-11-17 上午8.47.18.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-17_%E4%B8%8A%E5%8D%888.47.18.png)\n\n除了自己手動到 Google Play 的後台去設定產品，開發人員也可以透過 [Google In App Products API](https://developers.google.com/android-publisher/api-ref/rest/v3/inappproducts) 對產品列表做新增修改刪除，方便開發者客製化自己的後台產品上架流程。\n\n# 整合 Google Play In App Billing\n\n### 安裝套件\n\n在 pub.dev 上，與應用程式內購買的相關的套件有不少，我們選擇使用 Flutter 官方提供的 in_app_purchase。這個套件除了可以用來整合 Google IAB，也同時包含了 Apple IAP。\n\n[**in_app_purchase | Flutter Package***A storefront-independent API for purchases in Flutter apps. This plugin supports in-app purchases ( IAP) through an…*pub.dev](https://pub.dev/packages/in_app_purchase)\n\nin_app_purchase 在 Google IAB 功能實作是基於 Android BillingClient。所以在整合的時候，可以適時參考 [整合 Android BillingClient](https://developer.android.com/google/play/billing/integrate) 的文章，有助於更了解 Google IAB 的核心流程。\n\n### 啟用 PendingPurchase\n\n在 2019 年的 Google I/O 上，Google 宣布 Google Play 將提供 Pending Transactions 功能，讓使用者擁有更多樣的付款方式。在整合 Google IAB 時，我們需要在 main 方法中加上 enablePendingPurchase 的程式碼，讓 App 支援 Pending Transactions 功能。\n\n```dart\nvoid main() {\n  if (defaultTargetPlatform == TargetPlatform.android) {\n    InAppPurchaseAndroidPlatformAddition.enablePendingPurchases();\n  }\n  runApp(MyApp());\n}\n```\n\n### 確保與 Google Play 正常連線\n\nApp 透過這個 API 來確保與 Google Play 正常連線。當手機上沒有 Google Play 或者 Google Play 尚未登入之類的情況，這個 API 回傳的就會是 false。而回傳 false 時，App 也就無法正常購買產品，甚至連產品列表都無法獲得。\n\n```dart\nawait InAppPurchase.instance.isAvailable();\n```\n\n### 獲取產品列表\n\n透過這個 API，App 可以獲取產品的詳細資訊，像是價格與貨幣資訊 ...等。其中需要把產品 ID 列表做為參數傳給這個 API，這個產品 ID 列表需要與 Google Play Console 中設定的一致。取得的回傳值 ProductDetails 也會是稍後購買產品 API 的參數。\n\n```dart\nvar productIds = [\"prodcut_1\", \"product_2\"];\nProductDetailsResponse response =\n    await InAppPurchase.instance.queryProductDetails(productIds);\nif (response.notFoundIDs.isNotEmpty) {\n  // Handle the error.\n}\nList<ProductDetails> products = response.productDetails;\n```\n\n### 購買產品\n\nin_app_purchase 套件提供兩個 API 讓開發者實現購買功能： buyConsumable 和 buyNonConsumable。如何選擇要使用哪個方法，需要開發人員根據產品販售策略來決定。以下是一些比較簡單的原則提供大家參考。\n\n- 當產品會重複販售給使用者多次，使用 buyConsumable。\n- 當產品只能販售給每個使用一次，使用 buyNonConsumable。\n\n```dart\nfinal PurchaseParam purchaseParam = PurchaseParam(productDetails: productDetails);\nif (_isConsumable(productDetails)) {\n  InAppPurchase.instance.buyConsumable(purchaseParam: purchaseParam);\n} else {\n\tInAppPurchase.instance.buyNonConsumable(purchaseParam: purchaseParam);\n}\n```\n\n除此之外，這兩個方法在實作購買流程上會有些許不同，如果是使用 buyNonConsumable 購買產品後，購買成功後需要呼叫 completePurchase，讓 Google Play 知道此次購買已經完成，而 buyConsumable 則不強制。\n\n```dart\nawait InAppPurchase.instance.completePurchase(purchaseDetails);\n```\n\n若是使用 buyNonConsumable 後未呼叫 completePurchase，則會造成 Google Play 認為此筆購買未完成，將導致該筆付款在 3 天後退還給使用者。\n\n### 等待完成購買流程\n\n當呼叫了購買 API 之後，就需要透過 purchaseStream 來監聽購買的狀態，無論是使用者取消購買、購買成功、付款失敗 ...等，都會透過 purchaseStream 來通知 App 購買的狀態。\n\n```dart\n_subscription = InAppPurchase.instance.purchaseStream.listen((purchaseDetailsList) {\n  _listenToPurchaseUpdated(purchaseDetailsList);\n}\n```\n\n而我們能從 PurchaseDetail 中的 status 確認購買狀態並決定 App 相應的行為，例如：處於 PurchaseStatus.pending 時要顯示等待畫面、處於 PurchaseStatus.purchased 時顯示購買成功 ...等，開發者需要依照實際需求實作。\n\n```dart\nvoid _listenToPurchaseUpdated(List<PurchaseDetails> purchaseDetailsList) {\n  purchaseDetailsList.forEach((PurchaseDetails purchaseDetails) async {\n    if (purchaseDetails.status == PurchaseStatus.pending) {\n      // handle pending\n    } \n\n    if (purchaseDetails.status == PurchaseStatus.error) {\n      // handle error\n    } \n\n    if(purchaseDetails.status == PurchaseStatus.purchased || \n       purchaseDetails.status == PurchaseStatus.restored) {\n      // handle purchased\n    }\n  });\n}\n```\n\nGoogle 在整合 BillingClient 的文章中有提到，當購買成功時，建議把購買成功時的 Purchase Token 送到後端，後端能夠透過 [Google Purchase API](https://developers.google.com/android-publisher/api-ref/rest/v3/purchases.products/get) 驗證訂單是否合法，在合法的狀況才把產品交付給使用者。\n\n```dart\nif (purchaseDetails.status == PurchaseStatus.purchased || \n    purchaseDetails.status == PurchaseStatus.restored) {\n  bool valid = await _verifyPurchase(purchaseDetails);\n  if (valid) {\n    _deliverProduct(purchaseDetails);\n  } else {\n    _handleInvalidPurchase(purchaseDetails);\n  }\n}\n```\n\n以上講解的是從 App 端接收訂單資訊並處理，而 Google Play 也提供了另一種從後端處理訂單資訊方式。Google Play 可以透過 Google Pub / Sub 傳送訂單資訊給後端，讓後端接收訂單資訊並驗證訂單，App 則可以省去呼叫後端驗證的工作，更詳細的實作可以參考[這邊](https://developer.android.com/google/play/billing/getting-ready#configure-rtdn)。\n\n# 測試購買流程\n\n當寫完程式碼之後，我們理所當然地需要在測試機裝 Debug 版本測試一下。為了讓 Google Play 允許 Debug 版本也可以測試 Google IAB，我們必須在 Google Play 後台設定**授權測試**，在設定中的帳號使用測試信用卡付費，能夠避免實際付費。透過這個方法，我們就不必頻繁的上傳 App 到 Google Play 上測試，能夠增加開發速度。\n\n![截圖 2021-11-17 上午10.00.43.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-17_%E4%B8%8A%E5%8D%8810.00.43.png)\n\n當授權測試帳號設定完成後，需要先到測試機上的 Google Play 登入該帳號。測試付款流程時，就會看到付款選項中出現 Test Card 的選單。點開之後有更多付款選項，可以用來測試不同的情境，像是 Slow test card 的選項就可以用來測試 Pending 的情況。\n\n![Screenshot_20211117_101352-2.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/Screenshot_20211117_101352-2.png)\n\n![Screenshot_20211117_101442-2.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/Screenshot_20211117_101442-2.png)\n\n最後要提醒的是，如果是使用模擬器來測試，請確保模擬器上有 Google Play 且登入想要用來測試的帳號，這樣才能夠正常測試。否則在確保與 Google Play 連線的步驟會不成功，導致後續流程無法進行。開發人員可以在 AVD Manager 中確認模擬器是否含有 Google Play。\n\n# 結論\n\n本篇紀錄了在 Flutter 上整合 Google IAB 的過程，從商店設定、簡化的流程處理到如何測試付費。其中在流程處理的部分，實際應用上可能會有許多場景需要特別處理，例如：不同支付方式的 Pending 處理、退款的後續處理流程、例外狀況的處理 ...等，需要開發者根據實際情況中思考如何處理。\n\n# 參考\n\n- 整合 Android BillingClient：[https://developer.android.com/google/play/billing/integrate](https://developer.android.com/google/play/billing/integrate)\n- 測試 Google IAB：[https://developer.android.com/google/play/billing/test](https://developer.android.com/google/play/billing/test)",
      "createdAt": "November 15, 2021 10:23 AM",
      "updatedAt": "October 2, 2025 11:51 PM",
      "id": "74e04f6b90ed4369855df505c99dd0ab",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "在 Flutter App 中整合 Google play In-App-Billing 74e04f6b90ed4369855df505c99dd0ab.md"
    },
    {
      "title": "深入瞭解 GetX 的 Obx 與 Rx",
      "summary": "最近在做畫面時，滿常使用 GetX 的 Obx + Rx 變數，讓畫面可以根據狀態變化即時更新。過程中有時會碰到一些錯誤，在建置 Widget 的過程中，因為 Obx 找不到可以被監聽的目標，導致 Obx 認為使用者錯誤的使用了 Obx，所以透過 Exception 來提醒使用者。 Obx 的使用方...",
      "content": "最近在做畫面時，滿常使用 GetX 的 Obx + Rx 變數，讓畫面可以根據狀態變化即時更新。過程中有時會碰到一些錯誤，在建置 Widget 的過程中，因為 Obx 找不到可以被監聽的目標，導致 Obx 認為使用者錯誤的使用了 Obx，所以透過 Exception 來提醒使用者。\n\n![截圖 2021-12-16 下午9.58.38.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%889.58.38.png)\n\nObx 的使用方法是把一個 builder 方法傳給 Obx 這個 Widget，不需要任何 Rx 變數做為參數。像是下面的這個簡單的 count 例子中，Obx 傳入一個 builder 方法，只要 builder 在建置 Widget 的過程中使用 Rx 變數，Obx 就能進行監聽。\n\n![截圖 2021-12-16 下午11.33.43.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.33.43.png)\n\n這就讓我自己十分好奇，Obx 到底是如何找到 builder 方法中的 Rx 變數，然後對這個 Rx 變數進行監聽呢？自己花了一些時間研究和實驗，今天就來分享一下，到底 GetX 中的 Obx 是如何完成他的工作的。\n\n## 兩位主角\n\n在  Counter 例子中，有兩個重要的物件，一個是 Obx，另一個則是存放 count 的 Rx 變數。其中 Obx 身上有一個型態為 RxNotifier 的 _observer 變數，主要用來監聽 Rx 變數並更新畫面的。而存放 count 的 Rx 變數的爺爺也是 RxNotifier。\n\n![3.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/3.png)\n\nRxNotifier 本身沒有任何實作，實作都是集中 NotifyManager 這個 mixin 身上。NotifyManger 身上主要有兩個方法 \n\n1. addListener：用來決定監聽什麼事件\n2. listen：用來決定監聽到事件後，要做什麼事\n\n## Obx 如何更新畫面\n\n當開始 build GetCountView 的畫面並 build 到 Obx 時，程式會先執行 ObxWidget initState() 方法。在 initState() 中執行 _observer.listen，並傳入 _updateTree，讓 _observer 監聽到事件時，可以呼叫 setState 更新畫面。\n\n![截圖 2021-12-20 上午12.57.02.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-20_%E4%B8%8A%E5%8D%8812.57.02.png)\n\n再來程式會走進 ObxWidget 的 build 方法。可以發現 ObxWidget 的 build 方法也就只是轉頭呼叫 RxInterface 的 notifyChildren 靜態方法，並傳入 ObxWidget 身上的 _observer 和 [widget.build](http://widget.build) 。\n\n![截圖 2021-12-16 下午11.36.31.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.36.31.png)\n\n此時的 widget.build 也就是我們在 GetCountView 中傳給 Obx 的那段印出 count 的 builder。\n\n![截圖 2021-12-16 下午11.34.41.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.34.41.png)\n\n當我們在深入 RxInterface.notifyChildren 之後，可以發現在程式會把 ObxWidget 身上的 _observer 塞到一個全域變數 RxInterface.proxy 中。然後繼續執行 builder 並 build 出顯示 count 數的 Text Widget。最後把 RxInterface.proxy 還原成原本的值，然後就回傳結果了。\n\n![截圖 2021-12-16 下午11.21.26.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.21.26.png)\n\n看到這邊好像還是不知道 Obx 到底是如何發現 builder 之中的 RxInt 的，我們只有看到 _observer 被賦予了他要觸發 setState 的工作，但是 _observer 是如何監聽 count 事件呢？\n\n## 在 Getter 中註冊監聽\n\n其實關鍵就在 builder 中。我們回頭看一下使用 Obx 那段程式碼，Text 中使用了 count.value，而關鍵就在這個 value getter 中。\n\n![截圖 2021-12-16 下午11.34.41.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.34.41.png)\n\n讓我們深入看一下 value 這個 getter 是如何被實作的。\n\n![截圖 2021-12-16 下午11.41.09.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.41.09.png)\n\n在使用 value getter 時，程式會向 RxInterface.proxy 這個全域變數註冊一個 subject，還記得先前 RxInterface.notifyChildren 做了什麼嗎，它把 ObxWidget 身上的 _observer 塞給 RxInterface.proxy，此時 value getter 中用的對象就是 ObxWidget 身上的 _observer。最後，當 value 發生變化時， Rx 變數就會透過 subject 通知 _observer。\n\n簡單來說，Obx 與 Rx 變數是透過 RxInterface 這個全域變數作為橋樑，讓兩者可以在 build 的時候建立觀察者模式。當 Rx 變數透過 value setter 賦值時，就能成功通知 ObxWidget 身上的 _observer，_observer 接收到事件之後就觸發 setState()，讓畫面根據新的狀態更新。\n\n## 整理流程\n\n1. GetCounterView 開始建置，隨後呼叫 ObxWidget 的 build 方法\n2. ObxＷidget 的 build 方法被呼叫後，轉頭直接把工作轉交給 RxInterface.notifyChildren，並且傳入 _observer 與 builder\n3. RxInterface 先是把 _observer 放進 RxInterface.proxy 中\n4. RxInterface.notifyChildren 呼叫 builder，建置 builder 中的 Widget\n5. builder 在建置的過程中會使用 count 這個 Rx 變數取得 count 值\n6. 取得 count 值過程中，Rx 也會呼叫 RxInterface.proxy?.addListener，讓 _observer 可以監聽\n\n![GetX 研究.drawio.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/GetX_%E7%A0%94%E7%A9%B6.drawio.png)\n\nps. 實際上並不是由 GetCountView 直接呼叫 [ObxWidget.build](http://Obx.build) 的，這邊只是簡化一下呼叫流程。實際上是由 GetCountView 的 Element 去呼叫的。\n\n## 小結\n\nGetX 作為熱門的 Flutter 狀態管理套件之一，有許多容易使用的 API，其中也大量的使用全域變數 。使用的時候還需要多加考慮一下，用得太多容易導致產品程式碼與套件緊緊相依，不只測試難寫，想抽換狀態管理的套件也會十分麻煩，使用的時候需要多多思考。",
      "createdAt": "December 12, 2021 9:41 PM",
      "updatedAt": "October 2, 2025 11:51 PM",
      "id": "9b167e815ad042cb85b02e7d3639e782",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "深入瞭解 GetX 的 Obx 與 Rx 9b167e815ad042cb85b02e7d3639e782.md"
    },
    {
      "title": "如何在 Flutter 中製作漂浮 Widget",
      "summary": "今天在工作中碰到一個需求，需要顯示漂浮 Widget，類似於 Dialog 那樣漂浮於畫面之上，但是需要客製自己的 Widget。於是自己做了一些研究，研究如何製作這種漂浮於畫面最上層的 Widget，本篇就來分享一下兩種製作漂浮 Widget 的方式。 自己一開始想到最簡單的辦法是，透過在外層使用...",
      "content": "今天在工作中碰到一個需求，需要顯示漂浮 Widget，類似於 Dialog 那樣漂浮於畫面之上，但是需要客製自己的 Widget。於是自己做了一些研究，研究如何製作這種漂浮於畫面最上層的 Widget，本篇就來分享一下兩種製作漂浮 Widget 的方式。\n\n## 使用 Stack\n\n自己一開始想到最簡單的辦法是，透過在外層使用 Stack，並在 Stack 放入 child 與漂浮 Widget，讓漂浮 Widget 蓋在 child 之上，達到漂浮 Widget 可以漂浮在 child 之上，最後提供一個控制顯示的方法，讓使用端可以傳入客製化 Widget。\n\n```dart\nclass FloatingWidgetState extends State<FloatingWidget> {\n  Widget? _floatingWidget;\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        widget.child,\n        if (_floatingWidget != null)\n          Center(\n            child: _floatingWidget,\n          ),\n      ],\n    );\n  }\n\n  void show(Widget child) {\n    setState(() {\n      _floatingWidget = child;\n    });\n  }\n}\n```\n\n在 Widget 中提供 of 方法讓使用端更方便使用\n\n```dart\nclass FloatingWidget extends StatefulWidget {\n  final Widget child;\n\n  const FloatingWidget({Key? key, required this.child}) : super(key: key);\n\n  @override\n  FloatingWidgetState createState() => FloatingWidgetState();\n}\n```\n\n使用端則是可以透過 context 找到 FloatingWidget，並呼叫 show() 傳入客製化 Widget 並顯示畫面上層。\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: FloatingWidget(\n        child: Scaffold(\n          appBar: AppBar(title: Text(\"Floating Widget Example\")),\n          body: Builder(\n            builder: (context) {\n              return ElevatedButton(\n                onPressed: () {\n                  FloatingWidget.of(context).show(\n                    Card(\n                      elevation: 5.0,\n                      child: Padding(\n                          padding: EdgeInsets.all(8),\n                          child: Text(\"My Floating Widget\")),\n                      color: Colors.blue,\n                    ),\n                  );\n                },\n                child: Text(\"Click Me\"),\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n使用 Stack 的做法有個缺點，根據放置 FloatingWidget 的地方不同，它能蓋住的層級也會不同。如果想讓所有 Route 都能使用 FloatingWidget，就需要把 FloatingWidget 放在 MaterialApp 之上。但是若把 Stack 直接放在 MaterialApp 之外，執行時就會報錯，會需要額外處理。\n\n## 使用 Overlay\n\nFlutter 定義好的 MaterialApp 中包了很多東西，其中就包含了 Overlay 這個 Widget，透過這個 Widget，我們可以客製我們想要的 Widget，並使之漂浮於畫面最上層。\n\n```dart\nOverlay.of(context)?.insert(\n  OverlayEntry(\n    builder: (context) {\n      return Text(\"My Floating Widget\");\n    },\n  ),\n);\n```\n\n當要移除時，則需要使用剛剛 insert 進去的 OverlayEntry，所以使用端需要暫存 OverlayEntry。\n\n```dart\nclass MyApp extends StatelessWidget {\n  final OverlayEntry _overlayEntry = OverlayEntry(\n    builder: (context) {\n      return Center(\n        child: Card(\n          elevation: 5.0,\n          child: Padding(\n            padding: EdgeInsets.all(8),\n            child: Text(\"My Floating Widget\"),\n          ),\n          color: Colors.blue,\n        ),\n      );\n    },\n  );\n\n  MyApp({Key? key}) : super(key: key);\n\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(\"Floating Widget Example\")),\n      body: Builder(\n        builder: (context) {\n          return ElevatedButton(\n            onPressed: () {\n              if (_overlayEntry.mounted) {\n                _overlayEntry.remove();\n              } else {\n                Overlay.of(context)!.insert(_overlayEntry);\n              }\n            },\n            child: Text(\"Click Me\"),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n使用 Overlay 做法相對於 Stack 作法來說，使用上比較方便一點。但免不了還是有一些缺點。使用 OverlayEntry 所產生的 Floating Widget 會漂浮於畫面最上層，甚至是所有 route 之上。當使用端 insert 了一個 Floating Widget，如果沒有先移除這個 Floating Widget 就 route 到其他頁面，就會發現 Floating Widget 仍舊漂浮於新頁面之上。所以使用 Overlay 做法時，會需要花一些心思控制 Floating Widget 的顯示與隱藏時機，讓 UI 顯示邏輯更合理。\n\n## 小結\n\n其實在 [pub.dev](http://pub.dev) 上已經有不少套件能顯示客製的漂浮 Widget 了，我自己最後也是直接使用套件。畢竟套件若能完美貼合自己的需求，那就沒有必要再自己造一個輪子了。但是經過一些研究，才發現還有 Overlay 這個 Widget 存在，也對 Flutter 更瞭解了一些。",
      "createdAt": "October 11, 2021 9:51 PM",
      "updatedAt": "October 2, 2025 11:50 PM",
      "id": "16d979fd41d74ed3b30deb840cd3df87",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "如何在 Flutter 中製作漂浮 Widget 16d979fd41d74ed3b30deb840cd3df87.md"
    },
    {
      "title": "Flame 測試驅動開發俄羅斯方塊",
      "summary": "這邊文章拖了好久，終於有空來完成它了。 去年在練習如何使用 [Flame](https://docs.flame-engine.org/latest/)，這是一個用 Flutter 的遊戲引擎，之前也用 Flame 做了許多小作品，為了練習與了解引擎，在這些過程中都沒有嘗試寫測試。所以又想了一個新的...",
      "content": "這邊文章拖了好久，終於有空來完成它了。\n\n去年在練習如何使用 [Flame](https://docs.flame-engine.org/latest/)，這是一個用 Flutter 的遊戲引擎，之前也用 Flame 做了許多小作品，為了練習與了解引擎，在這些過程中都沒有嘗試寫測試。所以又想了一個新的專案想來練習，針對如何對 Flame 遊戲進行測試。\n\n那到底要寫什麼遊戲呢？之前用 Flame 做過小朋友下樓梯、打磚塊 …等古老遊戲，幾經思考過後，決定嘗試寫一個俄羅斯方塊。在實踐的部分，既然要寫測試，我想想不然乾脆就用測試驅動開發的方式來完成一個俄羅斯方塊吧。\n\n雖然是要製作一個俄羅斯方塊，但是其實並不會真的把所有俄羅斯方塊有的功能都做出來，例如：顯示下一個方塊、T 轉、多等級關卡等等。\n\n我們必須從需求分析開始，思考俄羅斯方塊有什麼功能，有了功能，我們才能知道我們要做什麼，才能知道我們要怎麼做。\n\n- 六種方塊：L N Z I\n- 一次掉落一個方塊\n- 消除一列\n- 計分\n    - 消除 1 列：40 分\n    - 消除 2 列：100 分\n    - 消除 3 列：300 分\n    - 消除 4 列：1200 分\n\n練習把需求拆小，讓我們可以一步一步的把產品開發出來，而不是一口氣做到完整。",
      "createdAt": "June 23, 2023 4:17 PM",
      "updatedAt": "October 2, 2025 11:49 PM",
      "id": "ca6aa2957a3340ed972c7ba8d76e126e",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "Flame 測試驅動開發俄羅斯方塊 ca6aa2957a3340ed972c7ba8d76e126e.md"
    },
    {
      "title": "Flutter Theme 切換效果研究",
      "summary": "許多 App 都會支持 Light 模式與 Dark 模式，增加使用者體驗，為了做到這個功能，我們可以使用內建 Theme 加上 StatefulWidget 或其他狀態管理套件，就可以輕鬆完成 Light 模式與 Dark 模式。讓我們看看一個簡單的例子。 ```dart main() {   r...",
      "content": "![_fd765116-9712-4098-b0e3-e0cde699eff3.jpeg](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/_fd765116-9712-4098-b0e3-e0cde699eff3.jpeg)\n\n許多 App 都會支持 Light 模式與 Dark 模式，增加使用者體驗，為了做到這個功能，我們可以使用內建 Theme 加上 StatefulWidget 或其他狀態管理套件，就可以輕鬆完成 Light 模式與 Dark 模式。讓我們看看一個簡單的例子。\n\n## 簡單的切換主題\n\n```dart\nmain() {\n  runApp(const MainApp());\n}\n\nclass MainApp extends StatefulWidget {\n  const MainApp({super.key});\n\n  @override\n  State<MainApp> createState() => _MainAppState();\n}\n\nclass _MainAppState extends State<MainApp> {\n  bool isDark = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: isDark ? ThemeData.dark() : ThemeData.light(),\n      home: Scaffold(\n        body: const Center(\n          child: Text(\"Hello World\"),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: const Icon(Icons.refresh),\n          onPressed: () => setState(() => isDark = !isDark),\n        ),\n      ),\n    );\n  }\n}\n```\n\n我們在 StatefulWidget 中維護了 isDark 變數，當使用者按下左下角按鈕時，就會更新 isDark，並設定不同模式的 ThemeData 給 MaterialApp，藉此達到切換 Light / Dark 模式的效果，而在切換過程中，Flutter 也會幫我們用漸變的方式切換主題，而不是一瞬間就切換完成，增加視覺效果。\n\n![Discuss - Theme switch.jpg](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/Discuss_-_Theme_switch.jpg)\n\n## 自定義的 ThemeExtension\n\n有些時候，當我們的設計不是遵循 Material Design 的話，Flutter 提供的 Theme 就會不足以完成我們的需求，此時我們就會使用 ThemeExtension 的功能來擴充 Theme，讓整個 App 都可以使用一致的設計。下面是一段我們自定義的 ThemeExtension，其中除了自定義的顏色設計之外，我們還需要實作 copyWith 與 lerp 方法。\n\n```dart\nclass MyThemeExtension extends ThemeExtension<MyThemeExtension> {\n  final Color backgroundColor;\n\n  MyThemeExtension(this.backgroundColor);\n\n  @override\n  ThemeExtension<MyThemeExtension> copyWith() {\n    // TODO: implement copyWith\n    throw UnimplementedError();\n  }\n\n  @override\n  ThemeExtension<MyThemeExtension> lerp(covariant MyThemeExtension other, double t) {\n    // TODO: implement lerp\n    throw UnimplementedError();\n  }\n}\n```\n\n還記得剛剛提到的，切換 Light / Dark 模式時，Flutter 會用漸變的方式，讓畫面漸漸的從 Light 模式轉變為 Dark 模式 (其實動畫時間很短，一下次就轉換完成 XD)，為了讓自定義的 ThemeExtension 也能享受到這個效果，實作 lerp 方法就很重要了。lerp 方法會傳入要轉換的 Theme 與動畫時間，讓我們可以自行決定顏色在轉換過程中如何變化，在這邊我們簡單地使用 Color.lerp 來協助做線性轉換即可。\n\n```dart\n@override\nThemeExtension<MyThemeExtension> lerp(covariant MyThemeExtension other, double t) {\n  return MyThemeExtension(\n    Color.lerp(backgroundColor, other.backgroundColor, t)!,\n  );\n}\n```\n\n當我們實作了 lerp 方法之後，再次打開 App 切換 Light / Dark 模式，會發現我們自定義的顏色也能在切換過程中有平滑的視覺效果。\n\n![Discuss - Theme Switch 2.jpg](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/Discuss_-_Theme_Switch_2.jpg)\n\n完整效果請參考[這邊](https://dartpad.dev/?id=1264772a9ffa905f346a1d2c5a8c02a6)。\n\n## 更酷炫的切換動畫\n\n在研究 Light / Dark 模式切換的過程中，發現了很特別切換效果，詳細可以參考[這邊](https://stackoverflow.com/questions/60897816/how-to-add-animation-for-theme-switching-in-flutter)。當使用者切換模式時，畫面會由左上角開始轉換，並往右下角輻射，直到所有畫面都轉換完成，讓我們直接看看下面圖片。\n\n![螢幕錄影_2023-06-24_上午12_04_38_AdobeExpress.gif](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/%25E8%259E%25A2%25E5%25B9%2595%25E9%258C%2584%25E5%25BD%25B1_2023-06-24_%25E4%25B8%258A%25E5%258D%258812_04_38_AdobeExpress.gif)\n\n與 Flutter 預設的切換方式不同，這種切換方式更令人眼睛一亮，讓我們來看看這是如何做到的。其實要做到這個效果也並不複雜，主要原理是使用 Stack + ClipPath 來完成，簡單來說就是，先在 Stack 中疊上 Light 模式 Widget，然後再疊上被 ClipPath 裁切過的 Dark 模式 Widget，最後透過動畫來慢慢放大被裁切的 Dark 模式 Widget，最後填滿的畫面。如此一來，就能完成這個酷炫的 Light / Dark 模式切換效果。\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return AnimatedBuilder(\n    animation: _animationController,\n    builder: (BuildContext context, Widget? child) {\n      return Stack(\n        children: [\n          Theme(\n            data: _getTheme(widget.isDark),\n            child: widget.builder(context),\n          ),\n          ClipPath(\n            clipper: CircularClipper(\n              1.5 * MediaQuery.of(context).size.height * _animationController.value,\n              Offset.zero,\n            ),\n            child: Theme(\n              data: _getTheme(!widget.isDark),\n              child: widget.builder(context),\n            ),\n          ),\n        ],\n      );\n    },\n  );\n}\n```\n\n完整效果請參考[這邊](https://dartpad.dev/?id=883cd4304e8f0a032d5d3a3f87dced70)。\n\n## 小結\n\n為 App 增加一些轉場特效，像是我們今天分享的 Light / Dark 模式切換，或者是 Routing 時的 Transition 效果，都能有效增加使用者體驗，讓 App 看起來更加精緻。",
      "createdAt": "June 23, 2023 11:19 PM",
      "updatedAt": "October 2, 2025 11:49 PM",
      "id": "cfabe2e638ef4210bdc9660155dcdfa5",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "Flutter Theme 切換效果研究 cfabe2e638ef4210bdc9660155dcdfa5.md"
    },
    {
      "title": "Vibe Coding 回顧",
      "summary": "今年 AI 能力大躍進，不斷地在社群或網路看到別人說大部分的 Code 都是由 AI 產生，讓我不禁開始懷疑自己的開發方式。去年我還只是拿著 Github Copilot 當作更智能自動補完工具，完全沒有感覺這東西是能有大改變，覺得 AI 終究只是從上下文來預測結果，終究是有其極限。 在三月的時候，...",
      "content": "今年 AI 能力大躍進，不斷地在社群或網路看到別人說大部分的 Code 都是由 AI 產生，讓我不禁開始懷疑自己的開發方式。去年我還只是拿著 Github Copilot 當作更智能自動補完工具，完全沒有感覺這東西是能有大改變，覺得 AI 終究只是從上下文來預測結果，終究是有其極限。\n\n在三月的時候，剛好在 Flutter Taipei Meetup 聽了有兩個關於 AI 的主題，這才發現或許 AI 已經進步到超乎我想像的地步了，是時候改變思維，擁抱變化了。至今大約 Vibe Coding 了半年多，剛好最近想法上有轉變（最後會提到），所以先來回顧一下這半年的 AI 使用心得了。\n\n三月那會兒，最流行的 AI 工具大概也就是 Cursor 或 Winsurf，有鑒於之前買了一年的 Github Copilot 的教訓，這次就來一個月、一個月的買 Cursor。那買了 Cursor 要用在什麼地方呢？首先在除了在工作中的產品嘗試之外，當時有個朋友找我弄個小小的自動化工具，想想這也是個挺好的機會，就來用 Vibe Coding 的方式來建立這個小工具吧。\n\n## 開始 Vibe Coding\n\n在開始這個 Side Project 時，我刻意選擇了自己幾乎不太懂的語言加框架，用 Electron + React + Playwright 來做一個自動化的爬蟲工具，希望自己能在開發的過程中學會這些技能（雖然事後看起來效果並不算太好）。\n\n一開始就像坊間常見的 Vibe Coding 分享一樣，直接開始跟 AI 對話，說明我想要什麼功能，要用什麼技術，從最基礎的畫面，一點一點的增加新功能。由於我對 Electron 也不熟，加上人的惰性，所以大多時候，只要功能正常，且我看的懂它在寫什麼，生成的 Code 我大多都直接接受，不太會進一步修改。\n\n### 失去動手改的能力\n\n但是這樣有個缺點，那就是我只看得懂，要自己動手改就比較難。變成任何小改動，我都是請AI 來做，而不是自己做。熟悉使用 AI 工具的人也都知道，AI 一跑起來快一點也要三四十秒、一分鐘的，甚至還有更久的。但是如果知道怎麼改而且熟悉工具的話，自己改可能也不到 AI 一半時間。\n\n我在自己的工作中也會使用 AI，常常會在內心評估每個改動到底是自己改比較快，還是 AI 改比較快。但是在不熟悉的技術中，這個評估幾乎變得沒有意義，因為幾乎都是 AI 改比較快。越常讓 AI 來改，就越加不可能出現自己改比較快的情況。\n\n或許看起來有一些負面影響，但我想這應該就是趨勢，單一任務或許 AI 做起來比較慢，但是 AI 可以同步執行多個任務，理論上來說應該會增加生產力（前提是任務沒有相依）。\n\n> AI 削弱了開發人員自己實作的能力，但是也開啟工作同步執行的能力。就像手工製作與工廠生產，單一機器的效率中難以跟真人匹敵，但是大量機器 24 小時同時運轉就不是人類可以比較的。\n> \n\n### 只有一個 AI 不夠\n\n在開發的過程中，碰到一個問題：打包 macOS 應用程式失敗。在本地端打包都沒什麼問題，但是上 CI 打包建置卻一直出錯。由於 Cursor 並無法直接讀到 Github Action 的結果，所以只好手動貼錯誤給 Cursor（或許現在有 MCP 能做到了？），請 Cursor 修復 Github Workflow 腳本。\n\n但即便如此，Cursor 還是一直鬼打牆，無法真正的解決問題。最後只好把 Github Workflow 腳本、Github Action 錯誤，再加上我想做的事情的 Context 通通整理貼到 Claude 與 Gemini 去問，而且兩者的回答還都不同，只好自己交叉比對結果與實驗，最後才讓打包工作能在 CI 上完成。\n\n> 讓 AI 自動改 Code 非常方便，但也意味著她也只選擇一種方向來處理，方向是對是錯，是好還是壞，還是得要依靠人的判斷。\n> \n\n## 免不了，也快不了的學習\n\n本想靠著 AI 實際做個東西，藉此在開發的過程中快速學一門新技術，但事後看起來還是有一定的極限，沒有想像中的這麼美好。\n\n### Electron 線程的坑\n\n最初是這個工具只有使用 Electron，而沒有 React，程式也是在 Electron 中啟動 Playwright 腳本。後來加入 React 之後，想把啟動 Playwright 腳本的工作也搬到 React 中，卻怎麼一直都無法正常運作。幾過一番折騰才了解 Playwright 只能由 Node.js 啟動，所以只能放在 Electron 中，讓 React 跟 Electron 溝通呼叫腳本，無法放在 React 中。\n\n這件工作也是來來回回請 AI 改了好幾次，每一次改就壞，過程中也出現奇奇怪怪的改法，看著都不太對勁。最後也是直接問了 AI 是否這個任務其實是有問題的，AI 才說了上面提到的問題（但也很有可能這結論也是錯的XD）。\n\n> AI 會盡全力滿足你的要求，即便這的要求不合理。如果沒有了人的判斷，可以想像如果開發時間一長，技術債會快速累積。\n> \n\n### 測試的難處\n\n同樣的問題也發生在測試，自己對測試的概念還算熟悉，本來想模仿工作中測試方式，用比較大粒度的方式來測試這個工具。與常見小粒度的測試方式不同，可能訓練資料比較缺乏，所以無論我怎麼跟 AI 溝通，都得不到理想的結果。\n\n原因可能是自己對技術的理解不夠，無法有效用該技術常見的用語與 AI 溝通，導致 AI 無法完成我想要的結果。另外一種可能是，這根本就是做不到的，但對這個語言與框架理解有限的我，也無法知道這件事。\n\n> 即便使用了 AI ，我們還是得學習相關技術，否則既限制了上限，也會浪費許多時間。\n> \n\n## 下一步\n\n最後，我已經對這個 Side Project 失去了興趣，暫時不會在這個 Side Project  上繼續 Vibe Coding。同時最近也從 Cursor 跳槽到 Claude Code，所以就趁這些轉變，回顧一下這半年的過程，總結一下 Vibe Coding 不熟悉技術的體驗。\n\n但這終究不是現實的常態，現在對於大部分開發人員來說，工作中使用的還是自己比較熟悉的技術，只是需要摸索與 AI 如何共生。自己也打算開始另外一個 Side Project，這次會使用自己熟悉的技能模仿實際工作中的流程來 Vibe Coding，看看能否帶來開發上的改變。\n\n## 小結\n\n透過這次 Vibe Coding 的過程，感受到動口不動手的快感，但也更清楚感受到 AI 的限制。無論如何，AI 已經開始改變了開發人員的工作方式，既要放下成見，接受 AI 的結果，也要持續學習，不斷反思與改善這個過程。",
      "createdAt": "August 7, 2025 8:15 PM",
      "updatedAt": "September 21, 2025 10:09 PM",
      "id": "2488303f78f7804eb849e2bb796fa8ca",
      "type": "Medium",
      "tag": "AI Coding",
      "filename": "Vibe Coding 回顧 2488303f78f7804eb849e2bb796fa8ca.md"
    },
    {
      "title": "Container - 一個你最熟悉又最陌生的 Widget",
      "summary": "AI summary: Container 在 Flutter 中的行為複雜，設定大小後會拉大子 Widget，使用 alignment 可以解決此問題。深入了解 Container 的 build 方法和原始碼有助於開發者更有效地處理佈局問題。 每次在開發的時候，碰到不如預期的狀況時，都是一個非常...",
      "content": "AI summary: Container 在 Flutter 中的行為複雜，設定大小後會拉大子 Widget，使用 alignment 可以解決此問題。深入了解 Container 的 build 方法和原始碼有助於開發者更有效地處理佈局問題。\n\n每次在開發的時候，碰到不如預期的狀況時，都是一個非常好的機會，可以讓我們更深了解某些事。\n\n最近在開發的時候又碰到一些意料之外的事，經過一些實驗，終於定位了問題點。\n\n讓我們看看以下這段程式碼，在這段程式碼中，我們指定了 Container 的大小為 300 x 300，同時也指定 child 中的 Image 大小為 30 x 30。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: Image.asset(\n    \"assets/images/blog.png\",\n    width: 30,\n    height: 30,\n  ),\n)\n```\n\n大家可以在腦海中想像一下，這段程式碼在畫面中會呈現成什麼樣子？是否會覺得下圖這樣呢？\n\n![align_center.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/align_center.png)\n\n但結果卻是 Container 把 Image 也拉大到 300 x 300 了。\n\n![no_align.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/no_align.png)\n\n觀眾們可能會想，都設定圖片大小了，怎麼還是會被放到最大呢？\n\n顯然肯定有個人在搞鬼，今天就來看看這個搞鬼的人：**Container**。\n\n## Container 的行為\n\nContainer 作為開發 Flutter App 最常用的 Widget 之一，其實有著相當複雜的行為。如果我們看到[官方文件](https://api.flutter.dev/flutter/widgets/Container-class.html)，會發現其中有一段文字在描述 Container 的行為。\n\nContainer 的佈局行為按以下順序進行：\n\n- 優先遵循 `alignment`。\n- 根據 child 的大小來決定自身大小。\n- 遵循 `width`、`height` 和 `constraints`\n- 擴展以適配父級大小。\n- 嘗試盡量小化自身大小。\n\n若是調整一下剛剛的例子，把 `width` 與 `height` 拿掉。\n\n```dart\nContainer(\n  color: Colors.pinkAccent,\n  child: Image.asset(\n    \"assets/images/blog.png\",\n    width: 30,\n    height: 30,\n  ),\n)\n```\n\n此時就會發現，Container 就遵循了第二條規則：**根據 child 大小來決定自身大小**。\n\n![截圖 2024-12-19 晚上11.33.09.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.33.09.png)\n\n設定了 `width` 與 `height` 後，到底實際發生了什麼事呢？讓我們深入 Container 的 build 方法一探究竟。\n\n## Container 的 build 方法\n\n當我們設定了 `width` 或 `height` 而沒有給 `constraints` 時，實際上 Container 會幫我們生成一個 `BoxConstraints.tightFor(width: width, height: height)`。\n\n```dart\nContainer({\n    // 省略...\n  }) : // 省略 ...,\n       constraints =\n        (width != null || height != null)\n          ? constraints?.tighten(width: width, height: height)\n            ?? BoxConstraints.tightFor(width: width, height: height)\n          : constraints;\n\n```\n\n`tighFor` 方法會限制 Widget 的大小，指定 Widget 的寬高，那這個 BoxConstraints 會用在哪邊呢？\n\n```dart\nconst BoxConstraints.tightFor({\n    double? width,\n    double? height,\n  }) : minWidth = width ?? 0.0,\n       maxWidth = width ?? double.infinity,\n       minHeight = height ?? 0.0,\n       maxHeight = height ?? double.infinity;\n\n```\n\n在 build 方法中，我們可以看到剛剛的 constraints 被放在 ConstrainedBox 中，用來限制 Container 的子 Widget。以上面的例子來說，被限制的 Widget 就是放入的 child 的 Image。\n\n```dart\n@override\nWidget build(BuildContext context) {\n  // Container 的 build 方法\n  // 省略 ...\n\n  if (constraints != null) {\n    current = ConstrainedBox(constraints: constraints!, child: current);\n  }\n\n  // 省略 ...\n\n  return current!;\n}\n```\n\n所以也就使得了 Image 被拉到與 Container 一樣大小。\n\n## 使用 alignment\n\n熟悉 Flutter 的開發人員肯定對這狀況也不陌生，知道加上 alignment 參數就能解決問題。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  alignment: Alignment.center,\n  child: Image.asset(\n    \"assets/images/blog.png\",\n    width: 30,\n    height: 30,\n  ),\n)\n\n```\n\n那為什麼在 Container 中加上 `alignment` 時，圖片就能維持當初設定的大小呢？讓我們再次看回 Container 的 build 方法中。\n\n```dart\n@override\nWidget build(BuildContext context) {\n  // Container 的 build 方法\n  // 省略 ...\n\n  if (child == null && (constraints == null || !constraints!.isTight)) {\n    // 省略 ...\n  } else if (alignment != null) {\n    current = Align(alignment: alignment!, child: current);\n  }\n\n  // 省略 ...\n\n  if (constraints != null) {\n    current = ConstrainedBox(constraints: constraints!, child: current);\n  }\n\n  // 省略 ...\n\n  return current!;\n}\n\n```\n\n當 `alignment` 不為 null 時，就會在 child 外面包上一層 Align，接著才是在 Align 外面再包上 ConstrainedBox。這樣一來，就使得實際被拉大的是 Align，而非 Image。\n\n如果有認真看 Container 原始碼的觀眾可能會問，即便我沒有設定 `alignment`，但我有設定 `color`，而 ConstrainedBox 的下一層 child 應該是 ColoredBox，所以要拉大也是拉大 ColoredBox，而不應該是 Image 吧？\n\n```dart\n@override\nWidget build(BuildContext context) {\n  // Container 的 build 方法\n  // 省略 ...\n\n  if (child == null && (constraints == null || !constraints!.isTight)) {\n    // 省略 ...\n  } else if (alignment != null) {\n    current = Align(alignment: alignment!, child: current);\n  }\n\n  if (color != null) {\n    current = ColoredBox(color: color!, child: current);\n  }\n\n  // 省略 ...\n\n  if (constraints != null) {\n    current = ConstrainedBox(constraints: constraints!, child: current);\n  }\n\n  // 省略 ...\n\n  return current!;\n}\n```\n\n的確，ColoredBox 確實會被拉大，但是 ColoredBox 也直接把上頭來的 constraints 直接轉送給了他的 child。在這兩種狀況中，雖然 Image 上層還有其他 Widget，但是卻有不同的結果。\n\n若繼續深入 Align 與 ColoredBox 的佈局方式，很快就有答案了。\n\n一路追蹤 ColoredBox 的原始碼：ColoredBox -> _RenderColoredBox -> RenderProxyBoxWithHitTestBehavior -> RenderProxyBox，最後可以發現 ColoredBox 繼承了 RenderProxyBox。在 RenderProxyBox 的佈局中，其實也就只是把自己收到的限制，直接原封不動的傳給子 Widget，所以即便中間多墊了一層 ColoredBox，也不能避免 Image 被拉大的效果。\n\n```dart\n@override\nvoid performLayout() {\n  size = (child?..layout(constraints, parentUsesSize: true))?.size\n      ?? computeSizeForNoChild(constraints);\n  return;\n}\n```\n\n接著看到 Align，Align 繼承了 RenderPositionedBox。在 RenderPositionedBox 的佈局中，我們可以發現，它從上頭接收到了限制，接著轉頭就將限制放寬，讓子 Widget 可以挑選他希望的大小。所以在 Align 中，Image 可以維持當初設定的 30 x 30 的大小。\n\n```dart\n@override\nvoid performLayout() {\n  final BoxConstraints constraints = this.constraints;\n\n  // 省略 ...\n\n  if (child != null) {\n    child!.layout(constraints.loosen(), parentUsesSize: true);\n\n    // 省略 ...\n\n  } else {...}\n}\n```\n\n## 實驗放入不同的 Widget\n\n最後讓我們做一些實驗，如果採用相同 Container 設定，但是在 child 中放入不同東西，看看會發生什麼事？\n\n### 放入指定大小的 Container\n\n與 Image 一樣，放入了指定大小的 Container，結果這個 Container 還是被拉大到 300 x 300。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: Container(\n    width: 100,\n    height: 100,\n    color: Colors.blueAccent,\n  ),\n)\n```\n\n![截圖 2024-12-19 晚上11.43.51.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.43.51.png)\n\n### 放入 TextButton\n\n乍看之下，放入的 TextButton 好像沒被拉大，但實際上卻是有的，我們可以從 Hover 效果看出，按鈕還是被拉大了。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: TextButton(\n    onPressed: () {},\n    child: const Text('Click me'),\n  ),\n)\n```\n\n![截圖 2024-12-19 晚上11.47.46.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.47.46.png)\n\n### 放入 Text\n\n當我們試到 Text 的時候，卻發現 Text 好像就沒被拉大的問題，這又是怎麼一回事呢？\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: const Text(\"Hello World\"),\n)\n```\n\n![截圖 2024-12-19 晚上11.35.25.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.35.25.png)\n\n關於這個問題，有機會再讓我們深入探討，好奇的觀眾也可以先自行研究看看。\n\n## 小結\n\nContainer 做為我們最常使用的 Widget 之一，了解他如何運作對於開發必然有些幫助。雖然不是每天都會碰到 Widget 排版不如預期的問題，但是每次碰上就會相當困擾，需要花許多時間嘗試才能解決。\n\n追蹤原始碼，了解 Widget 底層的運作邏輯，能夠提供我們更多解決問題的思路。當未來碰上問題時，就能用正確又快速的方式解決，而不是留下更多的 Workaround。",
      "createdAt": "December 24, 2024 12:10 AM",
      "updatedAt": "September 9, 2025 8:08 AM",
      "id": "1658303f78f780648388f15ef489fe47",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "Container - 一個你最熟悉又最陌生的 Widget 1658303f78f780648388f15ef489fe47.md"
    },
    {
      "title": "不可不知的 Flutter App 自動化測試實戰攻略",
      "summary": "[2022](https://ithelp.ithome.com.tw/users/20129825/ironman/4992)、[2023](https://ithelp.ithome.com.tw/users/20129825/ironman/5974) 連續參加了兩年鐵人賽，分別談論 Flut...",
      "content": "[2022](https://ithelp.ithome.com.tw/users/20129825/ironman/4992)、[2023](https://ithelp.ithome.com.tw/users/20129825/ironman/5974) 連續參加了兩年鐵人賽，分別談論 Flutter 的設計與測試兩項議題，也連續兩年有幸獲得佳作，也就索性以 23 年的文章為主軸，將這些年來的開發經驗整理成冊：[不可不知的 Flutter App 自動化測試實戰攻略：從設計到測試、維持產品品質的高效實踐](https://www.tenlong.com.tw/products/9786264140010?list_name=c-flutter)。\n\n自從七年前接觸了敏捷開發，陸續上了許多課程與看了許多書，很多敏捷開發與 XP 相關實踐已是日常發開中一部分。其中測試就是十分重要的一環，例如軟體開發人員最耳熟能詳的 TDD (測試驅動開發) 便是其中的一部分。\n\n雖然說寫測試並不困難，上網搜尋或問 ChatGPT 很快就能得到答案，但是通常這些答案都是比較片段，著重於如何寫，與如何融入日常開發仍有一段距離。所以本書特別著重介紹測試的部分，並實際測試一個完整小專案，讓讀者能夠以俯視角全面觀察測試如何應用在專案的每個部分。\n\n### 本書內容\n\n書中使用了一個已經完成的 Puzzle 專案，帶領讀者一步一步的來測試專案中的每的部分，從單元測試、Widget 測試到整合測試，從基礎到進階，帶領讀者深入探討自動化測試的奧秘。\n\n![MP22459_封面3校_1107_page-0001.jpg](%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%20Flutter%20App%20%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6%E5%AF%A6%E6%88%B0%E6%94%BB%E7%95%A5/MP22459_%25E5%25B0%2581%25E9%259D%25A23%25E6%25A0%25A1_1107_page-0001.jpg)\n\n除了介紹測試的寫法之外，也會帶入不同場景的測試該怎麼做，以及如何處理常見的測試難題。此外，書中還談論了如何重構測試，讓測試即便在數量變多，專案變大時，也能夠更輕鬆地維護這些測試。\n\n對自動化測試有興趣的朋友，有歡迎參考看看。\n\n雖然筆者在日常開發上會運用 TDD，但是 TDD 在本書中只有在末段的時候簡單帶過，沒有詳細討論，如果追著 TDD 而來的朋友可能失望。其主要是因為本書偏基礎向，但是使用 TDD 的前提是要熟練測試的各種基礎與進階技巧，如果連測試技巧都還沒熟練，TDD 起來也大概不順暢。不過要是對於如何在 Flutter 上 TDD 有興趣的朋友，非常歡迎聯絡我一起討論。\n\n### 後續\n\n在寫這本書的時候，筆者其實就有本著某些想法來安排，而當這些想法從別人的口中說出時，又是特別的感動。\n\n![Pasted image 20241229211234.png](%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%20Flutter%20App%20%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6%E5%AF%A6%E6%88%B0%E6%94%BB%E7%95%A5/Pasted_image_20241229211234.png)\n\n筆者也只是一個學習者，很多觀念都是從許多教練身上或大師的書中獲得，所以在寫的時候附上許多相關資源。不得不說，比起本書，這些相關資源更加來得重要，也超級無敵推薦讀者閱讀。本書只是將這些重要觀念用更具體的例子呈現，讓讀者更容易了解。（講更不好聽一些，筆者的書可以不看，大師的書可不能不讀，希望編輯不會打我XD）\n\n![Pasted image 20241229210021.png](%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%20Flutter%20App%20%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6%E5%AF%A6%E6%88%B0%E6%94%BB%E7%95%A5/Pasted_image_20241229210021.png)\n\n筆者當初在寫的時候也確實希望 Flutter 只是一個範例，背後的軟體開發觀念才是真正重要的東西，希望這些觀念能帶領讀者走得更遠。帶著這些觀念，即便未來換了語言或工具，不再使用 Flutter 了，也能將這些觀念運用在開發工作中。\n\n之後筆者也會在明年 (2025) 的台中社群有一場分享，主題是筆者在公司使用 Flutter 測試的心路歷程。最後，無論你是否有購買本書，有任何問題也歡迎隨時聯絡我，謝謝大家。",
      "createdAt": "December 29, 2024 10:10 PM",
      "updatedAt": "September 9, 2025 8:08 AM",
      "id": "16b8303f78f78005aefdf9f0fe3d57cc",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "不可不知的 Flutter App 自動化測試實戰攻略 16b8303f78f78005aefdf9f0fe3d57cc.md"
    },
    {
      "title": "避免隱晦的程式邏輯 - Index",
      "summary": "在開發過程中，我們會使用各種資料結構來表示不同類型的資料，例如 List、Set、Map 等。List 作為一種有序的元素集合，允許重複元素，並提供基於索引（Index）的存取方式，適用於需要保持元素順序的場景。在程式中，我們經常需要與 List 互動，例如取出所有資料來顯示，或對 List 進行篩...",
      "content": "在開發過程中，我們會使用各種資料結構來表示不同類型的資料，例如 List、Set、Map 等。List 作為一種有序的元素集合，允許重複元素，並提供基於索引（Index）的存取方式，適用於需要保持元素順序的場景。在程式中，我們經常需要與 List 互動，例如取出所有資料來顯示，或對 List 進行篩選 (`where`) 與轉換 (`map`) 等操作。\n\n大多數情況下，對 List 的操作並不複雜，程式碼的可讀性也不會受到影響。然而，某些特定的寫法可能會降低可讀性，尤其是當我們使用索引來存取 List 時，可能會帶來潛在的問題。今天我們就來看看這些情況。\n\n## 使用 Index 表示資料\n\n在較舊的開發方式中，為了避免 API 直接暴露資料的屬性，可能會讓 API 回傳一個 JSON 陣列，其中每個位置代表某個特定的資料屬性。例如：\n\n```json\n[123, \"Jonh\", 27, \"john@gamil.com\", \"male\"]\n\n```\n\n當客戶端接收到這樣的回應時，必須透過 Index 來解析資料：\n\n```dart\nFuture<User> getUser() async {\n\tfinal data = await api.get(\"/user\").data;\n\treturn User.from(\n\t\tid: data[0],\n\t\tname: data[1],\n\t\tage: data[2],\n\t\temail: data[3],\n\t\tgender: data[4],\n\t);\n}\n\n```\n\n類似地，當某個方法需要回傳多個值時，我們可能會選擇用 List 來存放結果，讓呼叫端透過 Index 來取出對應的值：\n\n```dart\nWidget build(BuildContext context) {\n\tfinal results = summarizeFee(orders);\n\treturn Column(\n\t\tchildren: [\n\t\t\tText(\"Price ${result[0].toString()}\"),\n\t\t\tText(\"Fee ${result[1].toString()}\"),\n\t\t],\n\t);\n}\n\nList<int> summarizeFee(List<Order> orders) {\n\tvar price = 0;\n\tvar fee = 0;\n\tfor (var order in orders) {\n\t\tprice += order.price;\n\t\tfee += order.fee;\n\t}\n\treturn [price, fee];\n}\n\n```\n\n在這些例子中，當我們閱讀 `data[0]` 或 `results[0]` 時，完全無法從字面上理解它們的意義，必須對照命名參數或其他使用處，才能弄清楚這些 Index 所代表的資訊。\n\n以第一個例子來說，即便使用 List 避免了直接暴露屬性名稱，但這種方法終究是「防君子不防小人」，沒有太大的實際意義。而對於回傳多個值的情境，我們可以改用更具可讀性的方式，例如使用具名類別或 [Record](https://dart.dev/language/records) 來改善可讀性：\n\n```dart\n({int price, int fee}) summarizeFee(List<Order> orders) {\n  var price = 0;\n  var fee = 0;\n  for (var order in orders) {\n    price += order.price;\n    fee += order.fee;\n  }\n  return (price: price, fee: fee);\n}\n\n```\n\n接著我們來看看另一個 Index 造成的問題。\n\n## Index 判斷\n\n在以下程式碼中，我們根據 `index` 是否為 `0` 來決定是否要顯示標題：\n\n```dart\nWidget build(BuildContext context) {\n\treturn Column(\n\t\tchildren: users.mapIndexed((index, user) {\n\t\t\treturn Column(\n\t\t\t\tchildren: [\n\t\t\t\t\tif (index == 0)\n\t\t\t\t\t\tText(\"User List Title\"),\n\t\t\t\t\tText(user.name),\n\t\t\t\t]\n\t\t\t);\n\t\t}).toList(),\n\t);\n}\n\n```\n\n乍看之下，這段程式碼可能不容易理解為何會有這個判斷條件。但細看後會發現，這是為了讓標題只顯示一次。\n\n與其依賴 Index 來決定顯示標題的時機，我們可以直接將標題作為 `Column` 的第一個子元素，如下所示：\n\n```dart\nWidget build(BuildContext context) {\n\treturn Column(\n\t\tchildren: [\n\t\t\tText(\"User List Title\"),\n\t\t\t...users.map((user) {\n\t\t\t\treturn Text(user.name);\n\t\t\t}),\n\t\t],\n\t);\n}\n\n```\n\n這樣的寫法不僅更直覺，也更清楚地表達了「標題應該只顯示一次，並位於使用者名稱清單的最上方」。\n\n然而，這仍然不完全等價於原始程式碼。原始版本的邏輯還包括「當 `users` 為空時，不應顯示標題」。因此，我們可以進一步調整程式碼，使其更明確地表達這一邏輯：\n\n```dart\nWidget build(BuildContext context) {\n\tif (users.isEmpty) {\n\t\treturn SizedBox.shrink();\n\t}\n\n\treturn Column(\n\t\tchildren: [\n\t\t\tText(\"User List Title\"),\n\t\t\t...users.map((user) {\n\t\t\t\treturn Text(user.name);\n\t\t\t}),\n\t\t],\n\t);\n}\n\n```\n\n如此一來，讀者能夠一眼看出程式的意圖：標題僅在 `users` 非空時顯示，並且只會出現一次。\n\n## 小結\n\n使用 Index 並非絕對不妥，而是應視情境而定。我們應該考慮索引是否真正表達了程式的意圖，還是讓讀者需要額外推理才能理解它的用途。透過適當的資料結構與語法特性，我們可以讓程式碼更易讀、更容易維護。",
      "createdAt": "March 9, 2025 3:15 PM",
      "updatedAt": "September 9, 2025 8:08 AM",
      "id": "1b18303f78f780719e3af619d44bc33f",
      "type": "Medium",
      "tag": "軟體開發",
      "filename": "避免隱晦的程式邏輯 - Index 1b18303f78f780719e3af619d44bc33f.md"
    },
    {
      "title": "避免隱晦的程式邏輯 - 避免把細節當狀態",
      "summary": "最近改開發的時候，碰到一段很難懂的 Code，讓自己看了非常久，明明程式邏輯沒多複雜，但是整體讓我覺得很不舒服，總覺得有太多東西混雜在裡面。 這段程式主要的功能是做電話號碼 OTP 驗證，功能沒有太複雜，也就是拿著使用者輸入的 OTP 驗證碼去打一隻 API 做驗證。 這段 Code 來回看了幾天，...",
      "content": "最近改開發的時候，碰到一段很難懂的 Code，讓自己看了非常久，明明程式邏輯沒多複雜，但是整體讓我覺得很不舒服，總覺得有太多東西混雜在裡面。\n\n這段程式主要的功能是做電話號碼 OTP 驗證，功能沒有太複雜，也就是拿著使用者輸入的 OTP 驗證碼去打一隻 API 做驗證。\n\n這段 Code 來回看了幾天，請 AI 重構了無數回，也 Rollback 無數次。\n\n最後終於想通了到底問題在哪邊，到底是什麼讓整段程式難以理解。\n\n# **舉個例子**\n\n先來看看下面這段簡化過的程式碼例子：\n\n```dart\nclass OtpPage extends StatefulWidget {\n  @override\n  _OtpPageState createState() => _OtpPageState();\n}\n\nclass _OtpPageState extends State<OtpPage> {\n  String? errorMessage;\n  String otpCode = \"\";\n\n  Future<void> _verifyOtp(String otp) async {\n    try {\n      await otpService.verify(otp);\n    } catch (e) {\n   setState(() {\n        if (e.code == 'INVALID_OTP') {\n          errorMessage = \"OTP 驗證碼錯誤，請重新輸入\";\n     } else if (e.code == 'EXPIRED_OTP') {\n          errorMessage = \"OTP 驗證碼已過期\";\n        }\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          onChanged: (value) => otpCode = value,\n          decoration: InputDecoration(\n            hintText: \"請輸入 OTP 驗證碼\",\n          ),\n        ),\n        ElevatedButton(\n          onPressed: () => _verifyOtp(otpCode),\n          child: Text(\"驗證\"),\n        ),\n        if (errorMessage != null)\n          Text(\n            errorMessage!,\n            style: TextStyle(color: Colors.red),\n          ),\n      ],\n    );\n  }\n}\n```\n\n這段程式挺單純的，使用者輸入 OTP 驗證碼，按下驗證按鈕後就打 API 去驗證。\n\n在驗證的時候，程式會用 try/catch 來攔截 API 回的 400/500 錯誤，並且將指定錯誤訊息存到狀態中，以供畫面顯示。\n\n![1.jpg](%E9%81%BF%E5%85%8D%E9%9A%B1%E6%99%A6%E7%9A%84%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF%20-%20%E9%81%BF%E5%85%8D%E6%8A%8A%E7%B4%B0%E7%AF%80%E7%95%B6%E7%8B%80%E6%85%8B/1.jpg)\n\n這功能做起來也沒什麼問題，也挺好理解的，錯誤訊息就是要顯示給使用者看的，放在 _OtpPageState 中也是合情合理。\n\n但是如果故事只到此處，那也沒什麼好說的，難就難在需求總是會改，我們總是要回來重新閱讀這段程式碼。\n\n# **需求異動**\n\n有天客人抱怨錯誤訊息不夠清楚，害他沒看到驗證碼錯誤的訊息，覺得怎麼系統一直沒反應，然後就很不高興的刪除 App 了。\n\n既然客戶抱怨了，那我們只好想想辦法來解決客戶的問題。\n\n經過 PO 與設計師討論，最終決定強化錯誤提示，讓客人可以更清楚了解現在是發什麼狀況。\n\n![4.jpg](%E9%81%BF%E5%85%8D%E9%9A%B1%E6%99%A6%E7%9A%84%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF%20-%20%E9%81%BF%E5%85%8D%E6%8A%8A%E7%B4%B0%E7%AF%80%E7%95%B6%E7%8B%80%E6%85%8B/4.jpg)\n\n這邊有個小細節，就是只有在 OTP 驗證碼錯誤的情況下才需要顯示紅框，其餘像是過期就不顯示紅框。\n\n當開發人員看到設計之後，肯定覺得這題我會，不過就是一個 if 能解決的事，IDE 一開，手指一動，測試一跑，輕輕鬆鬆就完成了。\n\n```dart\nclass _OtpPageState extends State<OtpPage> {\n  String? errorMessage;\n  String otpCode = \"\";\n  String phoneNumber = \"0912345678\";\n\n  Future<void> _verifyOtp(String otp) async {\n    try {\n      await otpService.verify(otp);\n    } catch (e) {\n      setState(() {\n        if (e.code == 'INVALID_OTP') {\n          errorMessage = \"OTP 驗證碼錯誤，請重新輸入\";\n        } else if (e.code == 'EXPIRED_OTP') {\n          errorMessage = \"OTP 驗證碼已過期\";\n        }\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          onChanged: (value) => otpCode = value,\n          decoration: InputDecoration(\n            hintText: \"請輸入 OTP 驗證碼\",\n          ),\n          border: OutlineInputBorder(\n            borderSide: BorderSide(。\n              color: errorMessage == \"OTP 驗證碼錯誤，請重新輸入\" ?\n                  Colors.red :\n                  Colors.black,\n            ),\n          ),\n        ),\n        ElevatedButton(\n          onPressed: () => _verifyOtp(otpCode),\n          child: Text(\"驗證\"),\n        ),\n        if (errorMessage != null)\n          Text(\n            errorMessage!,\n            style: TextStyle(color: Colors.red),\n          ),\n        if (errorMessage == \"OTP 驗證碼錯誤，請重新輸入\")\n          Row(\n            children: [\n              Icon(Icons.phone, color: Colors.orange),\n              Text(\"請檢查您的電話號碼：\"),\n              Text(\n                phoneNumber,\n                style: TextStyle(\n                  fontWeight: FontWeight.bold,\n                  color: Colors.orange,\n                ),\n              ),\n            ],\n          ),\n      ],\n    );\n  }\n}\n```\n\n結果 Review 的時候一看，就出現了 errorMessage == “OTP 驗證碼錯誤，請重新輸入” 的 if 判斷。\n\n看到這裡，你肯定會想，功能完成是完成了，但是總感覺哪裡怪怪的。\n\n這裡就得回到我們的主題，**把細節當狀態了**。\n\n由於前面錯誤訊息與錯誤狀態是一對一，所以把訊息當狀態好像也沒什麼毛病。\n\n但當今天錯誤狀態與錯誤畫面細節不是一對一的時候，問題就出現了。\n\n直接把畫面細節當狀態來存的時候，當未來需要根據狀態來判斷時，就會變得很麻煩。\n\n尤其是當一個錯誤可能又會出現多個提示的時候，錯綜復雜的關係，讓閱讀的人根本不可能從當前的提示組合中理解當前是處於什麼錯誤狀態。\n\n所以我們應該儲存的是**錯誤狀態**，而不是**畫面細節**。\n\n# **更好的做法**\n\n了解問題之後，其實解法也就顯而易見，我們在 _OtpPageState 中應該存的是錯誤狀態，而不是錯誤訊息。\n\n```dart\nenum OtpError {\n  invalidOtp,\n  expiredOtp,\n}\n\nclass _OtpPageState extends State<OtpPage> {\n  OtpError? otpError;\n  String otpCode = \"\";\n  String phoneNumber = \"0912345678\";\n\n  Future<void> _verifyOtp(String otp) async {\n    try {\n      await otpService.verify(otp);\n    } catch (e) {\n      setState(() {\n        if (e.code == 'INVALID_OTP') {\n          otpError = OtpError.invalidOtp;\n        } else if (e.code == 'EXPIRED_OTP') {\n          otpError = OtpError.expiredOtp;\n        }\n      });\n    }\n  }\n\n  String? get errorMessage {\n    switch (otpError) {\n      case OtpError.invalidOtp:\n        return \"OTP 驗證碼錯誤，請重新輸入\";\n      case OtpError.expiredOtp:\n        return \"OTP 驗證碼已過期\";\n      default:\n        return null;\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          onChanged: (value) => otpCode = value,\n          decoration: InputDecoration(\n            hintText: \"請輸入 OTP 驗證碼\",\n            border: OutlineInputBorder(\n              borderSide: BorderSide(。\n                color: otpError == OtpError.invalidOtp ?\n                  Colors.red :\n                  Colors.black,\n              ),\n            ),\n          ),\n        ),\n        ElevatedButton(\n          onPressed: () => _verifyOtp(otpCode),\n          child: Text(\"驗證\"),\n        ),\n        if (errorMessage != null)\n          Text(\n            errorMessage!,\n            style: TextStyle(color: Colors.red),\n          ),\n      ],\n    );\n  }\n}\n```\n\n使用 enum 來儲存錯誤狀態之後，我們要拿這個錯誤狀態來衍生更多不同的顯示，就更容易的。\n\n當然錯誤不一定得用 enum 來表示，這部分就得視需求來決定。\n\n但重點是儲存錯誤狀態，能讓看的人更容易理解程式碼的邏輯。\n\n# **結語**\n\n避免把細節當狀態，是寫出易讀、易維護程式碼的重要概念。\n\n當你發現自己在用字串比對、或是用畫面顯示的內容做邏輯判斷時，就要停下來想想：我儲存的是系統狀態，還是畫面細節？\n\n存正確的狀態不只能讓讀的人更容易理解，也增加未來修改彈性。\n\n記住：**狀態管理的核心，是管理系統的真實狀況，而不是管理畫面的呈現細節。**\n\n在 Flutter 開發中，合理運用 enum、class 和狀態管理工具，可以讓你的程式碼更清晰、更容易測試和維護。",
      "createdAt": "July 7, 2025 10:48 PM",
      "updatedAt": "September 9, 2025 8:08 AM",
      "id": "2298303f78f7807fb25ff4f4fad22b5b",
      "type": "Medium",
      "tag": "軟體開發",
      "filename": "避免隱晦的程式邏輯 - 避免把細節當狀態 2298303f78f7807fb25ff4f4fad22b5b.md"
    },
    {
      "title": "避免隱晦的程式邏輯",
      "summary": "在開發中，我們為了完成某項功能的細部行為，可能會有很多種做法，如何評估哪種作法更好呢？其中一項準則就是清楚呈現邏輯。當程式碼能夠清楚呈現邏輯時，往後其他人在閱讀程式碼時，就能更快的了解其意圖。 就同如《先整理一下？》所提到的：「作者只有一個，但讀者通常會有很多個」，如果把邏輯用隱晦的方式完成，我們很...",
      "content": "在開發中，我們為了完成某項功能的細部行為，可能會有很多種做法，如何評估哪種作法更好呢？其中一項準則就是清楚呈現邏輯。當程式碼能夠清楚呈現邏輯時，往後其他人在閱讀程式碼時，就能更快的了解其意圖。\n\n就同如《先整理一下？》所提到的：「作者只有一個，但讀者通常會有很多個」，如果把邏輯用隱晦的方式完成，我們很難保證每個人對都能理解這段邏輯的意圖，而呈現意圖也是 Kent Beck 簡單設計中的一項原則。\n\n## 舉個例子\n\n假設畫面有兩個彈跳視窗 A 與 B，這兩個彈跳視窗有些規則，規則如下：\n\n- 系統會先顯示彈跳視窗 A，接著才顯示彈跳視窗 B。\n- 如果使用者已經看過了彈跳視窗 A，則 A **此後都不再顯示**。\n- 如果使用者**今天**看過了彈跳視窗 B，則 B **今天不再顯示**。\n\n根據這三個規則，我們可以很容易地寫出類似下方這樣的程式碼：\n\n( 這裡讓我們先暫時忽略持久化的部分，畢竟這不是重點 )\n\n```dart\nFuture<void> showPopups() async {\n\tif (!hasPopupAShow) {\n\t\tawait showPopupA();\n\t\thasPopupAShow = true;\n\t}\n\n\tif (popupBShowDate != today()) {\n\t\tawait showPopupB();\n\t\tpopupBShowDate = today();\n\t}\n}\n\n```\n\n這段程式碼也完整地呈現了上述的三的規則。\n\n## 事情發生了改變\n\n若是今天需求發生了變化，在這兩個彈窗之間，又新增了一條規則\n\n- 如果使用者今天看過了 A，今天之內就不要再看到 B 了。\n\n那我們應該如何調整呢？觀眾們也可以先想想看，若是自己來處理的話，會怎麼做。\n\n![1737783415192.png](%E9%81%BF%E5%85%8D%E9%9A%B1%E6%99%A6%E7%9A%84%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF/1737783415192.png)\n\n## 一種作法\n\n一種作法是，我們可以在看完 A 的時候，順手把 B 的 popupBShowDate 也順手設了，這樣一來，當檢查到 B 的時候，自然也就會不打開 B。這個作法相當簡單，不要改動太多程式碼，只要僅僅多家一行程式碼就能完成，省時又省力。\n\n```dart\nFuture<void> showPopups() async {\n\tif (!hasPopupAShow) {\n\t\tawait showPopupA();\n\t\thasPopupAShow = true;\n\t\tpopupBShowDate = today();\n\t}\n\n\tif (popupBShowDate != today()) {\n\t\tawait showPopupB();\n\t\tpopupBShowDate = today();\n\t}\n}\n\n```\n\n這種作法乍聽起來也很自然：看了 A 之後，就當作 B 也看過了，但若是仔細想想，真的是這樣嗎？\n\n但若是對於作者以外的人來說，如果對這個功能不是很了解，在爬 Code 看到這段的時候，就可能很難聯想為什麼 A 看完之後，要同時把 B 的時間也設定了，也就更難推論出當初的作法：看過 A 之後，今天之內就不要再看到 B 了 的行為。\n\n## 另一種作法\n\n讓我們來看看另外一種作法：把 A 的彈窗顯示紀錄從 bool 改成 DateTime，當看過 A 之後，紀錄 A 看過的時間。\n\n接著我們就在能檢查 B 彈窗的時候，確認只有在今天都還沒看過 A 與 B 兩個彈窗時，才顯示 B。\n\n```dart\nFuture<void> showPopups() async {\n\tif (popupAShowDate == null) {\n\t\tawait showPopupA();\n\t\tpopupAShowDate = today();\n\t}\n\n\tif (popupBShowDate != today() && popupAShowDate != today()) {\n\t\tawait showPopupB();\n\t\tpopupBShowDate = today();\n\t}\n}\n\n```\n\n相比於第一個作法，我們可以更清楚在邏輯中展示 A 與 B 之間的關係，向讀者說明若是今天看過 A，就不要再顯示 B 了。\n\n雖然第二種寫法看起來比較囉唆，需要的改動也比較多，但是他能更準確地從 if 條件中看出 B 的顯示邏輯。\n\n看完兩種作法之後，不知道你喜歡哪種呢？或者你有更好的作法，歡迎留言交流分享。\n\n## 小結\n\n無論第一種作法或第二種，我們都能完成功能。在完成功能之後，我們還得花時間看看我們的程式碼，確認程式碼是否符合各種設計原則，透過不斷重構，讓程式碼不斷演化的過程中，能維持品質，支持後續的改動。\n\n年節已到，祝大家新年快樂。",
      "createdAt": "January 25, 2025 2:35 PM",
      "updatedAt": "September 9, 2025 8:08 AM",
      "id": "1868303f78f78085ae92e639d0bdfac2",
      "type": "Medium",
      "tag": "軟體開發",
      "filename": "避免隱晦的程式邏輯 1868303f78f78085ae92e639d0bdfac2.md"
    },
    {
      "title": "Widget Test 的 tap 原來這樣運作？一探 Flutter 測試點擊的祕密",
      "summary": "前陣子有同事問我：「WidgetTester 中的 `tap` 方法，到底是點擊卡片的哪個位置？它是真的模擬使用者的點擊行為，還是單純呼叫底層某個 callback 來觸發事件？」當下我其實不太確定，只好回家趕快研究一下。 雖然這些細節在大部分情境下不影響我們的日常測試，但世事難料，總有可能哪天派得...",
      "content": "![robottesting2.png](Widget%20Test%20%E7%9A%84%20tap%20%E5%8E%9F%E4%BE%86%E9%80%99%E6%A8%A3%E9%81%8B%E4%BD%9C%EF%BC%9F%E4%B8%80%E6%8E%A2%20Flutter%20%E6%B8%AC%E8%A9%A6%E9%BB%9E%E6%93%8A%E7%9A%84%E7%A5%95%E5%AF%86/robottesting2.png)\n\n前陣子有同事問我：「WidgetTester 中的 `tap` 方法，到底是點擊卡片的哪個位置？它是真的模擬使用者的點擊行為，還是單純呼叫底層某個 callback 來觸發事件？」當下我其實不太確定，只好回家趕快研究一下。\n\n雖然這些細節在大部分情境下不影響我們的日常測試，但世事難料，總有可能哪天派得上用場。所以趁有空時，就來探索一下這個小細節吧。\n\n今天想和大家分享一個關於 Widget Test 的冷知識。本篇文章會包含不少原始碼，如果你對底層實作細節沒有興趣，可以考慮先跳過。\n\n## WidgetTester 的 tap 方法\n\n首先來看 `tap` 的實作，這應該能回答第一個問題：**`tap` 方法到底是點擊 Widget 的哪個位置？**\n\n從程式碼中可以看到，它實際上呼叫了 `tapAt`，並傳入 `getCenter(...)`。光從名稱就能推測出來：`tap` 點擊的是 **Widget 的中心點**。\n\n```dart\nFuture<void> tap(\n  finders.FinderBase<Element> finder, {\n  int? pointer,\n  int buttons = kPrimaryButton,\n  bool warnIfMissed = true,\n  PointerDeviceKind kind = PointerDeviceKind.touch,\n}) {\n  return tapAt(\n    getCenter(finder, warnIfMissed: warnIfMissed, callee: 'tap'),\n    pointer: pointer,\n    buttons: buttons,\n    kind: kind,\n  );\n}\n```\n\n接下來的問題就是：它是怎麼找到「中心點」的？\n\n## 找尋 Widget 中心點\n\n往下追 `getCenter` 的實作，可以看到它呼叫了 `_getElementPoint`，這個方法的功能就是：**計算 Widget 某個位置的 Global 座標**。\n\n```dart\nOffset getCenter(\n  finders.FinderBase<Element> finder, {\n  bool warnIfMissed = false,\n  String callee = 'getCenter',\n}) {\n  return _getElementPoint(\n    finder,\n    (Size size) => size.center(Offset.zero),\n    warnIfMissed: warnIfMissed,\n    callee: callee,\n  );\n}\n\nOffset _getElementPoint(\n  finders.FinderBase<Element> finder,\n  Offset Function(Size size) sizeToPoint, {\n  required bool warnIfMissed,\n  required String callee,\n}) {\n  TestAsyncUtils.guardSync();\n  final Iterable<Element> elements = finder.evaluate();\n  \n  // 省略檢查細節\n\n  final Element element = elements.single;\n  final RenderObject? renderObject = element.renderObject;\n  \n  // 省略檢查細節\n\n  final RenderBox box = element.renderObject! as RenderBox;\n  final Offset location = box.localToGlobal(sizeToPoint(box.size));\n  \n  // 省略 warnIfMissed 細節\n\n  return location;\n}\n```\n\n總結來說：`getCenter` 並不複雜，它只是透過 finder 找出 Element，再用 RenderBox 算出 Widget 中心點的 Global 座標。\n\n除了 `getCenter`，還有像 `getTopLeft`、`getBottomLeft` 等方法，可以讓我們在測試中指定不同的點擊位置。\n\n## **tapAt 的點擊流程**\n\n找到座標之後，`tap` 會透過 `tapAt` 來模擬點擊。\n\n來看一下主要流程：\n\n1. `tapAt` 先呼叫 `startGesture`，建立一個 `TestGesture`，並執行 `result.down(downLocation)` 來模擬 **手指按下**。\n2. 接著呼叫 `gesture.up()` 來模擬 **手指放開**。\n\n```dart\nFuture<void> tapAt(\n  Offset location, {\n  int? pointer,\n  int buttons = kPrimaryButton,\n  PointerDeviceKind kind = PointerDeviceKind.touch,\n}) {\n  return TestAsyncUtils.guard<void>(() async {\n    final TestGesture gesture = await startGesture(\n      location,\n      pointer: pointer,\n      buttons: buttons,\n      kind: kind,\n    );\n    await gesture.up();\n  });\n}\n\nFuture<TestGesture> startGesture(\n  Offset downLocation, {\n  int? pointer,\n  PointerDeviceKind kind = PointerDeviceKind.touch,\n  int buttons = kPrimaryButton,\n}) async {\n  final TestGesture result = _createGesture(pointer: pointer, kind: kind, buttons: buttons);\n  if (kind == PointerDeviceKind.trackpad) {\n    // 處理觸控板的點擊行為\n  } else {\n    await result.down(downLocation);\n  }\n  return result;\n}\n```\n\n如果你曾經用 Listener 監聽過觸控事件，對這流程應該不陌生：\n\n- 按下時 → `PointerDownEvent`\n- 放開時 → `PointerUpEvent`\n\n想實際觀察的人，可以參考[這個範例](https://dartpad.dev/?id=5b0ff587c3653927bdc93e39fddac731)。\n\n## TestGesture 如何發送事件\n\n那這些事件是怎麼真正「傳到 Flutter Framework」的呢？\n\n答案就在 `TestGesture` 的 `down` 與 `up` 方法中。\n\n```dart\nFuture<void> down(Offset downLocation, {Duration timeStamp = Duration.zero}) async {\n  \n  // 省略檢查細節\n  \n  return TestAsyncUtils.guard<void>(() async {\n    return _dispatcher(_pointer.down(downLocation, timeStamp: timeStamp));\n  });\n}\n```\n\n這裡 `_dispatcher` 會發送一個 `PointerDownEvent`。在 `TestGesture` 的建構過程中，可以看到它實際上被綁定成 `sendEventToBinding`，最後透過 `WidgetsBinding` 把事件送進 Framework。\n\n```dart\nTestGesture _createGesture({\n  int? pointer,\n  required PointerDeviceKind kind,\n  required int buttons,\n}) {\n  return TestGesture(\n    dispatcher: sendEventToBinding,\n    kind: kind,\n    pointer: pointer ?? _getNextPointer(),\n    buttons: buttons,\n  );\n}\n\nFuture<void> sendEventToBinding(PointerEvent event) {\n  return TestAsyncUtils.guard<void>(() async {\n    binding.handlePointerEvent(event);\n  });\n}\n```\n\n熟悉 Flutter 的人應該對 `WidgetsBinding` 不陌生。我們常用的 `WidgetsBinding.instance.addPostFrameCallback(...)` 就是它的功能之一。\n\n在點擊事件的情境下，Engine 收到事件後，會透過 `WidgetsBinding`（更精確地說是 `GestureBinding`）把事件傳進 Framework，經過像 **GestureArena** 這樣的機制過濾與解析，最後才交給我們常用的 `GestureDetector`。\n\n## 整理一下\n\n整個 `tap` 的執行流程，可以簡單整理如下：\n\n![開發 - Frame 11.jpg](Widget%20Test%20%E7%9A%84%20tap%20%E5%8E%9F%E4%BE%86%E9%80%99%E6%A8%A3%E9%81%8B%E4%BD%9C%EF%BC%9F%E4%B8%80%E6%8E%A2%20Flutter%20%E6%B8%AC%E8%A9%A6%E9%BB%9E%E6%93%8A%E7%9A%84%E7%A5%95%E5%AF%86/%E9%96%8B%E7%99%BC_-_Frame_11.jpg)\n\n1. 呼叫 `WidgetTester.tap`\n2. 透過 finder 找到 Element，計算中心點的 Global 座標\n3. 呼叫 `tapAt`，傳入座標\n4. 建立 `TestGesture` 負責處理點擊\n5. 呼叫 `down` → 發送 `PointerDownEvent`\n6. 呼叫 `up` → 發送 `PointerUpEvent`\n\n## 小結\n\n透過研究 `WidgetTester.tap` 的實作，我們不僅加深了對 Widget Test 使用方式的理解，也更清楚它是如何與 Flutter Framework 互動。雖然這些細節未必直接影響日常開發，但它可以視為一種「閱讀程式碼的訓練」。在 AI 不斷進步的時代，我們反而更需要具備閱讀、理解 **別人程式碼** 的能力。\n\n每次遇到不熟悉的地方，都是充實知識庫的契機。在追原始碼的過程中，不只能更透徹地理解框架運作，也能從中學到設計思維與程式風格。\n\n希望這篇文章能帶給你一些啟發。如果有任何問題，歡迎留言與我討論，感謝你讀到這裡！",
      "createdAt": "August 23, 2025 9:08 AM",
      "updatedAt": "August 23, 2025 4:27 PM",
      "id": "2588303f78f780b3a789ccdae073e04a",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "Widget Test 的 tap 原來這樣運作？一探 Flutter 測試點擊的祕密 2588303f78f780b3a789ccdae073e04a.md"
    },
    {
      "title": "BuildContext in Flutter",
      "summary": "BuildContext在flutter開發中很常出現，是build方法的唯一參數。我們時常需要透過of方法取得某些Widget時，此時就會使用到context，例如： ```dart MediaQuery.of(context).size // 取得畫面寬高 Scaffold.of(context...",
      "content": "BuildContext在flutter開發中很常出現，是build方法的唯一參數。我們時常需要透過of方法取得某些Widget時，此時就會使用到context，例如：\n\n```dart\nMediaQuery.of(context).size // 取得畫面寬高\nScaffold.of(context).showSnackBar(snackBar); // 顯示Snack Bar\n```\n\n但是實際上context到底是什麼呢？今天就來聊聊這個話題吧。\n\n## Flutter的三棵樹\n\n如果有稍微研究過Flutter的話，多多少少都知道Flutter有三顆樹，分別是Widget Tree, Element Tree, RenderObject Tree。而當中的Element Tree是由各式各樣的Element組成的，例如:SatelessElement、StatefulElement、InheritedElement...等，每個Widget都有他自己相對應的element。\n\nElement主要職責是橫向連接Widget與RenderObject，縱向連結parent Element與child Element，並在Widget發生變化時，根據情況更新RenderObject或重新建立子樹。如果追著這些Element的繼承一路往上，會發現最終Element實作了BuildContext這個抽象類別。\n\n![](BuildContext%20in%20Flutter/_2021-01-19_1.34.08.png)\n\n## 各式各樣的找祖先方法\n\nElement實作BuildContext，並實作了BuildContext裡的眾多方法。在這些方法中，有一系列找祖先的方法，讓我們可以透過context找到往上好幾層的Widget或State。\n\n```dart\nabstract class BuildContext {\n\n  ...\n\n  T findAncestorWidgetOfExactType<T extends Widget>();\n\n  T findAncestorStateOfType<T extends State>();\n\n  T findRootAncestorStateOfType<T extends State>();\n\n  T findAncestorRenderObjectOfType<T extends RenderObject>();\n\n  void visitAncestorElements(bool visitor(Element element));\n\n  void visitChildElements(ElementVisitor visitor);\n\n  ...\n\n}\n```\n\n這些找祖先方法被廣泛的運用在各種of方法中，例如Scaffold.of(context)就是透過context.findAncestorStateOfType<T>()來取得ScaffoldState的。\n\n![](BuildContext%20in%20Flutter/_2021-01-24_9.14.25.png)\n\n## Build方法中的唯一參數\n\n為了讓我們能更靈活的控制UI，BuildContext作為build方法唯一參數，讓我們可以透過它取得祖先Widget，並應用在一些常見的場景中\n\n1. 取得祖先Widget的狀態，來做相對應的顯示，例如：我們需要根據手機的寬高來顯示不一樣的UI設計。\n2. 操作祖先Widget並改變他的狀態，例如：當我們想顯示自訂訊息在SnackBar時，我們必須透過BuildContext取得ScaffoldState，才能用它顯示SnackBar。\n\n## 小結\n\n我們都會從StackOverflow上找某個UI如何實作，這些解答中多多少少會用到BuildContext。BuildContext作為Flutter核心設計之一，理解BuildContext能有效讓我們更清楚Flutter是如何運作的，也能在發生error時，更清楚其背後的根本原因。\n\n## 參考",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "January 1, 2025 8:55 AM",
      "id": "512453b346714c74ac7c102844711624",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "BuildContext in Flutter 512453b346714c74ac7c102844711624.md"
    },
    {
      "title": "Context that does not contains ...",
      "summary": "在開發Flutter的時候，多多少少都會遇到一些error。在眾多error中，多多少少都會遇到的一種error是context中找不到想要的東西，讓我們舉個例子來看看這個錯誤。 以下面這段代碼為例，當按下FloatingActionButton時，畫面顯示\"Worlds!\"在SnackBar上。當...",
      "content": "在開發Flutter的時候，多多少少都會遇到一些error。在眾多error中，多多少少都會遇到的一種error是context中找不到想要的東西，讓我們舉個例子來看看這個錯誤。\n\n## context中找不到Scaffold\n\n以下面這段代碼為例，當按下FloatingActionButton時，畫面顯示\"Worlds!\"在SnackBar上。當程式執行onPressed callback時，透過Scaffold.of(context)找到ScaffoldState，並呼叫其showSnackBar方法來顯示SnackBar。\n\n![](Context%20that%20does%20not%20contains/_2021-01-31_7.58.31.png)\n\n實際執行並按下FloatingActionButton後會噴error，訊息中提示context不包含Scaffold。\n\n```dart\nScaffold.of() called with a context that does not contain a Scaffold.\n```\n\n![](Context%20that%20does%20not%20contains/_2021-01-24_8.41.24.png)\n\n可以發現錯誤是發生在嘗試呼叫Scaffold.of()取得Scaffold的時候，初學者容易在這個地方覺得奇怪，因為Scaffold確實是FloatingActionButton的parent，那為什麼會找不到呢？\n\n## 發生原因\n\n在上一篇BuildContext的文章中提到，of方法會從parent開始一層一層往上找，但是此時的context是這個MyHomePage的context，並非FloatingActionButton的context，所以會找不到Scaffold，以上面的代碼為例，此時畫面的結構是\n\n![](Context%20that%20does%20not%20contains/_2021-01-31_8.24.08.png)\n\n所以當呼叫Scaffold.of()時，程式循著MyHomePage的context往parent一層一層往上找，理所當然是找不到任何ScaffoldState，因為想要的ScaffoldState在child（Context of Scaffold）中。\n\n## 如何解決\n\n1. 把目標UI抽取Widget，並為其取一個合適的名稱。\n    \n    ![](Context%20that%20does%20not%20contains/_2021-01-31_8.19.05.png)\n    \n    但是當目標UI沒有重複利用的需求且本身已經夠小的時候，或許可以考慮使用Builder來解決\n    \n2. 用Builder把Widget包起來\n    \n    ![](Context%20that%20does%20not%20contains/_2021-01-31_8.11.58.png)\n    \n    此時就能用Builder中的context來正確取得ScaffoldState。\n    \n\n## 不只Scaffold\n\n在開發過程中，我們也常常會用到MediaQuery.of(context)來幫助我們取得畫面的寬高，但是當我們的Widget Tree中沒有MediaQuery時，也同樣的會噴錯。\n\n![](Context%20that%20does%20not%20contains/_2021-02-02_2.02.44.png)\n\n如果在自己的Widget中實作了of方法，也同樣需要在使用的時注意是否有正確的使用，否則就會造成系統出錯而畫面無法正常顯示。\n\n## 小結\n\n如果第一次看到這個錯誤，對初學者的人來說，可能會上網搜尋解法。找到解法貼上來後也可能會一頭霧水，不知道錯誤的原因是什麼，也不知道為什麼這樣寫就會好，改起來總是不安心。希望這篇文章能幫助大家更好地瞭解Flutter，讓代碼寫起來更有信心。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "January 1, 2025 8:55 AM",
      "id": "6b3707dc2af34e82a203ba90279b70c2",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "Context that does not contains 6b3707dc2af34e82a203ba90279b70c2.md"
    },
    {
      "title": "Dart 非同步介紹(一) - Event Loop",
      "summary": "寫Flutter的時候，如果我們需要從後端api拿回資料時，我們會使用一些network相關的package來幫忙，例如：[http](https://pub.dev/packages/http)。我們透過await http.get來讓代碼停在這一行，釋放Thread去做其他工作，直到後端resp...",
      "content": "寫Flutter的時候，如果我們需要從後端api拿回資料時，我們會使用一些network相關的package來幫忙，例如：[http](https://pub.dev/packages/http)。我們透過await http.get來讓代碼停在這一行，釋放Thread去做其他工作，直到後端response傳回來後，Thread再從之後的代碼繼續執行，這種非同步的操作只是用在存取api，在很多其他場景中也都會用到，今天就來講講Dart的非同步操作是如何運作的。\n\n## Event Loop與單執行緒\n\n在預設的情況下，Dart只使用一條Thread來執行代碼，Dart用三個東西來完成這件事情：**Event**, **Event Loop**, **Event Queue**。我們可以想像Dart把一段一段的代碼包成Event放在Event Queue的中，當中不管是渲染畫面的代碼、點擊按鈕的callback代碼，或者http response callback代碼。\n\n![](Dart%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%B4%B9(%E4%B8%80)%20-%20Event%20Loop/_2021-03-01_3.08.29.png)\n\n所有Event都會放在Event Queue中，然後Event Loop從Event Queue中把Event拿出來執行。我們可以把Event Loop想像成一條Thread裡頭跑著一個無窮迴圈，它會一直不斷的檢查Queue中有沒有Event，有的話就把它拿出來執行，如果沒有的話就一直等待下一個Event的出現。\n\n我們舉一些簡單的例子來看看\n\n```dart\nFlatButton(\n  onPressed: () => {\n\tprint('Hello World!');\n  },\n  child: Text(\"Click me\"),\n),\n```\n\n當FlatButton被宣告的時，onPress不會直接被執行，而是使用者按下FlatButton時，Flutter會在Event Queue中加入一個Click的Event，等待Event Loop處理它。順帶一提，宣告FlatButton的代碼也曾經被放在某個Event中，並被Event Loop執行。\n\n**http範例代碼：**\n\n```dart\nvar url = 'https://example.com/whatsit/create';\nvar response = await http.post(url, body: {'name': 'doodle', 'color': 'blue'});\nprint('Response status: ${response.statusCode}');\nprint('Response body: ${response.body}');\n```\n\n這段代碼執行到 await http.post且送出request之後，Event Loop轉去處理下一個Event。等到成功接收response之後，Dart就會加入剩餘部分代碼的Event到Event Queue中（也就是print的部分\n），等待Event Loop處理它。\n\n## await是一種語法糖\n\n在Dart中，await是一種then方法的語法糖，也就是說編譯器會在編譯過程中幫你把await轉換成then的寫法。以上面http範例代碼來說，就會變成下面這樣。\n\n```dart\nvar url = 'https://example.com/whatsit/create';\nhttp.post(url, body: {'name': 'doodle', 'color': 'blue'})\n\t\t.then((response) => {\n\t\t\tprint('Response status: ${response.statusCode}');\n\t\t\tprint('Response body: ${response.body}');\n\t\t}); \n```\n\n## 小心耗時工作\n\nEvent Loop會把正在處理的Event處理完以後，才會繼續從Queue中拿下一個Event。當我們在Queue中放入了耗時工作的Event時，例如：壓縮圖片、加密解密..等等，就會造成下一個UI遲遲無法被處理。如果今天下一個Event剛好是渲染UI Event，就會發現畫面開始卡頓，甚至沒有反應，直到Event Loop處理完手上的工作。\n\n但是實際應用場景中難免會有這樣的需求，此時我們可以使用Isolate來解決這類問題，避免占用到渲染UI的時間或者是Click事件的處理，我下次會繼續介紹Isolate如何使用，感謝你耐心的看這邊。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "January 1, 2025 8:55 AM",
      "id": "fad780524ae04e6fbadb7c6c280e0f2b",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "Dart 非同步介紹(一) - Event Loop fad780524ae04e6fbadb7c6c280e0f2b.md"
    },
    {
      "title": "Dart 非同步介紹(三) - Stream",
      "summary": "在 Dart 非同步的使用情境中，除了常用的 Future 以外，還有 Stream 也是常常被用到的一個元件，相對於 Future 來說，Stream 是一個比較難理解的元件，今天就來研究一下 Stream 是什麼，以及如何建立與使用。 根據 [Flutter 官方影片](https://www....",
      "content": "在 Dart 非同步的使用情境中，除了常用的 Future 以外，還有 Stream 也是常常被用到的一個元件，相對於 Future 來說，Stream 是一個比較難理解的元件，今天就來研究一下 Stream 是什麼，以及如何建立與使用。\n\n## **什麼是 Stream**\n\n根據 [Flutter 官方影片](https://www.youtube.com/watch?v=nQBpOIHE4eE)提到的，Stream 是非同步元件的 Iterator 形式。白話一點來說，可以想像成一個由多個 Future 組成的 List。 我們可以用 awiat 等待一個 Future 的結果，在 Iterator 形式中，可以用 await for 等待 Stream 中的每一個非同步結果。\n\n```csharp\nvoid main() async {\n    // 等待一個 Future\n    await Future.delayed(Duration(seconds: 1), \n    () => print(\"Hello World!!\"));\n  \n    // 等待一個 Stream\n    await for(var value in helloWorld()) {\n        print(value);\n    }\n}\n\nStream<String> helloWorld() async* {\n    yield \"Hello\";\n    yield \"World\";\n    yield \"!!\";\n}\n```\n\n## **如何建立 Stream**\n\n1. 使用 async* 方法如同上面範例中寫的，我們可以寫一個方法，回傳 Stream 並標註為 async*，這樣就能透過 yield 回傳想要的值。\n    \n    ```csharp\n    Stream<String> helloWorld() async* {\n        yield \"Hello\";\n        yield \"World\";\n        yield \"!!\";\n    }\n    ```\n    \n2. 使用 StreamController除了使用 async* 方法之外，還可以使用 StreamController 來建立 Stream，建立完後可以透過 StreamController 的 add() 發送 Event（也等同於使用 StreamController.sink.add())。\n    \n    ```csharp\n    StreamController<String> streamController =  \n        new StreamController<String>();  \n      \n    void helloWorld() {  \n        streamController.add(\"Hello\");  \n        streamController.add(\"World\");  \n        streamController.add(\"!!\");  \n    }\n    ```\n    \n3. 從其他 Stream 轉換最後一個方法則是從現有的 Stream 中創建，比較常見的例子像是 map、where..等方法。\n    \n    ```csharp\n    void main() async {  \n        var firstChars = helloWorld().map<String>((data) => data[0]);  \n            await for (var value in firstChars) {  \n            print(value);  \n        }  \n    }\n    \n    Stream<String> helloWorld() async* {\n        yield \"Hello\";\n        yield \"World\";\n        yield \"!!\";\n    }\n    ```\n    \n\n## **監聽 Stream 並獲取 Event**\n\n在前面的例子中，我們使用了 await for 來等待 Stream 中的所有 Event 回來，這樣會使得程式碼卡在 await for 那邊。在實際應用中，更多是使用 listen() ，以非同步的方式取得 Stream 的值。\n\n```csharp\nStream<String> helloWorld() async* {  \n    yield \"Hello\";  \n    yield \"World\";  \n    yield \"!!\";  \n}  \n  \nvoid main() {  \n    helloWorld().listen((event) {  \n        print(event);  \n    });  \n}\n```\n\n## **常見的 Stream 操作**\n\n除了 listen 之外，我們也可以透過 Stream 的各式各樣 API 來操作 Stream，例如\n\n- 使用 map 把 Stream 中的每一個 Event 轉成其他物件\n- 使用 where 把預期的 Event 從 Stream 中過濾出來\n- 使用 distinct 忽略相同的 Event，值得注意的是，distinct 是比較當前的 Event 與 上一個 Event 是否一樣，如果一樣就忽略掉。Stream 還有其他許多類似陣列的操作，這邊就不特別列出來，有興趣的人可以參考 [Stream API](https://api.dart.dev/stable/2.13.4/dart-async/Stream-class.html)。\n\n## 在 UI 中使用 Stream\n\n跟 FutureBuilder 一樣，如果需要根據 Stream 回傳的 Event 來影響畫面的話，可以使用 Flutter 提供的 StreamBuilder。我們可以傳入一個 Stream 到 StreamBuilder 中，當新的 Event 進來時，就可以根據 Event 重新呼叫 builder 方法渲染畫面。\n\n```dart\nclass HelloWorld extends StatelessWidget {\n \tconst HelloWorld({Key? key}) : super(key: key);\n\n \t@override\n \tWidget build(BuildContext context) {\n \t\treturn StreamBuilder<String>(\n \t\t\tstream: helloWorld(),\n \t\t\tbuilder: (context, snapShot) {\n \t\t\t\tvar text = snapShot.hasData ? snapShot.data! : \"Loading\";\n\t\t\t\treturn Text(text);\n \t\t\t},\n \t\t);\n \t}\n\n \tStream<String> helloWorld() async* {\n \t\tyield \"Hello\";\n \t\tyield \"World\";\n \t\tyield \"!!\";\n \t}\n}\n\n```\n\n## 無用小知識\n\nQ: Stream 如果是 Future 的 List 版本，那 Stream.first 是否會回傳 Future？\nA: 答案：是，確實會回傳 Future，但實際上 Stream 並非真的是 Future 的陣列，first 是透過 Stream.listen 取得第一個 Event 並把它包裝成 Future，然後才回傳給呼叫端。\n\n![](Dart%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%B4%B9(%E4%B8%89)%20-%20Stream/stream_first_impl.png)\n\n## 參考\n\n- [Creating streams in Dart](https://dart.dev/articles/libraries/creating-streams)",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "January 1, 2025 8:55 AM",
      "id": "dbd16c50a0cc425aa313a3552758683d",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "Dart 非同步介紹(三) - Stream dbd16c50a0cc425aa313a3552758683d.md"
    },
    {
      "title": "Dart 非同步介紹(二) - Future",
      "summary": "在寫 Dart 的過程中，一定會碰到許多需要非同步的情境，例如：打 Web Api 從 Server 端讀寫資料、存取 local storage、sqlite...等等。Future 讓非同步操作用起來很容易，但若不清楚其執行邏輯，有些時候難免會造成一些 bug，而非同步的 bug 又比較難以除錯...",
      "content": "在寫 Dart 的過程中，一定會碰到許多需要非同步的情境，例如：打 Web Api 從 Server 端讀寫資料、存取 local storage、sqlite...等等。Future 讓非同步操作用起來很容易，但若不清楚其執行邏輯，有些時候難免會造成一些 bug，而非同步的 bug 又比較難以除錯。所以今天就來用個簡單的例子，來聊聊 Future 的執行邏輯。\n\n```dart\nvoid main() async {\n  print(\"1\");\n  await loadData();\n  print(\"4\");\n}\n\nFuture loadData() async {\n  print(\"2\");\n  await Future.delayed(Duration(seconds:1), () => \"data\");\n  print(\"3\");\n}\n```\n\n上面這段代碼執行結果是\n\n```dart\n1\n2\n3\n4\n```\n\n因為每一段非同步都用了await來等待，會等到結果回傳了才會往下一步前進。執行過程如下：\n\n1. 執行 print(\"1\") 並印出 1\n2. 進入 loadData() 方法中\n3. 執行 print(\"2\") 並印出 2\n4. 執行 Future.delayed() 並回傳 Future\n5. await 接到 Future.delayed 回傳的 Future 後，發現 Future 尚未執行完成，loadData() 也從 await 處回傳 Future，程式控制權從 loadData() 回到 main() 中\n6. 同理，main 方法中的 await 發現 loadData() 回傳的 Future 尚未執行完成，所以 main() 也從 await 處回傳 Future，程式控制權也從 main() 回到呼叫 main() 的 framework 中\n7. Future.delayed() 執行完成，並從 loadData() 中的 await 處繼續往下執行\n8. 執行 print(\"3\") 並印出 3\n9. loadData() 執行完成，並回傳完成執行的 Future 到 main() 中\n10. 回到 main() 後，從 await 處往下執行\n11. 執行 print(\"4\") 並印出 4\n\n## 移除 main 中的 await\n\n把呼叫 loadData() 時的 await拿掉以後並在執行一次\n\n```dart\nvoid main() async {\n  print(\"1\");\n  loadData();\n  print(\"4\");\n\n\t// 讓程式不要太快結束，避免來不及印出 3\n  await Future.delayed(Duration(seconds: 5), () => {});\n}\n\nFuture loadData() async {\n  print(\"2\");\n  await Future.delayed(Duration(seconds:1), () => \"data\");\n  print(\"3\");\n}\n```\n\n執行結果變成\n\n```dart\n1\n2\n4\n3\n```\n\n與第一個例子不同的是，當 loadData() 回傳未完成的 Future 後，main() 並沒有用 await 等待，所以程式就繼續往下執行，並印出 4。過了一秒之後，Future.delayed 完成並從 loadData() 的 await 處往下執行，並印出 3。\n\n## 移除 loadData 中的 await\n\n我們稍微修改一下例子，讓 main() 同樣 await loadData()，但是 loadData() 不 await Future.delayed()\n\n```dart\nvoid main() async {\n  print(\"1\");\n  await loadData();\n  print(\"4\");\n}\n\nFuture loadData() async {\n  print(\"2\");\n  Future.delayed(Duration(seconds:1), () => \"data\");\n  print(\"3\");\n}\n```\n\n執行結果回到\n\n```dart\n1\n2\n3\n4\n```\n\n與第一個例子不同的是，當 loadData() 執行到 Future.delayed() 時，此處沒有使用 await 來中斷執行，而是繼續往下執行並印出 3。當loadData() 執行完 print(\"3\") 回傳 Future 到 main() 中，此時 main() 中的 await 發現 Future 已經執行完成，所以也就已同步的方式往下執行並印出 4。\n\n## 執行 await 後的工作\n\n如同之前提到的 Dart 非同步會使用 queue 來安排工作，從 await 處往下執行的這項工作也同樣會被排進 queue 中，也就是說在當前工作未完成之前，即使 await 處的工作已經完成，也無法繼續往下執行，讓我們來看看另外一個例子\n\n```dart\nvoid main() async {\n  print(\"1\");\n  loadData();\n  sleep(Duration(seconds: 2));\n  print(\"4\");\n\n\t// 讓程式不要太快結束，避免來不及印出 3\n  await Future.delayed(Duration(seconds: 5), () => {});\n}\n\nFuture loadData() async {\n  print(\"2\");\n  await Future.delayed(Duration(seconds: 1), () => \"data\");\n  print(\"3\");\n}\n```\n\n執行結果是\n\n```dart\n1\n2\n4\n3\n```\n\n執行完 main() 需要兩秒，而Future.delayed() 的工作只需要一秒，但是結果還是先印出4，再印出 3，因為一次只能有一項工作在執行，此時已經被 main() 方法佔住了，所以即便 Future.delayed() 已經執行完成，它也只能乖乖在 queue 中等待 main() 把 sleep() 和 print(\"4\") 執行完，然後才輪到 print(\"3\")。\n\n## 小結\n\n看了上面幾個例子之後，我們可以歸納一些結論\n\n1. 沒有 await 的 async 方法等於同步方法\n2. 當程式執行到 await 時，是否往下執行取決於當下 Future 的狀態\n3. 非同步的 Future 執行結束後會排入 queue 中等待執行",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "January 1, 2025 8:55 AM",
      "id": "106987e499184351b18378ccef8a722b",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "Dart 非同步介紹(二) - Future 106987e499184351b18378ccef8a722b.md"
    },
    {
      "title": "Flutter Notification 事件機制研究",
      "summary": "當 CustomScrollView 或 ListView 開始滑動時，可以使用 NotificationListener 捕捉  ScrollStartNotification 的 Notification 事件。這些 Widget 會在滾動開始、進行中、結束時，發出各式各的 Notificati...",
      "content": "## 什麼是 Notification 事件\n\n當 CustomScrollView 或 ListView 開始滑動時，可以使用 NotificationListener 捕捉  ScrollStartNotification 的 Notification 事件。這些 Widget 會在滾動開始、進行中、結束時，發出各式各的 Notification 事件。\n\n```dart\nScrollStartNotification(metrics: metrics, context: context);\n\nScrollUpdateNotification(metrics: metrics, context: context, scrollDelta: scrollDelta);\n\nScrollEndNotification(metrics: metrics, context: context);\n```\n\n## 如何送出 Notification 事件\n\n送 Notification 事件的方式很簡單，以上面的 ScrollEndNotification 事件為例，只要呼叫 Notification 身上的 dispatch 方法，Notification 就會以同步的方式往上傳遞 Notification 事件。\n\n```dart\nScrollEndNotification(metrics: metrics, context: context).dispatch(context);\n```\n\n## Dispatch Notification 事件\n\ndispatch 是 Notification 這個抽象類別身上的一個方法，主要功能是送通知給上層 Widget。當 dispatch 被呼叫時，它沿著 Element Tree 一路往上，遇到 NotificationListener 時，就會呼叫 NotificationListener 的 _dispatch。（這邊的 _dispatch 不同於 Notification 身上的 dispatch）\n\n```dart\nabstract class Notification {\n\n  @protected\n  @mustCallSuper\n  bool visitAncestor(Element element) {\n    if (element is StatelessElement) {\n      final StatelessWidget widget = element.widget;\n      if (widget is NotificationListener<Notification>) {\n        if (widget._dispatch(this, element)) // that function checks the type dynamically\n          return false;\n      }\n    }\n    return true;\n  }\n\n  void dispatch(BuildContext? target) {\n    // The `target` may be null if the subtree the notification is supposed to be\n    // dispatched in is in the process of being disposed.\n    target?.visitAncestorElements(visitAncestor);\n  }\n\n  ...\n}\n```\n\n## Notification 事件傳遞\n\n當 _dispatch 被呼叫時，它嘗試呼叫傳入的 onNotification 的 callback。onNotification callback 會回傳 bool 值，用以決定這個 Notification 事件是否繼續往上通知，如果回傳 true，表示阻斷這個 Notification 事件繼續往上，這個 Notification 就不會被更外層的 NotificationListener 收到了。相反的，如果回傳 false，則會繼續往上傳遞這個 Notification 事件。\n\n```dart\nclass NotificationListener<T extends Notification> extends StatelessWidget {\n  \n\t...\n\t\n  final NotificationListenerCallback<T>? onNotification;\n\n  bool _dispatch(Notification notification, Element element) {\n    if (onNotification != null && notification is T) {\n      final bool result = onNotification!(notification);\n      return result == true; // so that null and false have the same effect\n    }\n    return false;\n  }\n\n}\n```\n\n比方說以下面這段代碼為例，當使用者按下 Click me 按鈕送出 MyNotification 之後，最靠近 Button  的 NotificationListener 會收到 Notification，並印出 \"Receive notification inside\"，隨即回傳了 true，也終止了事件繼續往上傳遞，外層 NotificationListener 也就收不到 Notification，在 Console 就只會印出 \"Receive notification inside\"，而沒有印出 \"Receive notification outside\"。\n\n```dart\nclass MyNotificationWidget extends StatelessWidget {\n  const MyNotificationWidget({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return NotificationListener<MyNotification>(\n      onNotification: (notification) {\n        print(\"Receive notification outside\");\n        return false;\n      },\n      child: NotificationListener<MyNotification>(\n        onNotification: (notification) {\n          print(\"Receive notification inside\");\n          return true;\n        },\n        child: Builder(\n          builder: (context) {\n            return TextButton(\n              child: Text(\"Click me\"),\n              onPressed: () {\n                MyNotification().dispatch(context);\n              },\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 客製化 Notification 事件\n\n除了 Scroll 的 Notification 事件，我們也可以定義自己的 Notification 事件\n\n```dart\nclass MyNotifcation extends Notification {}\n```\n\n在需要的時候，使用 Notification 身上的 dispatch 發送事件\n\n```dart\nMyNotifcation().dispatch(context);\n```\n\n最後在 Widget 中使用 NotificationListener 接收事件\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return NotificationListener<MyNotification>(\n    onNotification: (notification) {\n      setState(() {\n        _count++;\n      });\n      return false;\n    },\n    child: Text(\n      'count: $_count',\n      style: Theme.of(context).textTheme.headline4,\n    ),\n  );\n}\n```\n\n## 小結\n\nNotification 事件提供了一種機制讓子層 Widget 通知父層 Widget，用法也相當的簡單，且可以通知多個 NotificationListener，不過需要注意的是，Notification 事件通知的方式是同步的，所以盡量不要再 onNotification 中執行耗時的操作，否則可能會影響畫面更新。",
      "createdAt": "August 31, 2021 1:46 PM",
      "updatedAt": "January 1, 2025 8:55 AM",
      "id": "349055b3e6dc43c5976af586d01cbe81",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "Flutter Notification 事件機制研究 349055b3e6dc43c5976af586d01cbe81.md"
    },
    {
      "title": "如何在多台電腦間同步開發工具",
      "summary": "這篇來紀錄一下我如何同步開發工具這件事，我自己有一台 MacBook，公司也提供一台 MacBook 供同仁開發使用。有時候我在公司或家裡進行開發時，會發現某些設定過的熱鍵怎麼失效了，而原因也其實很簡單，由於熱鍵只被設定在公司或家裡的電腦上，所以當今天用到另外一台時，熱鍵就會失效。 為了解決這個問題...",
      "content": "![richard-lee-HZvKrcQflA0-unsplash.jpg](%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%9A%E5%8F%B0%E9%9B%BB%E8%85%A6%E9%96%93%E5%90%8C%E6%AD%A5%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7/richard-lee-HZvKrcQflA0-unsplash.jpg)\n\n這篇來紀錄一下我如何同步開發工具這件事，我自己有一台 MacBook，公司也提供一台 MacBook 供同仁開發使用。有時候我在公司或家裡進行開發時，會發現某些設定過的熱鍵怎麼失效了，而原因也其實很簡單，由於熱鍵只被設定在公司或家裡的電腦上，所以當今天用到另外一台時，熱鍵就會失效。\n\n為了解決這個問題，我們需要一些同步開發工具的方法，讓我們無論何時何地進行開發，都能用自己最熟練的工具，有效減少開發時間的浪費。\n\n本篇文章會紀錄如何同步 IntelliJ、ideaVim 和 Alfred，所以如果你的開發工具與我不同，可以自行斟酌是否繼續往下觀看。\n\n# 同步 IntelliJ 的設定\n\n同步 intelliJ 本身的設定並不困難，IntelliJ 本身就有提供同步設定的功能，只要我們在 IntelliJ 登入相同的帳號，並開啟同步功能，Plugin 與快捷鍵 …等設定就能在兩台不同的電腦中同步。\n\n![截圖 2023-02-05 下午9.53.36.png](%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%9A%E5%8F%B0%E9%9B%BB%E8%85%A6%E9%96%93%E5%90%8C%E6%AD%A5%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7/%25E6%2588%25AA%25E5%259C%2596_2023-02-05_%25E4%25B8%258B%25E5%258D%25889.53.36.png)\n\n# 同步 IdeaVim 的設定\n\n除了快捷鍵之外，還有 IdeaVim 的設定需要同步，IdeaVim 的指令設定檔預設存放在 ~/.ideavimrc 中，而且無法修改其路徑。為了解決這個問題，我們可以把 ideavimrc 放到可以同步共享的目錄中，例如：Apple 的 iCloud 或 Dropbox 中。\n\n![截圖 2023-03-05 下午10.16.35.png](%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%9A%E5%8F%B0%E9%9B%BB%E8%85%A6%E9%96%93%E5%90%8C%E6%AD%A5%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7/%25E6%2588%25AA%25E5%259C%2596_2023-03-05_%25E4%25B8%258B%25E5%258D%258810.16.35.png)\n\n並在本地的 .ideavimrc 檔案中，載入共享的 ideavimrc，直得注意的是，共享的檔案並非一定要命名成 ideavimrc。值得注意的是，必須允許 IntelliJ 必須有存取共享資料夾權限，否則會發現無法正常載入共享的 ideavimrc。\n\n```bash\nsource ~/Library/CloudStorage/Dropbox/ideavimrc\n```\n\n修改完之後，我們只要重開 IntelliJ 或者輸入以下指令重載本地 .ideavimrc 即可。\n\n```bash\n:source /Users/username/.ideavimrc\n```\n\n# 同步共享工具箱\n\n除了 IDE ，我們時常會需要使用一些小工具來輔助開發，例如：timestamp 轉換工具、JSON format 工具、正規表示法等等。以我自己的習慣來說，我喜歡直接使用相關網站，如果我們使用 Chrome，我們可以透過登入相同帳號來同步書籤。但是有些時候，我們的私人帳號與公司帳號是分開的，我們就比較難用同步書籤的方式來同步公司與家中電腦的書籤。\n\n### 使用 Alfred Workflow 維護工具庫\n\n利用 Alfred workflow 功能，我們可以實現簡單的開發工具箱，並且使用 Dropbox 等共享資料夾的功能，我們就可以同步 Alfred 設定的同時，同步我們的工具箱。此外 Dropbox 可以根據自己的喜好，替換成其他相同功能的產品。\n\n![Discuss - Alfred toolbox.jpg](%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%9A%E5%8F%B0%E9%9B%BB%E8%85%A6%E9%96%93%E5%90%8C%E6%AD%A5%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7/Discuss_-_Alfred_toolbox.jpg)\n\n![截圖 2023-03-05 下午9.16.53.png](%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%9A%E5%8F%B0%E9%9B%BB%E8%85%A6%E9%96%93%E5%90%8C%E6%AD%A5%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7/%25E6%2588%25AA%25E5%259C%2596_2023-03-05_%25E4%25B8%258B%25E5%258D%25889.16.53.png)\n\n# 結論\n\n在開發中，我們需要維護好自己的開發工具，就好像廚師會磨刀，把自己的工具擺放整齊，當下廚時，就能專注在料理這件事情上。同樣的的道理，如何在多台電腦中同步好自己的開發工具，也是十分重要的準備，即便我們換了一台電腦，也可以快速進入狀態，而不是手忙腳亂的白白浪費寶貴的開發時間。",
      "createdAt": "February 4, 2023 11:37 PM",
      "updatedAt": "January 1, 2025 8:55 AM",
      "id": "11773cd13f2a46f5adfa039331d42af8",
      "type": "Medium",
      "tag": "熟練工具",
      "filename": "如何在多台電腦間同步開發工具 11773cd13f2a46f5adfa039331d42af8.md"
    },
    {
      "title": "如何處理善變的畫面",
      "summary": "開發客戶端程式時，有些時候後端傳過來的資料根據情況變化，畫面也有所不同。舉例來說，當使用者登入系統時，後端會根據使用者的權限等級傳送不同的資料，使畫面呈現出不同的功能和選項。另一個例子是，在我們的開發的遊戲中，顯示比賽列表的畫面，也會根據不同的場次型態，顯示不同的卡片樣式。 當回傳資料不一致時，會發...",
      "content": "![hal-gatewood-tZc3vjPCk-Q-unsplash.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/hal-gatewood-tZc3vjPCk-Q-unsplash.jpg)\n\n開發客戶端程式時，有些時候後端傳過來的資料根據情況變化，畫面也有所不同。舉例來說，當使用者登入系統時，後端會根據使用者的權限等級傳送不同的資料，使畫面呈現出不同的功能和選項。另一個例子是，在我們的開發的遊戲中，顯示比賽列表的畫面，也會根據不同的場次型態，顯示不同的卡片樣式。\n\n![Screenshot_1677384908.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677384908.jpg)\n\n![Screenshot_1677384904.png](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677384904.png)\n\n當回傳資料不一致時，會發生許多 if 判斷式散佈在各個地方，這就是所謂的 Shortgun Surgery 問題。換句話說，當你需要修改一個功能時，你需要在多個地方進行修改，這樣會導致代碼的耦合性增加，並且增加了代碼的維護成本。\n\n# 舉個例子\n\n在我們的遊戲中，後端會給前端每一場比賽資料，讓前端可以顯示比賽資訊。在下圖中，我們從後端接收了一個 Json 物件，然後把 Json 物件轉換成 Contest 物件，最後一路傳到 View，給 View 決定如何顯示畫面。\n\n![Discuss - Receive contest from server.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Receive_contest_from_server.jpg)\n\n在上面的例子中，不同的 Contest 型態，有不同的卡片樣式，當 Contest 的類型不同，後端可能也會根據不同的 Contest 而給前端不同資料，假設我們使用的強型別的語言，那我們到底要如何把不同的 Json 轉成同一個物件呢？\n\n# 萬能的 Value Object\n\n最簡單解決問題的方式，我們可以在 Contest 放上所有可能的出現的資料，View 則是根據自己的需要選擇相對應的欄位使用。以 Practice Contest View 來說，他只會使用 type 與 spots，但對 Non-Pratice Contest 來說，則是所有欄位都會使用。\n\n![Discuss - Omnipotent Value Object.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Omnipotent_Value_Object.jpg)\n\n### 優點\n\n- 容易使用\n\n### 缺點\n\n- 使用端依賴了他不需要的東西，違反介面隔離的原則，以 Practice Contest 來說，他並不需要 entryFee 與 maxPrizePool\n\n# 轉接器模式\n\n另一個例子是，在下面的畫面中，可以發現大部分的畫面樣式都相同，唯一不同的是球員的資訊，不同球類的球員，顯示不同的數值來展示球員的過去表現。以板球球員來說，我們使用 Batting 與 Bowling 表示球員綜合表現，以足球來說，則是使用 Points 表示。\n\n![Screenshot_1677250687.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677250687.jpg)\n\n![Screenshot_1677248725.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677248725.jpg)\n\n此時大部分的資料都是類似的，只有少部分關於球員表現的資料略微不同，我們可以使用**轉接器模式**，把後端傳回來的資料，轉換成另一種格式，讓畫面可以用一致的方式操作資料。\n\n![Discuss - Adapter for vo.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Adapter_for_vo.jpg)\n\n以球員表現的例子來説，我們可以把新增一個 Map，用以儲存每種球員數據的 Enum 與其數字，View 在使用時，就可以顯示 Map 中的所有數據即可，而無須關心到底是板球還是足球。\n\n### 優點\n\n- 畫面可以使用一致的邏輯處理資料\n\n### 缺點\n\n- 當資料差異畫過大時，難以整理成一種共用的格式\n\n# 策略模式\n\n在我們的遊戲中，我們有許多不同的廣告，有時是單純的一張圖，有時是比賽資訊，而後端則是根據不同情況傳回不同資料。與球員數據問題類似，我們都接收來自後端不大相同的資料，但不同的是，這些資料幾乎沒有共通性，我們難以使用轉接器模式整理出一致的格式。\n\n![Screenshot_1677251104.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677251104.jpg)\n\n![Screenshot_1677425946.png](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677425946.png)\n\n為了解決這個問題，我們可以使用**策略模式**，提供一個包含 buildComponent 的方法的介面。當 AdView 從 Controller 取得 Ad 物件時，呼叫 Ad 物件身上的 buildComponent 方法取得顯示用的 Component。 當我們這樣做之後，View 再也無需關心現在到底是哪一種廣告，只需要呼叫 buildComponent 即可取得相對應的廣告畫面，並把它塞進畫面中即可。\n\n![Discuss - Strategy for vo.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Strategy_for_vo.jpg)\n\n在 GeneralAd 與 ContestAd 中，它們會各自實現 buildComponent，提供該類型廣告的 Widget 給 View 顯示。\n\n### 優點\n\n- 畫面可以使用一致的邏輯處理資料\n\n### 缺點\n\n- Value Object 會認識 View\n\n# 結論\n\n由於客戶端畫面可能會相當多變，後端可能會給一個 type，不同 type 所包含的資料格式也大不相同，如何處理這個資料與畫面的關係也沒有標準答案，即便問題相似，但是在不同的 Context 之下，也適合不同的解法，只有根據當下情況選擇適當的做法，才能讓後續開發與維護更加順利。",
      "createdAt": "February 21, 2023 11:40 PM",
      "updatedAt": "January 1, 2025 8:55 AM",
      "id": "c87c61c7fc3541378813919fd3d19efa",
      "type": "Medium",
      "tag": "軟體開發",
      "filename": "如何處理善變的畫面 c87c61c7fc3541378813919fd3d19efa.md"
    },
    {
      "title": "如何讓 ListView 自動對齊",
      "summary": "在 Flutter 中，ListView 和 PageView 都是用於顯示多個元素的 Widget，使用者可以滑動瀏覽列表中的 Widget。如果單看功能性，ListView 和 PageView 可能沒太大區別。但是實際與其互動之後，就會發現他們在畫面上的表現還是有所不同。 使用 ListVie...",
      "content": "![glenn-carstens-peters-RLw-UC03Gwc-unsplash.jpg](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/glenn-carstens-peters-RLw-UC03Gwc-unsplash.jpg)\n\n在 Flutter 中，ListView 和 PageView 都是用於顯示多個元素的 Widget，使用者可以滑動瀏覽列表中的 Widget。如果單看功能性，ListView 和 PageView 可能沒太大區別。但是實際與其互動之後，就會發現他們在畫面上的表現還是有所不同。\n\n使用 ListView，使用者可以讓 ListView 停在列表中的任意位置，可以讓它停在某個元素的開頭，也可以停在某個元素一半的位置。而 PageView 就有點不同，雖然使用者一樣可以透過滑動來把 PageView 中的元素滑到任意位置，但是只要手一放開，PageView 就會自動的把元素歸位到正中央。\n\n![list_view.gif](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/list_view.gif)\n\n![page_view.gif](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/page_view.gif)\n\n大多數情況下，我們可以用 ListView 與 PageView 來完成功能。但是有些時候，我們也會需要客製化一些特別的行為，就像是今天要介紹的：用 ListView 來達到自動對齊的效果。\n\n# **建立 SnapListView**\n\n首先我們需要一個可以水平滑動的 ListView 並先命名為 SnapListView。\n\n```dart\nclass SnapListView extends StatelessWidget {\n  const SnapListView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    const itemExtent = 200.0;\n    return ListView.builder(\n      scrollDirection: Axis.horizontal,\n      itemBuilder: (context, index) => Container(\n        width: 200,\n        alignment: Alignment.center,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.black),\n        ),\n        child: Text('Item $index', style: const TextStyle(fontSize: 30)),\n      ),\n    );\n  }\n}\n```\n\n接下來我們要如何實現自動對齊的效果呢？答案就是修改 ListView 中的 physics 參數。physics 參數定義在 ListView 祖父類別 ScrollView 中，型別為 ScrollPhysics。\n\n```dart\nconst ScrollView({\n    super.key,\n    this.scrollDirection = Axis.vertical,\n    this.reverse = false,\n    this.controller,\n    this.primary,\n    ScrollPhysics? physics,\n    this.scrollBehavior,\n    this.shrinkWrap = false,\n    this.center,\n    this.anchor = 0.0,\n    this.cacheExtent,\n    this.semanticChildCount,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,\n    this.restorationId,\n    this.clipBehavior = Clip.hardEdge,\n  })\n\n```\n\n# **ScrollPhysics**\n\nFlutter 中原本就內建許多類別繼承自 ScrollPhysics ，例如：Android 預設的 ClampingScrollPhysics 或者是 iOS 預設 BouncingScrollPhysics 。這些 ScrollPhysics 可以套在很多可滑動的 Widget，例如：CustomeScrollView 或 GridView …等，套用不同的 ScrollPhysics 可在滑動的時候產生不同效果。\n\n雖然 Flutter 提供許多不同的 ScrollPhysics，但是這些內建的 ScrollPhysics 並不能幫助我們的目標：自動對齊第一個元素。所以我們需要自定義一個 ScrollPhysics 來幫助我們達到目的。\n\n# **建立 SnapScrollPhysics**\n\n讓我們新增一個 SnapScrollPhysics 類別，並繼承 ScrollPhysics 。我們傳入 itemExtent 來表明列表中每個元素的大小，用於計算模擬滑動的最終位置，畢竟使用者不會每次都停在相同位置，所以我們必須根據停止的位置與元素大小來計算最終位置。\n\n```dart\nclass SnapScrollPhysics extends ScrollPhysics {\n  final double itemExtent;\n\n  const SnapScrollPhysics({\n    required this.itemExtent,\n    super.parent,\n  });\n\n  @override\n  SnapScrollPhysics applyTo(ScrollPhysics? ancestor) {\n    return SnapScrollPhysics(\n      itemDimension: itemExtent,\n      parent: buildParent(ancestor),\n    );\n  }\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    return null;\n  }\n}\n```\n\n在 ScrollPhysics 中有許多方法可提供覆寫。而在這個需求中，我們需要覆寫 createBallisticSimulation ，這個方法可以回傳一個 Simulation，讓使用者手指放開時，讓程式依據回傳的 Simulation，自動的把列表滾到 Simulation 所設定的位置。\n\n值得一提的是，我們也需要覆寫 applyTo 方法，讓 ScrollView 在引入效果時，可以套用到我們定義的 SnapScrollPhysics 。雖然我們只在 ListView 中只傳入了 SnapScrollPhysics ，但是其實 Flutter 底層還會繼續套用其他的 ScrollPhysics ，讓 ListView 具有多種滑動效果。\n\n# **實現 createBallisticSimulation**\n\n首先，我們先處理一些例外狀況，當使用者滑超出列表範圍時，我們呼叫 super 的 createBallisticSimulation 的方法即可，讓其他 ScrollPhysics 來處理超出列表的行為。\n\n```dart\nclass SnapScrollPhysics extends ScrollPhysics {\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    if (position.pixels <= position.minScrollExtent ||\n        position.pixels >= position.maxScrollExtent) {\n      return super.createBallisticSimulation(position, velocity);\n    }\n\n    return null;\n  }\n}\n```\n\n接著我們透過 position.pixels 取得列表當前的位置，並使用 roundToDouble 四捨五入，來決定應該要自動移動到上一個元素或下一個元素。最後建立 ScrollSpringSimulation 並指定起始位置與目標位置，讓 Flutter 在使用者手放開之後，模擬使用者滑動，讓使用者體驗更好。\n\n```dart\n\nclass SnapScrollPhysics extends ScrollPhysics {\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    if (position.pixels <= position.minScrollExtent ||\n        position.pixels >= position.maxScrollExtent) {\n      return super.createBallisticSimulation(position, velocity);\n    }\n\n    double page = position.pixels / itemExtent;\n    double target = page.roundToDouble() * itemExtent;\n    if (target != position.pixels) {\n      return ScrollSpringSimulation(\n        spring,\n        position.pixels,\n        target,\n        velocity,\n      );\n    }\n    return null;\n  }\n}\n```\n\n但是當我們實際執行後，卻會發現用起來十分不順，原因是當使用者一放開手，Flutter 就會馬上開始模擬滑動，造成滑動不順暢。在真實滑動的過程中，使用者的手指是會頻繁地離開的手機螢幕，不會一直貼在螢幕上，所以我們必須在使用者手離開螢幕時，依據使用者滑動方向與速率來微調一下目標位置。\n\n```dart\nclass SnapScrollPhysics extends ScrollPhysics {\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    if (position.pixels <= position.minScrollExtent ||\n        position.pixels >= position.maxScrollExtent) {\n      return super.createBallisticSimulation(position, velocity);\n    }\n\n    double page = position.pixels / itemExtent;\n    \n    var tolerance = toleranceFor(position);\n    if (velocity < -tolerance.velocity) {\n      page -= 1;\n    } else if (velocity > tolerance.velocity) {\n      page += 1;\n    }\n\n    double target = page.roundToDouble() * itemExtent;\n    if (target != position.pixels) {\n      return ScrollSpringSimulation(\n        spring,\n        position.pixels,\n        target,\n        velocity,\n      );\n    }\n    return null;\n  }\n}\n```\n\n當發現使用者滑動的速率大於容忍值時，表示使用者想要快速滑動。所以我們必須依照使用者快速滑動的方向，創建一個往使用者滑動方向的滑動模擬，避免使用者手指一離開，列表就往反方向滑動。最後我們把完成的 SnapScrollingPhysics 放回 ListView 中，就能得到一個比較順暢的自動對齊效果。\n\n```dart\nclass SnapListView extends StatelessWidget {\n  const SnapListView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      scrollDirection: Axis.horizontal,\n      physics: const SnapScrollPhysics(itemExtent: 200.0),\n      itemCount: 10,\n      itemBuilder: (context, index) => Container(\n        width: 200,\n        alignment: Alignment.center,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.black),\n        ),\n        child: Text('Item $index', style: const TextStyle(fontSize: 30)),\n      ),\n    );\n  }\n}\n```\n\n![snap_list_view.gif](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/snap_list_view.gif)\n\n# **最後**\n\n雖然我們完成了自動對齊的效果，但其實程式碼還是有一些 Bug。例如：滑到最後一個元素時，列表不會像預期中的自動對齊，因為它採用了其他 ScrollPhysics 而非我們設定的 SnapScrollPhysics ，有興趣的觀眾可以嘗試修改看看。\n\n除此之外，ScrollPhysics 還有許多方法可以覆寫，讓開發人員可以調整許多滑動細節，有興趣的觀眾也可以也可以參考 [ScrollPhysics](https://api.flutter.dev/flutter/widgets/ScrollPhysics-class.html) 。",
      "createdAt": "May 2, 2024 1:08 AM",
      "updatedAt": "January 1, 2025 8:55 AM",
      "id": "c33fa8d2cae0490f8a7761e388b43224",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "如何讓 ListView 自動對齊 c33fa8d2cae0490f8a7761e388b43224.md"
    },
    {
      "title": "減緩 PageView 動畫加上 Table 造成的卡頓",
      "summary": "最近我們新增了一個顯示球員詳細資訊的頁面，當我們完成第一版程式碼，開始調整細節時，我們發現了畫面滑動似乎不太順暢。 每個球員訊息彈跳視窗是靜態，外層使用了 PageView 加上一些的特效，使得畫面在滑動時會頻繁的 setState，造成了整個彈跳視窗卡頓，使用者體驗不佳，就像遊戲效能不好一樣會掉幀...",
      "content": "![mateus-campos-felipe-ebRHyE2u3X4-unsplash.jpg](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/mateus-campos-felipe-ebRHyE2u3X4-unsplash.jpg)\n\n最近我們新增了一個顯示球員詳細資訊的頁面，當我們完成第一版程式碼，開始調整細節時，我們發現了畫面滑動似乎不太順暢。\n\n![改善前_AdobeExpress.gif](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/%25E6%2594%25B9%25E5%2596%2584%25E5%2589%258D_AdobeExpress.gif)\n\n每個球員訊息彈跳視窗是靜態，外層使用了 PageView 加上一些的特效，使得畫面在滑動時會頻繁的 setState，造成了整個彈跳視窗卡頓，使用者體驗不佳，就像遊戲效能不好一樣會掉幀，嚴重一點可能會讓人不舒服。今天就來分享如何快速有效的解決這個問題吧。\n\n# 釐清問題\n\n首先，想要有效的解決問題，釐清問題是第一步。為了要了解我們畫面卡頓的問題根源，我們使用 Flutter 提供的 DevTools 並在實體手機上運行 Profile 模式，Profile 模式是讓 App 運行效能接近 Release 模式同時又能搜集運行資訊的一種模式。當我們執行程式並開起 DevTools 之後，可以觀察到 App 運行時，每一個 Frame 效能到底如何。\n\n### Dev tools\n\n在  Dev Tools 面板中，可以發現在大多數 Frame 中，UI phase 與 Raster phase 都花了很多時間，這通常表示問題可能有很多個，但是我們今天先研究 UI phase 花過久時間的問題吧。\n\n![Screen Shot 2023-07-03 at 1.23.37 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-03_at_1.23.37_PM.png)\n\n在面板中清楚看到了 Build 和 Layout 畫面的操作各花了多久時間，我們可以初步了解問題可能發生在哪邊，但是只有這些資訊，顯然不夠我們解決問題。\n\n### 啟用 Track Widget Builds\n\n為了更深入了解問題出在哪邊，我們可以在 Dev Tools 的右上角打開 Enhance Tracing，並且勾選 Track Widget Builds，這個功能可以提供更詳細的時間，提供每一個 Widget 在每一個 Frame 中所花費的時間。\n\n![Screen Shot 2023-07-03 at 1.36.51 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-03_at_1.36.51_PM.png)\n\n### 觀察 Widget Build 火焰圖\n\n當我們啟用 Track Widget Build 之後，我們再繼續操作一下手機，讓手機繼續執行幾個 Frame，我們就能這些新產生的報告找到 Timeline Events，在 Timeline Events 中， DevTools 顯示在這個 Frame 中 Build Widget 所花費的時間，能更直觀地看到時間到底花在哪個 Widget 上了。\n\n![Screen Shot 2023-07-03 at 1.24.21 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-03_at_1.24.21_PM.png)\n\n### 分析問題\n\n從火焰圖中我們可以得知，PlayerInfoGameLogView 花費的時間佔了很大一部份比例，而且每一個 Frame 都是這種狀況。這表示畫面滑動的時候，每一個 Frame 都在重新建立這個 Widget。雖然我們滑動需要頻繁的 setState，畫面其實是不變的，數值並不會在滑動過程中有變化，應該要可以使用重複使用之前已經 Build 好的 Widget，但是顯然 Flutter 不這麼認為，而是辛苦的每一個 Frame 都Rebuild 新的 Widget。\n\n# 解決問題\n\n為了更準確解決 PlayerInfoGameLogView 被頻繁建立的問題，也為了讓讀者們可以一起同樂，我們先在 Dartpad 準備有問題的範例程式 [[連結](https://dartpad.dev/?id=9bf6ba724ce6b3c62c9c490905b2fbbf)]，有興趣的讀者也可以試試看。讓我們看一下程式碼，在範例程式中，當我們滑動 PageView 時，PageView 頻繁的呼叫 itemBuilder 來更新畫面，讓 PageView 中的每一個 Item 可以隨著滑動改變大小，但是這麼做也使得 GameLogView 頻繁的被 Rebuild，即便每次傳進去的 gameLogs 是一模一樣的。\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key, required this.players});\n\n  final List<Player> players;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: PlayerPageView(\n        itemCount: players.length,\n        itemBuilder: (BuildContext context, int index) {\n          return Container(\n            padding: const EdgeInsets.symmetric(horizontal: 16),\n            alignment: Alignment.center,\n            child: GameLogView(gameLogs: players[index].gameLogs),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n讓我們看一下這段範例程式碼的效能分析，與正式程式碼的效能差不多，在 UI phase 階段所花的時間都偏高。\n\n![Screen Shot 2023-07-07 at 1.46.59 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-07_at_1.46.59_PM.png)\n\n### 只在資料變化時 Rebuild\n\n最終，我希望 Flutter 不要總是 Rebuild GameLogView，而達到這個目標，我們可以把 gameLogs 放在 Provider 中，然後需要使用 gameLogs 的地方呼叫 context.watch 去存取並監聽 gameLogs，這樣一來就能讓 Widget 不需要一層一層傳遞 gameLogs，最外層的 GameLogView 也就可以加上 const 修飾詞，讓 Flutter 知道這是一個固定的 Widget，避免 Flutter 總是 Rebuild 它。\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key, required this.players});\n\n  final List<Player> players;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: PlayerPageView(\n        itemCount: players.length,\n        itemBuilder: (BuildContext context, int index) {\n          return Container(\n            padding: const EdgeInsets.symmetric(horizontal: 16),\n            alignment: Alignment.center,\n            child: Provider<List<GameLog>>.value(\n              value: players[index].gameLogs,\n              child: const GameLogView(),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass _GameLogTable extends StatelessWidget {\n  const _GameLogTable();\n\n  @override\n  Widget build(BuildContext context) {\n    var gameLogs = context.watch<List<GameLog>>();\n    return Table(\n      ...\n    );\n  }\n}\n```\n\n當我們調整好程式碼之後，PageView 執行 setState 之後，GameLog 就不會 Rebuild，而是會重複使用已經建好的 Widget，有興趣的觀眾也可以在 GameLogView 的 build 方法印 log 觀察看看。最後讓我們看一下問題解決之後的範例程式碼的效能分析，在少數幾個 Frame 中，UI phase 花的時間是超時的，剩下大部分時間都是在標準以內。\n\n![Screen Shot 2023-07-07 at 1.44.26 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-07_at_1.44.26_PM.png)\n\n如果實際上運行解決後的範例程式之後 [[連結](https://dartpad.dev/?id=fdc0e92365fade89d5253647a4710b2d)]，可以發現滑動的過程中比較順了，但還是有一些時刻會感受到卡頓。\n\n### 尚未解決的卡頓\n\n當我們使用 Provider 提升效能之後，我們發現第一次 Build  GameLogView 的時候還是會超時，使得下一個 GameLog 顯示時，畫面會出現明顯卡頓。此時我們暫時沒有比較好的辦法可以解決問題，因為 Table 目前沒有提供 builder 的方法，當渲染比較大的 Table 時，所有欄位都會在第一時間被建立，無論他有沒有出現在畫面上，使得 UI phase 的時間還是會比較長，也就是我們上面效能分析所顯示的狀況。\n\n### 應用在產品程式碼中\n\n當我們把這個做法放回產品程式碼中，並再次檢測 App 效能，可以發現超時的 UI phase 大幅減少，更多的是超時的 Raster phase，這也表示我們方法有效這個畫面的效能。\n\n![調整後.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/%25E8%25AA%25BF%25E6%2595%25B4%25E5%25BE%258C.png)\n\n# 結論\n\n過早優化是萬惡之源，當我們發現效能問題時，透過釐清與分析問題，找到並解決瓶頸，在能花最小的力氣獲得最大的增益。如果我們再開發的時候為了使用 const 而寫了很多不必要的程式碼，除了浪費時間之外，也降低程式碼的可讀性，獲得的增益可能微乎其微。",
      "createdAt": "June 24, 2023 11:24 PM",
      "updatedAt": "January 1, 2025 8:55 AM",
      "id": "a05dbbc423404d19954fb69ebfee4496",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "減緩 PageView 動畫加上 Table 造成的卡頓 a05dbbc423404d19954fb69ebfee4496.md"
    }
  ],
  "tags": [
    "AI Coding",
    "Android",
    "C# / .NET",
    "Flutter",
    "Notion",
    "思維進化",
    "熟練工具",
    "軟體開發"
  ],
  "sideProjects": [
    {
      "name": "今彩 539 開獎資訊",
      "description": "用 Github Action + 爬蟲達成無後端式資訊收集與統計",
      "tags": [
        "React",
        "Python",
        "AI"
      ],
      "date": "2025/06",
      "websiteUrl": "https://easylive1989.github.io/ito539_analytics/",
      "sourceUrl": "https://github.com/easylive1989/ito539_analytics",
      "preview": "images/ito539_analytics.png"
    },
    {
      "name": "Auto Master",
      "description": "自動化各種常見任務，例如：FB 發文、FB 社團發文 ...等",
      "tags": [
        "Electron",
        "React",
        "Playwright",
        "AI"
      ],
      "date": "2025/04",
      "websiteUrl": "",
      "sourceUrl": "",
      "preview": "images/auto_master.png"
    },
    {
      "name": "Breakout",
      "description": "按照教程練習 Flame，實作經典遊戲：打磚塊",
      "tags": [
        "Flutter",
        "Flame"
      ],
      "date": "2023/02",
      "websiteUrl": "https://easylive1989.github.io/flutter_breakout",
      "sourceUrl": "https://github.com/easylive1989/flutter_breakout",
      "preview": "images/breakout.png"
    },
    {
      "name": "NS-SHAFT",
      "description": "練習 Flame 開發，搭配 Firebase Hosting 部署，實作經典遊戲：小朋友下樓梯",
      "tags": [
        "Flutter",
        "Flame",
        "Firebase Hosting"
      ],
      "date": "2022/12",
      "websiteUrl": "https://playernsshaft.web.app/#/",
      "sourceUrl": "https://github.com/easylive1989/player_ns_shaft",
      "preview": "images/ns-shaft.png"
    },
    {
      "name": "Notion Assisant",
      "description": "用 Flutter 嘗試製作 Chrome Extension 快速存取 Notion 資訊",
      "tags": [
        "Flutter",
        "Chrome Extension",
        "Notion API"
      ],
      "date": "2022/10",
      "websiteUrl": "",
      "sourceUrl": "https://github.com/easylive1989/notion_assistant",
      "preview": "images/notion_assistant.png"
    },
    {
      "name": "Habit Tracker",
      "description": "練習追蹤習慣 App，回憶一下 Android 開發",
      "tags": [
        "Android"
      ],
      "date": "2021/07",
      "websiteUrl": "",
      "sourceUrl": "https://github.com/easylive1989/HabitTracker",
      "preview": "images/habit_tracker.png"
    },
    {
      "name": "Notion Cron Job",
      "description": "用 Github Action 觸發 Python 腳本使用 Notion API 定期更新 Notion 內容",
      "tags": [
        "Python",
        "Notion API"
      ],
      "date": "2021/07",
      "websiteUrl": "",
      "sourceUrl": "https://github.com/easylive1989/notion_cron_job",
      "preview": "images/notion_cron_job.png"
    },
    {
      "name": "Gomoku",
      "description": "嘗試用 Flutter 開發五子棋小遊戲，並且使用 Github Action 自動化部署到 Google Play",
      "tags": [
        "Flutter",
        "CI/CD"
      ],
      "date": "2021/03",
      "websiteUrl": "https://easylive1989.github.io/LittleFlowerApp/",
      "sourceUrl": "https://github.com/easylive1989/LittleFlowerApp",
      "preview": "images/gomoku.png"
    },
    {
      "name": "小遊戲 Line Bot",
      "description": "嘗試用 .Net Core + LINE 讓朋友們可用 Line 玩小遊戲，例如：猜數字、井字遊戲、五子棋",
      "tags": [
        ".Net Core",
        "Line Notify"
      ],
      "date": "2020/05",
      "websiteUrl": "",
      "sourceUrl": "https://github.com/easylive1989/LittleFlowerBot",
      "preview": "images/game_bot.png"
    }
  ],
  "generatedAt": "2025-10-24T07:40:21.584Z"
}
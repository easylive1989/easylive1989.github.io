# Day 8 - 共享狀態加上複雜邏輯

note: 跨頁面共享資料
id: 8
tag: 設計

當我們在開發 Flutter 時，有些時候我們會需要不斷的改變狀態，並把改變後的狀態渲染至畫面上。當隨著需求越來越複雜，改變狀態的邏輯也會開始變得複雜。假設今天有一個選擇相片的功能：畫面中有一個相片列表，使用者可以透過點擊相片選取，並且選取有些限制。

![it_img_8_2.png](Day%208%20-%20%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B%E5%8A%A0%E4%B8%8A%E8%A4%87%E9%9B%9C%E9%82%8F%E8%BC%AF/it_img_8_2.png)

[https://dartpad.dev/?id=dd689d7e21bfadcb7c2df8805552a3b6](https://dartpad.dev/?id=dd689d7e21bfadcb7c2df8805552a3b6)

一開始，我們會嘗試使用 StatefulWidget 來實現，但是從上面的程式碼可以得知，使用 StatefulWidget 會造成一個問題：那就是邏輯與畫面樣式混再一起，造成 Widget 違反了單一職責。

## 抽取類別

為了解決這個問題，我們來嘗試使用傳統物件導向的方式來解決。運用[抽取類別](https://refactoring.guru/extract-class)的技巧，將複雜的選取邏輯抽到 SelectedPhotos 中，讓 SelectedPhotos 自己決定照片是否能被選取。

![it_img_7_2.png](Day%208%20-%20%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B%E5%8A%A0%E4%B8%8A%E8%A4%87%E9%9B%9C%E9%82%8F%E8%BC%AF/it_img_7_2.png)

[https://dartpad.dev/?id=886bcbddaf299475a141d22e7d099a4e](https://dartpad.dev/?id=886bcbddaf299475a141d22e7d099a4e)

當我們把 SelectPhotos 的狀態與邏輯抽取至獨立類別後，原本的 Widget 就變得簡單許多。將 SelectPhotos 獨立成一個類別，我們也更好對其邏輯進行[單元測試](https://zh.wikipedia.org/zh-tw/单元测试)。關於測試的議題，我們會在未來的文章進行討論，這邊就不延伸討論。

## 狀態管理

在開發客端應用程式時，我們時常會需要在程式中維護狀態。使用者通過 UI 介面操作狀態，程式根據使用者的操作來改變狀態，最後把最終狀態渲染在畫面上。我們可以使用 StatefulWidget 來進行狀態管理，就像上面的例子一樣，但是當邏輯變得複雜，就會造成 Widget 變大而難以修改。

除了使用傳統的物件導向技巧處理，我們還可以選擇引入狀態管理套件，幫助我們簡化設計，在這邊我們使用 Riverpod 來修改上面的例子。

![it_img_7_3.png](Day%208%20-%20%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B%E5%8A%A0%E4%B8%8A%E8%A4%87%E9%9B%9C%E9%82%8F%E8%BC%AF/it_img_7_3.png)

[https://dartpad.dev/?id=427c1a2f44a98474a89f35e10aa9f313](https://dartpad.dev/?id=427c1a2f44a98474a89f35e10aa9f313)

相比於抽取類別的作法，使用狀態管理的作法會與前者有兩處不同

1. 由狀態管理維護狀態：顧名思義，狀態管理主要關心的就是狀態，使用狀態管理，我們就不需要維護自己的 selectedPhotos 陣列，而是交由狀態管理維護，我們只需關注如何操作。
2. 由狀態管理更新畫面：大多數的狀態管理套件都有一個重要的功能，那就是偵測狀態變化，一旦變化，就觸發畫面更新，而不需要我們自己使用 setState。

雖然在程式碼的長度並不會差很多，但實際上，使用狀態管理套件能讓我們更專注在操作狀態即可，是否重新渲染畫面則交由狀態管理決定，減輕 Widget 的負擔。

## 結論

當程式邏輯開始變得複雜時，適時的引入狀態管理套件，能有效的簡化設計。雖然在上面的例子中，我自己是使用 riverpod 解決問題，但是 Flutter 還有許多非常優秀的的狀態管理套件，例如：Bloc、Redux …等，Flutter 官方也有給出一些選項：[List of state management approaches](https://docs.flutter.dev/development/data-and-backend/state-mgmt/options)，大家在開發時，也可以參考看看。

## 參考

- 抽取類別：[https://refactoring.guru/extract-class](https://refactoring.guru/extract-class)
- 單元測試：[https://zh.wikipedia.org/zh-tw/单元测试](https://zh.wikipedia.org/zh-tw/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)
- List of state management approaches：[https://docs.flutter.dev/development/data-and-backend/state-mgmt/options](https://docs.flutter.dev/development/data-and-backend/state-mgmt/options)

在開發像是 App 或 Web 前端時，一個無可避免的議題就是，如何管理狀態。由於需要提供使用者更好的體驗，我們常常會需要把資料暫存在前端，當畫面重新渲染時，我們就不需要再打一次 API 拿資料。

在 Flutter 中，最簡單的狀態管理作法就是使用 StatefulWidget  

```dart

```

這也是最簡單方便的解法。

隨著狀態越來越複雜，我們可能希望把從 API 取得的資料進行一些處理

例如把資料進行 sort 

就會造成 StatefulWidget 的邏輯越來越複雜

當我們想要跨頁面存取資料時，

有些時候，我們想讓

橫向存取資料圖

worst practice

使用 Global

使用 Provider

使用其他狀態管理套件

[https://www.reddit.com/r/FlutterDev/comments/p4t2ct/comment/h91ui6q/](https://www.reddit.com/r/FlutterDev/comments/p4t2ct/comment/h91ui6q/)

[https://twitter.com/remi_rousselet/status/1281157412448276480?lang=zh-Hant](https://twitter.com/remi_rousselet/status/1281157412448276480?lang=zh-Hant)

[https://stackoverflow.com/questions/65248439/dependency-injection-in-flutter-repercussions-of-different-approaches](https://stackoverflow.com/questions/65248439/dependency-injection-in-flutter-repercussions-of-different-approaches)

**TL;DR: Don’t use setState if you already use a state management solution.** After two years of using flutter extensively, separating between the logic and UI parts is a must. my first project is not using any state management at all, and when I encounter a bug in the logic part, I fixed the bug in the same file with the UI part. It will be fine when you deal with a simple app, but when you have a larger app, it will be a headache for you and your team. It will eventually slow down your development process. My recommendation is to use [cubit](https://pub.dev/packages/flutter_bloc) as your state management because it is less boilerplate than BloC and provides a nice way of handling state in the app (and also scalable).

> If you have already implemented any state management, my advice is to not use setState method in any of your code because it means that you need to add business logic in your UI code, except if you can not achieve it otherwise (I rarely encounter such a problem).
> 

[https://medium.com/@zharfan104/top-10-flutter-developer-tips-i-learned-after-2-million-users-ab03eda10a55](https://medium.com/@zharfan104/top-10-flutter-developer-tips-i-learned-after-2-million-users-ab03eda10a55)

Flutter itself doesn’t impose any state management by default, so it’s easy to end up with a messy combination and might depend on parameter passing or storing everything in persistent storage for storing state.

While using a simple solution for state management is always recommended, we should also **consider the scalability and maintainability of the app** to select it.

Furthermore, even though stateful widgets offer the simplest solution for state management, it can not scale when we want to maintain the state across multiple screens. e.g. Authentication state of User.

State management comes really handy here. It allows to have central store of things that we can use to store anything and when anything in store changes, all the widgets dependent on that will be changed automatically.

There are so **many options available** for state management. Depending on the experience and level of comfort of the team, we can use any of the available solutions as mentioned [here](https://flutter.dev/docs/development/data-and-backend/state-mgmt/options). For instance, one powerful option for State Management with Flutter is the [BloC pattern](https://pub.dev/packages/flutter_bloc).
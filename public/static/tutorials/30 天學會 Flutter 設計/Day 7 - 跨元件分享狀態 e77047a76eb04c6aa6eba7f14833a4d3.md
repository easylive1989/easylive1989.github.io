# Day 7 - 跨元件分享狀態

note: 避免使用 static，讓程式具備可測試性
id: 7
tag: 設計

在前幾天的 Game List 的例子中，我們消除了 onTap 層層傳遞的問題。但是，如果我們仔細觀察的話，會發現 Game 也是同樣的情況，只要底層的哪個 Widget 需要 Game，中間層的 Widget 就需要當中間人，代為傳遞參數。

![it_img_7_1.png](Day%207%20-%20%E8%B7%A8%E5%85%83%E4%BB%B6%E5%88%86%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_7_1.png)

[https://dartpad.dev/?id=831bf7d1714ef8d70daa0e473d5e2bed](https://dartpad.dev/?id=831bf7d1714ef8d70daa0e473d5e2bed)

中間的 Widget 傳遞這個參數，自己卻是用不到，這個問題在上一張討論如何傳遞 callback 時也有討論到。今天就來聊聊如何簡化設計。

## InheritedWidget

Flutter 有提供許多基礎類型的 Widget，例如：StatelessWidget, StatefulWidget，而其中有一類 Widget 稱作 InheritedWidget。透過 InheritedWidget，我們能有效地讓子層可以跨過父層，直接存取 InheritedWidget。使用這個特性，我們就能避免層層傳遞 Game 的問題了。

![it_img_7_2.png](Day%207%20-%20%E8%B7%A8%E5%85%83%E4%BB%B6%E5%88%86%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_7_2.png)

![it_img_7_3.png](Day%207%20-%20%E8%B7%A8%E5%85%83%E4%BB%B6%E5%88%86%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_7_3.png)

[https://dartpad.dev/?id=90fdfc781c4d43360eeb178174918381](https://dartpad.dev/?id=90fdfc781c4d43360eeb178174918381)

經過修改之後，在上面的程式碼中，我們在頂層使用 GameInfo 這個 InheritedWidget，讓 GameInfoSection 和 GameActionSection 自己去取得 GameInfo，最後 GameItemView 也不需要幫忙傳遞 Game 了。

## Provider

當我們每次想要在 Widget Tree 中，縱向的分享資料時，我們都得寫一個 Widget 並讓他繼承 InheritedWidget，但是其實在 Flutter 眾多套件中，有一個能幫助我更簡單的使用 InheritedWidget，那就是 Provider。

![it_img_7_4.png](Day%207%20-%20%E8%B7%A8%E5%85%83%E4%BB%B6%E5%88%86%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_7_4.png)

![it_img_7_5.png](Day%207%20-%20%E8%B7%A8%E5%85%83%E4%BB%B6%E5%88%86%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_7_5.png)

[https://dartpad.dev/?id=1ec4a9a9cb445e7b50bfb6974628d62d](https://dartpad.dev/?id=1ec4a9a9cb445e7b50bfb6974628d62d)

可以發現使用 Provider 之後的程式碼，簡潔非常多，不需要使用繼承，也不需要特別定義一個新的 Widget，直接使用 Provider 並放入 game 就好。由於 Provider 裏頭其實就是 InheritedWidget，透過 Provider 我們能用組合的方式去使用 InheritedWidget，而不是繼承，想比喻繼承，我們傾向於使用組合，也是一個有名的規則：以[組合取代繼承](https://en.wikipedia.org/wiki/Composition_over_inheritance)。

值得一提的是，InheritedWidget 是狀態管理的基礎，所以也使得作為 InheritedWidget 的 Wrapper，Provider 也被[大量套件引用](https://pub.dev/packages?q=dependency%3Aprovider)，其中最知名的就是 Bloc 了。

## 用 Provider 傳遞按鈕事件

回想前兩天的[主題](https://ithelp.ithome.com.tw/articles/10294365)，按鈕傳遞我們也能把 callback 放在 Provider，當子 Widget 渲染時，從 Provider 身上讀取 callback。但其實這個作法並不太合適，因為當我們從 Provider 讀取 callback 時，也意味著使用這個按鈕必須提供相應的 Provider，即使用他的人不需要按鈕有行為。大多時候，使用 Provider 傳遞狀態會比較合理，因為畫面顯示與資料是一致的，不同的資料會有不同的畫面。相比於資料，按鈕行為就很可能會因為畫面不同，而有不同的功能，所以使用 Provider 來傳遞按鈕事件，就會降低按鈕元件通用性。

## 結論

InheritedWidget 讓我們可以往子層 Widget 共享資料，避免過多的傳遞參數，畢竟沒有參數的方法或物件最好用。雖然 InheritedWidget 好用，但是在實戰中，我們還是傾向於使用 Provider，畢竟組合還是比繼承要來得有彈性。

## 參考

- InheritedWidget：[https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html](https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html)
- Provider：[https://pub.dev/packages/provider](https://pub.dev/packages/provider)
- Dependency of Provider：[https://pub.dev/packages?q=dependency%3Aprovider](https://pub.dev/packages?q=dependency%3Aprovider)
- 組合取代繼承：[https://en.wikipedia.org/wiki/Composition_over_inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance)

Flutter 的設計特性，Widget 具有上下層關係，子孫 Widget 如果想與祖先 Widget 享用共同的資料，必須得從祖先 Widget 把資料透過參數一路往下子孫 Widget 傳，直到傳到目標 Widget。

ex: code

在上面這段程式碼中，我們可以發現一個問題，那就是路途中的所有 Widget 都會需要開出這個參數的接口，只會了接力傳遞這個參數，自己卻是用不到。這個問題在上一張討論如何傳遞 callback 時也有討論到

為了解決這個問題，Flutter 提供了 InheritedWidget 來幫助我們解決這個問題。

ex: code

透過這個方法，Widget 就能在縱向的方向共享狀態。

Widget 縱向的共享狀態圖

除了直接使用 IneritedWidget 之外，推薦直接使用 Provider 套件，這個套件讓是一個 InheritedWidget 的 Wrapper，簡化其使用方式。

不過使用這個方法的壞處也顯而易見，就是 Widget 比較難以重複使用。假設今天有兩個與商品有關的頁面，一個顯示商品詳細資訊，一個顯示商品的 xxx，而這兩個頁面都需要顯示商品的名稱與圖片。

今天 A 頁面在頂層共享了 DataA，而 B 頁面在頂層與他的子孫 Widget 共享了 DataB，此時共用的 Widget C 就會不知道應該使用 Inherited Widget A 或者 Inherited Widget B 來讀取資料。

或許有讀者想到一個做法，那就是在 Widget C 中使用 if 來判斷今天是否能 Inherited Widget Ａ 或 Inhertied Widget Ｂ 是否存在，來決定使用哪一個資料。

但是這個做法存在的開放封閉原則，當今天又出現了一個新的頁面想使用 Widget C，則開發者又必須修改 Widget Ｃ 以符合需求。

另外一個做法是採用 IOC 的概念，利用 Flutter 萬物皆是 Widget 的特性，把子孫 Widget 當作參數傳給祖父 Widget，讓祖父 Widget 無需擔心子孫 Widget 如何實作，需要用什麼參數。樣板方法 像是 AppBar
{
  "articles": [
    {
      "title": "這個 Flutter 小技巧，讓你看懂 Widget Test 到底哪裡壞了",
      "summary": "在 Flutter 開發中，我們除了寫程式之外，也會需要寫一些測試來確保功能沒有問題。Flutter SDK 內建提供了 Unit Test、Widget Test 與 Integration Test 三種測試工具供開發人員使用。這三種工具分別有些不同特性，Unit Test 無論是執行速度或是錯...",
      "content": "![](https://images.unsplash.com/photo-1501163109389-abf37ca1276a?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n在 Flutter 開發中，我們除了寫程式之外，也會需要寫一些測試來確保功能沒有問題。Flutter SDK 內建提供了 Unit Test、Widget Test 與 Integration Test 三種測試工具供開發人員使用。這三種工具分別有些不同特性，Unit Test 無論是執行速度或是錯誤訊息清晰度，都要比 Integration Test 要來得好很多。\n\n在 Flutter 開發中，除了撰寫功能程式碼之外，撰寫測試也是確保應用穩定性的重要一環。Flutter SDK 內建提供了三種測試工具：**Unit Test**、**Widget Test** 與 **Integration Test**。這三者的主要差異在於測試的層級與執行效能，其中 **Unit Test** 速度最快、錯誤訊息最清晰；而 **Integration Test**\n\n涵蓋範圍最廣，但速度最慢、維護成本也最高。\n\n![[https://docs.flutter.dev/testing/overview](https://docs.flutter.dev/testing/overview)](%E9%80%99%E5%80%8B%20Flutter%20%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%AE%93%E4%BD%A0%E7%9C%8B%E6%87%82%20Widget%20Test%20%E5%88%B0%E5%BA%95%E5%93%AA%E8%A3%A1%E5%A3%9E%E4%BA%86/image.png)\n\n[https://docs.flutter.dev/testing/overview](https://docs.flutter.dev/testing/overview)\n\n相較之下，**Widget Test** 的執行速度僅略慢於 Unit Test，但其錯誤訊息往往不夠直覺。例如，下列訊息僅指出某個 Widget 找不到，卻無法明確告訴我們原因：\n\n```bash\nExpected: no matching candidates\n  Actual: _TextWidgetFinder:<Found 1 widget with text \"1\": [\n            Text(\"1\", debugLabel: (englishLike headlineMedium 2021).merge((blackMountainView\nheadlineMedium).apply), inherit: false, color: Color(alpha: 1.0000, red: 0.1137, green: 0.1059,\nblue: 0.1255, colorSpace: ColorSpace.sRGB), family: Roboto, size: 28.0, weight: 400, letterSpacing:\n0.0, baseline: alphabetic, height: 1.3x, leadingDistribution: even, decoration: Color(alpha: 1.0000,\nred: 0.1137, green: 0.1059, blue: 0.1255, colorSpace: ColorSpace.sRGB) TextDecoration.none,\ndependencies: [DefaultSelectionStyle, DefaultTextStyle, MediaQuery]),\n```\n\n造成測試失敗的原因可能很多：邏輯錯誤、畫面未刷新、Widget 被遮擋 ……單靠這樣的訊息，很難快速定位問題，也因此 Widget Test 維護成本較高。\n\n## 使用 debugDumpApp 顯示 Widget Tree\n\n若上網搜尋「如何除錯 Widget Test」，很容易找到 Flutter 提供的 `debugDumpApp` API。這個工具可以輸出整個 Widget Tree，理論上可協助我們檢查畫面結構是否正確（[完整範例在這裡](https://dartpad.dev/?id=97d3dae3a802cc1d3076998ca6c43772)）。\n\n```bash\nAutomatedTestWidgetsFlutterBinding - DEBUG MODE\n[root]\n└View(state: _ViewState#f6410)\n └RawView\n  └_RawViewInternal-[_DeprecatedRawViewKey TestFlutterView#36943](renderObject: _ReusableRenderView#62b88)\n   └_ViewScope\n    └_PipelineOwnerScope\n     └_MediaQueryFromView(state: _MediaQueryFromViewState#8f554)\n      └MediaQuery(MediaQueryData(size: Size(800.0, 600.0), devicePixelRatio: 3.0, textScaler: no scaling, platformBrightness: Brightness.light, padding: EdgeInsets.zero, viewPadding: EdgeInsets.zero, viewInsets: EdgeInsets.zero, systemGestureInsets: EdgeInsets.zero, alwaysUse24HourFormat: false, accessibleNavigation: false, highContrast: false, onOffSwitchLabels: false, disableAnimations: false, invertColors: false, boldText: false, navigationMode: traditional, gestureSettings: DeviceGestureSettings(touchSlop: null), displayFeatures: [], supportsShowingSystemContextMenu: false))\n       └FocusTraversalGroup(policy: ReadingOrderTraversalPolicy#9bb45, state: _FocusTraversalGroupState#c8c8d)\n        └Focus(debugLabel: \"FocusTraversalGroup\", focusNode: _FocusTraversalGroupNode#1ee5d(FocusTraversalGroup [IN FOCUS PATH]), state: _FocusState#deea3)\n         └_FocusInheritedScope\n          └_FocusScopeWithExternalFocusNode(debugLabel: \"View Scope\", focusNode: FocusScopeNode#98f92(View Scope [IN FOCUS PATH]), dependencies: [_FocusInheritedScope], state: _FocusScopeState#7ba60)\n           └_FocusInheritedScope\n            └MyApp\n     \n```\n\n但實際使用後會發現，這份輸出往往冗長又難以閱讀。即使是一個簡單的 Counter App，Widget Tree 也可能超過兩百行，每行還充滿細節資訊。因此，透過 `debugDumpApp` 來排查畫面問題在實務上並不方便。\n\n那麼，我們該怎麼辦？在介紹解法之前，先來認識另一種測試方式——**Golden Test**。\n\n## 什麼是 Golden Test\n\n除了常見的 Unit Test、Widget Test 與 Integration Test 之外，Flutter 還有第四種測試：**Golden Test**。它不是用程式邏輯比對結果，而是透過**畫面比對**的方式確認 UI 是否異動。\n\nGolden Test 的原理很簡單：\n\n1. 先將正確的畫面狀態儲存為基準圖（snapshot）。\n2. 下次執行測試時，再將目前畫面與基準圖比較。\n3. 若畫面有任何變化，就會自動產生差異圖檔，讓開發者快速檢查變動位置。\n\n使用方式也很直觀：\n\n```dart\nexpect(find.byType(MaterialApp), matchesGoldenFile(\"snapshot.png\"));\n```\n\n若結果不同，Flutter 會在 snapshot.png 旁邊自動產生比較結果，使用者就能確認變動是否預期：\n\n```bash\ntest\n├── failures\n│   ├── snapshot_isolatedDiff.png\n│   ├── snapshot_maskedDiff.png\n│   ├── snapshot_masterImage.png\n│   ├── snapshot_testImage.png\n├── snapshot.png\n└── widget_test.dart\n```\n\n如果確認畫面變動是預期內的修改，只需執行以下指令即可更新基準圖：\n\n```dart\nflutter test --update-goldens\n```\n\n聰明的你可能已經想到：我們能否利用 Golden Test 的特性，讓 Widget Test 也能快速檢查畫面呢？\n\n## 使用 matchesGoldenFile 直接顯示畫面\n\n在 Widget Test 中，我們雖然不是真的在做 Golden Test，但其實還是可以使用 `matchesGoldenFile` 來將當前的畫面結果印出來。印出來之後，我們就能更快的檢查畫面是不是符合預期，而不用看 `debugDumpApp` 的那一長串資料了。\n\n雖然在 Widget Test 中我們並非真正執行 Golden Test，但仍可透過 `matchesGoldenFile` 來**輸出當前畫面結果**。\n\n這樣一來，我們就能以圖像的方式檢查畫面是否如預期，而不必苦讀 `debugDumpApp` 的長篇輸出。\n\n![snapshot.png](%E9%80%99%E5%80%8B%20Flutter%20%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%AE%93%E4%BD%A0%E7%9C%8B%E6%87%82%20Widget%20Test%20%E5%88%B0%E5%BA%95%E5%93%AA%E8%A3%A1%E5%A3%9E%E4%BA%86/snapshot.png)\n\n儘管測試環境中使用的字型可能與真實 App 不同（例如無法顯示文字或 Icon），但大部分畫面元素仍足以協助我們判斷 UI 是否正常。\n\n下次當 Widget Test 報錯卻不知從何下手時，試著加入 `matchesGoldenFile`，你可能能立刻看出問題所在。\n\n**注意事項**：`matchesGoldenFile` 在 Widget Test 只是一種用來 Debug 的手段，不適合一直放在測試中，務必在問題解決之後移除。\n\n## 小結\n\nWidget Test 是在速度與真實性之間取得平衡的測試方式，能快速驗證 App 的行為並提升測試覆蓋率。然而，它的除錯難度也較高。\n\n在進行逐步除錯（debug）之前，不妨先透過 `matchesGoldenFile` 生成畫面快照，快速比對結果。這個簡單的技巧，常能讓你瞬間發現問題根源。",
      "createdAt": "October 5, 2025 4:39 PM",
      "updatedAt": "October 24, 2025 4:47 PM",
      "id": "2838303f78f780a19f9eed48ccc9f2c6",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "這個 Flutter 小技巧，讓你看懂 Widget Test 到底哪裡壞了 2838303f78f780a19f9eed48ccc9f2c6.md",
      "folderName": "這個 Flutter 小技巧，讓你看懂 Widget Test 到底哪裡壞了"
    },
    {
      "title": "Widget Test 的 tap 原來這樣運作？一探 Flutter 測試點擊的祕密",
      "summary": "前陣子有同事問我：「WidgetTester 中的 `tap` 方法，到底是點擊卡片的哪個位置？它是真的模擬使用者的點擊行為，還是單純呼叫底層某個 callback 來觸發事件？」當下我其實不太確定，只好回家趕快研究一下。 雖然這些細節在大部分情境下不影響我們的日常測試，但世事難料，總有可能哪天派得...",
      "content": "![robottesting2.png](Widget%20Test%20%E7%9A%84%20tap%20%E5%8E%9F%E4%BE%86%E9%80%99%E6%A8%A3%E9%81%8B%E4%BD%9C%EF%BC%9F%E4%B8%80%E6%8E%A2%20Flutter%20%E6%B8%AC%E8%A9%A6%E9%BB%9E%E6%93%8A%E7%9A%84%E7%A5%95%E5%AF%86/robottesting2.png)\n\n前陣子有同事問我：「WidgetTester 中的 `tap` 方法，到底是點擊卡片的哪個位置？它是真的模擬使用者的點擊行為，還是單純呼叫底層某個 callback 來觸發事件？」當下我其實不太確定，只好回家趕快研究一下。\n\n雖然這些細節在大部分情境下不影響我們的日常測試，但世事難料，總有可能哪天派得上用場。所以趁有空時，就來探索一下這個小細節吧。\n\n今天想和大家分享一個關於 Widget Test 的冷知識。本篇文章會包含不少原始碼，如果你對底層實作細節沒有興趣，可以考慮先跳過。\n\n## WidgetTester 的 tap 方法\n\n首先來看 `tap` 的實作，這應該能回答第一個問題：**`tap` 方法到底是點擊 Widget 的哪個位置？**\n\n從程式碼中可以看到，它實際上呼叫了 `tapAt`，並傳入 `getCenter(...)`。光從名稱就能推測出來：`tap` 點擊的是 **Widget 的中心點**。\n\n```dart\nFuture<void> tap(\n  finders.FinderBase<Element> finder, {\n  int? pointer,\n  int buttons = kPrimaryButton,\n  bool warnIfMissed = true,\n  PointerDeviceKind kind = PointerDeviceKind.touch,\n}) {\n  return tapAt(\n    getCenter(finder, warnIfMissed: warnIfMissed, callee: 'tap'),\n    pointer: pointer,\n    buttons: buttons,\n    kind: kind,\n  );\n}\n```\n\n接下來的問題就是：它是怎麼找到「中心點」的？\n\n## 找尋 Widget 中心點\n\n往下追 `getCenter` 的實作，可以看到它呼叫了 `_getElementPoint`，這個方法的功能就是：**計算 Widget 某個位置的 Global 座標**。\n\n```dart\nOffset getCenter(\n  finders.FinderBase<Element> finder, {\n  bool warnIfMissed = false,\n  String callee = 'getCenter',\n}) {\n  return _getElementPoint(\n    finder,\n    (Size size) => size.center(Offset.zero),\n    warnIfMissed: warnIfMissed,\n    callee: callee,\n  );\n}\n\nOffset _getElementPoint(\n  finders.FinderBase<Element> finder,\n  Offset Function(Size size) sizeToPoint, {\n  required bool warnIfMissed,\n  required String callee,\n}) {\n  TestAsyncUtils.guardSync();\n  final Iterable<Element> elements = finder.evaluate();\n  \n  // 省略檢查細節\n\n  final Element element = elements.single;\n  final RenderObject? renderObject = element.renderObject;\n  \n  // 省略檢查細節\n\n  final RenderBox box = element.renderObject! as RenderBox;\n  final Offset location = box.localToGlobal(sizeToPoint(box.size));\n  \n  // 省略 warnIfMissed 細節\n\n  return location;\n}\n```\n\n總結來說：`getCenter` 並不複雜，它只是透過 finder 找出 Element，再用 RenderBox 算出 Widget 中心點的 Global 座標。\n\n除了 `getCenter`，還有像 `getTopLeft`、`getBottomLeft` 等方法，可以讓我們在測試中指定不同的點擊位置。\n\n## **tapAt 的點擊流程**\n\n找到座標之後，`tap` 會透過 `tapAt` 來模擬點擊。\n\n來看一下主要流程：\n\n1. `tapAt` 先呼叫 `startGesture`，建立一個 `TestGesture`，並執行 `result.down(downLocation)` 來模擬 **手指按下**。\n2. 接著呼叫 `gesture.up()` 來模擬 **手指放開**。\n\n```dart\nFuture<void> tapAt(\n  Offset location, {\n  int? pointer,\n  int buttons = kPrimaryButton,\n  PointerDeviceKind kind = PointerDeviceKind.touch,\n}) {\n  return TestAsyncUtils.guard<void>(() async {\n    final TestGesture gesture = await startGesture(\n      location,\n      pointer: pointer,\n      buttons: buttons,\n      kind: kind,\n    );\n    await gesture.up();\n  });\n}\n\nFuture<TestGesture> startGesture(\n  Offset downLocation, {\n  int? pointer,\n  PointerDeviceKind kind = PointerDeviceKind.touch,\n  int buttons = kPrimaryButton,\n}) async {\n  final TestGesture result = _createGesture(pointer: pointer, kind: kind, buttons: buttons);\n  if (kind == PointerDeviceKind.trackpad) {\n    // 處理觸控板的點擊行為\n  } else {\n    await result.down(downLocation);\n  }\n  return result;\n}\n```\n\n如果你曾經用 Listener 監聽過觸控事件，對這流程應該不陌生：\n\n- 按下時 → `PointerDownEvent`\n- 放開時 → `PointerUpEvent`\n\n想實際觀察的人，可以參考[這個範例](https://dartpad.dev/?id=5b0ff587c3653927bdc93e39fddac731)。\n\n## TestGesture 如何發送事件\n\n那這些事件是怎麼真正「傳到 Flutter Framework」的呢？\n\n答案就在 `TestGesture` 的 `down` 與 `up` 方法中。\n\n```dart\nFuture<void> down(Offset downLocation, {Duration timeStamp = Duration.zero}) async {\n  \n  // 省略檢查細節\n  \n  return TestAsyncUtils.guard<void>(() async {\n    return _dispatcher(_pointer.down(downLocation, timeStamp: timeStamp));\n  });\n}\n```\n\n這裡 `_dispatcher` 會發送一個 `PointerDownEvent`。在 `TestGesture` 的建構過程中，可以看到它實際上被綁定成 `sendEventToBinding`，最後透過 `WidgetsBinding` 把事件送進 Framework。\n\n```dart\nTestGesture _createGesture({\n  int? pointer,\n  required PointerDeviceKind kind,\n  required int buttons,\n}) {\n  return TestGesture(\n    dispatcher: sendEventToBinding,\n    kind: kind,\n    pointer: pointer ?? _getNextPointer(),\n    buttons: buttons,\n  );\n}\n\nFuture<void> sendEventToBinding(PointerEvent event) {\n  return TestAsyncUtils.guard<void>(() async {\n    binding.handlePointerEvent(event);\n  });\n}\n```\n\n熟悉 Flutter 的人應該對 `WidgetsBinding` 不陌生。我們常用的 `WidgetsBinding.instance.addPostFrameCallback(...)` 就是它的功能之一。\n\n在點擊事件的情境下，Engine 收到事件後，會透過 `WidgetsBinding`（更精確地說是 `GestureBinding`）把事件傳進 Framework，經過像 **GestureArena** 這樣的機制過濾與解析，最後才交給我們常用的 `GestureDetector`。\n\n## 整理一下\n\n整個 `tap` 的執行流程，可以簡單整理如下：\n\n![開發 - Frame 11.jpg](Widget%20Test%20%E7%9A%84%20tap%20%E5%8E%9F%E4%BE%86%E9%80%99%E6%A8%A3%E9%81%8B%E4%BD%9C%EF%BC%9F%E4%B8%80%E6%8E%A2%20Flutter%20%E6%B8%AC%E8%A9%A6%E9%BB%9E%E6%93%8A%E7%9A%84%E7%A5%95%E5%AF%86/%E9%96%8B%E7%99%BC_-_Frame_11.jpg)\n\n1. 呼叫 `WidgetTester.tap`\n2. 透過 finder 找到 Element，計算中心點的 Global 座標\n3. 呼叫 `tapAt`，傳入座標\n4. 建立 `TestGesture` 負責處理點擊\n5. 呼叫 `down` → 發送 `PointerDownEvent`\n6. 呼叫 `up` → 發送 `PointerUpEvent`\n\n## 小結\n\n透過研究 `WidgetTester.tap` 的實作，我們不僅加深了對 Widget Test 使用方式的理解，也更清楚它是如何與 Flutter Framework 互動。雖然這些細節未必直接影響日常開發，但它可以視為一種「閱讀程式碼的訓練」。在 AI 不斷進步的時代，我們反而更需要具備閱讀、理解 **別人程式碼** 的能力。\n\n每次遇到不熟悉的地方，都是充實知識庫的契機。在追原始碼的過程中，不只能更透徹地理解框架運作，也能從中學到設計思維與程式風格。\n\n希望這篇文章能帶給你一些啟發。如果有任何問題，歡迎留言與我討論，感謝你讀到這裡！",
      "createdAt": "August 23, 2025 9:08 AM",
      "updatedAt": "October 24, 2025 4:47 PM",
      "id": "2588303f78f780b3a789ccdae073e04a",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Widget Test 的 tap 原來這樣運作？一探 Flutter 測試點擊的祕密 2588303f78f780b3a789ccdae073e04a.md",
      "folderName": "Widget Test 的 tap 原來這樣運作？一探 Flutter 測試點擊的祕密"
    },
    {
      "title": "Vibe Coding 回顧",
      "summary": "今年 AI 能力大躍進，不斷地在社群或網路看到別人說大部分的 Code 都是由 AI 產生，讓我不禁開始懷疑自己的開發方式。去年我還只是拿著 Github Copilot 當作更智能自動補完工具，完全沒有感覺這東西是能有大改變，覺得 AI 終究只是從上下文來預測結果，終究是有其極限。 在三月的時候，...",
      "content": "![image.png](Vibe%20Coding%20%E5%9B%9E%E9%A1%A7/image.png)\n\n今年 AI 能力大躍進，不斷地在社群或網路看到別人說大部分的 Code 都是由 AI 產生，讓我不禁開始懷疑自己的開發方式。去年我還只是拿著 Github Copilot 當作更智能自動補完工具，完全沒有感覺這東西是能有大改變，覺得 AI 終究只是從上下文來預測結果，終究是有其極限。\n\n在三月的時候，剛好在 Flutter Taipei Meetup 聽了有兩個關於 AI 的主題，這才發現或許 AI 已經進步到超乎我想像的地步了，是時候改變思維，擁抱變化了。至今大約 Vibe Coding 了半年多，剛好最近想法上有轉變（最後會提到），所以先來回顧一下這半年的 AI 使用心得了。\n\n三月那會兒，最流行的 AI 工具大概也就是 Cursor 或 Winsurf，有鑒於之前買了一年的 Github Copilot 的教訓，這次就來一個月、一個月的買 Cursor。那買了 Cursor 要用在什麼地方呢？首先在除了在工作中的產品嘗試之外，當時有個朋友找我弄個小小的自動化工具，想想這也是個挺好的機會，就來用 Vibe Coding 的方式來建立這個小工具吧。\n\n## 開始 Vibe Coding\n\n在開始這個 Side Project 時，我刻意選擇了自己幾乎不太懂的語言加框架，用 Electron + React + Playwright 來做一個自動化的爬蟲工具，希望自己能在開發的過程中學會這些技能（雖然事後看起來效果並不算太好）。\n\n一開始就像坊間常見的 Vibe Coding 分享一樣，直接開始跟 AI 對話，說明我想要什麼功能，要用什麼技術，從最基礎的畫面，一點一點的增加新功能。由於我對 Electron 也不熟，加上人的惰性，所以大多時候，只要功能正常，且我看的懂它在寫什麼，生成的 Code 我大多都直接接受，不太會進一步修改。\n\n### 失去動手改的能力\n\n但是這樣有個缺點，那就是我只看得懂，要自己動手改就比較難。變成任何小改動，我都是請AI 來做，而不是自己做。熟悉使用 AI 工具的人也都知道，AI 一跑起來快一點也要三四十秒、一分鐘的，甚至還有更久的。但是如果知道怎麼改而且熟悉工具的話，自己改可能也不到 AI 一半時間。\n\n我在自己的工作中也會使用 AI，常常會在內心評估每個改動到底是自己改比較快，還是 AI 改比較快。但是在不熟悉的技術中，這個評估幾乎變得沒有意義，因為幾乎都是 AI 改比較快。越常讓 AI 來改，就越加不可能出現自己改比較快的情況。\n\n或許看起來有一些負面影響，但我想這應該就是趨勢，單一任務或許 AI 做起來比較慢，但是 AI 可以同步執行多個任務，理論上來說應該會增加生產力（前提是任務沒有相依）。\n\n> AI 削弱了開發人員自己實作的能力，但是也開啟工作同步執行的能力。就像手工製作與工廠生產，單一機器的效率中難以跟真人匹敵，但是大量機器 24 小時同時運轉就不是人類可以比較的。\n> \n\n### 只有一個 AI 不夠\n\n在開發的過程中，碰到一個問題：打包 macOS 應用程式失敗。在本地端打包都沒什麼問題，但是上 CI 打包建置卻一直出錯。由於 Cursor 並無法直接讀到 Github Action 的結果，所以只好手動貼錯誤給 Cursor（或許現在有 MCP 能做到了？），請 Cursor 修復 Github Workflow 腳本。\n\n但即便如此，Cursor 還是一直鬼打牆，無法真正的解決問題。最後只好把 Github Workflow 腳本、Github Action 錯誤，再加上我想做的事情的 Context 通通整理貼到 Claude 與 Gemini 去問，而且兩者的回答還都不同，只好自己交叉比對結果與實驗，最後才讓打包工作能在 CI 上完成。\n\n> 讓 AI 自動改 Code 非常方便，但也意味著她也只選擇一種方向來處理，方向是對是錯，是好還是壞，還是得要依靠人的判斷。\n> \n\n## 免不了，也快不了的學習\n\n本想靠著 AI 實際做個東西，藉此在開發的過程中快速學一門新技術，但事後看起來還是有一定的極限，沒有想像中的這麼美好。\n\n### Electron 線程的坑\n\n最初是這個工具只有使用 Electron，而沒有 React，程式也是在 Electron 中啟動 Playwright 腳本。後來加入 React 之後，想把啟動 Playwright 腳本的工作也搬到 React 中，卻怎麼一直都無法正常運作。幾過一番折騰才了解 Playwright 只能由 Node.js 啟動，所以只能放在 Electron 中，讓 React 跟 Electron 溝通呼叫腳本，無法放在 React 中。\n\n這件工作也是來來回回請 AI 改了好幾次，每一次改就壞，過程中也出現奇奇怪怪的改法，看著都不太對勁。最後也是直接問了 AI 是否這個任務其實是有問題的，AI 才說了上面提到的問題（但也很有可能這結論也是錯的XD）。\n\n> AI 會盡全力滿足你的要求，即便這的要求不合理。如果沒有了人的判斷，可以想像如果開發時間一長，技術債會快速累積。\n> \n\n### 測試的難處\n\n同樣的問題也發生在測試，自己對測試的概念還算熟悉，本來想模仿工作中測試方式，用比較大粒度的方式來測試這個工具。與常見小粒度的測試方式不同，可能訓練資料比較缺乏，所以無論我怎麼跟 AI 溝通，都得不到理想的結果。\n\n原因可能是自己對技術的理解不夠，無法有效用該技術常見的用語與 AI 溝通，導致 AI 無法完成我想要的結果。另外一種可能是，這根本就是做不到的，但對這個語言與框架理解有限的我，也無法知道這件事。\n\n> 即便使用了 AI ，我們還是得學習相關技術，否則既限制了上限，也會浪費許多時間。\n> \n\n## 下一步\n\n最後，我已經對這個 Side Project 失去了興趣，暫時不會在這個 Side Project  上繼續 Vibe Coding。同時最近也從 Cursor 跳槽到 Claude Code，所以就趁這些轉變，回顧一下這半年的過程，總結一下 Vibe Coding 不熟悉技術的體驗。\n\n但這終究不是現實的常態，現在對於大部分開發人員來說，工作中使用的還是自己比較熟悉的技術，只是需要摸索與 AI 如何共生。自己也打算開始另外一個 Side Project，這次會使用自己熟悉的技能模仿實際工作中的流程來 Vibe Coding，看看能否帶來開發上的改變。\n\n## 小結\n\n透過這次 Vibe Coding 的過程，感受到動口不動手的快感，但也更清楚感受到 AI 的限制。無論如何，AI 已經開始改變了開發人員的工作方式，既要放下成見，接受 AI 的結果，也要持續學習，不斷反思與改善這個過程。",
      "createdAt": "August 7, 2025 8:15 PM",
      "updatedAt": "October 24, 2025 5:02 PM",
      "id": "2488303f78f7804eb849e2bb796fa8ca",
      "type": "輸出文章",
      "tag": "AI Coding",
      "filename": "Vibe Coding 回顧 2488303f78f7804eb849e2bb796fa8ca.md",
      "folderName": "Vibe Coding 回顧"
    },
    {
      "title": "避免隱晦的程式邏輯 - 避免把細節當狀態",
      "summary": "最近改開發的時候，碰到一段很難懂的 Code，讓自己看了非常久，明明程式邏輯沒多複雜，但是整體讓我覺得很不舒服，總覺得有太多東西混雜在裡面。 這段程式主要的功能是做電話號碼 OTP 驗證，功能沒有太複雜，也就是拿著使用者輸入的 OTP 驗證碼去打一隻 API 做驗證。 這段 Code 來回看了幾天，...",
      "content": "![](https://images.unsplash.com/photo-1701766993323-cc05898df2bd?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n最近改開發的時候，碰到一段很難懂的 Code，讓自己看了非常久，明明程式邏輯沒多複雜，但是整體讓我覺得很不舒服，總覺得有太多東西混雜在裡面。\n\n這段程式主要的功能是做電話號碼 OTP 驗證，功能沒有太複雜，也就是拿著使用者輸入的 OTP 驗證碼去打一隻 API 做驗證。\n\n這段 Code 來回看了幾天，請 AI 重構了無數回，也 Rollback 無數次。\n\n最後終於想通了到底問題在哪邊，到底是什麼讓整段程式難以理解。\n\n# **舉個例子**\n\n先來看看下面這段簡化過的程式碼例子：\n\n```dart\nclass OtpPage extends StatefulWidget {\n  @override\n  _OtpPageState createState() => _OtpPageState();\n}\n\nclass _OtpPageState extends State<OtpPage> {\n  String? errorMessage;\n  String otpCode = \"\";\n\n  Future<void> _verifyOtp(String otp) async {\n    try {\n      await otpService.verify(otp);\n    } catch (e) {\n   setState(() {\n        if (e.code == 'INVALID_OTP') {\n          errorMessage = \"OTP 驗證碼錯誤，請重新輸入\";\n     } else if (e.code == 'EXPIRED_OTP') {\n          errorMessage = \"OTP 驗證碼已過期\";\n        }\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          onChanged: (value) => otpCode = value,\n          decoration: InputDecoration(\n            hintText: \"請輸入 OTP 驗證碼\",\n          ),\n        ),\n        ElevatedButton(\n          onPressed: () => _verifyOtp(otpCode),\n          child: Text(\"驗證\"),\n        ),\n        if (errorMessage != null)\n          Text(\n            errorMessage!,\n            style: TextStyle(color: Colors.red),\n          ),\n      ],\n    );\n  }\n}\n```\n\n這段程式挺單純的，使用者輸入 OTP 驗證碼，按下驗證按鈕後就打 API 去驗證。\n\n在驗證的時候，程式會用 try/catch 來攔截 API 回的 400/500 錯誤，並且將指定錯誤訊息存到狀態中，以供畫面顯示。\n\n![1.jpg](%E9%81%BF%E5%85%8D%E9%9A%B1%E6%99%A6%E7%9A%84%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF%20-%20%E9%81%BF%E5%85%8D%E6%8A%8A%E7%B4%B0%E7%AF%80%E7%95%B6%E7%8B%80%E6%85%8B/1.jpg)\n\n這功能做起來也沒什麼問題，也挺好理解的，錯誤訊息就是要顯示給使用者看的，放在 _OtpPageState 中也是合情合理。\n\n但是如果故事只到此處，那也沒什麼好說的，難就難在需求總是會改，我們總是要回來重新閱讀這段程式碼。\n\n# **需求異動**\n\n有天客人抱怨錯誤訊息不夠清楚，害他沒看到驗證碼錯誤的訊息，覺得怎麼系統一直沒反應，然後就很不高興的刪除 App 了。\n\n既然客戶抱怨了，那我們只好想想辦法來解決客戶的問題。\n\n經過 PO 與設計師討論，最終決定強化錯誤提示，讓客人可以更清楚了解現在是發什麼狀況。\n\n![4.jpg](%E9%81%BF%E5%85%8D%E9%9A%B1%E6%99%A6%E7%9A%84%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF%20-%20%E9%81%BF%E5%85%8D%E6%8A%8A%E7%B4%B0%E7%AF%80%E7%95%B6%E7%8B%80%E6%85%8B/4.jpg)\n\n這邊有個小細節，就是只有在 OTP 驗證碼錯誤的情況下才需要顯示紅框，其餘像是過期就不顯示紅框。\n\n當開發人員看到設計之後，肯定覺得這題我會，不過就是一個 if 能解決的事，IDE 一開，手指一動，測試一跑，輕輕鬆鬆就完成了。\n\n```dart\nclass _OtpPageState extends State<OtpPage> {\n  String? errorMessage;\n  String otpCode = \"\";\n  String phoneNumber = \"0912345678\";\n\n  Future<void> _verifyOtp(String otp) async {\n    try {\n      await otpService.verify(otp);\n    } catch (e) {\n      setState(() {\n        if (e.code == 'INVALID_OTP') {\n          errorMessage = \"OTP 驗證碼錯誤，請重新輸入\";\n        } else if (e.code == 'EXPIRED_OTP') {\n          errorMessage = \"OTP 驗證碼已過期\";\n        }\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          onChanged: (value) => otpCode = value,\n          decoration: InputDecoration(\n            hintText: \"請輸入 OTP 驗證碼\",\n          ),\n          border: OutlineInputBorder(\n            borderSide: BorderSide(。\n              color: errorMessage == \"OTP 驗證碼錯誤，請重新輸入\" ?\n                  Colors.red :\n                  Colors.black,\n            ),\n          ),\n        ),\n        ElevatedButton(\n          onPressed: () => _verifyOtp(otpCode),\n          child: Text(\"驗證\"),\n        ),\n        if (errorMessage != null)\n          Text(\n            errorMessage!,\n            style: TextStyle(color: Colors.red),\n          ),\n        if (errorMessage == \"OTP 驗證碼錯誤，請重新輸入\")\n          Row(\n            children: [\n              Icon(Icons.phone, color: Colors.orange),\n              Text(\"請檢查您的電話號碼：\"),\n              Text(\n                phoneNumber,\n                style: TextStyle(\n                  fontWeight: FontWeight.bold,\n                  color: Colors.orange,\n                ),\n              ),\n            ],\n          ),\n      ],\n    );\n  }\n}\n```\n\n結果 Review 的時候一看，就出現了 errorMessage == “OTP 驗證碼錯誤，請重新輸入” 的 if 判斷。\n\n看到這裡，你肯定會想，功能完成是完成了，但是總感覺哪裡怪怪的。\n\n這裡就得回到我們的主題，**把細節當狀態了**。\n\n由於前面錯誤訊息與錯誤狀態是一對一，所以把訊息當狀態好像也沒什麼毛病。\n\n但當今天錯誤狀態與錯誤畫面細節不是一對一的時候，問題就出現了。\n\n直接把畫面細節當狀態來存的時候，當未來需要根據狀態來判斷時，就會變得很麻煩。\n\n尤其是當一個錯誤可能又會出現多個提示的時候，錯綜復雜的關係，讓閱讀的人根本不可能從當前的提示組合中理解當前是處於什麼錯誤狀態。\n\n所以我們應該儲存的是**錯誤狀態**，而不是**畫面細節**。\n\n# **更好的做法**\n\n了解問題之後，其實解法也就顯而易見，我們在 _OtpPageState 中應該存的是錯誤狀態，而不是錯誤訊息。\n\n```dart\nenum OtpError {\n  invalidOtp,\n  expiredOtp,\n}\n\nclass _OtpPageState extends State<OtpPage> {\n  OtpError? otpError;\n  String otpCode = \"\";\n  String phoneNumber = \"0912345678\";\n\n  Future<void> _verifyOtp(String otp) async {\n    try {\n      await otpService.verify(otp);\n    } catch (e) {\n      setState(() {\n        if (e.code == 'INVALID_OTP') {\n          otpError = OtpError.invalidOtp;\n        } else if (e.code == 'EXPIRED_OTP') {\n          otpError = OtpError.expiredOtp;\n        }\n      });\n    }\n  }\n\n  String? get errorMessage {\n    switch (otpError) {\n      case OtpError.invalidOtp:\n        return \"OTP 驗證碼錯誤，請重新輸入\";\n      case OtpError.expiredOtp:\n        return \"OTP 驗證碼已過期\";\n      default:\n        return null;\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          onChanged: (value) => otpCode = value,\n          decoration: InputDecoration(\n            hintText: \"請輸入 OTP 驗證碼\",\n            border: OutlineInputBorder(\n              borderSide: BorderSide(。\n                color: otpError == OtpError.invalidOtp ?\n                  Colors.red :\n                  Colors.black,\n              ),\n            ),\n          ),\n        ),\n        ElevatedButton(\n          onPressed: () => _verifyOtp(otpCode),\n          child: Text(\"驗證\"),\n        ),\n        if (errorMessage != null)\n          Text(\n            errorMessage!,\n            style: TextStyle(color: Colors.red),\n          ),\n      ],\n    );\n  }\n}\n```\n\n使用 enum 來儲存錯誤狀態之後，我們要拿這個錯誤狀態來衍生更多不同的顯示，就更容易的。\n\n當然錯誤不一定得用 enum 來表示，這部分就得視需求來決定。\n\n但重點是儲存錯誤狀態，能讓看的人更容易理解程式碼的邏輯。\n\n# **結語**\n\n避免把細節當狀態，是寫出易讀、易維護程式碼的重要概念。\n\n當你發現自己在用字串比對、或是用畫面顯示的內容做邏輯判斷時，就要停下來想想：我儲存的是系統狀態，還是畫面細節？\n\n存正確的狀態不只能讓讀的人更容易理解，也增加未來修改彈性。\n\n記住：**狀態管理的核心，是管理系統的真實狀況，而不是管理畫面的呈現細節。**\n\n在 Flutter 開發中，合理運用 enum、class 和狀態管理工具，可以讓你的程式碼更清晰、更容易測試和維護。",
      "createdAt": "July 7, 2025 10:48 PM",
      "updatedAt": "October 24, 2025 5:06 PM",
      "id": "2298303f78f7807fb25ff4f4fad22b5b",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "避免隱晦的程式邏輯 - 避免把細節當狀態 2298303f78f7807fb25ff4f4fad22b5b.md",
      "folderName": "避免隱晦的程式邏輯 - 避免把細節當狀態"
    },
    {
      "title": "避免隱晦的程式邏輯 - Index",
      "summary": "在開發過程中，我們會使用各種資料結構來表示不同類型的資料，例如 List、Set、Map 等。List 作為一種有序的元素集合，允許重複元素，並提供基於索引（Index）的存取方式，適用於需要保持元素順序的場景。在程式中，我們經常需要與 List 互動，例如取出所有資料來顯示，或對 List 進行篩...",
      "content": "![](https://images.unsplash.com/photo-1466781783364-36c955e42a7f?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n在開發過程中，我們會使用各種資料結構來表示不同類型的資料，例如 List、Set、Map 等。List 作為一種有序的元素集合，允許重複元素，並提供基於索引（Index）的存取方式，適用於需要保持元素順序的場景。在程式中，我們經常需要與 List 互動，例如取出所有資料來顯示，或對 List 進行篩選 (`where`) 與轉換 (`map`) 等操作。\n\n大多數情況下，對 List 的操作並不複雜，程式碼的可讀性也不會受到影響。然而，某些特定的寫法可能會降低可讀性，尤其是當我們使用索引來存取 List 時，可能會帶來潛在的問題。今天我們就來看看這些情況。\n\n# **使用 Index 表示資料**\n\n在較舊的開發方式中，為了避免 API 直接暴露資料的屬性，可能會讓 API 回傳一個 JSON 陣列，其中每個位置代表某個特定的資料屬性。例如：\n\n```\n[123, \"Jonh\", 27, \"john@gamil.com\", \"male\"]\n```\n\n當客戶端接收到這樣的回應時，必須透過 Index 來解析資料：\n\n```\nFuture<User> getUser() async {\n  final data = await api.get(\"/user\").data;\n  return User.from(\n    id: data[0],\n    name: data[1],\n    age: data[2],\n    email: data[3],\n    gender: data[4],\n  );\n}\n```\n\n類似地，當某個方法需要回傳多個值時，我們可能會選擇用 List 來存放結果，讓呼叫端透過 Index 來取出對應的值：\n\n```\nWidget build(BuildContext context) {\n  final results = summarizeFee(orders);\n  return Column(\n    children: [\n      Text(\"Price ${result[0].toString()}\"),\n      Text(\"Fee ${result[1].toString()}\"),\n    ],\n  );\n}\n\nList<int> summarizeFee(List<Order> orders) {\n  var price = 0;\n  var fee = 0;\n\n  for (var order in orders) {\n    price += order.price;\n    fee += order.fee;\n  }\n\n  return [price, fee];\n}\n```\n\n在這些例子中，當我們閱讀 `data[0]` 或 `results[0]` 時，完全無法從字面上理解它們的意義，必須對照命名參數或其他使用處，才能弄清楚這些 Index 所代表的資訊。\n\n那要如何解決呢？\n\n以第一個例子來說，即便使用 List 避免了直接暴露屬性名稱，但這種方法終究是「防君子不防小人」，沒有太大的實際意義，就盡量避免使用。而對於回傳多個值的情境，我們可以改用更具可讀性的方式，例如使用具名類別或 [Record](https://dart.dev/language/records) 來改善可讀性：\n\n```\n({int price, int fee}) summarizeFee(List<Order> orders) {\n  var price = 0;\n  var fee = 0;\n  for (var order in orders) {\n    price += order.price;\n    fee += order.fee;\n  }\n  return (price: price, fee: fee);\n}\n```\n\n接著我們來看看另一個 Index 造成的問題。\n\n# **Index 判斷**\n\n在以下程式碼中，我們根據 `index` 是否為 `0` 來決定是否要顯示標題：\n\n```\nWidget build(BuildContext context) {\n  return Column(\n    children: users.mapIndexed((index, user) {\n      return Column(\n        children: [\n          if (index == 0)\n            Text(\"User List Title\"),\n          Text(user.name),\n        ]\n      );\n    }).toList(),\n  );\n}\n```\n\n乍看之下，這段程式碼可能不容易理解為何會有這個判斷條件。但細看後會發現，這是為了讓標題只顯示一次。\n\n與其依賴 Index 來決定顯示標題的時機，我們可以直接將標題作為 `Column` 的第一個子元素，如下所示：\n\n```\nWidget build(BuildContext context) {\n  return Column(\n    children: [\n      Text(\"User List Title\"),\n      ...users.map((user) {\n        return Text(user.name);\n      }),\n    ],\n  );\n}\n```\n\n這樣的寫法不僅更直覺，也更清楚地表達了「標題應該只顯示一次，並位於使用者名稱清單的最上方」。\n\n然而，這仍然不完全等價於原始程式碼。原始版本的邏輯還包括「當 `users` 為空時，不應顯示標題」。因此，我們可以進一步調整程式碼，使其更明確地表達這一邏輯：\n\n```\nWidget build(BuildContext context) {\n  if (users.isEmpty) {\n    return SizedBox.shrink();\n  }\n\n  return Column(\n    children: [\n      Text(\"User List Title\"),\n      ...users.map((user) {\n        return Text(user.name);\n      }),\n    ],\n  );\n}\n```\n\n如此一來，讀者能夠一眼看出程式的意圖：標題僅在 `users` 非空時顯示，並且只會出現一次。\n\n# **小結**\n\n使用 Index 並非絕對不妥，而是應視情境而定。我們應該考慮索引是否真正表達了程式的意圖，還是讓讀者需要額外推理才能理解它的用途。透過適當的資料結構與語法特性，我們可以讓程式碼更易讀、更容易維護。",
      "createdAt": "March 9, 2025 3:15 PM",
      "updatedAt": "October 24, 2025 5:12 PM",
      "id": "1b18303f78f780719e3af619d44bc33f",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "避免隱晦的程式邏輯 - Index 1b18303f78f780719e3af619d44bc33f.md",
      "folderName": "避免隱晦的程式邏輯 - Index"
    },
    {
      "title": "避免隱晦的程式邏輯",
      "summary": "在開發中，我們為了完成某項功能的細部行為，可能會有很多種做法，如何評估哪種作法更好呢？其中一項準則就是清楚呈現邏輯。當程式碼能夠清楚呈現邏輯時，往後其他人在閱讀程式碼時，就能更快的了解其意圖。 就同如《先整理一下？》所提到的：「作者只有一個，但讀者通常會有很多個」，如果把邏輯用隱晦的方式完成，我們很...",
      "content": "![](https://images.unsplash.com/photo-1756253665162-c2fe14ad0caa?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n在開發中，我們為了完成某項功能的細部行為，可能會有很多種做法，如何評估哪種作法更好呢？其中一項準則就是清楚呈現邏輯。當程式碼能夠清楚呈現邏輯時，往後其他人在閱讀程式碼時，就能更快的了解其意圖。\n\n就同如《先整理一下？》所提到的：「作者只有一個，但讀者通常會有很多個」，如果把邏輯用隱晦的方式完成，我們很難保證每個人對都能理解這段邏輯的意圖，而呈現意圖也是 Kent Beck 簡單設計中的一項原則。\n\n## 舉個例子\n\n假設畫面有兩個彈跳視窗 A 與 B，這兩個彈跳視窗有些規則，規則如下：\n\n- 系統會先顯示彈跳視窗 A，接著才顯示彈跳視窗 B。\n- 如果使用者已經看過了彈跳視窗 A，則 A **此後都不再顯示**。\n- 如果使用者**今天**看過了彈跳視窗 B，則 B **今天不再顯示**。\n\n根據這三個規則，我們可以很容易地寫出類似下方這樣的程式碼：\n\n( 這裡讓我們先暫時忽略持久化的部分，畢竟這不是重點 )\n\n```dart\nFuture<void> showPopups() async {\n\tif (!hasPopupAShow) {\n\t\tawait showPopupA();\n\t\thasPopupAShow = true;\n\t}\n\n\tif (popupBShowDate != today()) {\n\t\tawait showPopupB();\n\t\tpopupBShowDate = today();\n\t}\n}\n\n```\n\n這段程式碼也完整地呈現了上述的三的規則。\n\n## 事情發生了改變\n\n若是今天需求發生了變化，在這兩個彈窗之間，又新增了一條規則\n\n- 如果使用者今天看過了 A，今天之內就不要再看到 B 了。\n\n那我們應該如何調整呢？觀眾們也可以先想想看，若是自己來處理的話，會怎麼做。\n\n![1737783415192.png](%E9%81%BF%E5%85%8D%E9%9A%B1%E6%99%A6%E7%9A%84%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF/1737783415192.png)\n\n## 一種作法\n\n一種作法是，我們可以在看完 A 的時候，順手把 B 的 popupBShowDate 也順手設了，這樣一來，當檢查到 B 的時候，自然也就會不打開 B。這個作法相當簡單，不要改動太多程式碼，只要僅僅多家一行程式碼就能完成，省時又省力。\n\n```dart\nFuture<void> showPopups() async {\n\tif (!hasPopupAShow) {\n\t\tawait showPopupA();\n\t\thasPopupAShow = true;\n\t\tpopupBShowDate = today();\n\t}\n\n\tif (popupBShowDate != today()) {\n\t\tawait showPopupB();\n\t\tpopupBShowDate = today();\n\t}\n}\n\n```\n\n這種作法乍聽起來也很自然：看了 A 之後，就當作 B 也看過了，但若是仔細想想，真的是這樣嗎？\n\n但若是對於作者以外的人來說，如果對這個功能不是很了解，在爬 Code 看到這段的時候，就可能很難聯想為什麼 A 看完之後，要同時把 B 的時間也設定了，也就更難推論出當初的作法：看過 A 之後，今天之內就不要再看到 B 了 的行為。\n\n## 另一種作法\n\n讓我們來看看另外一種作法：把 A 的彈窗顯示紀錄從 bool 改成 DateTime，當看過 A 之後，紀錄 A 看過的時間。\n\n接著我們就在能檢查 B 彈窗的時候，確認只有在今天都還沒看過 A 與 B 兩個彈窗時，才顯示 B。\n\n```dart\nFuture<void> showPopups() async {\n\tif (popupAShowDate == null) {\n\t\tawait showPopupA();\n\t\tpopupAShowDate = today();\n\t}\n\n\tif (popupBShowDate != today() && popupAShowDate != today()) {\n\t\tawait showPopupB();\n\t\tpopupBShowDate = today();\n\t}\n}\n\n```\n\n相比於第一個作法，我們可以更清楚在邏輯中展示 A 與 B 之間的關係，向讀者說明若是今天看過 A，就不要再顯示 B 了。\n\n雖然第二種寫法看起來比較囉唆，需要的改動也比較多，但是他能更準確地從 if 條件中看出 B 的顯示邏輯。\n\n看完兩種作法之後，不知道你喜歡哪種呢？或者你有更好的作法，歡迎留言交流分享。\n\n## 小結\n\n無論第一種作法或第二種，我們都能完成功能。在完成功能之後，我們還得花時間看看我們的程式碼，確認程式碼是否符合各種設計原則，透過不斷重構，讓程式碼不斷演化的過程中，能維持品質，支持後續的改動。\n\n年節已到，祝大家新年快樂。",
      "createdAt": "January 25, 2025 2:35 PM",
      "updatedAt": "October 24, 2025 5:13 PM",
      "id": "1868303f78f78085ae92e639d0bdfac2",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "避免隱晦的程式邏輯 1868303f78f78085ae92e639d0bdfac2.md",
      "folderName": "避免隱晦的程式邏輯"
    },
    {
      "title": "Container - 一個你最熟悉又最陌生的 Widget",
      "summary": "AI summary: Container 在 Flutter 中的行為複雜，設定大小後會拉大子 Widget，使用 alignment 可以解決此問題。深入了解 Container 的 build 方法和原始碼有助於開發者更有效地處理佈局問題。 每次在開發的時候，碰到不如預期的狀況時，都是一個非常...",
      "content": "AI summary: Container 在 Flutter 中的行為複雜，設定大小後會拉大子 Widget，使用 alignment 可以解決此問題。深入了解 Container 的 build 方法和原始碼有助於開發者更有效地處理佈局問題。\n\n![](https://images.unsplash.com/photo-1493946740644-2d8a1f1a6aff?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb)\n\n每次在開發的時候，碰到不如預期的狀況時，都是一個非常好的機會，可以讓我們更深了解某些事。\n\n最近在開發的時候又碰到一些意料之外的事，經過一些實驗，終於定位了問題點。\n\n讓我們看看以下這段程式碼，在這段程式碼中，我們指定了 Container 的大小為 300 x 300，同時也指定 child 中的 Image 大小為 30 x 30。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: Image.asset(\n    \"assets/images/blog.png\",\n    width: 30,\n    height: 30,\n  ),\n)\n```\n\n大家可以在腦海中想像一下，這段程式碼在畫面中會呈現成什麼樣子？是否會覺得下圖這樣呢？\n\n![align_center.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/align_center.png)\n\n但結果卻是 Container 把 Image 也拉大到 300 x 300 了。\n\n![no_align.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/no_align.png)\n\n觀眾們可能會想，都設定圖片大小了，怎麼還是會被放到最大呢？\n\n顯然肯定有個人在搞鬼，今天就來看看這個搞鬼的人：**Container**。\n\n## Container 的行為\n\nContainer 作為開發 Flutter App 最常用的 Widget 之一，其實有著相當複雜的行為。如果我們看到[官方文件](https://api.flutter.dev/flutter/widgets/Container-class.html)，會發現其中有一段文字在描述 Container 的行為。\n\nContainer 的佈局行為按以下順序進行：\n\n- 優先遵循 `alignment`。\n- 根據 child 的大小來決定自身大小。\n- 遵循 `width`、`height` 和 `constraints`\n- 擴展以適配父級大小。\n- 嘗試盡量小化自身大小。\n\n若是調整一下剛剛的例子，把 `width` 與 `height` 拿掉。\n\n```dart\nContainer(\n  color: Colors.pinkAccent,\n  child: Image.asset(\n    \"assets/images/blog.png\",\n    width: 30,\n    height: 30,\n  ),\n)\n```\n\n此時就會發現，Container 就遵循了第二條規則：**根據 child 大小來決定自身大小**。\n\n![截圖 2024-12-19 晚上11.33.09.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.33.09.png)\n\n設定了 `width` 與 `height` 後，到底實際發生了什麼事呢？讓我們深入 Container 的 build 方法一探究竟。\n\n## Container 的 build 方法\n\n當我們設定了 `width` 或 `height` 而沒有給 `constraints` 時，實際上 Container 會幫我們生成一個 `BoxConstraints.tightFor(width: width, height: height)`。\n\n```dart\nContainer({\n    // 省略...\n  }) : // 省略 ...,\n       constraints =\n        (width != null || height != null)\n          ? constraints?.tighten(width: width, height: height)\n            ?? BoxConstraints.tightFor(width: width, height: height)\n          : constraints;\n\n```\n\n`tighFor` 方法會限制 Widget 的大小，指定 Widget 的寬高，那這個 BoxConstraints 會用在哪邊呢？\n\n```dart\nconst BoxConstraints.tightFor({\n    double? width,\n    double? height,\n  }) : minWidth = width ?? 0.0,\n       maxWidth = width ?? double.infinity,\n       minHeight = height ?? 0.0,\n       maxHeight = height ?? double.infinity;\n\n```\n\n在 build 方法中，我們可以看到剛剛的 constraints 被放在 ConstrainedBox 中，用來限制 Container 的子 Widget。以上面的例子來說，被限制的 Widget 就是放入的 child 的 Image。\n\n```dart\n@override\nWidget build(BuildContext context) {\n  // Container 的 build 方法\n  // 省略 ...\n\n  if (constraints != null) {\n    current = ConstrainedBox(constraints: constraints!, child: current);\n  }\n\n  // 省略 ...\n\n  return current!;\n}\n```\n\n所以也就使得了 Image 被拉到與 Container 一樣大小。\n\n## 使用 alignment\n\n熟悉 Flutter 的開發人員肯定對這狀況也不陌生，知道加上 alignment 參數就能解決問題。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  alignment: Alignment.center,\n  child: Image.asset(\n    \"assets/images/blog.png\",\n    width: 30,\n    height: 30,\n  ),\n)\n\n```\n\n那為什麼在 Container 中加上 `alignment` 時，圖片就能維持當初設定的大小呢？讓我們再次看回 Container 的 build 方法中。\n\n```dart\n@override\nWidget build(BuildContext context) {\n  // Container 的 build 方法\n  // 省略 ...\n\n  if (child == null && (constraints == null || !constraints!.isTight)) {\n    // 省略 ...\n  } else if (alignment != null) {\n    current = Align(alignment: alignment!, child: current);\n  }\n\n  // 省略 ...\n\n  if (constraints != null) {\n    current = ConstrainedBox(constraints: constraints!, child: current);\n  }\n\n  // 省略 ...\n\n  return current!;\n}\n\n```\n\n當 `alignment` 不為 null 時，就會在 child 外面包上一層 Align，接著才是在 Align 外面再包上 ConstrainedBox。這樣一來，就使得實際被拉大的是 Align，而非 Image。\n\n如果有認真看 Container 原始碼的觀眾可能會問，即便我沒有設定 `alignment`，但我有設定 `color`，而 ConstrainedBox 的下一層 child 應該是 ColoredBox，所以要拉大也是拉大 ColoredBox，而不應該是 Image 吧？\n\n```dart\n@override\nWidget build(BuildContext context) {\n  // Container 的 build 方法\n  // 省略 ...\n\n  if (child == null && (constraints == null || !constraints!.isTight)) {\n    // 省略 ...\n  } else if (alignment != null) {\n    current = Align(alignment: alignment!, child: current);\n  }\n\n  if (color != null) {\n    current = ColoredBox(color: color!, child: current);\n  }\n\n  // 省略 ...\n\n  if (constraints != null) {\n    current = ConstrainedBox(constraints: constraints!, child: current);\n  }\n\n  // 省略 ...\n\n  return current!;\n}\n```\n\n的確，ColoredBox 確實會被拉大，但是 ColoredBox 也直接把上頭來的 constraints 直接轉送給了他的 child。在這兩種狀況中，雖然 Image 上層還有其他 Widget，但是卻有不同的結果。\n\n若繼續深入 Align 與 ColoredBox 的佈局方式，很快就有答案了。\n\n一路追蹤 ColoredBox 的原始碼：ColoredBox -> _RenderColoredBox -> RenderProxyBoxWithHitTestBehavior -> RenderProxyBox，最後可以發現 ColoredBox 繼承了 RenderProxyBox。在 RenderProxyBox 的佈局中，其實也就只是把自己收到的限制，直接原封不動的傳給子 Widget，所以即便中間多墊了一層 ColoredBox，也不能避免 Image 被拉大的效果。\n\n```dart\n@override\nvoid performLayout() {\n  size = (child?..layout(constraints, parentUsesSize: true))?.size\n      ?? computeSizeForNoChild(constraints);\n  return;\n}\n```\n\n接著看到 Align，Align 繼承了 RenderPositionedBox。在 RenderPositionedBox 的佈局中，我們可以發現，它從上頭接收到了限制，接著轉頭就將限制放寬，讓子 Widget 可以挑選他希望的大小。所以在 Align 中，Image 可以維持當初設定的 30 x 30 的大小。\n\n```dart\n@override\nvoid performLayout() {\n  final BoxConstraints constraints = this.constraints;\n\n  // 省略 ...\n\n  if (child != null) {\n    child!.layout(constraints.loosen(), parentUsesSize: true);\n\n    // 省略 ...\n\n  } else {...}\n}\n```\n\n## 實驗放入不同的 Widget\n\n最後讓我們做一些實驗，如果採用相同 Container 設定，但是在 child 中放入不同東西，看看會發生什麼事？\n\n### 放入指定大小的 Container\n\n與 Image 一樣，放入了指定大小的 Container，結果這個 Container 還是被拉大到 300 x 300。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: Container(\n    width: 100,\n    height: 100,\n    color: Colors.blueAccent,\n  ),\n)\n```\n\n![截圖 2024-12-19 晚上11.43.51.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.43.51.png)\n\n### 放入 TextButton\n\n乍看之下，放入的 TextButton 好像沒被拉大，但實際上卻是有的，我們可以從 Hover 效果看出，按鈕還是被拉大了。\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: TextButton(\n    onPressed: () {},\n    child: const Text('Click me'),\n  ),\n)\n```\n\n![截圖 2024-12-19 晚上11.47.46.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.47.46.png)\n\n### 放入 Text\n\n當我們試到 Text 的時候，卻發現 Text 好像就沒被拉大的問題，這又是怎麼一回事呢？\n\n```dart\nContainer(\n  width: 300,\n  height: 300,\n  color: Colors.pinkAccent,\n  child: const Text(\"Hello World\"),\n)\n```\n\n![截圖 2024-12-19 晚上11.35.25.png](Container%20-%20%E4%B8%80%E5%80%8B%E4%BD%A0%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E6%9C%80%E9%99%8C%E7%94%9F%E7%9A%84%20Widget/%25E6%2588%25AA%25E5%259C%2596_2024-12-19_%25E6%2599%259A%25E4%25B8%258A11.35.25.png)\n\n關於這個問題，有機會再讓我們深入探討，好奇的觀眾也可以先自行研究看看。\n\n## 小結\n\nContainer 做為我們最常使用的 Widget 之一，了解他如何運作對於開發必然有些幫助。雖然不是每天都會碰到 Widget 排版不如預期的問題，但是每次碰上就會相當困擾，需要花許多時間嘗試才能解決。\n\n追蹤原始碼，了解 Widget 底層的運作邏輯，能夠提供我們更多解決問題的思路。當未來碰上問題時，就能用正確又快速的方式解決，而不是留下更多的 Workaround。",
      "createdAt": "December 24, 2024 12:10 AM",
      "updatedAt": "October 24, 2025 5:15 PM",
      "id": "1658303f78f780648388f15ef489fe47",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Container - 一個你最熟悉又最陌生的 Widget 1658303f78f780648388f15ef489fe47.md",
      "folderName": "Container - 一個你最熟悉又最陌生的 Widget"
    },
    {
      "title": "自製 Flutter Tab Bar - 深入底層更新機制",
      "summary": "AI summary: 本文探討了 Element 更新機制，並分析 Row + Expanded 與 AnimatedSize 無法正常運作的元因。最後提供了兩種解決方案：使用 Expanded 並將 flex 設為 0，或使用 GlobalObjectKey。 這個系列終於迎來最終回了，為了完成...",
      "content": "AI summary: 本文探討了 Element 更新機制，並分析 Row + Expanded 與 AnimatedSize 無法正常運作的元因。最後提供了兩種解決方案：使用 Expanded 並將 flex 設為 0，或使用 GlobalObjectKey。\n\n![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%A4%E6%9B%B4%E6%96%B0%E6%A9%9F%E5%88%B6/image.png)\n\n這個系列終於迎來最終回了，為了完成下圖這個特別的 Tab Bar 動畫效果，我們最初直接使用 CustomMultiChildLayout 來完成，但是也同時好奇為什麼 Row + Expanded + AnimatedSize 做不到一樣效果，所以在上一篇文章中分析了 Row 的佈局邏輯。\n\n![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%A4%E6%9B%B4%E6%96%B0%E6%A9%9F%E5%88%B6/image%201.png)\n\n但是在研究 Row 的過程中，卻發現事情跟想像中的不同。以 Row 的佈局邏輯來說，應該要能完美的配合 AnimatedSize 的動畫，讓 AnimatedSize 中子 Widget 在大小有所變化時，可以順暢地以動畫的方式呈現。\n\n但是當實際使用了 Row + Expanded 包在 AnimatedSize 外面時，效果並不如預期。當狀態改變時，AnimatedSize 中的 Tab 卻是一瞬間縮小，而不是以動畫形式變小。\n\n![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%A4%E6%9B%B4%E6%96%B0%E6%A9%9F%E5%88%B6/image%202.png)\n\n```dart\nRow(\n  children: [\n    for (int index = 0; index < tabLength; index++)\n      currentIndex == index\n          ? AnimatedSize(\n            duration: const Duration(milliseconds: 300),\n            child: _SelectedTab(index: index),\n          )\n          : Expanded(\n              child: AnimatedSize(\n                duration: const Duration(milliseconds: 300),\n                child: GestureDetector(\n                  onTap: () => setState(() => currentIndex = index),\n                  child: _UnselectedTab(index: index),\n                ),\n              ),\n            )\n  ],\n)\n```\n\n那這是為什麼呢？明明 Row 沒有限制子 Widget 大小，為什麼選中的 Tab 沒有按照預期的用動畫變大變小呢？\n\n答案其實是：**因為被選中的 Tab 沒被 Expanded 包住**。\n\n對 Flutter 不熟悉的觀眾可能會滿頭問號，為什麼沒有被 Expanded 包住會造成問題？而且如果要用 Expanded 包住被選中的 Tab，我們又要如何不限制選中的 Tab 大小？\n\n讓我們來一一解答這些問題吧。\n\n## Element Tree 的更新邏輯\n\n首先，對 Flutter 有研究的觀眾多少都會知道，Flutter 框架底層維護了三顆樹：Widget Tree、Element Tree 與 RenderObject Tree，他們分別掌管了不同職責。\n\n其中 Element 負責管理 Widget 與 RenderObject，當狀態改變時，能有效的因應變化，只調整有改變的部分，避免頻繁的重建 Element，進而提高效能。\n\n當畫面需要更新時，Element 會從需要更新的 Element 開始，一路往子 Element 更新。\n\n當更新某個 Element 時，Element 中的 `updateChild` 方法就會被呼叫，用來處理當前 Element 的下一層節點結構變化。在 `updateChild` 方法的上方也有一大段註釋在解釋其運作邏輯，其中包含了一段表格，用來展示幾種更新的狀況。\n\n```markdown\n|                 |   newWidget == null    |       newWidget != null          |\n| :-------------: | :--------------------- | :------------------------------- |\n|  child == null  |  Returns null.         |  Returns new [Element].          |\n|                 |                        |                                  |\n|  child != null  |  Old child is removed, | Old child updated if possible,   |\n|                 |  returns null.         | returns child or new [Element].  |  \n```\n\n表格中的 child 是指當前更新中的 Element 的子節點，而 newWidget 則是打算新增進來的 Widget。讓我們看個簡單的例子，假設我們在畫面中存在著一個 Text，這個 Text 會隨著不同的狀態而出現底色。\n\n```dart\nclass _MyTextState extends State<MyText> {\n  bool isHighlight = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () => setState(() => isHighlight = !isHighlight),\n      child: isHighlight\n          ? Container(color: Colors.red, child: const Text(\"Hello World\"))\n          : const Text(\"Hello World\"),\n    );\n  }\n}\n\n```\n\n若當前 isHighlight 為 false，畫面中的 Text(\"Hello World\") 也沒有任何底色。接著下一秒程式呼叫了 setState 並將 isHighlight 更新為 true。GestureDetector 的子 Widget 也從 Text 改變成 Container。\n\n此時 GestureDetector 的 Element 的 updateChild 方法就會被呼叫到，帶進來的 child 就是 Text，而 newWidget 則是 Container。（註：事實上，GestureDetector 並非 Text 的父母，而是祖父母，因為 GestureDetector 中還包了許多其他 Widget，這裡為了說明方便而簡化。）\n\n```dart\nElement? updateChild(Element? child, Widget? newWidget, Object? newSlot) {\n    ...\n}\n```\n\n按照上面表格的邏輯 child 不為 null，newWidget 也不為 null，就會走到 **Old child updated if possible, returns child or new [Element]** 這段分支。這段邏輯分支主要由三個 if 判斷實現，第一個 if 會比較 child.widget 與 newWidget 是否相同，這裡比較的是兩者是否是相同實例。通常如果使用 const 的 Widget 就會直接落入這個 if 條件中。\n\n```dart\nif (hasSameSuperclass && child.widget == newWidget) {\n  if (child.slot != newSlot) {\n    updateSlotForChild(child, newSlot);\n  }\n  newChild = child;\n}\n```\n\n若以上面的範例來說，child.widget 是 Text，而 newWidget 則是 Container。兩者類別都不同了，更別提是否是相同實例了。（註：以下 `updateChild` 方法邏輯經過簡化，原始碼可以參考[這邊](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart)。）\n\n接著看到下一段 if 判斷，判斷是否可以透過更新 Element 來避免建立新 Element。\n\n```dart\nif (hasSameSuperclass && child.widget == newWidget) {\n  // 省略...\n} else if (hasSameSuperclass && Widget.canUpdate(child.widget, newWidget)) {\n  if (child.slot != newSlot) {\n    updateSlotForChild(child, newSlot);\n  }\n  child.update(newWidget);\n  newChild = child;\n}\n```\n\n在這個 if 判斷中，最主要的判斷由 `Widget.canUpdate` 決定，來看一下 `Widget.canUpdate` 的邏輯。\n\n```dart\nabstract class Widget extends DiagnosticableTree {\n  static bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n  }\n}\n```\n\n帶入上面的範例後，我們會發現 oldWidget (Text) 的 runtimeType 與 newWidget (Container) 的 runtimeType 不同了，所以也無法直接更新 Element。\n\n至此也只有最後一條路可以走，也就是建立新的 Element，這邊再往下走就會先停用當前的 Element，接著在 inflateWidget 方法中呼叫 Widget 身上的 createElement 方法來建立新的 Element。\n\n```dart\nif (hasSameSuperclass && child.widget == newWidget) {\n  // 省略...\n} else if (hasSameSuperclass && Widget.canUpdate(child.widget, newWidget)) {\n  // 省略...\n} else {\n  deactivateChild(child);\n  newChild = inflateWidget(newWidget, newSlot);\n}\n```\n\n至此我們應該可以回答：**為什麼被選中的 Tab 沒被 Expanded 包住會造成 AnimatedSize 失效**，其實原因就是因為 AnimatedSize 重建了。那 AnimatedSize 被重建為什麼會造成動畫失效呢？其實原因也很好想像 AnimatedSize 若想要有動畫效果，他就必須有**改變前的狀態**與**改變後的狀態**，這樣才能夠知道要變大還是變小。\n\n假設當前 AnimatedSize 的寬度為 10，setState 後變成 20，AnimatedSize 就會知道要從寬度要從 10 慢慢變化成 20。但是如果是重建 AnimatedSize 的情況，AnimatedSize 就不會有 10 的資訊，而是重新建了一個寬度為 20 的 AnimatedSize，自然也就不會有動畫。\n\n往後有機會的話，我們再來深入 Animated 系列 Widget 是怎麼製作的，現在先讓我們看看要怎麼解決這個問題呢？這邊有兩個方法。\n\n## 使用 Expanded 包住被選中的 Tab\n\n可能有觀眾會好奇，用 Expanded 包住被選中的 Tab 的話，那我們還怎麼實現想要的效果呢？答案其實在上一篇文章中也有提到，其實就把 flex 設為 0 就好。在 flex 設為 0 的狀態下，Row 就會給該 Widget 任意大小的空間，讓 Widget 佔住他需要的大小。\n\n同時也因為包了 Expanded，所以在 Element 更新子節點的邏輯中，就能在 Widget.canUpdate 的邏輯中被判斷為可更新，進而避免重建。\n\n```dart\nRow(\n  children: [\n    for (int index = 0; index < tabLength; index++)\n      currentIndex == index\n          ? Expanded(\n              flex: 0,\n              child: AnimatedSize(\n                duration: const Duration(milliseconds: 300),\n                child: _SelectedTab(index: index),\n              ),\n            )\n          : Expanded(\n              child: AnimatedSize(\n                duration: const Duration(milliseconds: 300),\n                child: GestureDetector(\n                  onTap: () => setState(() => currentIndex = index),\n                  child: _UnselectedTab(index: index),\n                ),\n              ),\n            )\n  ],\n)\n```\n\n## 使用 GlobalObjectKey\n\n除了使用 Expanded + flex 為 0 的設定之外，我們還能使用 GlobalKey 來避免 Widget 重建的問題。使用了 GlobalKey，在 Element 更新子節點時，就能透過 GlobalKey 來辨識 Element 是否已經建立過，進而重複使用先前已經建好的 Element。\n\n```dart\nRow(\n  children: [\n    for (int index = 0; index < tabLength; index++)\n      currentIndex == index\n          ? AnimatedSize(\n            key: GlobalObjectKey(index),\n            duration: const Duration(milliseconds: 300),\n            child: _SelectedTab(index: index),\n          )\n          : Expanded(\n              child: AnimatedSize(\n                key: GlobalObjectKey(index),\n                duration: const Duration(milliseconds: 300),\n                child: GestureDetector(\n                  onTap: () => setState(() => currentIndex = index),\n                  child: _UnselectedTab(index: index),\n                ),\n              ),\n            )\n  ],\n)\n```\n\n當 Widget 使用了 GlobalKey 之後，雖然在 updateChild 方法中依舊會走到 inflateWidget 嘗試重建 Element，但是在 inflateWidget 方法中，其實還有一場敗部復活賽。Element 會從被停用的子節點中，找尋是否有與新子節點一樣的 GlobalKey 的節點，如果有的話，就把它拿回來重複利用。\n\n## 小結\n\n從使用 CustomMultiChildLayout 自製 Widget，再到探索 Row 的佈局邏輯，輾轉之後，還帶著觀眾一起看了部分 Element 更新機制。雖然我們可能不太有機會修改到底層框架的機制，但是認識這些機制有助於我們在開發的時候提高程式運行效能，也能在碰到問題的時候，有更多資訊可以提供解決思路。\n\n## 參考連結\n\n- Element 原始碼：https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart",
      "createdAt": "December 4, 2024 10:24 PM",
      "updatedAt": "October 24, 2025 5:17 PM",
      "id": "1528303f78f780bfaaf3e3f295198061",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "自製 Flutter Tab Bar - 深入底層更新機制 1528303f78f780bfaaf3e3f295198061.md",
      "folderName": "自製 Flutter Tab Bar - 深入底層更新機制"
    },
    {
      "title": "自製 Flutter Tab Bar - 探索  Row 的佈局邏輯",
      "summary": "在上一篇文章中，我們製作 Tab Bar 時，曾嘗試使用 Row + Expanded 來完成，但是最終使用 AnimatedSize 套上動畫時，結果卻不如預期，Tab Bar 並沒有在切換 Tab 時顯示動畫，今天我們就來深入暸解到底發生了什麼。文章中，我們會分析 Row 的原始碼，了解 Row...",
      "content": "![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%8E%A2%E7%B4%A2%20Row%20%E7%9A%84%E4%BD%88%E5%B1%80%E9%82%8F%E8%BC%AF/image.png)\n\n在上一篇文章中，我們製作 Tab Bar 時，曾嘗試使用 Row + Expanded 來完成，但是最終使用 AnimatedSize 套上動畫時，結果卻不如預期，Tab Bar 並沒有在切換 Tab 時顯示動畫，今天我們就來深入暸解到底發生了什麼。文章中，我們會分析 Row 的原始碼，了解 Row 的行為，嘗試理解到底是哪邊有問題。\n\n## 軟體開發的抽象洩漏\n\n為什麼我們要研究底層框架的邏輯呢？我們用了框架，用了套件，不就是為了讓開發更容易嗎？我們不需要認識 Flutter 怎麼把文字、圖片顯示在畫面上，我們不需要事先了解隱藏在背後的複雜邏輯才能開始開發，只需要簡單的用 Widget 定義畫面細節，框架幫我們把這些複雜的邏輯簡化成易用的抽象操作，讓我們得以使用這些簡化的抽象操作迅速上手。\n\n確實在一開始，我們不需要知道這麼多就可以開發，但有時事實不如預期那樣發展，有一定經驗的開發者一定知道，若我們持續開發，總是會碰到一些不知道如何解決問題。例如：當 Container 放在 MaterialApp 的 home 時，無論 Container 寬高怎麼設定，最終 Container 最終都會跟畫面一樣大。又好比某個畫面在顯示的過程中卡頓不順暢時，我們如果對 Flutter 的渲染方式沒有一定了解，可能就沒有一個解決問題的方向。\n\n雖然框架與套件盡力的封裝複雜的操作，讓開發人員方便使用，但還是無可避免的會因為一些原因導致我們必須更深入了解實作細節，在 LeSS in Action 的課程中，老師就曾經提到這個問題，認為這是一種無可避免的抽象洩漏。所以身為一個開發人員，**我們必須持續學習，保持對事物的好奇心，探索事物的內在本質**，在未來的某一天，這些內功都會派上用場的。\n\n現在讓我們回歸正題，來一起研究 Row 的實作細節吧。\n\n## Row 的繼承關係\n\n首先打開 Row 的原始碼，我們可以發現它繼承了 Flex，Flex 有兩個實作，分別是大家都十分熟悉的 Row 與 Column，兩者差別其實只在於**方向**而已。\n\n```dart\nclass Row extends Flex {\n  const Row({\n    super.key,\n    super.mainAxisAlignment,\n    super.mainAxisSize,\n    super.crossAxisAlignment,\n    super.textDirection,\n    super.verticalDirection,\n    super.textBaseline,\n    super.children,\n  }) : super(\n    direction: Axis.horizontal,\n  );\n}\n\nclass Column extends Flex {\n  const Column({\n    super.key,\n    super.mainAxisAlignment,\n    super.mainAxisSize,\n    super.crossAxisAlignment,\n    super.textDirection,\n    super.verticalDirection,\n    super.textBaseline,\n    super.children,\n  }) : super(\n    direction: Axis.vertical,\n  );\n}\n```\n\n若是再往上延伸，就會看到 Flex 繼承了 MultiChildRenderObjectWidget，我們先前使用的 CustomMultiChildLayout 也同樣繼承了 MultiChildRenderObjectWidget。CustomMultiChildLayout 與 MultiChildRenderObjectWidget 的功能很像，前者只是把後者封裝成更簡單容易使用的 Widget。那 MultiChildRenderObjectWidget 是什麼呢？\n\n簡單來說，MultiChildRenderObjectWidget 接受一群 Widget 作為輸入，我們可以透過各種不同的實作來規劃這群 Widget 如何佈局，例如：使用 [Stack](https://api.flutter.dev/flutter/widgets/Stack-class.html) 決定每個 Widget 的位置，或是使用 [Row](https://api.flutter.dev/flutter/widgets/Row-class.html) 來橫向依序排列每個 Widget。\n\n在實作 MultiChildRenderObjectWidget 過程中， 具體實作類別會覆寫 createRenderObject 來建立各自對應的 RenderObject，用以實現剛剛提到的各種佈局邏輯。以 Flex 來說，createRenderObject 就會建立 RenderFlex，若想了解 Flex 的佈局邏輯，也就得深入研究 RenderFlex。\n\n```dart\nclass Flex extends MultiChildRenderObjectWidget {\n  @override\n  RenderFlex createRenderObject(BuildContext context) {\n    return RenderFlex(\n      direction: direction,\n      mainAxisAlignment: mainAxisAlignment,\n      mainAxisSize: mainAxisSize,\n      crossAxisAlignment: crossAxisAlignment,\n      textDirection: getEffectiveTextDirection(context),\n      verticalDirection: verticalDirection,\n      textBaseline: textBaseline,\n      clipBehavior: clipBehavior,\n    );\n  }\n}\n```\n\n註：接下來會看到許多像下方程式碼那樣的判斷方向邏輯，由於我們這邊先只有探討 Row 的行為，所以可以只看 Axis.horizontal 的邏輯即可。\n\n```dart\ndouble _getMainSize(Size size) {\n  return switch (_direction) {\n    Axis.horizontal => size.width,\n    Axis.vertical => size.height,\n  };\n}\n```\n\n## RenderFlex 如何限制子 Widget\n\n繞了一這麽大一圈，我們終於知道要去 RenderFlex 裡面找 Row 的佈局邏輯，那接著就能開始研究最初的問題：**為什麼 AnimatedSize 在 Row + Expanded 中不起作用呢？**\n\n在 RenderFlex 中，處理佈局的方法為 performLayout。在 performLayout 方法中，除去一些前置的狀態檢查邏輯之外，最先呼叫的是邏輯是 _computeSizes 方法。_computeSizes 最主要的任務就是處理「Constraints go down. Sizes go up.」，給定每個子 Widget 的限制，取回每個子 Widget 最終使用的大小。在 _computeSizes 方法中有幾段邏輯，讓我們一一細看。\n\n首先，透過 while 迴圈處理每一個子 Widget。這邊有段  if 邏輯，當子 Widget 的 flex 大於 0 的時候，並不會直接的使用 layoutChild 來決定子 Widget 的大小，而是只有在 flex 為 0 的時候，才會直接使用 layoutChild 來取得子 Widget 大小。\n\n設定 flex 的方式也就是我們熟悉的 Flexible 與 Expanded。\n\n```dart\nwhile (child != null) {\n  final FlexParentData childParentData = child.parentData! as FlexParentData;\n  final int flex = _getFlex(child);\n  if (flex > 0) {\n    totalFlex += flex;\n    lastFlexChild = child;\n  } else {\n    final BoxConstraints innerConstraints = switch ((stretched, _direction)) {\n      (true,  Axis.horizontal) => BoxConstraints.tightFor(height: constraints.maxHeight),\n      (true,  Axis.vertical)   => BoxConstraints.tightFor(width: constraints.maxWidth),\n      (false, Axis.horizontal) => BoxConstraints(maxHeight: constraints.maxHeight),\n      (false, Axis.vertical)   => BoxConstraints(maxWidth: constraints.maxWidth),\n    };\n    final Size childSize = layoutChild(child, innerConstraints);\n    allocatedSize += _getMainSize(childSize);\n    crossSize = math.max(crossSize, _getCrossSize(childSize));\n  }\n  assert(child.parentData == childParentData);\n  child = childParentData.nextSibling;\n}\n```\n\n這邊我們暫時假設 stretched 為 false，我們就能推算出：當我們使用 Row 並且沒有特別設定 flex 的話，RenderFlex 給的限制就是 BoxConstraints(maxHeight: constraints.maxHeight)。給定的 BoxConstraints 只設定了最大高度，沒有設定 maxWidth，使得子 Widget 可以在 0 到 double.infinity **之間選擇大小，簡而言之就是，愛多大就多大，甚至可能給出超過 Row 本身大小的 Size，也就會造成我們常見的跑版錯誤。\n\n## 子 Widget 加上 Flexible 時\n\n上面看到的邏輯分岔中，當 flex 大於 0 時，並不會直接使用 layoutChild 取得大小，而是只有記錄一下 totalFlex 與 lastFlexChild 就結束了，為什麼呢？原因應該也挺好想像的，因為使用了 flex 就表示我們要按比例來分配剩餘空間，我們肯定得先知道總共要**分成幾分**與**剩餘空間大小**，才能知道每個 Widget 要給多大。\n\n接著我們繼續往下看，在第二段 while 迴圈中，我們就能看到處理 flex 的邏輯了。在下方展示的邏輯中，minChildExtent 與 maxChildExtent 決定了寬度。當 fit 被設定為 FlexFit.tight 的時候，minChildExtent 也就等於 maxChildExtent，使得子 Widget 被強制為 maxChildExtent 大小。\n\n```dart\nwhile (child != null) {\n  final int flex = _getFlex(child);\n  if (flex > 0) {\n    final double maxChildExtent = switch (canFlex) {\n      true when child == lastFlexChild => freeSpace - allocatedFlexSpace,\n      true => spacePerFlex * flex,\n      false => double.infinity,\n    };\n    final double minChildExtent = switch (_getFit(child)) {\n      FlexFit.tight => maxChildExtent,\n      FlexFit.loose => 0.0,\n    };\n    assert(minChildExtent.isFinite);\n    final double minCrossSize = stretched ? _getCrossSize(constraints.biggest) : 0.0;\n    final BoxConstraints innerConstraints = switch (_direction) {\n      Axis.horizontal => constraints.copyWith(minHeight: minCrossSize, minWidth: minChildExtent, maxWidth: maxChildExtent),\n      Axis.vertical   => constraints.copyWith(minWidth: minCrossSize, minHeight: minChildExtent, maxHeight: maxChildExtent),\n    };\n    final Size childSize = layoutChild(child, innerConstraints);\n    final double childMainSize = _getMainSize(childSize);\n    assert(childMainSize <= maxChildExtent);\n    allocatedSize += childMainSize;\n    allocatedFlexSpace += maxChildExtent;\n    crossSize = math.max(crossSize, _getCrossSize(childSize));\n  }\n  final FlexParentData childParentData = child.parentData! as FlexParentData;\n  child = childParentData.nextSibling;\n}\n```\n\n那什麼時候 fit 會是 FlexFit.tight 呢？其實就是使用 Expanded 的時候。也就是說，當使用 Expanded 時，每個包了 Expanded 的子 Widget 會被強制依照 flex 比例分配剩餘空間，也就是 switch 邏輯中的 `spacePerFlex * flex`。\n\n```dart\nclass Expanded extends Flexible {\n  const Expanded({\n    super.key,\n    super.flex,\n    required super.child,\n  }) : super(fit: FlexFit.tight);\n}\n```\n\n而子 Widget 若是使用了 Flexible，並維持預設值，讓 fit 是 FlexFit.loose 時，Flex 會允許子 Widget 在 [ 0, `spacePerFlex * flex` ] 之間任意決定大小，並不像 Expanded 一樣強制撐到 flex 設定的比例。\n\n```dart\nclass Flexible extends ParentDataWidget<FlexParentData> {\n  const Flexible({\n    super.key,\n    this.flex = 1,\n    this.fit = FlexFit.loose,\n    required super.child,\n  });\n}\n```\n\n決定 flex > 0 的子 Widget 的大小之後，_computeSizes 的工作也基本完成。接下來的工作就是 Flex 如何安排每個子 Widget 的位置。到這邊我們已經基本了解 Row 如何設定子 Widget 的大小，我們也暫時獲得足夠的資訊來回答我們先前的問題，所以先讓我們暫停在這邊，剩餘的部分，有機會再讀者們分享。\n\n## 回顧 Row 的行為\n\n看到現在，讓我們快速回顧一下，當我們使用 Row 的時候，程式會優先計算沒有使用 flex 為 0 的子 Widget，並且讓這些子 Widget 想使用多大的空間就使用多大的空間。接著才是將剩餘的空間依比例分配給其他使用 Flexible 或 Expanded 設定 flex 的子 Widget。\n\n這裡其實有一件很有趣的事，假設 Row 中同時存在使用 Flexible 的子 Widget 與使用 Expanded 的子 Widget 時，如果使用 Flexible 的子 Widget 沒有用滿 flex 設定比例的空間，那剩下使用 Expanded 的子 Widget 如何分配剩餘空間呢？難道 Expanded 還得知道 Flexible 省下了多少空間沒用，進而把佔滿嗎？讓我們來實驗一下。\n\n首先是第一種情境：**Flexible 中的子 Widget 內容長到足以填滿 flex 設定的比例大小**。\n\n```dart\nRow(children: [\n  Expanded(\n    child: Container(color: Colors.red, child: const Text(\"Item 1\")),\n  ),\n  Expanded(\n    child: Container(color: Colors.green, child: const Text(\"Item 2\")),\n  ),\n  Flexible(\n    child: Container(color: Colors.blue, child: const Text(\"Long Long Long Long Long Item 3\")),\n  ),\n  Expanded(\n    child: Container(color: Colors.yellow, child: const Text(\"Item 4\")),\n  ),\n])\n```\n\n運行之後我們可以發現，畫面確實如預期一樣的平均分配了子 Widget 的空間。在這個情況中 Flexible 跟 Expanded 一起平均分配了空間。\n\n![截圖 2024-11-17 下午5.00.04.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%8E%A2%E7%B4%A2%20Row%20%E7%9A%84%E4%BD%88%E5%B1%80%E9%82%8F%E8%BC%AF/%25E6%2588%25AA%25E5%259C%2596_2024-11-17_%25E4%25B8%258B%25E5%258D%25885.00.04.png)\n\n接著是讓我們看看另外一個狀況：**Flexible 中的子 Widget 內容不足以填滿 flex 設定的比例大小**。\n\n```dart\nRow(children: [\n  Expanded(\n    child: Container(color: Colors.red, child: const Text(\"Item 1\")),\n  ),\n  Expanded(\n    child: Container(color: Colors.green, child: const Text(\"Item 2\")),\n  ),\n  Flexible(\n    child: Container(color: Colors.blue, child: const Text(\"Item 3\")),\n  ),\n  Expanded(\n    child: Container(color: Colors.yellow, child: const Text(\"Item 4\")),\n  ),\n])\n```\n\n運行之後我們就會發現，Flexible 中的 Widget 確實沒有佔滿整個 flex 設定的比例大小，但同時也發現 Expanded 並沒有去填滿 Flexible 所留下的空間，而是按照原本計算的大小來撐開而已。Flexible 沒有佔滿的部分，就真的放著沒有去使用了。\n\n![截圖 2024-11-17 下午5.00.16.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E6%8E%A2%E7%B4%A2%20Row%20%E7%9A%84%E4%BD%88%E5%B1%80%E9%82%8F%E8%BC%AF/%25E6%2588%25AA%25E5%259C%2596_2024-11-17_%25E4%25B8%258B%25E5%258D%25885.00.16.png)\n\n## 小結\n\n今天我們一起研究了 Row 一些佈局邏輯，也再一次認識了「Constraints go down. Sizes go up.」如何在 Flutter 框架中實踐，也發現了 Row 同時使用 Flexible 與 Expanded 可能會有的狀況。\n\n了解了 Row 的運作機制之後，根據我們看到的佈局邏輯，理論上 AnimatedSize 在 Row + Expanded 的組合中使用也要能正常出現動畫效果，那為什麼事實卻不是如此呢？我們在下一篇文章中會繼續探討這個問題，最後我們會發現 Row + Expanded 其實也能完成我們最初想要的行為，那就讓我們下次見吧。\n\n## 參考\n\n- RenderFlex 原始碼：https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/rendering/flex.dart",
      "createdAt": "November 9, 2024 9:12 AM",
      "updatedAt": "October 24, 2025 5:18 PM",
      "id": "1398303f78f780a093c6ece58bdf160d",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "自製 Flutter Tab Bar - 探索 Row 的佈局邏輯 1398303f78f780a093c6ece58bdf160d.md",
      "folderName": "自製 Flutter Tab Bar - 探索 Row 的佈局邏輯"
    },
    {
      "title": "自製 Flutter Tab Bar - 使用 CustomMultiChildLayout",
      "summary": "在產品開發上我們常常使用 Tab Bar 來切換不同分類的內容，使用 Tab Bar 可以讓使用者快速找到想要的內容，提升效率。一般來說，我們可以使用 Flutter 內建 TabBar 來完成，即便我們希望的樣式與預設的不同，也能透過參數調整或額外加工來調整成想要的結果。 [https://api...",
      "content": "![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/image.png)\n\n在產品開發上我們常常使用 Tab Bar 來切換不同分類的內容，使用 Tab Bar 可以讓使用者快速找到想要的內容，提升效率。一般來說，我們可以使用 Flutter 內建 TabBar 來完成，即便我們希望的樣式與預設的不同，也能透過參數調整或額外加工來調整成想要的結果。\n\n![image.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/image%201.png)\n\n[https://api.flutter.dev/flutter/material/TabBar-class.html](https://api.flutter.dev/flutter/material/TabBar-class.html)\n\n但是若碰上內建 TabBar 無法符合設計需求，我們通常就上 [pub.dev](http://pub.dev) 搜尋，看看有沒有人已經提供相同功能的套件。在找不到呢，我們也就只能自己做了，而這次碰到 Tab Bar 設計就剛好是最後一種狀況，這也給了筆者一個嘗試的機會。\n\n![images.png](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/images.png)\n\n## 了解 Tab Bar 行為\n\n首先先來簡單分析一下這個特別的 Tab Bar 的行為：\n\n1. 被選到 Tab 佔據他所需要的寬度，剩下的寬度由那些未被選到的 Tab 平均分配\n2. 被選到的 Tab 擁有不同的文字\n3. 當使用者點選其他 Tab 時，透過淡入淡與放大縮小來變化 Tab 樣式\n\n[ori.mov](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/ori.mov)\n\n分析不只讓我們更清楚要完成什麼需求，將需求拆成一個一個的小需求，我們就能解決多個簡單的小問題，最後集合解決原本的大問題。這也能讓我們優先處理最有價值的部分，用最快的時間產出最有價值的部分，這也是開發人員必備的 Divide and Conquer 技巧。\n\n## 從最重要的功能開始\n\n如果我們先不考慮動畫，我們可很容易地完成兩項要求。首先利用 Row 來放置每個一個 Tab，接著用 Expanded 包住其他沒被選到的 Tab，使得這些沒被選到的 Tab 以平均分配的形式來排列。(為了讓程式碼簡短一些些，筆者拿掉了一些例如圓角或粗體等不重要的細節)\n\n```dart\nclass MyTabBar extends StatefulWidget {\n  const MyTabBar({super.key});\n\n  @override\n  State<MyTabBar> createState() => _MyTabBarState();\n}\n\nclass _MyTabBarState extends State<MyTabBar> {\n  int currentIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    const tabLength = 4;\n    return Container(\n      padding: const EdgeInsets.all(4),\n      color: const Color(0xFFE6E6E6),\n      child: Row(\n        children: [\n          for (int index = 0; index < tabLength; index++)\n            currentIndex == index\n                ? Container(\n                    padding: const EdgeInsets.all(8),\n                    color: const Color(0xFF510E59),\n                    child: Text(\n                      \"Selected Tab $index\",\n                      style: const TextStyle(color: Colors.white),\n                    ),\n                  )\n                : Expanded(\n                    child: GestureDetector(\n                      onTap: () => setState(() => currentIndex = index),\n                      child: Container(\n                        padding: const EdgeInsets.all(8),\n                        color: const Color(0xFFE6E6E6),\n                        child: Text(\"Tab $index\", textAlign: TextAlign.center),\n                      ),\n                    ),\n                  )\n        ],\n      ),\n    );\n  }\n}\n```\n\n這個版本相當簡單，當使用者選到某個 Tab 之後，被選到的 Tab 一瞬間就換了樣式。\n\n[https://dartpad.dev/?id=e2b032cb7cf8392af5a1f0ea4c4a11fb](https://dartpad.dev/?id=e2b032cb7cf8392af5a1f0ea4c4a11fb)\n\n[v1.mov](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/v1.mov)\n\n以迭代的方式完成功能，避免**一口氣花很多時間**完成最終版本。這有幾個好處，以 Tab Bar 的例子來說，我們用熟練的工具快速完成了一個非動畫版本的 Tab Bar，這時候其實最重要的功能已經完成，即便最後時間來不及直接上線的話，也不會造成功能有使用上的問題。\n\n在開發這個功能的過程中，筆者也是先完成到這邊，接著轉頭去完成其他部分的工作。等到其他更重要的工作完成的差不多之後，才又回頭來思考如何實現 Tab Bar 動畫，接著讓我們來看看怎麼完成吧。\n\n## 嘗試加上動畫\n\n當我們想加動畫時，我們除了使用 AnimationController 自定義之外，還有其他更簡單的方式。Flutter 內建提供許多好用的動畫 Widget，例如：[AnimatedSwitcher](https://api.flutter.dev/flutter/widgets/AnimatedSwitcher-class.html)、[AnimatedContainer](https://api.flutter.dev/flutter/widgets/AnimatedContainer-class.html) ……等。筆者最一開始也是打算在 Row 的基礎上加上 [AnimatedSize](https://api.flutter.dev/flutter/widgets/AnimatedSize-class.html) 來完成動畫的部分，但是天不從人願，代誌不是憨人想得那麼簡單，加上 AnimatedSize 沒有任何效果。\n\n```dart\nRow(\n  children: [\n    for (int index = 0; index < tabLength; index++)\n      currentIndex == index\n          ? AnimatedSize(\n              duration: const Duration(milliseconds: 300),\n              child: Container(\n                padding: const EdgeInsets.all(8),\n                color: const Color(0xFF510E59),\n                child: Text(\n                  \"Selected Tab $index\",\n                  style: const TextStyle(color: Colors.white),\n                ),\n              ),\n            )\n          : Expanded(\n              child: AnimatedSize(\n                duration: const Duration(milliseconds: 300),\n                child: GestureDetector(\n                  onTap: () => setState(() => currentIndex = index),\n                  child: Container(\n                    padding: const EdgeInsets.all(8),\n                    color: const Color(0xFFE6E6E6),\n                    child: Text(\n                      \"Tab $index\",\n                      textAlign: TextAlign.center,\n                    ),\n                  ),\n                ),\n              ),\n          )\n  ],\n)\n```\n\n但是我們若是再嘗試一下，加上 AnimatedSize 但拿掉 Expanded 的話，會發現其實 AnimatedSize 是有效果的，顯然是 Row 的某些機制造成了問題，~~關於為什麼沒有效果以後我們會做一期專門的影片逕行講解~~。但是我們也不能接受這個版本，因為我們需要沒被選取的 Tab 平均分配寬度。\n\n```dart\nRow(\n  children: [\n    for (int index = 0; index < tabLength; index++)\n      currentIndex == index\n          ? AnimatedSize(\n              duration: const Duration(milliseconds: 300),\n              child: Container(\n                padding: const EdgeInsets.all(8),\n                color: const Color(0xFF510E59),\n                child: Text(\n                  \"Selected Tab $index\",\n                  style: const TextStyle(color: Colors.white),\n                ),\n              ),\n            )\n          : AnimatedSize(\n              duration: const Duration(milliseconds: 300),\n              child: GestureDetector(\n                onTap: () => setState(() => currentIndex = index),\n                child: Container(\n                  padding: const EdgeInsets.all(8),\n                  color: const Color(0xFFE6E6E6),\n                  child: Text(\n                    \"Tab $index\",\n                    textAlign: TextAlign.center,\n                  ),\n                ),\n              ),\n            )\n  ],\n)\n```\n\n[v2.mov](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/v2.mov)\n\n[https://dartpad.dev/?id=3e6285459821b93834d6bdfbd1308827](https://dartpad.dev/?id=3e6285459821b93834d6bdfbd1308827)\n\n事情到了這邊，顯然我們無法使用 Row 完成這個 Tab Bar 設計了，那我們還有什麼辦法呢？有的，我們可以用 [CustomMultiChildLayout](https://api.flutter.dev/flutter/widgets/CustomMultiChildLayout-class.html) 自製一個簡單的 Row，一個為這個特殊的 Tab Bar 佈局而生的 Row。\n\n## 使用 CustomMultiChildLayout + AnimatedSize\n\n使用 CustomMultiChildLayout 方法並不複雜，CustomMultiChildLayout 有個 children 參數可以傳入複數個 Widget，這邊我們就傳入各個包有 AnimatedSize 的 Tab，並且用 LayoutId 這個 Widget 包住 Tab 並指定 id。指定 id 的目的是為了讓等等在排列佈局的時候可以取得相對應得子 Widget。\n\n```dart\nclass MyTabBar extends StatefulWidget {\n  const MyTabBar({super.key});\n\n  @override\n  State<MyTabBar> createState() => _MyTabBarState();\n}\n\nclass _MyTabBarState extends State<MyTabBar> {\n  int currentIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    const tabLength = 4;\n    return Container(\n      padding: const EdgeInsets.all(4),\n      color: const Color(0xFFE6E6E6),\n      child: CustomMultiChildLayout(\n        delegate: _MyTabBarLayoutDelegate(\n          selectedIndex: currentIndex,\n          length: tabLength,\n        ),\n        children: <Widget>[\n          for (int index = 0; index < tabLength; index++)\n            LayoutId(\n              id: index,\n              child: GestureDetector(\n                onTap: () => setState(() => currentIndex = index),\n                child: currentIndex == index\n                    ? AnimatedSize(\n                        duration: const Duration(milliseconds: 300),\n                        child: Text(\n                          \"Selected Tab $index\",\n                          style: const TextStyle(color: Colors.white),\n                        ),\n                      )\n                    : AnimatedSize(\n                        duration: const Duration(milliseconds: 300),\n                        child: Text(\"Tab $index\", textAlign: TextAlign.center),\n                      ),\n              ),\n            ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n接著我們需要實作 MultiChildLayoutDelegate 定義各個子 Widget 的位置，這邊就需要一些簡單的數學計算了。首先，我們要實作 performLayout(Size size) 方法，我們必須在這個方法中設定子 Widget 的大小與位置。雖說是設定子 Widget 的大小，實際上是告訴子 Widget 一個**大小限制**，也就是 Constraint。\n\n## 實作 MultiChildLayoutDelegate\n\n在 Flutter 框架設計中有句話：「[**Constraints go down. Size go up. Parent sets position.**](https://docs.flutter.dev/ui/layout/constraints)」，這句話充分體現了 Flutter 的排版的核心機制，而 performLayout 方法所要處理的就恰恰是這一句話，筆者曾在社群聊天時分享過一個例子：\n\n想像一下，假設今天公司要辦員工旅遊，福委想知道總共有多少員工與員工家屬要參加，這時福委就通知每個員工說：「每個人可以帶 0 ~ 3」個家屬，而這就是 Constraints go down。當員工回家問親戚朋友，最終得到總共幾人參加後，員工把這人數回報給福委，這就是 Size go up。最後福委就能根據回報的資訊得知總共有多少人，也就能安排每個員工與家屬的梯次、機票、車位等資訊，也就是 Parent sets position。\n\n讓我們來看點實際例子。\n\n還記得我們特殊 Tab Bar 的第一個要求嗎？\n\n**被選到 Tab 佔據他所需要的寬度，剩下的寬度由那些未被選到的 Tab 平均分配**\n\n若想完成這個需求，我們首先得先知道被選到 Tab 的寬度，在 performLayout 方法的第一行，我們就呼叫了 layoutChild 並帶入被選到的 Tab 的 id 與 Constraints，這個 Constrains 告訴了被選到的 Tab 最大可以到多大。\n\n```dart\nclass _MyTabBarLayoutDelegate extends MultiChildLayoutDelegate {\n  _MyTabBarLayoutDelegate({\n    required this.selectedIndex,\n    required this.length,\n  });\n\n  final int selectedIndex;\n  final int length;\n\n  @override\n  void performLayout(Size size) {\n    final selectedSize = layoutChild(\n        selectedIndex,\n        BoxConstraints(\n          maxWidth: size.width,\n          maxHeight: size.height,\n        ));\n\n    final otherChildWidth = (size.width - selectedSize.width) / (length - 1);\n    \n    double currentWidth = 0;\n    for (int index = 0; index < length; index++) {\n      if (index == selectedIndex) {\n        positionChild(index, Offset(currentWidth, 0));\n        currentWidth += selectedSize.width;\n      } else {\n        layoutChild(\n            index,\n            BoxConstraints(\n              minWidth: otherChildWidth,\n              maxWidth: otherChildWidth,\n              maxHeight: size.height,\n            ));\n        positionChild(index, Offset(currentWidth, 0));\n        currentWidth += otherChildWidth;\n      }\n    }\n  }\n\n  @override\n  bool shouldRelayout(_MyTabBarLayoutDelegate oldDelegate) {\n    return oldDelegate.selectedIndex != selectedIndex ||\n        oldDelegate.length != length;\n  }\n}\n```\n\n得到大小之後，我們就能計算出其他沒被選到的 Tab 應該要多大，並在 layoutChild 的時候嚴格指定其寬度（把 minWidth 與 maxWidth 設定為相同值）。\n\n最後我們知道每個子 Widget 大小為多少之後，我們就能準確的設定其座標。透過 positionChild 方法指定每個子 Widget 的位置，我們也就能完成特製的 Row 了。\n\n完成之後，我們測試一個就能看到切換 Tab 時，Tab 有伸縮的動畫了。\n\n[https://dartpad.dev/?id=52542730fde0265f1690f3b29f5b12c6](https://dartpad.dev/?id=52542730fde0265f1690f3b29f5b12c6)\n\n[v4.mov](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/v4.mov)\n\n最後我們還想讓 Tab 的背景顏色也有淡入淡出的動畫效果時，我們只要簡單的把 Container 修改為 AnimatedContainer 就好，我們就能看到變大變小的同時也有淡入淡出的效果了。\n\n[https://dartpad.dev/?id=e5d78a92bdf62adc25df2d580348c661](https://dartpad.dev/?id=e5d78a92bdf62adc25df2d580348c661)\n\n[v4.mov](%E8%87%AA%E8%A3%BD%20Flutter%20Tab%20Bar%20-%20%E4%BD%BF%E7%94%A8%20CustomMultiChildLayout/v4%201.mov)\n\n## 小結\n\n今天分享了如何在 Flutter 中自訂 Tab Bar 特效，透過分析 Tab Bar 的行為，我們展示如何逐步實現功能，包括使用 Row 和 Expanded 佈局，以及後續添加動畫效果。最終，採用 CustomMultiChildLayout 和 AnimatedSize 實現了一個符合設計需求的 Tab Bar，確保選中 Tab 的寬度動態變化，最後再加上 AnimatedContainer 實現背景顏色的淡入淡出效果。",
      "createdAt": "October 30, 2024 8:20 AM",
      "updatedAt": "October 26, 2025 9:38 PM",
      "id": "12f8303f78f7805baacbff6d139421f6",
      "type": "Medium",
      "tag": "Flutter",
      "filename": "自製 Flutter Tab Bar - 使用 CustomMultiChildLayout 12f8303f78f7805baacbff6d139421f6.md",
      "folderName": "自製 Flutter Tab Bar - 使用 CustomMultiChildLayout"
    },
    {
      "title": "如何讓 ListView 自動對齊",
      "summary": "在 Flutter 中，ListView 和 PageView 都是用於顯示多個元素的 Widget，使用者可以滑動瀏覽列表中的 Widget。如果單看功能性，ListView 和 PageView 可能沒太大區別。但是實際與其互動之後，就會發現他們在畫面上的表現還是有所不同。 使用 ListVie...",
      "content": "![glenn-carstens-peters-RLw-UC03Gwc-unsplash.jpg](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/glenn-carstens-peters-RLw-UC03Gwc-unsplash.jpg)\n\n在 Flutter 中，ListView 和 PageView 都是用於顯示多個元素的 Widget，使用者可以滑動瀏覽列表中的 Widget。如果單看功能性，ListView 和 PageView 可能沒太大區別。但是實際與其互動之後，就會發現他們在畫面上的表現還是有所不同。\n\n使用 ListView，使用者可以讓 ListView 停在列表中的任意位置，可以讓它停在某個元素的開頭，也可以停在某個元素一半的位置。而 PageView 就有點不同，雖然使用者一樣可以透過滑動來把 PageView 中的元素滑到任意位置，但是只要手一放開，PageView 就會自動的把元素歸位到正中央。\n\n![list_view.gif](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/list_view.gif)\n\n![page_view.gif](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/page_view.gif)\n\n大多數情況下，我們可以用 ListView 與 PageView 來完成功能。但是有些時候，我們也會需要客製化一些特別的行為，就像是今天要介紹的：用 ListView 來達到自動對齊的效果。\n\n# **建立 SnapListView**\n\n首先我們需要一個可以水平滑動的 ListView 並先命名為 SnapListView。\n\n```dart\nclass SnapListView extends StatelessWidget {\n  const SnapListView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    const itemExtent = 200.0;\n    return ListView.builder(\n      scrollDirection: Axis.horizontal,\n      itemBuilder: (context, index) => Container(\n        width: 200,\n        alignment: Alignment.center,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.black),\n        ),\n        child: Text('Item $index', style: const TextStyle(fontSize: 30)),\n      ),\n    );\n  }\n}\n```\n\n接下來我們要如何實現自動對齊的效果呢？答案就是修改 ListView 中的 physics 參數。physics 參數定義在 ListView 祖父類別 ScrollView 中，型別為 ScrollPhysics。\n\n```dart\nconst ScrollView({\n    super.key,\n    this.scrollDirection = Axis.vertical,\n    this.reverse = false,\n    this.controller,\n    this.primary,\n    ScrollPhysics? physics,\n    this.scrollBehavior,\n    this.shrinkWrap = false,\n    this.center,\n    this.anchor = 0.0,\n    this.cacheExtent,\n    this.semanticChildCount,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,\n    this.restorationId,\n    this.clipBehavior = Clip.hardEdge,\n  })\n\n```\n\n# **ScrollPhysics**\n\nFlutter 中原本就內建許多類別繼承自 ScrollPhysics ，例如：Android 預設的 ClampingScrollPhysics 或者是 iOS 預設 BouncingScrollPhysics 。這些 ScrollPhysics 可以套在很多可滑動的 Widget，例如：CustomeScrollView 或 GridView …等，套用不同的 ScrollPhysics 可在滑動的時候產生不同效果。\n\n雖然 Flutter 提供許多不同的 ScrollPhysics，但是這些內建的 ScrollPhysics 並不能幫助我們的目標：自動對齊第一個元素。所以我們需要自定義一個 ScrollPhysics 來幫助我們達到目的。\n\n# **建立 SnapScrollPhysics**\n\n讓我們新增一個 SnapScrollPhysics 類別，並繼承 ScrollPhysics 。我們傳入 itemExtent 來表明列表中每個元素的大小，用於計算模擬滑動的最終位置，畢竟使用者不會每次都停在相同位置，所以我們必須根據停止的位置與元素大小來計算最終位置。\n\n```dart\nclass SnapScrollPhysics extends ScrollPhysics {\n  final double itemExtent;\n\n  const SnapScrollPhysics({\n    required this.itemExtent,\n    super.parent,\n  });\n\n  @override\n  SnapScrollPhysics applyTo(ScrollPhysics? ancestor) {\n    return SnapScrollPhysics(\n      itemDimension: itemExtent,\n      parent: buildParent(ancestor),\n    );\n  }\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    return null;\n  }\n}\n```\n\n在 ScrollPhysics 中有許多方法可提供覆寫。而在這個需求中，我們需要覆寫 createBallisticSimulation ，這個方法可以回傳一個 Simulation，讓使用者手指放開時，讓程式依據回傳的 Simulation，自動的把列表滾到 Simulation 所設定的位置。\n\n值得一提的是，我們也需要覆寫 applyTo 方法，讓 ScrollView 在引入效果時，可以套用到我們定義的 SnapScrollPhysics 。雖然我們只在 ListView 中只傳入了 SnapScrollPhysics ，但是其實 Flutter 底層還會繼續套用其他的 ScrollPhysics ，讓 ListView 具有多種滑動效果。\n\n# **實現 createBallisticSimulation**\n\n首先，我們先處理一些例外狀況，當使用者滑超出列表範圍時，我們呼叫 super 的 createBallisticSimulation 的方法即可，讓其他 ScrollPhysics 來處理超出列表的行為。\n\n```dart\nclass SnapScrollPhysics extends ScrollPhysics {\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    if (position.pixels <= position.minScrollExtent ||\n        position.pixels >= position.maxScrollExtent) {\n      return super.createBallisticSimulation(position, velocity);\n    }\n\n    return null;\n  }\n}\n```\n\n接著我們透過 position.pixels 取得列表當前的位置，並使用 roundToDouble 四捨五入，來決定應該要自動移動到上一個元素或下一個元素。最後建立 ScrollSpringSimulation 並指定起始位置與目標位置，讓 Flutter 在使用者手放開之後，模擬使用者滑動，讓使用者體驗更好。\n\n```dart\n\nclass SnapScrollPhysics extends ScrollPhysics {\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    if (position.pixels <= position.minScrollExtent ||\n        position.pixels >= position.maxScrollExtent) {\n      return super.createBallisticSimulation(position, velocity);\n    }\n\n    double page = position.pixels / itemExtent;\n    double target = page.roundToDouble() * itemExtent;\n    if (target != position.pixels) {\n      return ScrollSpringSimulation(\n        spring,\n        position.pixels,\n        target,\n        velocity,\n      );\n    }\n    return null;\n  }\n}\n```\n\n但是當我們實際執行後，卻會發現用起來十分不順，原因是當使用者一放開手，Flutter 就會馬上開始模擬滑動，造成滑動不順暢。在真實滑動的過程中，使用者的手指是會頻繁地離開的手機螢幕，不會一直貼在螢幕上，所以我們必須在使用者手離開螢幕時，依據使用者滑動方向與速率來微調一下目標位置。\n\n```dart\nclass SnapScrollPhysics extends ScrollPhysics {\n\n  @override\n  Simulation? createBallisticSimulation(\n    ScrollMetrics position,\n    double velocity,\n  ) {\n    if (position.pixels <= position.minScrollExtent ||\n        position.pixels >= position.maxScrollExtent) {\n      return super.createBallisticSimulation(position, velocity);\n    }\n\n    double page = position.pixels / itemExtent;\n    \n    var tolerance = toleranceFor(position);\n    if (velocity < -tolerance.velocity) {\n      page -= 1;\n    } else if (velocity > tolerance.velocity) {\n      page += 1;\n    }\n\n    double target = page.roundToDouble() * itemExtent;\n    if (target != position.pixels) {\n      return ScrollSpringSimulation(\n        spring,\n        position.pixels,\n        target,\n        velocity,\n      );\n    }\n    return null;\n  }\n}\n```\n\n當發現使用者滑動的速率大於容忍值時，表示使用者想要快速滑動。所以我們必須依照使用者快速滑動的方向，創建一個往使用者滑動方向的滑動模擬，避免使用者手指一離開，列表就往反方向滑動。最後我們把完成的 SnapScrollingPhysics 放回 ListView 中，就能得到一個比較順暢的自動對齊效果。\n\n```dart\nclass SnapListView extends StatelessWidget {\n  const SnapListView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      scrollDirection: Axis.horizontal,\n      physics: const SnapScrollPhysics(itemExtent: 200.0),\n      itemCount: 10,\n      itemBuilder: (context, index) => Container(\n        width: 200,\n        alignment: Alignment.center,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.black),\n        ),\n        child: Text('Item $index', style: const TextStyle(fontSize: 30)),\n      ),\n    );\n  }\n}\n```\n\n![snap_list_view.gif](%E5%A6%82%E4%BD%95%E8%AE%93%20ListView%20%E8%87%AA%E5%8B%95%E5%B0%8D%E9%BD%8A/snap_list_view.gif)\n\n# **最後**\n\n雖然我們完成了自動對齊的效果，但其實程式碼還是有一些 Bug。例如：滑到最後一個元素時，列表不會像預期中的自動對齊，因為它採用了其他 ScrollPhysics 而非我們設定的 SnapScrollPhysics ，有興趣的觀眾可以嘗試修改看看。\n\n除此之外，ScrollPhysics 還有許多方法可以覆寫，讓開發人員可以調整許多滑動細節，有興趣的觀眾也可以也可以參考 [ScrollPhysics](https://api.flutter.dev/flutter/widgets/ScrollPhysics-class.html) 。",
      "createdAt": "May 2, 2024 1:08 AM",
      "updatedAt": "October 24, 2025 4:48 PM",
      "id": "c33fa8d2cae0490f8a7761e388b43224",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "如何讓 ListView 自動對齊 c33fa8d2cae0490f8a7761e388b43224.md",
      "folderName": "如何讓 ListView 自動對齊"
    },
    {
      "title": "減緩 PageView 動畫加上 Table 造成的卡頓",
      "summary": "最近我們新增了一個顯示球員詳細資訊的頁面，當我們完成第一版程式碼，開始調整細節時，我們發現了畫面滑動似乎不太順暢。 每個球員訊息彈跳視窗是靜態，外層使用了 PageView 加上一些的特效，使得畫面在滑動時會頻繁的 setState，造成了整個彈跳視窗卡頓，使用者體驗不佳，就像遊戲效能不好一樣會掉幀...",
      "content": "![mateus-campos-felipe-ebRHyE2u3X4-unsplash.jpg](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/mateus-campos-felipe-ebRHyE2u3X4-unsplash.jpg)\n\n最近我們新增了一個顯示球員詳細資訊的頁面，當我們完成第一版程式碼，開始調整細節時，我們發現了畫面滑動似乎不太順暢。\n\n![改善前_AdobeExpress.gif](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/%25E6%2594%25B9%25E5%2596%2584%25E5%2589%258D_AdobeExpress.gif)\n\n每個球員訊息彈跳視窗是靜態，外層使用了 PageView 加上一些的特效，使得畫面在滑動時會頻繁的 setState，造成了整個彈跳視窗卡頓，使用者體驗不佳，就像遊戲效能不好一樣會掉幀，嚴重一點可能會讓人不舒服。今天就來分享如何快速有效的解決這個問題吧。\n\n# 釐清問題\n\n首先，想要有效的解決問題，釐清問題是第一步。為了要了解我們畫面卡頓的問題根源，我們使用 Flutter 提供的 DevTools 並在實體手機上運行 Profile 模式，Profile 模式是讓 App 運行效能接近 Release 模式同時又能搜集運行資訊的一種模式。當我們執行程式並開起 DevTools 之後，可以觀察到 App 運行時，每一個 Frame 效能到底如何。\n\n### Dev tools\n\n在  Dev Tools 面板中，可以發現在大多數 Frame 中，UI phase 與 Raster phase 都花了很多時間，這通常表示問題可能有很多個，但是我們今天先研究 UI phase 花過久時間的問題吧。\n\n![Screen Shot 2023-07-03 at 1.23.37 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-03_at_1.23.37_PM.png)\n\n在面板中清楚看到了 Build 和 Layout 畫面的操作各花了多久時間，我們可以初步了解問題可能發生在哪邊，但是只有這些資訊，顯然不夠我們解決問題。\n\n### 啟用 Track Widget Builds\n\n為了更深入了解問題出在哪邊，我們可以在 Dev Tools 的右上角打開 Enhance Tracing，並且勾選 Track Widget Builds，這個功能可以提供更詳細的時間，提供每一個 Widget 在每一個 Frame 中所花費的時間。\n\n![Screen Shot 2023-07-03 at 1.36.51 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-03_at_1.36.51_PM.png)\n\n### 觀察 Widget Build 火焰圖\n\n當我們啟用 Track Widget Build 之後，我們再繼續操作一下手機，讓手機繼續執行幾個 Frame，我們就能這些新產生的報告找到 Timeline Events，在 Timeline Events 中， DevTools 顯示在這個 Frame 中 Build Widget 所花費的時間，能更直觀地看到時間到底花在哪個 Widget 上了。\n\n![Screen Shot 2023-07-03 at 1.24.21 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-03_at_1.24.21_PM.png)\n\n### 分析問題\n\n從火焰圖中我們可以得知，PlayerInfoGameLogView 花費的時間佔了很大一部份比例，而且每一個 Frame 都是這種狀況。這表示畫面滑動的時候，每一個 Frame 都在重新建立這個 Widget。雖然我們滑動需要頻繁的 setState，畫面其實是不變的，數值並不會在滑動過程中有變化，應該要可以使用重複使用之前已經 Build 好的 Widget，但是顯然 Flutter 不這麼認為，而是辛苦的每一個 Frame 都Rebuild 新的 Widget。\n\n# 解決問題\n\n為了更準確解決 PlayerInfoGameLogView 被頻繁建立的問題，也為了讓讀者們可以一起同樂，我們先在 Dartpad 準備有問題的範例程式 [[連結](https://dartpad.dev/?id=9bf6ba724ce6b3c62c9c490905b2fbbf)]，有興趣的讀者也可以試試看。讓我們看一下程式碼，在範例程式中，當我們滑動 PageView 時，PageView 頻繁的呼叫 itemBuilder 來更新畫面，讓 PageView 中的每一個 Item 可以隨著滑動改變大小，但是這麼做也使得 GameLogView 頻繁的被 Rebuild，即便每次傳進去的 gameLogs 是一模一樣的。\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key, required this.players});\n\n  final List<Player> players;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: PlayerPageView(\n        itemCount: players.length,\n        itemBuilder: (BuildContext context, int index) {\n          return Container(\n            padding: const EdgeInsets.symmetric(horizontal: 16),\n            alignment: Alignment.center,\n            child: GameLogView(gameLogs: players[index].gameLogs),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n讓我們看一下這段範例程式碼的效能分析，與正式程式碼的效能差不多，在 UI phase 階段所花的時間都偏高。\n\n![Screen Shot 2023-07-07 at 1.46.59 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-07_at_1.46.59_PM.png)\n\n### 只在資料變化時 Rebuild\n\n最終，我希望 Flutter 不要總是 Rebuild GameLogView，而達到這個目標，我們可以把 gameLogs 放在 Provider 中，然後需要使用 gameLogs 的地方呼叫 context.watch 去存取並監聽 gameLogs，這樣一來就能讓 Widget 不需要一層一層傳遞 gameLogs，最外層的 GameLogView 也就可以加上 const 修飾詞，讓 Flutter 知道這是一個固定的 Widget，避免 Flutter 總是 Rebuild 它。\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key, required this.players});\n\n  final List<Player> players;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: PlayerPageView(\n        itemCount: players.length,\n        itemBuilder: (BuildContext context, int index) {\n          return Container(\n            padding: const EdgeInsets.symmetric(horizontal: 16),\n            alignment: Alignment.center,\n            child: Provider<List<GameLog>>.value(\n              value: players[index].gameLogs,\n              child: const GameLogView(),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass _GameLogTable extends StatelessWidget {\n  const _GameLogTable();\n\n  @override\n  Widget build(BuildContext context) {\n    var gameLogs = context.watch<List<GameLog>>();\n    return Table(\n      ...\n    );\n  }\n}\n```\n\n當我們調整好程式碼之後，PageView 執行 setState 之後，GameLog 就不會 Rebuild，而是會重複使用已經建好的 Widget，有興趣的觀眾也可以在 GameLogView 的 build 方法印 log 觀察看看。最後讓我們看一下問題解決之後的範例程式碼的效能分析，在少數幾個 Frame 中，UI phase 花的時間是超時的，剩下大部分時間都是在標準以內。\n\n![Screen Shot 2023-07-07 at 1.44.26 PM.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/Screen_Shot_2023-07-07_at_1.44.26_PM.png)\n\n如果實際上運行解決後的範例程式之後 [[連結](https://dartpad.dev/?id=fdc0e92365fade89d5253647a4710b2d)]，可以發現滑動的過程中比較順了，但還是有一些時刻會感受到卡頓。\n\n### 尚未解決的卡頓\n\n當我們使用 Provider 提升效能之後，我們發現第一次 Build  GameLogView 的時候還是會超時，使得下一個 GameLog 顯示時，畫面會出現明顯卡頓。此時我們暫時沒有比較好的辦法可以解決問題，因為 Table 目前沒有提供 builder 的方法，當渲染比較大的 Table 時，所有欄位都會在第一時間被建立，無論他有沒有出現在畫面上，使得 UI phase 的時間還是會比較長，也就是我們上面效能分析所顯示的狀況。\n\n### 應用在產品程式碼中\n\n當我們把這個做法放回產品程式碼中，並再次檢測 App 效能，可以發現超時的 UI phase 大幅減少，更多的是超時的 Raster phase，這也表示我們方法有效這個畫面的效能。\n\n![調整後.png](%E6%B8%9B%E7%B7%A9%20PageView%20%E5%8B%95%E7%95%AB%E5%8A%A0%E4%B8%8A%20Table%20%E9%80%A0%E6%88%90%E7%9A%84%E5%8D%A1%E9%A0%93/%25E8%25AA%25BF%25E6%2595%25B4%25E5%25BE%258C.png)\n\n# 結論\n\n過早優化是萬惡之源，當我們發現效能問題時，透過釐清與分析問題，找到並解決瓶頸，在能花最小的力氣獲得最大的增益。如果我們再開發的時候為了使用 const 而寫了很多不必要的程式碼，除了浪費時間之外，也降低程式碼的可讀性，獲得的增益可能微乎其微。",
      "createdAt": "June 24, 2023 11:24 PM",
      "updatedAt": "October 24, 2025 5:20 PM",
      "id": "a05dbbc423404d19954fb69ebfee4496",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "減緩 PageView 動畫加上 Table 造成的卡頓 a05dbbc423404d19954fb69ebfee4496.md",
      "folderName": "減緩 PageView 動畫加上 Table 造成的卡頓"
    },
    {
      "title": "Flutter Theme 切換效果研究",
      "summary": "許多 App 都會支持 Light 模式與 Dark 模式，增加使用者體驗，為了做到這個功能，我們可以使用內建 Theme 加上 StatefulWidget 或其他狀態管理套件，就可以輕鬆完成 Light 模式與 Dark 模式。讓我們看看一個簡單的例子。 ```dart main() {   r...",
      "content": "![_fd765116-9712-4098-b0e3-e0cde699eff3.jpeg](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/_fd765116-9712-4098-b0e3-e0cde699eff3.jpeg)\n\n許多 App 都會支持 Light 模式與 Dark 模式，增加使用者體驗，為了做到這個功能，我們可以使用內建 Theme 加上 StatefulWidget 或其他狀態管理套件，就可以輕鬆完成 Light 模式與 Dark 模式。讓我們看看一個簡單的例子。\n\n## 簡單的切換主題\n\n```dart\nmain() {\n  runApp(const MainApp());\n}\n\nclass MainApp extends StatefulWidget {\n  const MainApp({super.key});\n\n  @override\n  State<MainApp> createState() => _MainAppState();\n}\n\nclass _MainAppState extends State<MainApp> {\n  bool isDark = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: isDark ? ThemeData.dark() : ThemeData.light(),\n      home: Scaffold(\n        body: const Center(\n          child: Text(\"Hello World\"),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: const Icon(Icons.refresh),\n          onPressed: () => setState(() => isDark = !isDark),\n        ),\n      ),\n    );\n  }\n}\n```\n\n我們在 StatefulWidget 中維護了 isDark 變數，當使用者按下左下角按鈕時，就會更新 isDark，並設定不同模式的 ThemeData 給 MaterialApp，藉此達到切換 Light / Dark 模式的效果，而在切換過程中，Flutter 也會幫我們用漸變的方式切換主題，而不是一瞬間就切換完成，增加視覺效果。\n\n![Discuss - Theme switch.jpg](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/Discuss_-_Theme_switch.jpg)\n\n## 自定義的 ThemeExtension\n\n有些時候，當我們的設計不是遵循 Material Design 的話，Flutter 提供的 Theme 就會不足以完成我們的需求，此時我們就會使用 ThemeExtension 的功能來擴充 Theme，讓整個 App 都可以使用一致的設計。下面是一段我們自定義的 ThemeExtension，其中除了自定義的顏色設計之外，我們還需要實作 copyWith 與 lerp 方法。\n\n```dart\nclass MyThemeExtension extends ThemeExtension<MyThemeExtension> {\n  final Color backgroundColor;\n\n  MyThemeExtension(this.backgroundColor);\n\n  @override\n  ThemeExtension<MyThemeExtension> copyWith() {\n    // TODO: implement copyWith\n    throw UnimplementedError();\n  }\n\n  @override\n  ThemeExtension<MyThemeExtension> lerp(covariant MyThemeExtension other, double t) {\n    // TODO: implement lerp\n    throw UnimplementedError();\n  }\n}\n```\n\n還記得剛剛提到的，切換 Light / Dark 模式時，Flutter 會用漸變的方式，讓畫面漸漸的從 Light 模式轉變為 Dark 模式 (其實動畫時間很短，一下次就轉換完成 XD)，為了讓自定義的 ThemeExtension 也能享受到這個效果，實作 lerp 方法就很重要了。lerp 方法會傳入要轉換的 Theme 與動畫時間，讓我們可以自行決定顏色在轉換過程中如何變化，在這邊我們簡單地使用 Color.lerp 來協助做線性轉換即可。\n\n```dart\n@override\nThemeExtension<MyThemeExtension> lerp(covariant MyThemeExtension other, double t) {\n  return MyThemeExtension(\n    Color.lerp(backgroundColor, other.backgroundColor, t)!,\n  );\n}\n```\n\n當我們實作了 lerp 方法之後，再次打開 App 切換 Light / Dark 模式，會發現我們自定義的顏色也能在切換過程中有平滑的視覺效果。\n\n![Discuss - Theme Switch 2.jpg](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/Discuss_-_Theme_Switch_2.jpg)\n\n完整效果請參考[這邊](https://dartpad.dev/?id=1264772a9ffa905f346a1d2c5a8c02a6)。\n\n## 更酷炫的切換動畫\n\n在研究 Light / Dark 模式切換的過程中，發現了很特別切換效果，詳細可以參考[這邊](https://stackoverflow.com/questions/60897816/how-to-add-animation-for-theme-switching-in-flutter)。當使用者切換模式時，畫面會由左上角開始轉換，並往右下角輻射，直到所有畫面都轉換完成，讓我們直接看看下面圖片。\n\n![螢幕錄影_2023-06-24_上午12_04_38_AdobeExpress.gif](Flutter%20Theme%20%E5%88%87%E6%8F%9B%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/%25E8%259E%25A2%25E5%25B9%2595%25E9%258C%2584%25E5%25BD%25B1_2023-06-24_%25E4%25B8%258A%25E5%258D%258812_04_38_AdobeExpress.gif)\n\n與 Flutter 預設的切換方式不同，這種切換方式更令人眼睛一亮，讓我們來看看這是如何做到的。其實要做到這個效果也並不複雜，主要原理是使用 Stack + ClipPath 來完成，簡單來說就是，先在 Stack 中疊上 Light 模式 Widget，然後再疊上被 ClipPath 裁切過的 Dark 模式 Widget，最後透過動畫來慢慢放大被裁切的 Dark 模式 Widget，最後填滿的畫面。如此一來，就能完成這個酷炫的 Light / Dark 模式切換效果。\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return AnimatedBuilder(\n    animation: _animationController,\n    builder: (BuildContext context, Widget? child) {\n      return Stack(\n        children: [\n          Theme(\n            data: _getTheme(widget.isDark),\n            child: widget.builder(context),\n          ),\n          ClipPath(\n            clipper: CircularClipper(\n              1.5 * MediaQuery.of(context).size.height * _animationController.value,\n              Offset.zero,\n            ),\n            child: Theme(\n              data: _getTheme(!widget.isDark),\n              child: widget.builder(context),\n            ),\n          ),\n        ],\n      );\n    },\n  );\n}\n```\n\n完整效果請參考[這邊](https://dartpad.dev/?id=883cd4304e8f0a032d5d3a3f87dced70)。\n\n## 小結\n\n為 App 增加一些轉場特效，像是我們今天分享的 Light / Dark 模式切換，或者是 Routing 時的 Transition 效果，都能有效增加使用者體驗，讓 App 看起來更加精緻。",
      "createdAt": "June 23, 2023 11:19 PM",
      "updatedAt": "October 24, 2025 5:20 PM",
      "id": "cfabe2e638ef4210bdc9660155dcdfa5",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Flutter Theme 切換效果研究 cfabe2e638ef4210bdc9660155dcdfa5.md",
      "folderName": "Flutter Theme 切換效果研究"
    },
    {
      "title": "用 Widget Test 測試 Routing",
      "summary": "在開發 Flutter 時，我們可以寫 Widget Test 確保功能在我們重構之後，還是保持正常運作。我們會針對許多不同的情境進行測試，其中一種情境是當使用者進行某些操作，或者當某些情況發生，把使用者導到其他頁面，今天就來分享如何使用 Widget Test 驗證 Routing。 假設我們有常...",
      "content": "![_206dd02c-3b32-4243-95a6-b8a7669e5acc.jpeg](%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%20Routing/_206dd02c-3b32-4243-95a6-b8a7669e5acc.jpeg)\n\n在開發 Flutter 時，我們可以寫 Widget Test 確保功能在我們重構之後，還是保持正常運作。我們會針對許多不同的情境進行測試，其中一種情境是當使用者進行某些操作，或者當某些情況發生，把使用者導到其他頁面，今天就來分享如何使用 Widget Test 驗證 Routing。\n\n## 舉個例子\n\n假設我們有常見的清單頁面，其中列滿了各種狗狗品種，當我們點擊了某一個品種之後，App 會把使用者導向另一個頁面，並向隨機呈現一張該品種的圖片。在這個例子中，我們使用 [DogAPI](https://dog.ceo/dog-api/)，有興趣的觀眾也可以參考看看。\n\n![Route 測試.jpg](%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%20Routing/Route_%25E6%25B8%25AC%25E8%25A9%25A6.jpg)\n\n這個需求並不複雜，經過一番操作之後，我們在相對應的 **ListTitle** 上加上 **GestureDetector** 並使用 **Navigator** 把使用者導到下一個頁面，也告訴下一個頁面要顯示哪種品種的狗狗，最後成功在畫面上隨機顯示一張該品種的狗狗圖片。\n\n```dart\nclass BreedListPage extends StatelessWidget {\n  \n\t...\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: breedList.length,\n      itemBuilder: (context, index) {\n        return GestureDetector(\n          onTap: () => Navigator.of(context).pushNamed(\n            \"/dog_image\",\n            arguments: breedList[index],\n          ),\n          child: ListTile(\n            title: Text(breedList[index]),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n但是當我們完成功能之後，可能會思考，我們該如何進行測試呢？我們該如何功能正確，並且在未來也都持續保持正確呢？\n\n## Arrange 與 Act\n\n對測試熟悉的觀眾，可能很快就能完成 Arrange 與 Act 的部分，關於測試 3A 原則可以參考[這邊](https://dotblogs.com.tw/hatelove/2012/11/07/learning-tdd-in-30-days-day3-how-to-write-a-unit-test-code)。在下面測試中，我們使用 [mocktail](https://pub.dev/packages/mocktail) 套件準備 DogAPI 的回傳結果，顯示 **BreedListPage**，接著我們點擊其中一個品種，一切都輕鬆寫意。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  MockClient mockClient = MockClient();\n  when(() => mockClient.get(Uri.parse(\"https://dog.ceo/api/breeds/list/all\"))).thenAnswer((_) async {\n    return Response('{\"message\": {\"affenpinscher\": [], \"african\": [], \"airedale\": []}, \"status\": \"success\"}', 200);\n  });\n\n  await tester.pumpWidget(\n    MaterialApp(\n      home: BreedListPage(client: mockClient)\n    ));\n  await tester.pump();\n\n\t// Act\n  await tester.tap(find.text(\"affenpinscher\"));\n\n  // How to assert routing?\n  \n});\n\nclass MockClient extends Mock implements Client {}\n```\n\n接下來的問題便是，我們如何驗證 Routing 是否成功呢？\n\n## Mock NavigatorObserver\n\n如果有使用過 [firebase_analytics](https://pub.dev/packages/firebase_analytics) 的觀眾，可能會知道可以使用套件中的 **FirebaseAnalyticsObserver** 協助我們追中使用 Routing 狀況，當 App 進行 Routing 時，會呼叫 [**NavigatorObserver.didPush](https://api.flutter.dev/flutter/widgets/NavigatorObserver/didPush.html)** 方法並透過參數告知當前 **Route** 與上一個 **Route**，此時 firebase_analytics 套件就有機會追蹤使用者的 Routing 行為。\n\n同樣地，我們也可以 mock 一個測試用的 **MockNavigatorObserver**，並驗證 didPush 方法是否有被呼叫，來達到驗證 Routing 的效果，那就讓我們使用 MockRoutingObserver 來驗證一下上述例子吧。\n\n在下面例子中，我們宣告了一個 **MockNavigatorObserver**，並把它傳給 **MaterialApp**，由此我們就能在測試中監聽 App Routing 的狀況。在 Assert 的地方中，我們使用驗證了 mockNavigatorObserver.didPush 是否有被呼叫，除此之外，我們還使用 captureAny() 來捕捉參數，驗證參數中的 **Route** 名稱是否符合預期。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\tMockNavigatorObserver mockNavigatorObserver = MockNavigatorObserver();\n  await tester.pumpWidget(\n    MaterialApp(\n      home: BreedListPage(client: mockClient),\n      navigatorObservers: [mockNavigatorObserver],\n   ));\n  await tester.pump();\n\n\t// Act\n  await tester.tap(find.text(\"affenpinscher\"));\n\n  // Assert\n  var result = verify(() => mockNavigatorObserver.didPush(captureAny(), any()));\n  expect(result.captured[1].settings.name, \"/dog_image\");\n});\n\nclass MockNavigatorObserver extends Mock implements NavigatorObserver {}\n```\n\n值得注意的是，在例子中我們使用了 captured[1] 來驗證，是因為在測試中，當我們在準備 BreedListPage 時，實際上也進行了一次 Routing，但這次 Routing 我們並不關心，我們關心的是第二次 Routing 結果，所以在上面例子中，我們驗證 captured[1] 的結果。\n\n## 找不到 Routing 錯誤\n\n當我們完成上面測試並運行後，會發現測試還是錯誤的，並在錯誤訊息中發現以下錯誤訊息。\n\n```\nCould not find a generator for route RouteSettings(\"/dog_image\", affenpinscher) in the _WidgetsAppState.\nMake sure your root app widget has provided a way to generate this route.\n```\n\n原因是我們在測試中沒有定義 /dog_image 這個 **Route**，所以當運行測試，程式走到 Navigator.of(context).pushNamed 時，就發生了錯誤。為了解決這個問題，我們只要在測試中給假的 **Route** 即可。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n  await tester.pumpWidget(\n    MaterialApp(\n      ...\n\t\t\troutes: {\"/dog_image\": (_) => const SizedBox()},\n   ));\n  await tester.pump();\n\n\t// Act\n  ...\n\n  // Assert\n\t...\n});\n```\n\n當我們加上假的 Route 之後，再次運行測試，就能通過測試得到綠燈了。\n\n## 除了驗證測試路徑之外\n\n在上面測試中，我們雖然成功驗證了 Routing 是否符合預期，但是其實還有一件事我們沒有驗證到，那就是我們少驗證了參數，我們除了把使用者導到下一個頁面之外，也會告訴下一個頁面要顯示哪一個品種的狗。在我們完成上面的測試之後，我們想再額外驗證參數其實就相對容易，我們只要加上另外一個 expect 即可。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\t// Act\n  ...\n\n  // Assert\n\tvar result = verify(() => mockNavigatorObserver.didPush(captureAny(), any()));\n  expect(result.captured[1].settings.name, DogImagePage.routeName);\n  expect(result.captured[1].settings.arguments, \"affenpinscher\");\n});\n```\n\n## 自定義 RouteMatcher\n\n當我們完成測試之後，除了重構一下程式碼之外，我們也必須重構一下測試，讓我們的測試保持簡單易懂，在驗證 Routing 的部分，我們可以自定義一個 RouteMatcher 來增加測試可讀性，讓我們不必每次都在測試中把 captured 挖出來一個一個檢查，那就讓我們來重構一下 Assert 的部分吧。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\t// Act\n  ...\n\n  // Assert\n\tverify(() => mockNavigatorObserver.didPush(\n\t  captureAny(\n\t    that: RouteMatcher(\n\t      routeName: \"/dog_image\",\n\t      arguments: \"affenpinscher\",\n\t    ),\n\t  ),\n\t  any(),\n\t));\n});\n\nclass RouteMatcher extends Matcher {\n  final String routeName;\n  final dynamic arguments;\n\n  RouteMatcher({required this.routeName, this.arguments});\n\n  @override\n  Description describe(Description description) {\n    return description.add('routeName: $routeName, arguments: $arguments');\n  }\n\n  @override\n  bool matches(item, Map matchState) {\n    return item.settings.name == routeName &&\n        item.settings.arguments == arguments;\n  }\n}\n```\n\n我們新增了一個 **RouteMatcher** 來協助比較 **Route** 是否符合預期，此後當我們閱讀 Routing 測試時，就能更直觀的在 Assert 中看到我們預期什麼路徑與參數，增加測試的可讀性，當然我們還可以利用**抽取方法**進一步的調整，讓測試真正變成容易閱讀的需求文件，像是下面程式碼那樣，這邊就不做過多贅述，~~關於這個問題，我們以後會做一集專門講解。~~\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n\t// Arrange\n  ...\n\n\t// Act\n  ...\n\n  // Assert\n\trouteShouldBe(routeName: \"/dog_image\", arguments: \"affenpinscher\");\n});\n```\n\n## 一定得使用 NavigatorObserver 嗎？\n\n除了使用 **NavigatorObserver** 來測試 Routing，其實也可以直接針對整個 App 測試，我們也就不用做假的 **Route** 與 **MockNavigatorObserver** 了，聽起來好像十分省事，對吧。讓我們簡單地改寫一下測試：\n\n1. 準備兩個頁面所必須使用的資料：狗狗品種清單與隨機一張狗狗圖片\n2. 顯示 **MainApp**，而不是 **BreedListPage**\n3. 按下其中一個品種\n4. 驗證 Image 所顯示的圖片是否符合預期。\n\n```dart\ntestWidgets('should open dog image page when click breed tile', (tester) async {\n  //Arrange\n  when(() => mockClient.get(Uri.parse(\"https://dog.ceo/api/breeds/list/all\"))).thenAnswer((_) async {\n    return Response( '{\"message\": {\"affenpinscher\": [], \"african\": [], \"airedale\": []}, \"status\": \"success\"}', 200);\n  });\n\n  when(() => mockClient.get(Uri.parse(\"https://dog.ceo/api/breed/african/images/random\"))).thenAnswer((_) async {\n    return Response( '{\"message\": \"https://images.dog.ceo/breeds/bulldog-boston/n02096585_355.jpg\", \"status\": \"success\"}', 200);\n  });\n\n  await tester.pumpWidget(MainApp(client: mockClient));\n  await tester.pump();\n\n  // Act\n  await tester.tap(find.text(\"african\"));\n  await tester.pumpAndSettle();\n\n  // Assert\n  expect(findNetworkImage(tester).url, \"https://images.dog.ceo/breeds/bulldog-boston/n02096585_355.jpg\");\n});\n\nNetworkImage findNetworkImage(WidgetTester tester) => tester.widget<Image>(find.byType(Image)).image as NetworkImage;\n```\n\n在上面例子中，測試看起來也更簡單俐落，也更貼近使用者的真實狀況，沒有 **MockNavigatorObserver** 好像看起來更好了。事實上，在這個例子中，也確實如此，使用 **MockNavigatorObserver** 反而增加了不必要的麻煩。\n\n但是在實務上，有時並非如此，當我們的 App 功能越來越多，越來越複雜時，若測試的進入點是整個  App，但是我們卻想測試某個頁面的行為，可能就得做很多準備工作，最後才能進到我們真正想測試的地方，雖然測試很貼近使用者的真實狀況，但同時也變得很難寫，變得脆弱。\n\n## 結論\n\n無論選擇使用 **MockNavigatorObserver** 協助測試，或是直接測試整個 App，我們應該依照當下情況調整，但是不管如何，我們都有義務為功能撰寫測試 ，這是開發人員必要工作之一，測試可以維護產品品質，也增加我們重構時的信心，更可以用來描述產品行為，讓後人可以透過測試案例來了解產品行為，是一石三鳥的好投資。\n\nP.S. 以上程式碼都只有片段，如果有興趣看更完整的 Demo 的觀眾，可以到[這邊](https://github.com/easylive1989/lovely_dog_app/tree/completed)。",
      "createdAt": "June 7, 2023 10:30 PM",
      "updatedAt": "October 24, 2025 5:20 PM",
      "id": "f610eefa549646aab96181e0d298a492",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "用 Widget Test 測試 Routing f610eefa549646aab96181e0d298a492.md",
      "folderName": "用 Widget Test 測試 Routing"
    },
    {
      "title": "如何處理善變的畫面",
      "summary": "開發客戶端程式時，有些時候後端傳過來的資料根據情況變化，畫面也有所不同。舉例來說，當使用者登入系統時，後端會根據使用者的權限等級傳送不同的資料，使畫面呈現出不同的功能和選項。另一個例子是，在我們的開發的遊戲中，顯示比賽列表的畫面，也會根據不同的場次型態，顯示不同的卡片樣式。 當回傳資料不一致時，會發...",
      "content": "![hal-gatewood-tZc3vjPCk-Q-unsplash.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/hal-gatewood-tZc3vjPCk-Q-unsplash.jpg)\n\n開發客戶端程式時，有些時候後端傳過來的資料根據情況變化，畫面也有所不同。舉例來說，當使用者登入系統時，後端會根據使用者的權限等級傳送不同的資料，使畫面呈現出不同的功能和選項。另一個例子是，在我們的開發的遊戲中，顯示比賽列表的畫面，也會根據不同的場次型態，顯示不同的卡片樣式。\n\n![Screenshot_1677384908.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677384908.jpg)\n\n![Screenshot_1677384904.png](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677384904.png)\n\n當回傳資料不一致時，會發生許多 if 判斷式散佈在各個地方，這就是所謂的 Shortgun Surgery 問題。換句話說，當你需要修改一個功能時，你需要在多個地方進行修改，這樣會導致代碼的耦合性增加，並且增加了代碼的維護成本。\n\n# 舉個例子\n\n在我們的遊戲中，後端會給前端每一場比賽資料，讓前端可以顯示比賽資訊。在下圖中，我們從後端接收了一個 Json 物件，然後把 Json 物件轉換成 Contest 物件，最後一路傳到 View，給 View 決定如何顯示畫面。\n\n![Discuss - Receive contest from server.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Receive_contest_from_server.jpg)\n\n在上面的例子中，不同的 Contest 型態，有不同的卡片樣式，當 Contest 的類型不同，後端可能也會根據不同的 Contest 而給前端不同資料，假設我們使用的強型別的語言，那我們到底要如何把不同的 Json 轉成同一個物件呢？\n\n# 萬能的 Value Object\n\n最簡單解決問題的方式，我們可以在 Contest 放上所有可能的出現的資料，View 則是根據自己的需要選擇相對應的欄位使用。以 Practice Contest View 來說，他只會使用 type 與 spots，但對 Non-Pratice Contest 來說，則是所有欄位都會使用。\n\n![Discuss - Omnipotent Value Object.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Omnipotent_Value_Object.jpg)\n\n### 優點\n\n- 容易使用\n\n### 缺點\n\n- 使用端依賴了他不需要的東西，違反介面隔離的原則，以 Practice Contest 來說，他並不需要 entryFee 與 maxPrizePool\n\n# 轉接器模式\n\n另一個例子是，在下面的畫面中，可以發現大部分的畫面樣式都相同，唯一不同的是球員的資訊，不同球類的球員，顯示不同的數值來展示球員的過去表現。以板球球員來說，我們使用 Batting 與 Bowling 表示球員綜合表現，以足球來說，則是使用 Points 表示。\n\n![Screenshot_1677250687.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677250687.jpg)\n\n![Screenshot_1677248725.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677248725.jpg)\n\n此時大部分的資料都是類似的，只有少部分關於球員表現的資料略微不同，我們可以使用**轉接器模式**，把後端傳回來的資料，轉換成另一種格式，讓畫面可以用一致的方式操作資料。\n\n![Discuss - Adapter for vo.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Adapter_for_vo.jpg)\n\n以球員表現的例子來説，我們可以把新增一個 Map，用以儲存每種球員數據的 Enum 與其數字，View 在使用時，就可以顯示 Map 中的所有數據即可，而無須關心到底是板球還是足球。\n\n### 優點\n\n- 畫面可以使用一致的邏輯處理資料\n\n### 缺點\n\n- 當資料差異畫過大時，難以整理成一種共用的格式\n\n# 策略模式\n\n在我們的遊戲中，我們有許多不同的廣告，有時是單純的一張圖，有時是比賽資訊，而後端則是根據不同情況傳回不同資料。與球員數據問題類似，我們都接收來自後端不大相同的資料，但不同的是，這些資料幾乎沒有共通性，我們難以使用轉接器模式整理出一致的格式。\n\n![Screenshot_1677251104.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677251104.jpg)\n\n![Screenshot_1677425946.png](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Screenshot_1677425946.png)\n\n為了解決這個問題，我們可以使用**策略模式**，提供一個包含 buildComponent 的方法的介面。當 AdView 從 Controller 取得 Ad 物件時，呼叫 Ad 物件身上的 buildComponent 方法取得顯示用的 Component。 當我們這樣做之後，View 再也無需關心現在到底是哪一種廣告，只需要呼叫 buildComponent 即可取得相對應的廣告畫面，並把它塞進畫面中即可。\n\n![Discuss - Strategy for vo.jpg](%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%96%84%E8%AE%8A%E7%9A%84%E7%95%AB%E9%9D%A2/Discuss_-_Strategy_for_vo.jpg)\n\n在 GeneralAd 與 ContestAd 中，它們會各自實現 buildComponent，提供該類型廣告的 Widget 給 View 顯示。\n\n### 優點\n\n- 畫面可以使用一致的邏輯處理資料\n\n### 缺點\n\n- Value Object 會認識 View\n\n# 結論\n\n由於客戶端畫面可能會相當多變，後端可能會給一個 type，不同 type 所包含的資料格式也大不相同，如何處理這個資料與畫面的關係也沒有標準答案，即便問題相似，但是在不同的 Context 之下，也適合不同的解法，只有根據當下情況選擇適當的做法，才能讓後續開發與維護更加順利。",
      "createdAt": "February 21, 2023 11:40 PM",
      "updatedAt": "October 24, 2025 4:48 PM",
      "id": "c87c61c7fc3541378813919fd3d19efa",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "如何處理善變的畫面 c87c61c7fc3541378813919fd3d19efa.md",
      "folderName": "如何處理善變的畫面"
    },
    {
      "title": "如何使用 Flame 開發一個小遊戲",
      "summary": "來到了 2023 年，今年就來學點不同的東西。本身興趣之一就是喜歡打電動，所以打從學寫程式以來，一直都有想自己寫遊戲的想法，但是一直都懶得去實現。自從學了 Flutter 之後，隱隱覺得 [Flutter](https://docs.flame-engine.org/1.4.0/index.html...",
      "content": "![carl-raw-m3hn2Kn5Bns-unsplash.jpg](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/carl-raw-m3hn2Kn5Bns-unsplash.jpg)\n\n來到了 2023 年，今年就來學點不同的東西。本身興趣之一就是喜歡打電動，所以打從學寫程式以來，一直都有想自己寫遊戲的想法，但是一直都懶得去實現。自從學了 Flutter 之後，隱隱覺得 [Flutter](https://docs.flame-engine.org/1.4.0/index.html) 的渲染模式其實跟遊戲十分相似，也從許多文章或影片中得知 Flame 這個基於 Flutter 的遊戲引擎，今天就來學學如何製作一個小遊戲吧 🕹️。\n\n## 引入 Flame\n\n當然第一步最重要的就是，把 flame 套件引入到我們的專案中\n\n```bash\nflutter pub add flame\n```\n\n當我們執行下面命令後，我們就能在 pubspec.yml 中發現多了 flame\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flame: ^1.5.0\n```\n\n## 使用 GameWidget\n\n開始使用 Flame 之後，第一個面對的 Widget 是 `GameWidget`，如同我們在 Flutter 中使用的各式各樣的 Widget，這個 `GameWidget` 也能直接被放在我們的 Flutter 程式中。GameWidget 有一個必要的參數：`Game`，可以想像成是整個遊戲最外層的 Component，有點類似於 Flutter 的 `MaterialApp`。\n\n```dart\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: GameWidget(\n        game: MyGame(),\n      ),\n    );\n  }\n}\n\nclass MyGame extends FlameGame {}\n```\n\n當我們執行上面這段程式碼後，會發現程式雖然可以執行，畫面卻是一片空白。這也是正常的，來為畫面加上一些東西吧。\n\n```dart\nclass MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    camera.zoom = 4;\n    await add(Knight(\n      position: size / 2,\n      anchor: Anchor.center,\n      size: Vector2(120, 80),e\n    ));\n  }\n}\n\nclass Knight extends PositionComponent {\n  Knight({super.position, super.size, super.anchor});\n\n  @override\n  Future<void> onLoad() async {\n    var animation = await SpriteAnimation.load(\n      \"knight_idle.png\",\n      SpriteAnimationData.sequenced(\n        amount: 10,\n        stepTime: 0.1,\n        textureSize: Vector2(120, 80),\n      ),\n    );\n    await add(SpriteAnimationComponent(\n      animation: animation,\n      size: size,\n    ));\n  }\n}\n```\n\n在上面我們中在 onLoad 中加入一個騎士的待機圖，當執行之後就會在畫面上看到騎士待機站立的遊戲畫面。\n\n![knight_idle.gif](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/knight_idle.gif)\n\n## 為騎士加上不同動作\n\n如果只有看著騎士在畫面上站著不動，這也不能算是個遊戲吧。為了讓他有點遊戲的感覺，我們可以加上一個行為：當點擊畫面，騎士就進行攻擊。\n\n為了讓騎士有更多動作，首先我們需要先修改一下動畫，使用 `SpriteAnimationGroupComponent` 針對不同行為，使用不同的動畫。透過設定 `SpriteAnimationGroupComponent` 的 current 變數，來決定當下要播放靜止站立的動畫，或攻擊的動畫。\n\n```dart\n@override\nFuture<void> onLoad() async {\n  var idleAnimation = await SpriteAnimation.load(\n    \"knight_idle.png\",\n    SpriteAnimationData.sequenced(\n      amount: 10,\n      stepTime: 0.1,\n      textureSize: Vector2(120, 80),\n    ),\n  );\n\n  var attackAnimation = await SpriteAnimation.load(\n    \"knight_attacking.png\",\n    SpriteAnimationData.sequenced(\n      amount: 10,\n      stepTime: 0.1,\n      textureSize: Vector2(120, 80),\n      loop: false,\n    ),\n  );\n\n  await add(_animations = SpriteAnimationGroupComponent<KnightBehavior>(\n    current: KnightBehavior.idle,\n    size: size,\n    animations: {\n      KnightBehavior.idle: idleAnimation,\n      KnightBehavior.attack: attackAnimation\n    },\n  ));\n}\n```\n\n![螢幕錄影_2023-01-02_上午10_27_10_AdobeExpress.gif](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/%25E8%259E%25A2%25E5%25B9%2595%25E9%258C%2584%25E5%25BD%25B1_2023-01-02_%25E4%25B8%258A%25E5%258D%258810_27_10_AdobeExpress.gif)\n\n## 新增點擊操作\n\n當我們的騎士可以支援多種不同的動作之後，下一步就是指定觸發條件了，讓程式知道什麼時候要播放靜止站立的動畫，什麼時候要播放攻擊動畫。當使用者點擊畫面時，騎士就播放攻擊動畫。為此，我們需要修改幾個地方，以收取點擊事件。\n\n- `MyGame` 加上 `HasTappableComponents`\n\n```dart\nclass MyGame extends FlameGame with HasTappableComponents {\n}\n```\n\n- `Knight` 加上 `TapCallbacks` 並覆寫 `onTapUp` 與 `containsLocalPoint`\n\n```dart\nclass Knight extends PositionComponent with TapCallbacks {\n\n  @override\n  Future<void> onLoad() async {}\n\n  @override\n  bool containsLocalPoint(Vector2 point) => true;\n\n  @override\n  void onTapUp(TapUpEvent event) {\n    _animations.current = KnightBehavior.attack;\n  }\n}\n```\n\n我們可以把點擊之後的行為放在 onTapUp 的方法中，指定 `SpriteAnimationGroupComponent` 的 current 變數為 KnightBehavior.attack，騎士就會在點擊之後，進入攻擊狀態。\n\n## 更進一步\n\n在我們新增點擊操作之後，我們可以紀錄騎士進行了幾次攻擊，並顯示在畫面上，變成一個簡單的點擊計數小遊戲，就像 Flutter 專案預設的 App 一樣。\n\n首先，我們在 `MyGame` 中加上 count 變數紀錄次數\n\n```dart\nclass MyGame extends FlameGame with HasTappableComponents {\n  int count = 0;\n}\n```\n\n然後在 `Knight` 加上 `HasGameRef<MyGame>` ，讓我們可以修改 `MyGame` 中的 counter\n\n```dart\nclass Knight extends PositionComponent with TapCallbacks, HasGameRef<MyGame> {\n\n  @override\n  void onTapUp(TapUpEvent event) {\n\t\tif (_animations.current == KnightBehavior.idle) {\n      _animations.current = KnightBehavior.attack;\n      gameRef.count++;\n    }\n  }\n  \n}\n```\n\n最後在 `MyGame` 的 onLoad 中加上一個 `Counter` 用來顯示次數。`Counter` 類似於 `Knight` 也是一個 Component，在 `Counter` 的 onLoad 中加上一個 `TextComponent` 顯示文字，並在複寫 update 方法，Flame 會在遊戲進行時，持續呼叫每個 Component 的 update 方法，讓我們可以更新 Component 的畫面，我們可以透過 update 方法持續更新最新計數了。\n\n```dart\nclass MyGame extends FlameGame with HasTappableComponents {\n  int count = 0;\n\n  @override\n  Future<void> onLoad() async {\n    camera.zoom = 4;\n    await add(Knight(\n      position: size / 2,\n      anchor: Anchor.center,\n      size: Vector2(120, 80),\n    ));\n    await add(Counter(\n      position: size / 2..sub(Vector2(0, 20)),\n      anchor: Anchor.center,\n    ));\n  }\n}\n\nclass Counter extends PositionComponent with HasGameRef<MyGame> {\n  Counter({super.position, super.size, super.anchor});\n\n  late TextComponent _text;\n\n  @override\n  Future<void> onLoad() async {\n    await add(_text = TextComponent(\n      anchor: anchor,\n      textRenderer: TextPaint(\n        style: const TextStyle(color: Colors.white, fontSize: 10),\n      ),\n    ));\n  }\n\n  @override\n  void update(double dt) {\n    _text.text = \"Knight has attacked ${gameRef.count} times\";\n  }\n}\n```\n\n![螢幕錄影_2023-01-02_上午10_57_43_AdobeExpress.gif](%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Flame%20%E9%96%8B%E7%99%BC%E4%B8%80%E5%80%8B%E5%B0%8F%E9%81%8A%E6%88%B2/%25E8%259E%25A2%25E5%25B9%2595%25E9%258C%2584%25E5%25BD%25B1_2023-01-02_%25E4%25B8%258A%25E5%258D%258810_57_43_AdobeExpress.gif)\n\n## 結論\n\nFlame 是基於 Flutter 框架之上的遊戲引擎，其中我們會碰到許多各式各樣的 Component，透過組合不同的 Component 完成各式各樣的遊戲效果，感覺有點像是在 Flutter 中組合各種不同的 Widget 來製作各式各樣的畫面。為了完成這個點擊小遊戲，我們使用了許多 Component，例如：`FlameGame` 、`SpriteAnimationGroupComponent`、`TextComponent` …等等，文章中的程式放在[這邊](https://github.com/easylive1989/knight_counter_demo)，有興趣的朋友也可以參考看看。",
      "createdAt": "January 1, 2023 11:37 AM",
      "updatedAt": "October 24, 2025 4:48 PM",
      "id": "ddaa1e706f2a4949a2bbd7d19e4d7674",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "如何使用 Flame 開發一個小遊戲 ddaa1e706f2a4949a2bbd7d19e4d7674.md",
      "folderName": "如何使用 Flame 開發一個小遊戲"
    },
    {
      "title": "用 Flutter Web 製作 Chrome Extension 待讀文章看板",
      "summary": "有一陣子沒寫文章了，趁著前陣子剛完成了[鐵人賽](https://ithelp.ithome.com.tw/users/20129825/ironman/4992)，趁著開始比較有空閒，就來更新一下最近學到的新東西XD。 在日常生活和工作中，每當看到一些不錯的文章，想要晚一點再看時，我們可以使用 N...",
      "content": "有一陣子沒寫文章了，趁著前陣子剛完成了[鐵人賽](https://ithelp.ithome.com.tw/users/20129825/ironman/4992)，趁著開始比較有空閒，就來更新一下最近學到的新東西XD。\n\n![wesley-tingey-snNHKZ-mGfE-unsplash.jpg](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/wesley-tingey-snNHKZ-mGfE-unsplash.jpg)\n\n在日常生活和工作中，每當看到一些不錯的文章，想要晚一點再看時，我們可以使用 Notion 官方推出的 Chrome Extension：[Notion Web Clipper](https://chrome.google.com/webstore/detail/notion-web-clipper/knheggckgoiihginacbkhaalnibhilkk)，快速的把文章儲存到 Notion 中的某個資料庫，等到有空閑的時間，我就能從資料庫中找到那篇想讀的文章。有時候，我們會記得回來看資料庫是否有未讀的文章，但更多是，在我們有空的時候，我們早就不記得資料庫中有一些文章正等著我們去讀，然後把這寶貴的空閒時間浪費掉了。\n\n# 難以維持習慣\n\n有時，我們學了新東西，一開始比較有熱情，可以讓新習慣維持一陣子。但是，有時候我們會忘記，有時候我們會懶惰，一次兩次的失敗，我們漸漸開始無心維持新習慣，最後就慢慢地回到舊的習慣。如同[最小阻力之路](https://www.books.com.tw/products/0010696380)中提到的，在大自然中，能量會往阻力最小的路線前進，這個道理也同樣適用於人。大多時候，我們所選做的決定，所選擇的方向，也都是自然而然地從阻力最小的方向去走。當我們嘗試建立新的習慣，總會帶來一些阻力，越是平常根本不做的事情，阻力越大，時間一長，我們自然而然的就會回到阻力最小的舊習慣。\n\n# 讓執行習慣毫不費勁\n\n那我們如何減小新習慣的阻力呢？我們可以運用[原子習慣](https://www.books.com.tw/products/0010822522)中提到的一個技巧：**習慣堆疊。**\n\n> 把新習慣放到每天已經習慣做的事情綁在一起。\n> \n\n於是我觀察我自己的原有的習慣，發現自己每天早上都一定會透過 Chrome 擴充功能的 [Google Mail Checker](https://chrome.google.com/webstore/detail/google-mail-checker/mihcahmgecmbnbcchbopgniflfhgnkff) 處理信件，並使用 [Feedly Notifier](https://chrome.google.com/webstore/detail/feedly-notifier/egikgfbhipinieabdmcpigejkaomgjgb) 看看自己訂閱的 RSS 有沒有什麼新文章。於是，我從商店中找找看是否有適用的擴充功能，看看有沒有像是 Mail Checker 一樣，可以顯示 Notion Daatabase 中還有多少待讀文章，但比較可惜的是大多擴充功能都是強化原本 Notion Web 版使用體驗。最後，我決定自己使用 Flutter Web 來做一個自用的 Chrome 擴充功能。\n\n# 建立 Chrome Extension\n\n之前我們透過 [Notion API 更新資料庫](https://easylive1989.medium.com/%E5%88%A9%E7%94%A8-notion-api-%E8%87%AA%E5%8B%95%E6%9B%B4%E6%96%B0%E6%AC%84%E4%BD%8D-318eac43008e?source=your_stories_page-------------------------------------)，這次也同樣需要使用 Notion API 來幫助我們取得待讀清單，再加上用 Flutter Web 建立 Chrome 擴充功能，把所有未讀文章放在擴充功能畫面上。\n\n首先我們得先建立一個 Flutter Project\n\n```bash\nflutter create notion_assistant\n```\n\n在 web 資料夾放入 manifest.json，和加上 index.html 取代原本檔案\n\n```bash\n{\n    \"name\": \"Notion Assistant\",\n    \"version\": \"0.1\",\n    \"manifest_version\": 2,\n    \"browser_action\" :{\n        \"default_popup\": \"index.html\",\n        \"default_icon\" : \"icons/Icon-192.png\"\n    },\n    \"icons\": {\n        \"16\": \"icons/Icon-192.png\"\n    }\n}\n```\n\n```html\n<html style=\"height: 300px; width: 300px\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Notion Assistant</title>\n</head>\n<body>\n<script src=\"main.dart.js\" type=\"application/javascript\"></script>\n</body>\n</html>\n```\n\n當我們用 flutter  build 出 web app 時，flutter 會把畫面的部分建成 main.dart.js，同時使用 —[web-renderer](https://docs.flutter.dev/development/platform-integration/web/renderers) 讓 flutter 用 html + css 來渲染畫面。\n\n```html\nflutter build web --web-renderer html\n```\n\n最後我們打開 Chrome 擴充功能設定 ( chrome://extensions )，從右上角開啟開發人員模式並載入未封裝項目，選擇 build/web 資料夾中的建置結果，我們就能在 Chrome 擴充功能中看到 Flutter 預設的 counter app。\n\n![截圖 2022-11-06 下午12.13.39.png](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/%25E6%2588%25AA%25E5%259C%2596_2022-11-06_%25E4%25B8%258B%25E5%258D%258812.13.39.png)\n\n此時，我們就能開始針對自己的需求製作畫面了擴充功能的畫面了，之後就是根據個人需求整畫面與 API 的使用了，以我自己來說，就是顯示待讀文章列表。\n\n![截圖 2022-11-06 上午10.42.04.png](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/%25E6%2588%25AA%25E5%259C%2596_2022-11-06_%25E4%25B8%258A%25E5%258D%258810.42.04.png)\n\n# 畫面以外的功能\n\n當我們只想知道還有多少未讀文章，每次都要點開擴充功能才能知道，不免有些麻煩，此時，我們可以使用 Chrome 擴充功能的 Background Job 幫我們定期呼叫 API，並更新 count 到 badge 上。第一步我們得先稍微修改一個 manifest.json，增加 background 的設定。\n\n```json\n{\n    \"background\": {\n        \"persistent\": true,\n        \"scripts\": [\"background.js\"]\n    },\n}\n```\n\n接下來我們就得想辦法產生 background.js 了。如果稍微會寫 Javascript 的朋友，這邊可以考慮根據自己的需求，直接使用 Javascript 實作 background.js。但是在這邊，讓我們嘗試用 Dart 來製作 background.js 吧，也因為同樣是使用 Dart ，所以我們可以共用製作畫面時 Dart 程式碼，讓我們省一點功夫。\n\n# 用 Dart 製作 background.js\n\nDart SDK 中，有提供[工具](https://dart.dev/tools/dart2js)讓我們能把 Dart 轉換成 Javascript，用這個工具我們就能先寫一份 background.dart，再透過他幫我轉成 Javascript。在 background.dart 中，import dart:js 之後，我們可以拿到 context，並用 context 呼叫到 [Chrome API](https://developer.chrome.com/docs/extensions/reference/browserAction/#badge)，並透過其設定 Badge 的上的文字與顏色。\n\n```bash\nimport 'dart:async';\nimport 'dart:js';\n\nvoid main() {\n  _setBadge(1);\n  Timer.periodic(const Duration(seconds: 300), (timer) async {\n    _setBadge(2);\n  });\n}\n\nvoid _setBadge(int count) {\n  var badgeText = JsObject.jsify({\"text\": \"$count\"});\n  var badgeBackgroundColor = JsObject.jsify({\"color\": \"#D00218\"});\n  context[\"chrome\"][\"browserAction\"].callMethod(\"setBadgeText\", [badgeText]);\n  context[\"chrome\"][\"browserAction\"].callMethod(\"setBadgeBackgroundColor\", [badgeBackgroundColor]);\n}\n```\n\n上面示範程式碼只有展示如何設定 Badge，實際則是需要根據自身需求，決定設定什麼文字到 Badge 上，我們這邊就不過多展示，有興趣有可以直接到 [https://github.com/easylive1989/notion_assistant](https://github.com/easylive1989/notion_assistant) 中查看。\n\n當寫完 background.dart 之後，最後在呼叫指令產生 background.js 即可。\n\n```bash\ndart compile js lib/background.dart -o background.js\n```\n\n最後我們就能成功的在 Chrome 擴充功能的圖示上看到 Badge 了。\n\n![截圖 2022-11-06 下午10.53.05.png](%E7%94%A8%20Flutter%20Web%20%E8%A3%BD%E4%BD%9C%20Chrome%20Extension%20%E5%BE%85%E8%AE%80%E6%96%87%E7%AB%A0%E7%9C%8B%E6%9D%BF/%25E6%2588%25AA%25E5%259C%2596_2022-11-06_%25E4%25B8%258B%25E5%258D%258810.53.05.png)\n\n# 結論\n\n當我們從書上或他人身上學到新的方法，通常無法直接的複製到自己身上，畢竟自身的環境或習慣與他人並不完全一樣。想要讓新方法融入自己的生活，必定得耐心思考與嘗試一番，經過不斷地調整與實驗，最終才能找到適合自己的工作方式，讓我們花費最少心力，把重要的注意力放在更重要的事情上。\n\n# 參考\n\n- Repository：[https://github.com/easylive1989/notion_assistant](https://github.com/easylive1989/notion_assistant)",
      "createdAt": "November 5, 2022 11:13 PM",
      "updatedAt": "October 24, 2025 5:20 PM",
      "id": "1baca95d3dd34180a74bc918af8f500c",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "用 Flutter Web 製作 Chrome Extension 待讀文章看板 1baca95d3dd34180a74bc918af8f500c.md",
      "folderName": "用 Flutter Web 製作 Chrome Extension 待讀文章看板"
    },
    {
      "title": "畫面莫名其妙地重 build 了",
      "summary": "Flutter 自帶各式各樣的 Widget，能透過改變 Widget 的參數，讓畫面符合開發者想要的設計。在大部分的時間裏，能有效減低開發者的開發時間。但是如果開發者使用方式不正確的話，往往會造成不預期的結果，今天就來分享一個問題。 假設我們有一個簡單的應用，總共有兩個頁面：第一個頁面會顯示一組隨...",
      "content": "![image.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/image.png)\n\nFlutter 自帶各式各樣的 Widget，能透過改變 Widget 的參數，讓畫面符合開發者想要的設計。在大部分的時間裏，能有效減低開發者的開發時間。但是如果開發者使用方式不正確的話，往往會造成不預期的結果，今天就來分享一個問題。\n\n## 舉個例子\n\n假設我們有一個簡單的應用，總共有兩個頁面：第一個頁面會顯示一組隨機繁體中文數字，然後使用者需要記下該數字，並且在第二頁輸入結果。Submit 之後，會在第一個頁面的底部顯示答案是否正確。\n\n![rebuild_by_media_query.drawio.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/rebuild_by_media_query.drawio.png)\n\n第一個頁面的程式碼\n\n```dart\nclass FirstPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    String randomNumber = _getRandomNumber();\n    return Scaffold(\n      body: Column(\n        children: [\n          Container(\n            alignment: Alignment.center,\n            height: MediaQuery.of(context).size.height * 0.6,\n            child: Text(\n              \"What's the number: ${NumberConvertor.toText(randomNumber)}\",\n            ),\n          ),\n          OutlinedButton(\n            child: const Text(\"Go to answer\"),\n            onPressed: () async {\n              var result = await Navigator.of(context).pushNamed(\"/second\");\n              ScaffoldMessenger.of(context).showSnackBar(SnackBar(\n                content: Text(\"Answer is ${result == randomNumber ? \"correct\" : \"wrong\"}\"),\n              ));\n            },\n          ),\n        ],\n      ),\n    );\n  }\n\n  String _getRandomNumber() {\n    return Random().nextInt(100).toString();\n  }\n}\n```\n\n第二個頁面的程式碼\n\n```dart\nclass SecondPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Container(\n          alignment: Alignment.center,\n          width: 300,\n          child: TextFormField(\n            keyboardType: TextInputType.number,\n            onFieldSubmitted: (text) => Navigator.of(context).pop(text),\n            decoration: const InputDecoration(\n              border: OutlineInputBorder(),\n              label: Text(\"Answer\"),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 發生了不預期狀況\n\n當使用者在第二個頁面填完答案回到第一頁面時，會發現雖然訊息顯示答案正確，但是原本的題目卻已經變成另外一組了\n\n![unknown_situation.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/unknown_situation.png)\n\n## 發生了什麼事\n\n如果我們 debug 了一下程式，就會發現一個神奇的狀況：當使用者在第二的頁面點開鍵盤時，第一個頁面就會重新 build 了一次，導致畫面又重新取了一次亂數，新的數字就出現在畫面上。\n\n![1654349336823.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/1654349336823.png)\n\n為什麼麼第二個頁面的動作會影響到第一個頁面呢？讓我們回到第一個頁面的程式碼，仔細觀察與實驗就會發現，是 MediaQuery.of(context) 在搞的鬼。\n\n```dart\nContainer(\n  alignment: Alignment.center,\n  height: MediaQuery.of(context).size.height * 0.6,\n  child: Text(\n    \"What's the number: ${NumberConvertor.toText(randomNumber)}\",\n  ),\n),\n```\n\n如果我們把 MediaQuery.of(context).size.height * 0.6 置換成固定值。\n\n```dart\nContainer(\n  alignment: Alignment.center,\n  height: 500,\n  child: Text(\n    \"What's the number: ${NumberConvertor.toText(randomNumber)}\",\n  ),\n),\n```\n\n當輸入答案回來之後，題目還是維持的原來的題目。\n\n![consistant_result.png](%E7%95%AB%E9%9D%A2%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%87%8D%20build%20%E4%BA%86/consistant_result.png)\n\n## MediaQuery.of(context) 做了什麼？\n\n如果我們查看 MediaQuery.of(context) 的原始碼，會發現其中有段 context.dependOnInheritedWidgetOfExtractType，如果再往裡面查，會發現這不過是 BuildContext 這個介面上的一個方法。\n\n```dart\nstatic MediaQueryData of(BuildContext context) {\n  assert(context != null);\n  assert(debugCheckHasMediaQuery(context));\n  return context.dependOnInheritedWidgetOfExactType<MediaQuery>()!.data;\n}\n```\n\n實作則需要找到 Element 這個類別。\n\n```dart\n@override\nT? dependOnInheritedWidgetOfExactType<T extends InheritedWidget>({Object? aspect}) {\n  assert(_debugCheckStateIsActiveForAncestorLookup());\n  final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T];\n  if (ancestor != null) {\n    return dependOnInheritedElement(ancestor, aspect: aspect) as T;\n  }\n  _hadUnsatisfiedDependencies = true;\n  return null;\n}\n\n@override\nInheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) {\n  assert(ancestor != null);\n  _dependencies ??= HashSet<InheritedElement>();\n  _dependencies!.add(ancestor);\n  ancestor.updateDependencies(this, aspect);\n  return ancestor.widget;\n}\n```\n\n當執行 dependOnInheritedWidgetOfExactType 時，會把 MediaQuery 的 InheritedElement 塞到 Element 身上的 _dependencies 中，同時也會呼叫 ancestor.updateDependencies，把自己也塞到 InheritedElement 的 _dependents 中。\n\n當 InheritedElement 發生改變時，就會呼叫身上的 notifyClients，從而更新所有的 dependents。\n\n```dart\n@override\nvoid notifyClients(InheritedWidget oldWidget) {\n  assert(_debugCheckOwnerBuildTargetExists('notifyClients'));\n  for (final Element dependent in _dependents.keys) {\n    assert(() {\n      // check that it really is our descendant\n      Element? ancestor = dependent._parent;\n      while (ancestor != this && ancestor != null)\n        ancestor = ancestor._parent;\n      return ancestor == this;\n    }());\n    // check that it really depends on us\n    assert(dependent._dependencies!.contains(this));\n    notifyDependent(oldWidget, dependent);\n  }\n}\n```\n\n回到例子上，也就是當第一個頁面呼叫 MediaQuery.of(context) 時，就已經向 MediaQuery 註冊了一個觀察者，當 MediaQuery 因為鍵盤的出現導致畫面高度發生改變時，第一頁面也就跟著一起重 build 了。\n\n## 如何解決問題\n\n回到我們的問題上，如何讓第一個頁面不要重 build 呢？以上面這個例子來看，目的只是想依照固定高度比例來設計畫面，可以簡單的使用 Column + Expanded 解決。\n\n## 小結\n\n我自己覺得 Flutter 把 Widget 設計得十分方便，讓使用者可以用比較少的程式碼就完成功能，但是其中比較困難的就是許多細節被隱藏在框架之中。像是一般情況下，我們幾乎不會碰到 InheritedWidget，更多的是直接使用他的衍生類別或 Wrapper，在這種情況下，我們就很難知道這行程式碼究竟會帶來什麼影響，進而造成一些不預期的狀況。除了明白如何使用框架，有時也需要深入理解框架做了什麼，才能更有效地使用框架。\n\n## 參考\n\n- 範例程式碼：[https://github.com/easylive1989/chinese_number_validator](https://github.com/easylive1989/chinese_number_validator)\n- Flutter framework.dart：[https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart)",
      "createdAt": "May 10, 2022 11:33 PM",
      "updatedAt": "October 24, 2025 5:21 PM",
      "id": "7073aa4ed07d42d8929752e25fbf71fa",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "畫面莫名其妙地重 build 了 7073aa4ed07d42d8929752e25fbf71fa.md",
      "folderName": "畫面莫名其妙地重 build 了"
    },
    {
      "title": "使用 Nested Navigation 簡化路由設計",
      "summary": "Flutter 習慣在最頂層的 MaterialApp 或 CupertinoApp 中統一定義整個 app 的路由管理。當我們把所有頁面的路由管理都放在最頂層時，就會讓它變得很長，不容易維護。或許應該適時思考，是否某些頁面的路由不應該被管理在最頂層。今天就來分享工作上遇到的一個情境，以及它存在什麼...",
      "content": "Flutter 習慣在最頂層的 MaterialApp 或 CupertinoApp 中統一定義整個 app 的路由管理。當我們把所有頁面的路由管理都放在最頂層時，就會讓它變得很長，不容易維護。或許應該適時思考，是否某些頁面的路由不應該被管理在最頂層。今天就來分享工作上遇到的一個情境，以及它存在什麼問題，而我們又是如何解決的。\n\n## 舉個例子\n\n假設我們需要實作一個搜尋附近裝置並傳輸檔案到該裝置的需求，一開始我們會搜尋附近裝置，完成之後，畫面會顯示可選擇的裝置清單給使用者進行選擇，當使用者完成選擇之後，畫面會列出檔案清單讓使用者選擇，當使用者選完檔案並按下 Transfer 按鈕後進行傳輸工作。當傳輸工作完成時，回到最一開始的頁面，並顯示 Transfer success 的訊息讓使用者知道。\n\n![nested navigation.drawio.png](%E4%BD%BF%E7%94%A8%20Nested%20Navigation%20%E7%B0%A1%E5%8C%96%E8%B7%AF%E7%94%B1%E8%A8%AD%E8%A8%88/nested_navigation.drawio.png)\n\n## 用 Top-Level Navigation 方式實作\n\n我們設計了三個頁面，分別是 SearchDevicesPage、SelectDevicePage 和 SelectFilePage，三個頁面的工作分別是搜尋裝置、讓使用者選擇裝置和 讓使用者選擇檔案，每個頁面都是定義在頂層的路由。為此，我們在路由管理中有了起始頁面 Home 與傳輸檔案所需要的三個頁面。\n\n```dart\nRoute _onGenerateRoute(RouteSettings routeSettings) {\n  if (routeSettings.name == HomePage.routeName) {\n    return MaterialPageRoute(builder: (BuildContext context) => const HomePage());\n  } else if (routeSettings.name == SearchDevicesPage.routeName) {\n    return MaterialPageRoute<TransferResult>(\n      builder: (BuildContext context) => const SearchDevicesPage(),\n      settings: routeSettings,\n    );\n  } else if (routeSettings.name == SelectDevicePage.routeName) {\n    return MaterialPageRoute<TransferResult>(\n      builder: (BuildContext context) => const SelectDevicePage(),\n      settings: routeSettings,\n    );\n  } else if (routeSettings.name == SelectFilePage.routeName) {\n    return MaterialPageRoute<TransferResult>(\n      builder: (BuildContext context) => const SelectFilePage(),\n      settings: routeSettings,\n    );\n  }\n  throw RouteNotFoundException(\"Need to implement ${routeSettings.name}\");\n}\n```\n\n當使用者在 Home 頁面中按下 + 按鈕，想要傳輸檔案時，程式會先打開 SearchDevicesPage 並開始搜尋附近的裝置。當搜尋完成並且使用者按下 Next 按鈕後，程式會開啟下一個頁面：SelectDevicePage，並把搜尋到的裝置清單傳給下一個頁面顯示。\n\n```dart\nFuture _openSelectDevicePage(BuildContext context, List<Device> devices) async {\n  Navigator.of(context).pushNamed(SelectDevicePage.routeName, arguments: devices);\n}\n```\n\n在 SelectDevicePage 中，畫面會顯示裝置清單。當使用者選擇任一裝置後按下 Next，程式就會開啟下一個頁面：SelectFilePage，並且把使用者選擇的裝置傳給它。\n\n```dart\nFuture _openSelectFilePage(BuildContext context) async {\n  Navigator.of(context).pushNamed(SelectFilePage.routeName, arguments: selectedDevice);\n}\n```\n\n當使用者來來到 SelectFilePage 時，畫面會顯示檔案清單。當使用者選擇任一檔案後按下 Next，程式會使用上一個頁面給的裝置與這個頁面選擇的檔案進行傳輸工作。當傳輸工作完成之後，把傳輸結果往回傳遞。\n\n```dart\nawait _transfer(selectedDevice, selectedFile!);\nNavigator.pop(context, TransferResult.success);\n```\n\n當 Navigator.pop 執行後，首先回到的是 SelectDevicePage 的 _openSelectDevicePage 方法中。我們需要修改這個方法，讓他可以取得從 SelectFilePage 得到傳輸的結果，並把他回傳給上一頁。\n\n```dart\nFuture _openSelectFilePage(BuildContext context) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(SelectFilePage.routeName, arguments: selectedDevice);\n  Navigator.pop(context, transferResult);\n}\n```\n\n同樣的 SearchDevicesPage 也需要進行修改，同樣的讓他可以把結果帶回給 HomePage。\n\n```dart\nFuture _openSelectDevicePage(BuildContext context, List<Device> devices) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(SelectDevicePage.routeName, arguments: devices);\n  Navigator.of(context).pop(transferResult);\n}\n```\n\n在 HomePage 中，當程式從 SearchDevicesPage 回來時，就可以取得傳輸檔案的結果，並決定畫面如何顯示。以下面程式碼來說，當傳輸成功時，我們會在畫面上顯示一個 Snackbar 訊息提示傳輸成功。\n\n```dart\nFuture _openSearchDevicePage(BuildContext context) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(SearchDevicesPage.routeName);\n  if (transferResult == TransferResult.success) {\n    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text(\"Transfer success\")));\n  }\n}\n```\n\n[完整程式碼](https://github.com/easylive1989/transfer_file/tree/pop_with_result)\n\n## 作法分析\n\n這種設計可能存在一些問題\n\n- 頁面會被強迫知道他不需要的資訊\n\n以上面的例子來說，SelectFilePage 本身的工作應該是讓使用者選擇檔案，但是他卻也同時必須儲存使用者選擇的裝置，只為了完成傳輸的工作。或許我們可以把傳輸的工作移到 HomePage，但是這樣一來，我們也會需要把使用者選擇的裝置和檔案往回傳，同樣的造成 SelectDevicePage 也需要知道檔案的資訊，兩種做法都無可避免的導致某些頁面知道他不需要知道的資訊。\n\n```dart\nFuture _openTransferFilePage(BuildContext context) async {\n  File? file = await Navigator.of(context).pushNamed<File>(SelectFilePage.routeName);\n  if (file != null) {\n    Navigator.pop(context, TransferAction(selectedDevice!, file));\n  }\n}\n```\n\n- 流程路徑上的每個頁面都需要知道如何處理結果\n\n在上面例子中，每個頁面都會需要接回 TransferFileResult，並在 Navigator.pop() 中往回帶，這也表示每個頁面都需要知道 TransferResult 的存在，以及決定如何處理它。但實際上只有 HomePage 是真正需要的人，決定這個結果的是 SelectFilePage，它跟 HomePage 隔了兩個頁面，導致中間的頁面需要幫忙傳遞它們不需要的資訊。 \n\n```dart\nTransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(...);\nNavigator.pop(context, transferResult);\n```\n\n這些問題容易導致這些頁面無法重複使用，假設今天多了一種需求：同樣的選擇 Device，同樣的選擇檔案，最後卻是要傳送檔案資訊的文字，而不是傳送檔案本身。如果依照原本的設計修改的話，就會變成需要把最後的行為抽成方法或類別，把他從第一個頁面一路往下一個頁面傳，直到最後一個頁面，但是這個傳遞參數跟中間過程的頁面的工作毫無關係，他只是為了最後一個頁面需要而幫忙傳遞，提高了頁面之間的耦合度。\n\n## 用 Nested Navigation 實作\n\n為了解決這個問題，我們使用 [Nest Navigation](https://docs.flutter.dev/cookbook/effects/nested-nav) 來處理，讓頁面只知道自己需要的訊息，並且輸出他工作後的結果，至於如何使用就讓使用方來決定。\n\n我們使用上面的例子進行修改，先創建一個 TransferFileFlow，並在其中使用 Navigator Widget，給定一個 GlobalKey 放進 Navigator 中，我們需要使用 GlobalKey 來進行 Nested Navigator 的頁面切換。\n\n```dart\nclass TransferFileFlow extends StatefulWidget {\n  static const String routeName = \"transfer-file-flow\";\n\n  const TransferFileFlow({Key? key}) : super(key: key);\n\n  @override\n  State<TransferFileFlow> createState() => _TransferFileFlowState();\n}\n\nclass _TransferFileFlowState extends State<TransferFileFlow> {\n  final GlobalKey<NavigatorState> _nestedNavigatorKey = GlobalKey<NavigatorState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Navigator(\n        key: _nestedNavigatorKey,\n        initialRoute: SearchDevicesPage.routeName,\n        onGenerateRoute: _onGenerateRoute,\n      ),\n    );\n  }\n}\n```\n\n在 Navigator 中傳入 _onGenerateRoute，定義 TransferFileFlow 各個頁面的路由與實際頁面的關係。並把相對應的 callback 傳入實際頁面中，讓每一個頁面完成工作時可以通知 TransferFileFlow，讓 TransferFileFlow 可以切換到下一個頁面。比如說 SelectDevicePage 就傳入了 _onDeviceSelected，當使用者選擇了任一裝置後，就會呼叫 _onDeviceSelected，而 TransferFileFlow 就進行流程的下一步了。\n\n```dart\nRoute _onGenerateRoute(RouteSettings routeSettings) {\n  if (routeSettings.name == SearchDevicesPage.routeName) {\n    return MaterialPageRoute(\n      builder: (BuildContext context) => SearchDevicesPage(\n        onBack: _onSearchDevicesPageClose,\n        onDevicesSearched: _onDevicesSearched,\n      ),\n    );\n  } else if (routeSettings.name == SelectDevicePage.routeName) {\n    return MaterialPageRoute(\n      builder: (BuildContext context) => SelectDevicePage(\n        searchedDevices: searchedDevices,\n        onDeviceSelected: _onDeviceSelected,\n      ),\n    );\n  } else if (routeSettings.name == SelectFilePage.routeName) {\n    return MaterialPageRoute(\n      builder: (BuildContext context) => SelectFilePage(\n        onFileSelected: _onFileSelected,\n      ),\n    );\n  }\n  throw RouteNotFoundException(\"Need to implement ${routeSettings.name}\");\n}\n```\n\n在每個 callback 中，TransferFileFlow 接收每一個頁面的輸出，並暫存在自己身上。在最後一個頁面完成之後，就進行傳輸檔案的動作。\n\n```dart\nvoid _onDevicesSearched(List<Device> devices) {\n  searchedDevices = devices;\n  _nestedNavigatorKey.currentState?.pushNamed(SelectDevicePage.routeName);\n}\n\nvoid _onDeviceSelected(Device device) {\n  selectedDevice = device;\n  _nestedNavigatorKey.currentState?.pushNamed(SelectFilePage.routeName);\n}\n\nFuture _onFileSelected(File file) async {\n  selectedFile = file;\n  await _transfer(selectedDevice, selectedFile);\n  Navigator.of(context).pop(TransferResult.success);\n}\n```\n\n當整個 TransferFileFlow 的流程完成之後，TransferFileFlow 就會回傳 TransferResult 給 HomePage。中間也不存在任何頁面幫忙傳遞結果，而是 TransferFileFlow 送出結果，HomePage 下一秒收到後就馬上使用。\n\n```dart\nFuture _openTransferFileFlow(BuildContext context) async {\n  TransferResult? transferResult = await Navigator.of(context).pushNamed<TransferResult>(TransferFileFlow.routeName);\n  if (transferResult != null) {\n    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text(\"Transfer success\")));\n  }\n}\n```\n\n至於原本頂層路由管理就會只剩下 HomePage 與 TransferFlow，也會變得簡單一些。\n\n```dart\nRoute _onGenerateRoute(RouteSettings routeSettings) {\n  if (routeSettings.name == HomePage.routeName) {\n    return MaterialPageRoute(builder: (BuildContext context) => const HomePage());\n  } else if (routeSettings.name == TransferFileFlow.routeName) {\n    return MaterialPageRoute<TransferResult>(builder: (BuildContext context) => const TransferFileFlow());\n  }\n  throw RouteNotFoundException(\"Need to implement ${routeSettings.name}\");\n}\n```\n\n[完整程式碼](https://github.com/easylive1989/transfer_file/tree/nested_navigator)\n\n## 作法分析\n\n- 傳遞給頁面的參數恰好是頁面所需要的\n\n使用 Nested Navigation，把控制流程的的工作轉交給 TransferFileFlow，由 TransferFileFlow 把頁面需要的參數直接傳給它，頁面再也不需要幫忙傳遞任何參數。以上面的例子來說，我們再也不需要把使用者選擇的 Device 傳給 SelectFilePage 了，讓 SelectDevicePage 處理完之後傳給 TransferFileFlow，SelectFilePage 只要專注地處理使用者選擇的 File，並把使用者選擇的 File 傳給 TransferFileFlow，最後由 TransferFileFlow 組合資訊並完成工作。\n\n- 頁面無須處理與流程相關的邏輯\n\n頁面做完工作之後，也只需要專注的輸出結果給 Flow，由 Flow 來蒐集必要資訊，用以完成傳輸工作，並決定傳輸結果。當今天多了另一個類似需求，我們就可以創建另一個 Flow，該 Flow 可以根據需求來組合需要的頁面，最後再進行不同的操作，讓頁面不會因為與前後頁面之間的耦合導致難以重複使用。\n\n## 結論\n\nNested Navigation 十分適合使用在這種固定流程的工作上，如果頁面沒辦法單獨提供功能，而是需要多個頁面共同組合出一個功能的話，就很適合使用 Nested Navigation 這種做法。當一個頁面能提供完整的功能，例如顯示比賽資訊，顯示裝置詳細資訊，或者是更新使用暱稱這種單一頁面就可以完成的，或許就不太需要特別使用 Nested Navigation。\n\n## 參考\n\n- [https://docs.flutter.dev/cookbook/effects/nested-nav](https://docs.flutter.dev/cookbook/effects/nested-nav)",
      "createdAt": "April 23, 2022 10:41 AM",
      "updatedAt": "October 24, 2025 4:50 PM",
      "id": "b715b9e2fdc541bca3d6d234664eda2d",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "使用 Nested Navigation 簡化路由設計 b715b9e2fdc541bca3d6d234664eda2d.md",
      "folderName": "使用 Nested Navigation 簡化路由設計"
    },
    {
      "title": "深入瞭解 GetX 的 Obx 與 Rx",
      "summary": "最近在做畫面時，滿常使用 GetX 的 Obx + Rx 變數，讓畫面可以根據狀態變化即時更新。過程中有時會碰到一些錯誤，在建置 Widget 的過程中，因為 Obx 找不到可以被監聽的目標，導致 Obx 認為使用者錯誤的使用了 Obx，所以透過 Exception 來提醒使用者。 Obx 的使用方...",
      "content": "![image.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/image.png)\n\n最近在做畫面時，滿常使用 GetX 的 Obx + Rx 變數，讓畫面可以根據狀態變化即時更新。過程中有時會碰到一些錯誤，在建置 Widget 的過程中，因為 Obx 找不到可以被監聽的目標，導致 Obx 認為使用者錯誤的使用了 Obx，所以透過 Exception 來提醒使用者。\n\n![截圖 2021-12-16 下午9.58.38.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%889.58.38.png)\n\nObx 的使用方法是把一個 builder 方法傳給 Obx 這個 Widget，不需要任何 Rx 變數做為參數。像是下面的這個簡單的 count 例子中，Obx 傳入一個 builder 方法，只要 builder 在建置 Widget 的過程中使用 Rx 變數，Obx 就能進行監聽。\n\n![截圖 2021-12-16 下午11.33.43.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.33.43.png)\n\n這就讓我自己十分好奇，Obx 到底是如何找到 builder 方法中的 Rx 變數，然後對這個 Rx 變數進行監聽呢？自己花了一些時間研究和實驗，今天就來分享一下，到底 GetX 中的 Obx 是如何完成他的工作的。\n\n## 兩位主角\n\n在  Counter 例子中，有兩個重要的物件，一個是 Obx，另一個則是存放 count 的 Rx 變數。其中 Obx 身上有一個型態為 RxNotifier 的 _observer 變數，主要用來監聽 Rx 變數並更新畫面的。而存放 count 的 Rx 變數的爺爺也是 RxNotifier。\n\n![3.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/3.png)\n\nRxNotifier 本身沒有任何實作，實作都是集中 NotifyManager 這個 mixin 身上。NotifyManger 身上主要有兩個方法 \n\n1. addListener：用來決定監聽什麼事件\n2. listen：用來決定監聽到事件後，要做什麼事\n\n## Obx 如何更新畫面\n\n當開始 build GetCountView 的畫面並 build 到 Obx 時，程式會先執行 ObxWidget initState() 方法。在 initState() 中執行 _observer.listen，並傳入 _updateTree，讓 _observer 監聽到事件時，可以呼叫 setState 更新畫面。\n\n![截圖 2021-12-20 上午12.57.02.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-20_%E4%B8%8A%E5%8D%8812.57.02.png)\n\n再來程式會走進 ObxWidget 的 build 方法。可以發現 ObxWidget 的 build 方法也就只是轉頭呼叫 RxInterface 的 notifyChildren 靜態方法，並傳入 ObxWidget 身上的 _observer 和 [widget.build](http://widget.build) 。\n\n![截圖 2021-12-16 下午11.36.31.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.36.31.png)\n\n此時的 widget.build 也就是我們在 GetCountView 中傳給 Obx 的那段印出 count 的 builder。\n\n![截圖 2021-12-16 下午11.34.41.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.34.41.png)\n\n當我們在深入 RxInterface.notifyChildren 之後，可以發現在程式會把 ObxWidget 身上的 _observer 塞到一個全域變數 RxInterface.proxy 中。然後繼續執行 builder 並 build 出顯示 count 數的 Text Widget。最後把 RxInterface.proxy 還原成原本的值，然後就回傳結果了。\n\n![截圖 2021-12-16 下午11.21.26.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.21.26.png)\n\n看到這邊好像還是不知道 Obx 到底是如何發現 builder 之中的 RxInt 的，我們只有看到 _observer 被賦予了他要觸發 setState 的工作，但是 _observer 是如何監聽 count 事件呢？\n\n## 在 Getter 中註冊監聽\n\n其實關鍵就在 builder 中。我們回頭看一下使用 Obx 那段程式碼，Text 中使用了 count.value，而關鍵就在這個 value getter 中。\n\n![截圖 2021-12-16 下午11.34.41.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.34.41.png)\n\n讓我們深入看一下 value 這個 getter 是如何被實作的。\n\n![截圖 2021-12-16 下午11.41.09.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/%E6%88%AA%E5%9C%96_2021-12-16_%E4%B8%8B%E5%8D%8811.41.09.png)\n\n在使用 value getter 時，程式會向 RxInterface.proxy 這個全域變數註冊一個 subject，還記得先前 RxInterface.notifyChildren 做了什麼嗎，它把 ObxWidget 身上的 _observer 塞給 RxInterface.proxy，此時 value getter 中用的對象就是 ObxWidget 身上的 _observer。最後，當 value 發生變化時， Rx 變數就會透過 subject 通知 _observer。\n\n簡單來說，Obx 與 Rx 變數是透過 RxInterface 這個全域變數作為橋樑，讓兩者可以在 build 的時候建立觀察者模式。當 Rx 變數透過 value setter 賦值時，就能成功通知 ObxWidget 身上的 _observer，_observer 接收到事件之後就觸發 setState()，讓畫面根據新的狀態更新。\n\n## 整理流程\n\n1. GetCounterView 開始建置，隨後呼叫 ObxWidget 的 build 方法\n2. ObxＷidget 的 build 方法被呼叫後，轉頭直接把工作轉交給 RxInterface.notifyChildren，並且傳入 _observer 與 builder\n3. RxInterface 先是把 _observer 放進 RxInterface.proxy 中\n4. RxInterface.notifyChildren 呼叫 builder，建置 builder 中的 Widget\n5. builder 在建置的過程中會使用 count 這個 Rx 變數取得 count 值\n6. 取得 count 值過程中，Rx 也會呼叫 RxInterface.proxy?.addListener，讓 _observer 可以監聽\n\n![GetX 研究.drawio.png](%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3%20GetX%20%E7%9A%84%20Obx%20%E8%88%87%20Rx/GetX_%E7%A0%94%E7%A9%B6.drawio.png)\n\nps. 實際上並不是由 GetCountView 直接呼叫 [ObxWidget.build](http://Obx.build) 的，這邊只是簡化一下呼叫流程。實際上是由 GetCountView 的 Element 去呼叫的。\n\n## 小結\n\nGetX 作為熱門的 Flutter 狀態管理套件之一，有許多容易使用的 API，其中也大量的使用全域變數 。使用的時候還需要多加考慮一下，用得太多容易導致產品程式碼與套件緊緊相依，不只測試難寫，想抽換狀態管理的套件也會十分麻煩，使用的時候需要多多思考。",
      "createdAt": "December 12, 2021 9:41 PM",
      "updatedAt": "October 24, 2025 5:21 PM",
      "id": "9b167e815ad042cb85b02e7d3639e782",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "深入瞭解 GetX 的 Obx 與 Rx 9b167e815ad042cb85b02e7d3639e782.md",
      "folderName": "深入瞭解 GetX 的 Obx 與 Rx"
    },
    {
      "title": "在 Flutter App 中整合 Google play In-App-Billing",
      "summary": "想在 App 上賺錢有兩種方式，一種是讓 App 本身是付費下載，另一種則是應用程式內購買。如果選擇應用程式內購買的話，在 iOS 上需要整合 Apple In App Purchase，而在 Google Play 上的話，則是需要整合 Google In App Billing，以下簡稱 Goo...",
      "content": "想在 App 上賺錢有兩種方式，一種是讓 App 本身是付費下載，另一種則是應用程式內購買。如果選擇應用程式內購買的話，在 iOS 上需要整合 Apple In App Purchase，而在 Google Play 上的話，則是需要整合 Google In App Billing，以下簡稱 Google IAB，本篇主要紀錄一下整合 Google IAB 的過程。\n\n# 後台設定\n\n在開始整合 Google IAB 之前，需要先準備一個 Google 開發者帳號。當準備好之後，就能使用該開發者帳號登入 Google Play Console ，進入到**應用程式內產品**的的選單中，點選建立產品，然後就可以新增可購買項目。設定完成後並啟用產品，表示這個產品已經上架販售。\n\n![截圖 2021-11-18 上午12.01.53.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-18_%E4%B8%8A%E5%8D%8812.01.53.png)\n\n當購買項目設定完成後，重新整理該頁面就會看到剛剛設定好的購買項目的列表。其中的產品 ID 是表示該購買項目的唯一 ID，稍後也會在程式碼使用中，用以獲取購買項目的詳細資訊。\n\n![截圖 2021-11-18 上午12.05.52.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-18_%E4%B8%8A%E5%8D%8812.05.52.png)\n\n值得注意的是，在設定購買項目之前，需要先上傳包含內購權限的 apk 到 Google Play 上。沒有完成這一步，在設定購買項目的頁面出會發現下面這個訊息，Google Play 提醒你需要上傳有內購權限的 apk。若是 App 還沒有準備要上架，可以先上傳 apk 到內部測試群組。\n\n![截圖 2021-11-17 上午8.47.18.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-17_%E4%B8%8A%E5%8D%888.47.18.png)\n\n除了自己手動到 Google Play 的後台去設定產品，開發人員也可以透過 [Google In App Products API](https://developers.google.com/android-publisher/api-ref/rest/v3/inappproducts) 對產品列表做新增修改刪除，方便開發者客製化自己的後台產品上架流程。\n\n# 整合 Google Play In App Billing\n\n### 安裝套件\n\n在 pub.dev 上，與應用程式內購買的相關的套件有不少，我們選擇使用 Flutter 官方提供的 in_app_purchase。這個套件除了可以用來整合 Google IAB，也同時包含了 Apple IAP。\n\n[**in_app_purchase | Flutter Package***A storefront-independent API for purchases in Flutter apps. This plugin supports in-app purchases ( IAP) through an…*pub.dev](https://pub.dev/packages/in_app_purchase)\n\nin_app_purchase 在 Google IAB 功能實作是基於 Android BillingClient。所以在整合的時候，可以適時參考 [整合 Android BillingClient](https://developer.android.com/google/play/billing/integrate) 的文章，有助於更了解 Google IAB 的核心流程。\n\n### 啟用 PendingPurchase\n\n在 2019 年的 Google I/O 上，Google 宣布 Google Play 將提供 Pending Transactions 功能，讓使用者擁有更多樣的付款方式。在整合 Google IAB 時，我們需要在 main 方法中加上 enablePendingPurchase 的程式碼，讓 App 支援 Pending Transactions 功能。\n\n```dart\nvoid main() {\n  if (defaultTargetPlatform == TargetPlatform.android) {\n    InAppPurchaseAndroidPlatformAddition.enablePendingPurchases();\n  }\n  runApp(MyApp());\n}\n```\n\n### 確保與 Google Play 正常連線\n\nApp 透過這個 API 來確保與 Google Play 正常連線。當手機上沒有 Google Play 或者 Google Play 尚未登入之類的情況，這個 API 回傳的就會是 false。而回傳 false 時，App 也就無法正常購買產品，甚至連產品列表都無法獲得。\n\n```dart\nawait InAppPurchase.instance.isAvailable();\n```\n\n### 獲取產品列表\n\n透過這個 API，App 可以獲取產品的詳細資訊，像是價格與貨幣資訊 ...等。其中需要把產品 ID 列表做為參數傳給這個 API，這個產品 ID 列表需要與 Google Play Console 中設定的一致。取得的回傳值 ProductDetails 也會是稍後購買產品 API 的參數。\n\n```dart\nvar productIds = [\"prodcut_1\", \"product_2\"];\nProductDetailsResponse response =\n    await InAppPurchase.instance.queryProductDetails(productIds);\nif (response.notFoundIDs.isNotEmpty) {\n  // Handle the error.\n}\nList<ProductDetails> products = response.productDetails;\n```\n\n### 購買產品\n\nin_app_purchase 套件提供兩個 API 讓開發者實現購買功能： buyConsumable 和 buyNonConsumable。如何選擇要使用哪個方法，需要開發人員根據產品販售策略來決定。以下是一些比較簡單的原則提供大家參考。\n\n- 當產品會重複販售給使用者多次，使用 buyConsumable。\n- 當產品只能販售給每個使用一次，使用 buyNonConsumable。\n\n```dart\nfinal PurchaseParam purchaseParam = PurchaseParam(productDetails: productDetails);\nif (_isConsumable(productDetails)) {\n  InAppPurchase.instance.buyConsumable(purchaseParam: purchaseParam);\n} else {\n\tInAppPurchase.instance.buyNonConsumable(purchaseParam: purchaseParam);\n}\n```\n\n除此之外，這兩個方法在實作購買流程上會有些許不同，如果是使用 buyNonConsumable 購買產品後，購買成功後需要呼叫 completePurchase，讓 Google Play 知道此次購買已經完成，而 buyConsumable 則不強制。\n\n```dart\nawait InAppPurchase.instance.completePurchase(purchaseDetails);\n```\n\n若是使用 buyNonConsumable 後未呼叫 completePurchase，則會造成 Google Play 認為此筆購買未完成，將導致該筆付款在 3 天後退還給使用者。\n\n### 等待完成購買流程\n\n當呼叫了購買 API 之後，就需要透過 purchaseStream 來監聽購買的狀態，無論是使用者取消購買、購買成功、付款失敗 ...等，都會透過 purchaseStream 來通知 App 購買的狀態。\n\n```dart\n_subscription = InAppPurchase.instance.purchaseStream.listen((purchaseDetailsList) {\n  _listenToPurchaseUpdated(purchaseDetailsList);\n}\n```\n\n而我們能從 PurchaseDetail 中的 status 確認購買狀態並決定 App 相應的行為，例如：處於 PurchaseStatus.pending 時要顯示等待畫面、處於 PurchaseStatus.purchased 時顯示購買成功 ...等，開發者需要依照實際需求實作。\n\n```dart\nvoid _listenToPurchaseUpdated(List<PurchaseDetails> purchaseDetailsList) {\n  purchaseDetailsList.forEach((PurchaseDetails purchaseDetails) async {\n    if (purchaseDetails.status == PurchaseStatus.pending) {\n      // handle pending\n    } \n\n    if (purchaseDetails.status == PurchaseStatus.error) {\n      // handle error\n    } \n\n    if(purchaseDetails.status == PurchaseStatus.purchased || \n       purchaseDetails.status == PurchaseStatus.restored) {\n      // handle purchased\n    }\n  });\n}\n```\n\nGoogle 在整合 BillingClient 的文章中有提到，當購買成功時，建議把購買成功時的 Purchase Token 送到後端，後端能夠透過 [Google Purchase API](https://developers.google.com/android-publisher/api-ref/rest/v3/purchases.products/get) 驗證訂單是否合法，在合法的狀況才把產品交付給使用者。\n\n```dart\nif (purchaseDetails.status == PurchaseStatus.purchased || \n    purchaseDetails.status == PurchaseStatus.restored) {\n  bool valid = await _verifyPurchase(purchaseDetails);\n  if (valid) {\n    _deliverProduct(purchaseDetails);\n  } else {\n    _handleInvalidPurchase(purchaseDetails);\n  }\n}\n```\n\n以上講解的是從 App 端接收訂單資訊並處理，而 Google Play 也提供了另一種從後端處理訂單資訊方式。Google Play 可以透過 Google Pub / Sub 傳送訂單資訊給後端，讓後端接收訂單資訊並驗證訂單，App 則可以省去呼叫後端驗證的工作，更詳細的實作可以參考[這邊](https://developer.android.com/google/play/billing/getting-ready#configure-rtdn)。\n\n# 測試購買流程\n\n當寫完程式碼之後，我們理所當然地需要在測試機裝 Debug 版本測試一下。為了讓 Google Play 允許 Debug 版本也可以測試 Google IAB，我們必須在 Google Play 後台設定**授權測試**，在設定中的帳號使用測試信用卡付費，能夠避免實際付費。透過這個方法，我們就不必頻繁的上傳 App 到 Google Play 上測試，能夠增加開發速度。\n\n![截圖 2021-11-17 上午10.00.43.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/%E6%88%AA%E5%9C%96_2021-11-17_%E4%B8%8A%E5%8D%8810.00.43.png)\n\n當授權測試帳號設定完成後，需要先到測試機上的 Google Play 登入該帳號。測試付款流程時，就會看到付款選項中出現 Test Card 的選單。點開之後有更多付款選項，可以用來測試不同的情境，像是 Slow test card 的選項就可以用來測試 Pending 的情況。\n\n![Screenshot_20211117_101352-2.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/Screenshot_20211117_101352-2.png)\n\n![Screenshot_20211117_101442-2.png](%E5%9C%A8%20Flutter%20App%20%E4%B8%AD%E6%95%B4%E5%90%88%20Google%20play%20In-App-Billing/Screenshot_20211117_101442-2.png)\n\n最後要提醒的是，如果是使用模擬器來測試，請確保模擬器上有 Google Play 且登入想要用來測試的帳號，這樣才能夠正常測試。否則在確保與 Google Play 連線的步驟會不成功，導致後續流程無法進行。開發人員可以在 AVD Manager 中確認模擬器是否含有 Google Play。\n\n# 結論\n\n本篇紀錄了在 Flutter 上整合 Google IAB 的過程，從商店設定、簡化的流程處理到如何測試付費。其中在流程處理的部分，實際應用上可能會有許多場景需要特別處理，例如：不同支付方式的 Pending 處理、退款的後續處理流程、例外狀況的處理 ...等，需要開發者根據實際情況中思考如何處理。\n\n# 參考\n\n- 整合 Android BillingClient：[https://developer.android.com/google/play/billing/integrate](https://developer.android.com/google/play/billing/integrate)\n- 測試 Google IAB：[https://developer.android.com/google/play/billing/test](https://developer.android.com/google/play/billing/test)",
      "createdAt": "November 15, 2021 10:23 AM",
      "updatedAt": "October 24, 2025 4:48 PM",
      "id": "74e04f6b90ed4369855df505c99dd0ab",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "在 Flutter App 中整合 Google play In-App-Billing 74e04f6b90ed4369855df505c99dd0ab.md",
      "folderName": "在 Flutter App 中整合 Google play In-App-Billing"
    },
    {
      "title": "如何在 Flutter 中製作漂浮 Widget",
      "summary": "今天在工作中碰到一個需求，需要顯示漂浮 Widget，類似於 Dialog 那樣漂浮於畫面之上，但是需要客製自己的 Widget。於是自己做了一些研究，研究如何製作這種漂浮於畫面最上層的 Widget，本篇就來分享一下兩種製作漂浮 Widget 的方式。 自己一開始想到最簡單的辦法是，透過在外層使用...",
      "content": "![image.png](%E5%A6%82%E4%BD%95%E5%9C%A8%20Flutter%20%E4%B8%AD%E8%A3%BD%E4%BD%9C%E6%BC%82%E6%B5%AE%20Widget/image.png)\n\n今天在工作中碰到一個需求，需要顯示漂浮 Widget，類似於 Dialog 那樣漂浮於畫面之上，但是需要客製自己的 Widget。於是自己做了一些研究，研究如何製作這種漂浮於畫面最上層的 Widget，本篇就來分享一下兩種製作漂浮 Widget 的方式。\n\n## 使用 Stack\n\n自己一開始想到最簡單的辦法是，透過在外層使用 Stack，並在 Stack 放入 child 與漂浮 Widget，讓漂浮 Widget 蓋在 child 之上，達到漂浮 Widget 可以漂浮在 child 之上，最後提供一個控制顯示的方法，讓使用端可以傳入客製化 Widget。\n\n```dart\nclass FloatingWidgetState extends State<FloatingWidget> {\n  Widget? _floatingWidget;\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        widget.child,\n        if (_floatingWidget != null)\n          Center(\n            child: _floatingWidget,\n          ),\n      ],\n    );\n  }\n\n  void show(Widget child) {\n    setState(() {\n      _floatingWidget = child;\n    });\n  }\n}\n```\n\n在 Widget 中提供 of 方法讓使用端更方便使用\n\n```dart\nclass FloatingWidget extends StatefulWidget {\n  final Widget child;\n\n  const FloatingWidget({Key? key, required this.child}) : super(key: key);\n\n  @override\n  FloatingWidgetState createState() => FloatingWidgetState();\n}\n```\n\n使用端則是可以透過 context 找到 FloatingWidget，並呼叫 show() 傳入客製化 Widget 並顯示畫面上層。\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: FloatingWidget(\n        child: Scaffold(\n          appBar: AppBar(title: Text(\"Floating Widget Example\")),\n          body: Builder(\n            builder: (context) {\n              return ElevatedButton(\n                onPressed: () {\n                  FloatingWidget.of(context).show(\n                    Card(\n                      elevation: 5.0,\n                      child: Padding(\n                          padding: EdgeInsets.all(8),\n                          child: Text(\"My Floating Widget\")),\n                      color: Colors.blue,\n                    ),\n                  );\n                },\n                child: Text(\"Click Me\"),\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n使用 Stack 的做法有個缺點，根據放置 FloatingWidget 的地方不同，它能蓋住的層級也會不同。如果想讓所有 Route 都能使用 FloatingWidget，就需要把 FloatingWidget 放在 MaterialApp 之上。但是若把 Stack 直接放在 MaterialApp 之外，執行時就會報錯，會需要額外處理。\n\n## 使用 Overlay\n\nFlutter 定義好的 MaterialApp 中包了很多東西，其中就包含了 Overlay 這個 Widget，透過這個 Widget，我們可以客製我們想要的 Widget，並使之漂浮於畫面最上層。\n\n```dart\nOverlay.of(context)?.insert(\n  OverlayEntry(\n    builder: (context) {\n      return Text(\"My Floating Widget\");\n    },\n  ),\n);\n```\n\n當要移除時，則需要使用剛剛 insert 進去的 OverlayEntry，所以使用端需要暫存 OverlayEntry。\n\n```dart\nclass MyApp extends StatelessWidget {\n  final OverlayEntry _overlayEntry = OverlayEntry(\n    builder: (context) {\n      return Center(\n        child: Card(\n          elevation: 5.0,\n          child: Padding(\n            padding: EdgeInsets.all(8),\n            child: Text(\"My Floating Widget\"),\n          ),\n          color: Colors.blue,\n        ),\n      );\n    },\n  );\n\n  MyApp({Key? key}) : super(key: key);\n\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(\"Floating Widget Example\")),\n      body: Builder(\n        builder: (context) {\n          return ElevatedButton(\n            onPressed: () {\n              if (_overlayEntry.mounted) {\n                _overlayEntry.remove();\n              } else {\n                Overlay.of(context)!.insert(_overlayEntry);\n              }\n            },\n            child: Text(\"Click Me\"),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n使用 Overlay 做法相對於 Stack 作法來說，使用上比較方便一點。但免不了還是有一些缺點。使用 OverlayEntry 所產生的 Floating Widget 會漂浮於畫面最上層，甚至是所有 route 之上。當使用端 insert 了一個 Floating Widget，如果沒有先移除這個 Floating Widget 就 route 到其他頁面，就會發現 Floating Widget 仍舊漂浮於新頁面之上。所以使用 Overlay 做法時，會需要花一些心思控制 Floating Widget 的顯示與隱藏時機，讓 UI 顯示邏輯更合理。\n\n## 小結\n\n其實在 [pub.dev](http://pub.dev) 上已經有不少套件能顯示客製的漂浮 Widget 了，我自己最後也是直接使用套件。畢竟套件若能完美貼合自己的需求，那就沒有必要再自己造一個輪子了。但是經過一些研究，才發現還有 Overlay 這個 Widget 存在，也對 Flutter 更瞭解了一些。",
      "createdAt": "October 11, 2021 9:51 PM",
      "updatedAt": "October 24, 2025 5:22 PM",
      "id": "16d979fd41d74ed3b30deb840cd3df87",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "如何在 Flutter 中製作漂浮 Widget 16d979fd41d74ed3b30deb840cd3df87.md",
      "folderName": "如何在 Flutter 中製作漂浮 Widget"
    },
    {
      "title": "跳過 Widget 直接渲染畫面",
      "summary": "大家都知道 Flutter 是一套 UI 框架，透過 dart:ui 與底層 API 互動，最終呈現在手機螢幕上或接收點擊事件。使用的時候，都是透過已經定義好的 Widget 決定畫面，並不會直接與 dart:ui 互動。但是實際上，我們也是可以跳過 Widget，直接操作 dart:ui 的 AP...",
      "content": "![image.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/image.png)\n\n大家都知道 Flutter 是一套 UI 框架，透過 dart:ui 與底層 API 互動，最終呈現在手機螢幕上或接收點擊事件。使用的時候，都是透過已經定義好的 Widget 決定畫面，並不會直接與 dart:ui 互動。但是實際上，我們也是可以跳過 Widget，直接操作 dart:ui 的 API 來幫我們畫出我們想樣的畫面\n\n![archdiagram.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/archdiagram.png)\n\n而 Widget、 Element、RenderObject 等等我們比較常互動的物件，則更多是讓我們更方面的使用 Flutter，讓我們可以輕鬆在畫面畫出想要的結果，而不用自己一筆一劃決定，也不需要自己決定何時重新渲染畫面。\n\n## 畫一個圓\n\n下面這段代碼直接操作 Picture、Scene、Window ...等物件，在畫面上畫出一個藍色的原型。\n\n1. 一開始創建了 PictureRecorder 與 Canvas，並利用 Paint 在 Canvas 上畫出一個圓，與在 CustomPainter 畫圖的做法相當類似。\n2. 當畫完之後，呼叫 PictureRecording.endRecording()，並取得一張 Picture\n3. 接著我們就能把這張 Picture 透過 SceneBuilder 放進 Scene 中\n4. 最後用 window 來這一幀的畫面\n\n```dart\nvoid main() {\n\tPictureRecorder recorder = PictureRecorder();\n  Canvas canvas = Canvas(recorder);\n\n  Paint circlePaint = Paint();\n  circlePaint.color = Colors.blue;\n  canvas.drawCircle(Offset(400, 400), 300, circlePaint);\n\n  Picture picture = recorder.endRecording();\n\n  SceneBuilder sceneBuilder = SceneBuilder();\n  sceneBuilder.addPicture(Offset(0, 0), picture);\n\n  Scene scene = sceneBuilder.build();\n  window.onDrawFrame = () {\n    window.render(scene);\n  };\n  window.scheduleFrame();\n}\n```\n\n當執行上面這段代碼後，我們在畫面上看到一個藍色圓形，向下方左圖一樣。同樣的方法也可以用來畫出向下方右圖那樣的複雜圖形。\n\n![Screenshot_20210926_173637.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/Screenshot_20210926_173637.png)\n\n![Screenshot_20210926_174545.png](%E8%B7%B3%E9%81%8E%20Widget%20%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E7%95%AB%E9%9D%A2/Screenshot_20210926_174545.png)\n\n## 小結\n\n雖然我們可以直接使用 dart:ui 在畫面上直接作畫，但實際上在絕大多數的狀況下不會這麼做，目前我自己也想不到一樣狀況會需要這樣做。畢竟除了繪製，Flutter 實際上還做了許許多多事，不管是狀態管理或者是效能優化，透過 Widget、Element 和 RenderObject 去操作還是推薦的做法。\n\n## 參考\n\n- [https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/](https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/)",
      "createdAt": "September 26, 2021 9:25 AM",
      "updatedAt": "October 24, 2025 5:22 PM",
      "id": "3248bae84f984870bdc4d05b3dbc569e",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "跳過 Widget 直接渲染畫面 3248bae84f984870bdc4d05b3dbc569e.md",
      "folderName": "跳過 Widget 直接渲染畫面"
    },
    {
      "title": "Flutter Notification 事件機制研究",
      "summary": "當 CustomScrollView 或 ListView 開始滑動時，可以使用 NotificationListener 捕捉  ScrollStartNotification 的 Notification 事件。這些 Widget 會在滾動開始、進行中、結束時，發出各式各的 Notificati...",
      "content": "![image.png](Flutter%20Notification%20%E4%BA%8B%E4%BB%B6%E6%A9%9F%E5%88%B6%E7%A0%94%E7%A9%B6/image.png)\n\n## 什麼是 Notification 事件\n\n當 CustomScrollView 或 ListView 開始滑動時，可以使用 NotificationListener 捕捉  ScrollStartNotification 的 Notification 事件。這些 Widget 會在滾動開始、進行中、結束時，發出各式各的 Notification 事件。\n\n```dart\nScrollStartNotification(metrics: metrics, context: context);\n\nScrollUpdateNotification(metrics: metrics, context: context, scrollDelta: scrollDelta);\n\nScrollEndNotification(metrics: metrics, context: context);\n```\n\n## 如何送出 Notification 事件\n\n送 Notification 事件的方式很簡單，以上面的 ScrollEndNotification 事件為例，只要呼叫 Notification 身上的 dispatch 方法，Notification 就會以同步的方式往上傳遞 Notification 事件。\n\n```dart\nScrollEndNotification(metrics: metrics, context: context).dispatch(context);\n```\n\n## Dispatch Notification 事件\n\ndispatch 是 Notification 這個抽象類別身上的一個方法，主要功能是送通知給上層 Widget。當 dispatch 被呼叫時，它沿著 Element Tree 一路往上，遇到 NotificationListener 時，就會呼叫 NotificationListener 的 _dispatch。（這邊的 _dispatch 不同於 Notification 身上的 dispatch）\n\n```dart\nabstract class Notification {\n\n  @protected\n  @mustCallSuper\n  bool visitAncestor(Element element) {\n    if (element is StatelessElement) {\n      final StatelessWidget widget = element.widget;\n      if (widget is NotificationListener<Notification>) {\n        if (widget._dispatch(this, element)) // that function checks the type dynamically\n          return false;\n      }\n    }\n    return true;\n  }\n\n  void dispatch(BuildContext? target) {\n    // The `target` may be null if the subtree the notification is supposed to be\n    // dispatched in is in the process of being disposed.\n    target?.visitAncestorElements(visitAncestor);\n  }\n\n  ...\n}\n```\n\n## Notification 事件傳遞\n\n當 _dispatch 被呼叫時，它嘗試呼叫傳入的 onNotification 的 callback。onNotification callback 會回傳 bool 值，用以決定這個 Notification 事件是否繼續往上通知，如果回傳 true，表示阻斷這個 Notification 事件繼續往上，這個 Notification 就不會被更外層的 NotificationListener 收到了。相反的，如果回傳 false，則會繼續往上傳遞這個 Notification 事件。\n\n```dart\nclass NotificationListener<T extends Notification> extends StatelessWidget {\n  \n\t...\n\t\n  final NotificationListenerCallback<T>? onNotification;\n\n  bool _dispatch(Notification notification, Element element) {\n    if (onNotification != null && notification is T) {\n      final bool result = onNotification!(notification);\n      return result == true; // so that null and false have the same effect\n    }\n    return false;\n  }\n\n}\n```\n\n比方說以下面這段代碼為例，當使用者按下 Click me 按鈕送出 MyNotification 之後，最靠近 Button  的 NotificationListener 會收到 Notification，並印出 \"Receive notification inside\"，隨即回傳了 true，也終止了事件繼續往上傳遞，外層 NotificationListener 也就收不到 Notification，在 Console 就只會印出 \"Receive notification inside\"，而沒有印出 \"Receive notification outside\"。\n\n```dart\nclass MyNotificationWidget extends StatelessWidget {\n  const MyNotificationWidget({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return NotificationListener<MyNotification>(\n      onNotification: (notification) {\n        print(\"Receive notification outside\");\n        return false;\n      },\n      child: NotificationListener<MyNotification>(\n        onNotification: (notification) {\n          print(\"Receive notification inside\");\n          return true;\n        },\n        child: Builder(\n          builder: (context) {\n            return TextButton(\n              child: Text(\"Click me\"),\n              onPressed: () {\n                MyNotification().dispatch(context);\n              },\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 客製化 Notification 事件\n\n除了 Scroll 的 Notification 事件，我們也可以定義自己的 Notification 事件\n\n```dart\nclass MyNotifcation extends Notification {}\n```\n\n在需要的時候，使用 Notification 身上的 dispatch 發送事件\n\n```dart\nMyNotifcation().dispatch(context);\n```\n\n最後在 Widget 中使用 NotificationListener 接收事件\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return NotificationListener<MyNotification>(\n    onNotification: (notification) {\n      setState(() {\n        _count++;\n      });\n      return false;\n    },\n    child: Text(\n      'count: $_count',\n      style: Theme.of(context).textTheme.headline4,\n    ),\n  );\n}\n```\n\n## 小結\n\nNotification 事件提供了一種機制讓子層 Widget 通知父層 Widget，用法也相當的簡單，且可以通知多個 NotificationListener，不過需要注意的是，Notification 事件通知的方式是同步的，所以盡量不要再 onNotification 中執行耗時的操作，否則可能會影響畫面更新。",
      "createdAt": "August 31, 2021 1:46 PM",
      "updatedAt": "October 24, 2025 5:22 PM",
      "id": "349055b3e6dc43c5976af586d01cbe81",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Flutter Notification 事件機制研究 349055b3e6dc43c5976af586d01cbe81.md",
      "folderName": "Flutter Notification 事件機制研究"
    },
    {
      "title": "如何用 Github Action 建置 Flutter Android App",
      "summary": "手動建置與上傳 app 是一件滿麻煩的事情，在最理想的狀況下，我們希望當我們確保程式沒有問題之後，合併回主線就可以開始自動建置並上傳到 google play 上。為了達到這個目的，我使用 Github Action 來幫我建置 flutter app，今天就來分享一下我如何自動化這些麻煩事。 透過...",
      "content": "手動建置與上傳 app 是一件滿麻煩的事情，在最理想的狀況下，我們希望當我們確保程式沒有問題之後，合併回主線就可以開始自動建置並上傳到 google play 上。為了達到這個目的，我使用 Github Action 來幫我建置 flutter app，今天就來分享一下我如何自動化這些麻煩事。\n\n## 加入建置 Flutter 的 Step\n\n透過使用第三方的 action：[subosito/flutter-action](https://github.com/subosito/flutter-action)，我們就可以使用 flutter 的命令來建置 flutter app。\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-java@v1\n        with:\n          java-version: '12.x'\n \t  - uses: subosito/flutter-action@v1\n        with:\n          channel: 'stable'\n      - run: flutter pub get\n      - run: flutter test\n      - run: flutter build appbundle\n```\n\n當用這上面這段代碼去建置時，會發現因為缺少 keystore 檔案與 google-service.json 而建置失敗。這些檔案因為需要保密的緣故，所以並沒有上傳到 Github 的 repository 中。為此，我們必須想個辦法讓 Github 可以保存這些保密的檔案。\n\n## 保密 keystore 與 google-service.json\n\n由於這些 keystore 檔案和 google-service.json 裡面放著重要的資料，不能放在直接 git repository，以防被其他人拿到並盜用你的名義簽署 app 或者使用 google 服務。但是當你建構你的自動化 app 建置流程，這些檔案又是必不可少的，否則就會建置失敗。\n\n為了在 github 上保密這些資料，github 也向其他各式各樣的 CI 工具一樣，提供了 secret 讓我們可以放一些重要的資料，例如：DB 的連線字串、API 的 token ...等等。但是 secret 目前是提供以文字形式的方式儲存這些保密資料，所以我們必須把 keystore 檔案和 google-services.json 檔轉換成文字形式，然後才能放到 secret 中。\n\n1. 在 local 端把檔案轉換成 base64 的格式\n    \n    ```bash\n    openssl base64 -in your-input-file -out your-output-file\n    ```\n    \n2. 把轉換出來的 base64 文字加到 Github Secret 中，同時也把\n    \n    ![截圖 2021-08-15 下午1.47.30.png](%E5%A6%82%E4%BD%95%E7%94%A8%20Github%20Action%20%E5%BB%BA%E7%BD%AE%20Flutter%20Android%20App/%E6%88%AA%E5%9C%96_2021-08-15_%E4%B8%8B%E5%8D%881.47.30.png)\n    \n3. 把 base64 文字在 step 中轉回檔案，如此一來，建置時就能拿到這些重要檔案\n    \n    ```yaml\n    jobs:\n      build:\n        runs-on: ubuntu-latest\n        steps:\n    \t  ...\n    \t  - run: echo $ANDROID_KEY_STORE | base64 -di > android/app/key.jks\n      \t\tenv:\n        \t\tANDROID_KEY_STORE: ${{ secrets.ANDROID_KEY_STORE }}\n    \t  - run: echo $GOOGLE_SERVICE | base64 -di > android/app/google-services.jon\n      \t\tenv:\n        \t\tGOOGLE_SERVICE: ${{ secrets.GOOGLE_SERVICE }}\n    \t  ...\n    ```\n    \n\n## 保密其他重要資料\n\n除了 keystore 外，還有重要的資料，像是 store password, key password, key alias，我們也需要一起放進 secret 中，讓建置時可以從 secret 中拿到這些資料。\n\n![Pasted image 20210815142324.png](%E5%A6%82%E4%BD%95%E7%94%A8%20Github%20Action%20%E5%BB%BA%E7%BD%AE%20Flutter%20Android%20App/Pasted_image_20210815142324.png)\n\n修改 github action，在建置時把這些 secret 放進環境變數中\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      ...\n      - run: flutter build appbundle\n\t  \tenv:\n  \t\t  KEY_ALIAS: ${{ secrets.KEY_ALIAS }}\n  \t\t  KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}\n  \t\t  STORE_PASSWORD: ${{ secrets.STORE_PASSWORD }}\n\n```\n\n最後修改 build.gradle，build.gradle 從環境變數中使用這些資料。\n\n```\nsigningConfigs {\n\trelease {\n \t\tstoreFile = file(\"key.jks\")\n \t\tstorePassword System.getenv(\"STORE_PASSWORD\")\n \t\tkeyAlias System.getenv(\"KEY_ALIAS\")\n \t\tkeyPassword System.getenv(\"KEY_PASSWORD\")\n \t}\n}\n```\n\n當以上都做完之後，Github Action 就能正常的建置出 flutter android app 了。\n\n## 下載建置出來的 app\n\n當建置完成後，檔案實際上還是存在 Github Action 的 Runner 中。為了拿到最後建置出來的檔案，我們必須再加上一個 step，把檔案上傳到 artifact 中。這樣我們就在建置完成之後，就能從 Github 網頁上下載到剛剛建置的檔案。\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      ...\n\t  - name: upload appbundle\n  \t\tuses: actions/upload-artifact@v2\n  \t\twith:\n    \t  name: app bundle\n    \t  path: build/app/outputs/bundle/release/app-release.aab\n\n```\n\n## 下一步\n\n把 app 建置出來並放到 artifact 後，我們就能從 github 上下載到 app，把這個 app 上傳到 google play 的後台，讓 user 可以下載。可以發現後面我們還是需要手動上傳到 google play，為了也把這段自動化，我會在下一篇中紀錄如何把 app 自動上傳到 google play 上。\n\n## 參考\n\n- [完整的 workflow](https://github.com/easylive1989/LittleFlowerApp/blob/master/.github/workflows/build.yml)\n- [Github Action Doc](https://docs.github.com/en/actions/guides/storing-workflow-data-as-artifacts#uploading-build-and-test-artifacts)",
      "createdAt": "August 15, 2021 2:58 PM",
      "updatedAt": "October 24, 2025 5:24 PM",
      "id": "b95a311f7549498ca192c4dd9a4538e8",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "如何用 Github Action 建置 Flutter Android App b95a311f7549498ca192c4dd9a4538e8.md",
      "folderName": "如何用 Github Action 建置 Flutter Android App"
    },
    {
      "title": "BuildContext in Flutter",
      "summary": "BuildContext在flutter開發中很常出現，是build方法的唯一參數。我們時常需要透過of方法取得某些Widget時，此時就會使用到context，例如： ```dart MediaQuery.of(context).size // 取得畫面寬高 Scaffold.of(context...",
      "content": "![image.png](BuildContext%20in%20Flutter/image.png)\n\nBuildContext在flutter開發中很常出現，是build方法的唯一參數。我們時常需要透過of方法取得某些Widget時，此時就會使用到context，例如：\n\n```dart\nMediaQuery.of(context).size // 取得畫面寬高\nScaffold.of(context).showSnackBar(snackBar); // 顯示Snack Bar\n```\n\n但是實際上context到底是什麼呢？今天就來聊聊這個話題吧。\n\n## Flutter的三棵樹\n\n如果有稍微研究過Flutter的話，多多少少都知道Flutter有三顆樹，分別是Widget Tree, Element Tree, RenderObject Tree。而當中的Element Tree是由各式各樣的Element組成的，例如:SatelessElement、StatefulElement、InheritedElement...等，每個Widget都有他自己相對應的element。\n\nElement主要職責是橫向連接Widget與RenderObject，縱向連結parent Element與child Element，並在Widget發生變化時，根據情況更新RenderObject或重新建立子樹。如果追著這些Element的繼承一路往上，會發現最終Element實作了BuildContext這個抽象類別。\n\n![](BuildContext%20in%20Flutter/_2021-01-19_1.34.08.png)\n\n## 各式各樣的找祖先方法\n\nElement實作BuildContext，並實作了BuildContext裡的眾多方法。在這些方法中，有一系列找祖先的方法，讓我們可以透過context找到往上好幾層的Widget或State。\n\n```dart\nabstract class BuildContext {\n\n  ...\n\n  T findAncestorWidgetOfExactType<T extends Widget>();\n\n  T findAncestorStateOfType<T extends State>();\n\n  T findRootAncestorStateOfType<T extends State>();\n\n  T findAncestorRenderObjectOfType<T extends RenderObject>();\n\n  void visitAncestorElements(bool visitor(Element element));\n\n  void visitChildElements(ElementVisitor visitor);\n\n  ...\n\n}\n```\n\n這些找祖先方法被廣泛的運用在各種of方法中，例如Scaffold.of(context)就是透過context.findAncestorStateOfType<T>()來取得ScaffoldState的。\n\n![](BuildContext%20in%20Flutter/_2021-01-24_9.14.25.png)\n\n## Build方法中的唯一參數\n\n為了讓我們能更靈活的控制UI，BuildContext作為build方法唯一參數，讓我們可以透過它取得祖先Widget，並應用在一些常見的場景中\n\n1. 取得祖先Widget的狀態，來做相對應的顯示，例如：我們需要根據手機的寬高來顯示不一樣的UI設計。\n2. 操作祖先Widget並改變他的狀態，例如：當我們想顯示自訂訊息在SnackBar時，我們必須透過BuildContext取得ScaffoldState，才能用它顯示SnackBar。\n\n## 小結\n\n我們都會從StackOverflow上找某個UI如何實作，這些解答中多多少少會用到BuildContext。BuildContext作為Flutter核心設計之一，理解BuildContext能有效讓我們更清楚Flutter是如何運作的，也能在發生error時，更清楚其背後的根本原因。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:26 PM",
      "id": "512453b346714c74ac7c102844711624",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "BuildContext in Flutter 512453b346714c74ac7c102844711624.md",
      "folderName": "BuildContext in Flutter"
    },
    {
      "title": "Context that does not contains ...",
      "summary": "在開發Flutter的時候，多多少少都會遇到一些error。在眾多error中，多多少少都會遇到的一種error是context中找不到想要的東西，讓我們舉個例子來看看這個錯誤。 以下面這段代碼為例，當按下FloatingActionButton時，畫面顯示\"Worlds!\"在SnackBar上。當...",
      "content": "![image.png](Context%20that%20does%20not%20contains/image.png)\n\n在開發Flutter的時候，多多少少都會遇到一些error。在眾多error中，多多少少都會遇到的一種error是context中找不到想要的東西，讓我們舉個例子來看看這個錯誤。\n\n## context中找不到Scaffold\n\n以下面這段代碼為例，當按下FloatingActionButton時，畫面顯示\"Worlds!\"在SnackBar上。當程式執行onPressed callback時，透過Scaffold.of(context)找到ScaffoldState，並呼叫其showSnackBar方法來顯示SnackBar。\n\n![](Context%20that%20does%20not%20contains/_2021-01-31_7.58.31.png)\n\n實際執行並按下FloatingActionButton後會噴error，訊息中提示context不包含Scaffold。\n\n```dart\nScaffold.of() called with a context that does not contain a Scaffold.\n```\n\n![](Context%20that%20does%20not%20contains/_2021-01-24_8.41.24.png)\n\n可以發現錯誤是發生在嘗試呼叫Scaffold.of()取得Scaffold的時候，初學者容易在這個地方覺得奇怪，因為Scaffold確實是FloatingActionButton的parent，那為什麼會找不到呢？\n\n## 發生原因\n\n在上一篇BuildContext的文章中提到，of方法會從parent開始一層一層往上找，但是此時的context是這個MyHomePage的context，並非FloatingActionButton的context，所以會找不到Scaffold，以上面的代碼為例，此時畫面的結構是\n\n![](Context%20that%20does%20not%20contains/_2021-01-31_8.24.08.png)\n\n所以當呼叫Scaffold.of()時，程式循著MyHomePage的context往parent一層一層往上找，理所當然是找不到任何ScaffoldState，因為想要的ScaffoldState在child（Context of Scaffold）中。\n\n## 如何解決\n\n1. 把目標UI抽取Widget，並為其取一個合適的名稱。\n    \n    ![](Context%20that%20does%20not%20contains/_2021-01-31_8.19.05.png)\n    \n    但是當目標UI沒有重複利用的需求且本身已經夠小的時候，或許可以考慮使用Builder來解決\n    \n2. 用Builder把Widget包起來\n    \n    ![](Context%20that%20does%20not%20contains/_2021-01-31_8.11.58.png)\n    \n    此時就能用Builder中的context來正確取得ScaffoldState。\n    \n\n## 不只Scaffold\n\n在開發過程中，我們也常常會用到MediaQuery.of(context)來幫助我們取得畫面的寬高，但是當我們的Widget Tree中沒有MediaQuery時，也同樣的會噴錯。\n\n![](Context%20that%20does%20not%20contains/_2021-02-02_2.02.44.png)\n\n如果在自己的Widget中實作了of方法，也同樣需要在使用的時注意是否有正確的使用，否則就會造成系統出錯而畫面無法正常顯示。\n\n## 小結\n\n如果第一次看到這個錯誤，對初學者的人來說，可能會上網搜尋解法。找到解法貼上來後也可能會一頭霧水，不知道錯誤的原因是什麼，也不知道為什麼這樣寫就會好，改起來總是不安心。希望這篇文章能幫助大家更好地瞭解Flutter，讓代碼寫起來更有信心。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:26 PM",
      "id": "6b3707dc2af34e82a203ba90279b70c2",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Context that does not contains 6b3707dc2af34e82a203ba90279b70c2.md",
      "folderName": "Context that does not contains"
    },
    {
      "title": "Dart 非同步介紹(一) - Event Loop",
      "summary": "寫Flutter的時候，如果我們需要從後端api拿回資料時，我們會使用一些network相關的package來幫忙，例如：[http](https://pub.dev/packages/http)。我們透過await http.get來讓代碼停在這一行，釋放Thread去做其他工作，直到後端resp...",
      "content": "![image.png](Dart%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%B4%B9(%E4%B8%80)%20-%20Event%20Loop/image.png)\n\n寫Flutter的時候，如果我們需要從後端api拿回資料時，我們會使用一些network相關的package來幫忙，例如：[http](https://pub.dev/packages/http)。我們透過await http.get來讓代碼停在這一行，釋放Thread去做其他工作，直到後端response傳回來後，Thread再從之後的代碼繼續執行，這種非同步的操作只是用在存取api，在很多其他場景中也都會用到，今天就來講講Dart的非同步操作是如何運作的。\n\n## Event Loop與單執行緒\n\n在預設的情況下，Dart只使用一條Thread來執行代碼，Dart用三個東西來完成這件事情：**Event**, **Event Loop**, **Event Queue**。我們可以想像Dart把一段一段的代碼包成Event放在Event Queue的中，當中不管是渲染畫面的代碼、點擊按鈕的callback代碼，或者http response callback代碼。\n\n![](Dart%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%B4%B9(%E4%B8%80)%20-%20Event%20Loop/_2021-03-01_3.08.29.png)\n\n所有Event都會放在Event Queue中，然後Event Loop從Event Queue中把Event拿出來執行。我們可以把Event Loop想像成一條Thread裡頭跑著一個無窮迴圈，它會一直不斷的檢查Queue中有沒有Event，有的話就把它拿出來執行，如果沒有的話就一直等待下一個Event的出現。\n\n我們舉一些簡單的例子來看看\n\n```dart\nFlatButton(\n  onPressed: () => {\n\tprint('Hello World!');\n  },\n  child: Text(\"Click me\"),\n),\n```\n\n當FlatButton被宣告的時，onPress不會直接被執行，而是使用者按下FlatButton時，Flutter會在Event Queue中加入一個Click的Event，等待Event Loop處理它。順帶一提，宣告FlatButton的代碼也曾經被放在某個Event中，並被Event Loop執行。\n\n**http範例代碼：**\n\n```dart\nvar url = 'https://example.com/whatsit/create';\nvar response = await http.post(url, body: {'name': 'doodle', 'color': 'blue'});\nprint('Response status: ${response.statusCode}');\nprint('Response body: ${response.body}');\n```\n\n這段代碼執行到 await http.post且送出request之後，Event Loop轉去處理下一個Event。等到成功接收response之後，Dart就會加入剩餘部分代碼的Event到Event Queue中（也就是print的部分\n），等待Event Loop處理它。\n\n## await是一種語法糖\n\n在Dart中，await是一種then方法的語法糖，也就是說編譯器會在編譯過程中幫你把await轉換成then的寫法。以上面http範例代碼來說，就會變成下面這樣。\n\n```dart\nvar url = 'https://example.com/whatsit/create';\nhttp.post(url, body: {'name': 'doodle', 'color': 'blue'})\n\t\t.then((response) => {\n\t\t\tprint('Response status: ${response.statusCode}');\n\t\t\tprint('Response body: ${response.body}');\n\t\t}); \n```\n\n## 小心耗時工作\n\nEvent Loop會把正在處理的Event處理完以後，才會繼續從Queue中拿下一個Event。當我們在Queue中放入了耗時工作的Event時，例如：壓縮圖片、加密解密..等等，就會造成下一個UI遲遲無法被處理。如果今天下一個Event剛好是渲染UI Event，就會發現畫面開始卡頓，甚至沒有反應，直到Event Loop處理完手上的工作。\n\n但是實際應用場景中難免會有這樣的需求，此時我們可以使用Isolate來解決這類問題，避免占用到渲染UI的時間或者是Click事件的處理，我下次會繼續介紹Isolate如何使用，感謝你耐心的看這邊。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:25 PM",
      "id": "fad780524ae04e6fbadb7c6c280e0f2b",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Dart 非同步介紹(一) - Event Loop fad780524ae04e6fbadb7c6c280e0f2b.md",
      "folderName": "Dart 非同步介紹(一) - Event Loop"
    },
    {
      "title": "Dart 非同步介紹(三) - Stream",
      "summary": "在 Dart 非同步的使用情境中，除了常用的 Future 以外，還有 Stream 也是常常被用到的一個元件，相對於 Future 來說，Stream 是一個比較難理解的元件，今天就來研究一下 Stream 是什麼，以及如何建立與使用。 根據 [Flutter 官方影片](https://www....",
      "content": "![image.png](Dart%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%B4%B9(%E4%B8%89)%20-%20Stream/image.png)\n\n在 Dart 非同步的使用情境中，除了常用的 Future 以外，還有 Stream 也是常常被用到的一個元件，相對於 Future 來說，Stream 是一個比較難理解的元件，今天就來研究一下 Stream 是什麼，以及如何建立與使用。\n\n## **什麼是 Stream**\n\n根據 [Flutter 官方影片](https://www.youtube.com/watch?v=nQBpOIHE4eE)提到的，Stream 是非同步元件的 Iterator 形式。白話一點來說，可以想像成一個由多個 Future 組成的 List。 我們可以用 awiat 等待一個 Future 的結果，在 Iterator 形式中，可以用 await for 等待 Stream 中的每一個非同步結果。\n\n```csharp\nvoid main() async {\n    // 等待一個 Future\n    await Future.delayed(Duration(seconds: 1), \n    () => print(\"Hello World!!\"));\n  \n    // 等待一個 Stream\n    await for(var value in helloWorld()) {\n        print(value);\n    }\n}\n\nStream<String> helloWorld() async* {\n    yield \"Hello\";\n    yield \"World\";\n    yield \"!!\";\n}\n```\n\n## **如何建立 Stream**\n\n1. 使用 async* 方法如同上面範例中寫的，我們可以寫一個方法，回傳 Stream 並標註為 async*，這樣就能透過 yield 回傳想要的值。\n    \n    ```csharp\n    Stream<String> helloWorld() async* {\n        yield \"Hello\";\n        yield \"World\";\n        yield \"!!\";\n    }\n    ```\n    \n2. 使用 StreamController除了使用 async* 方法之外，還可以使用 StreamController 來建立 Stream，建立完後可以透過 StreamController 的 add() 發送 Event（也等同於使用 StreamController.sink.add())。\n    \n    ```csharp\n    StreamController<String> streamController =  \n        new StreamController<String>();  \n      \n    void helloWorld() {  \n        streamController.add(\"Hello\");  \n        streamController.add(\"World\");  \n        streamController.add(\"!!\");  \n    }\n    ```\n    \n3. 從其他 Stream 轉換最後一個方法則是從現有的 Stream 中創建，比較常見的例子像是 map、where..等方法。\n    \n    ```csharp\n    void main() async {  \n        var firstChars = helloWorld().map<String>((data) => data[0]);  \n            await for (var value in firstChars) {  \n            print(value);  \n        }  \n    }\n    \n    Stream<String> helloWorld() async* {\n        yield \"Hello\";\n        yield \"World\";\n        yield \"!!\";\n    }\n    ```\n    \n\n## **監聽 Stream 並獲取 Event**\n\n在前面的例子中，我們使用了 await for 來等待 Stream 中的所有 Event 回來，這樣會使得程式碼卡在 await for 那邊。在實際應用中，更多是使用 listen() ，以非同步的方式取得 Stream 的值。\n\n```csharp\nStream<String> helloWorld() async* {  \n    yield \"Hello\";  \n    yield \"World\";  \n    yield \"!!\";  \n}  \n  \nvoid main() {  \n    helloWorld().listen((event) {  \n        print(event);  \n    });  \n}\n```\n\n## **常見的 Stream 操作**\n\n除了 listen 之外，我們也可以透過 Stream 的各式各樣 API 來操作 Stream，例如\n\n- 使用 map 把 Stream 中的每一個 Event 轉成其他物件\n- 使用 where 把預期的 Event 從 Stream 中過濾出來\n- 使用 distinct 忽略相同的 Event，值得注意的是，distinct 是比較當前的 Event 與 上一個 Event 是否一樣，如果一樣就忽略掉。Stream 還有其他許多類似陣列的操作，這邊就不特別列出來，有興趣的人可以參考 [Stream API](https://api.dart.dev/stable/2.13.4/dart-async/Stream-class.html)。\n\n## 在 UI 中使用 Stream\n\n跟 FutureBuilder 一樣，如果需要根據 Stream 回傳的 Event 來影響畫面的話，可以使用 Flutter 提供的 StreamBuilder。我們可以傳入一個 Stream 到 StreamBuilder 中，當新的 Event 進來時，就可以根據 Event 重新呼叫 builder 方法渲染畫面。\n\n```dart\nclass HelloWorld extends StatelessWidget {\n \tconst HelloWorld({Key? key}) : super(key: key);\n\n \t@override\n \tWidget build(BuildContext context) {\n \t\treturn StreamBuilder<String>(\n \t\t\tstream: helloWorld(),\n \t\t\tbuilder: (context, snapShot) {\n \t\t\t\tvar text = snapShot.hasData ? snapShot.data! : \"Loading\";\n\t\t\t\treturn Text(text);\n \t\t\t},\n \t\t);\n \t}\n\n \tStream<String> helloWorld() async* {\n \t\tyield \"Hello\";\n \t\tyield \"World\";\n \t\tyield \"!!\";\n \t}\n}\n\n```\n\n## 無用小知識\n\nQ: Stream 如果是 Future 的 List 版本，那 Stream.first 是否會回傳 Future？\nA: 答案：是，確實會回傳 Future，但實際上 Stream 並非真的是 Future 的陣列，first 是透過 Stream.listen 取得第一個 Event 並把它包裝成 Future，然後才回傳給呼叫端。\n\n![](Dart%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%B4%B9(%E4%B8%89)%20-%20Stream/stream_first_impl.png)\n\n## 參考\n\n- [Creating streams in Dart](https://dart.dev/articles/libraries/creating-streams)",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:27 PM",
      "id": "dbd16c50a0cc425aa313a3552758683d",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Dart 非同步介紹(三) - Stream dbd16c50a0cc425aa313a3552758683d.md",
      "folderName": "Dart 非同步介紹(三) - Stream"
    },
    {
      "title": "Dart 非同步介紹(二) - Future",
      "summary": "在寫 Dart 的過程中，一定會碰到許多需要非同步的情境，例如：打 Web Api 從 Server 端讀寫資料、存取 local storage、sqlite...等等。Future 讓非同步操作用起來很容易，但若不清楚其執行邏輯，有些時候難免會造成一些 bug，而非同步的 bug 又比較難以除錯...",
      "content": "在寫 Dart 的過程中，一定會碰到許多需要非同步的情境，例如：打 Web Api 從 Server 端讀寫資料、存取 local storage、sqlite...等等。Future 讓非同步操作用起來很容易，但若不清楚其執行邏輯，有些時候難免會造成一些 bug，而非同步的 bug 又比較難以除錯。所以今天就來用個簡單的例子，來聊聊 Future 的執行邏輯。\n\n```dart\nvoid main() async {\n  print(\"1\");\n  await loadData();\n  print(\"4\");\n}\n\nFuture loadData() async {\n  print(\"2\");\n  await Future.delayed(Duration(seconds:1), () => \"data\");\n  print(\"3\");\n}\n```\n\n上面這段代碼執行結果是\n\n```dart\n1\n2\n3\n4\n```\n\n因為每一段非同步都用了await來等待，會等到結果回傳了才會往下一步前進。執行過程如下：\n\n1. 執行 print(\"1\") 並印出 1\n2. 進入 loadData() 方法中\n3. 執行 print(\"2\") 並印出 2\n4. 執行 Future.delayed() 並回傳 Future\n5. await 接到 Future.delayed 回傳的 Future 後，發現 Future 尚未執行完成，loadData() 也從 await 處回傳 Future，程式控制權從 loadData() 回到 main() 中\n6. 同理，main 方法中的 await 發現 loadData() 回傳的 Future 尚未執行完成，所以 main() 也從 await 處回傳 Future，程式控制權也從 main() 回到呼叫 main() 的 framework 中\n7. Future.delayed() 執行完成，並從 loadData() 中的 await 處繼續往下執行\n8. 執行 print(\"3\") 並印出 3\n9. loadData() 執行完成，並回傳完成執行的 Future 到 main() 中\n10. 回到 main() 後，從 await 處往下執行\n11. 執行 print(\"4\") 並印出 4\n\n## 移除 main 中的 await\n\n把呼叫 loadData() 時的 await拿掉以後並在執行一次\n\n```dart\nvoid main() async {\n  print(\"1\");\n  loadData();\n  print(\"4\");\n\n\t// 讓程式不要太快結束，避免來不及印出 3\n  await Future.delayed(Duration(seconds: 5), () => {});\n}\n\nFuture loadData() async {\n  print(\"2\");\n  await Future.delayed(Duration(seconds:1), () => \"data\");\n  print(\"3\");\n}\n```\n\n執行結果變成\n\n```dart\n1\n2\n4\n3\n```\n\n與第一個例子不同的是，當 loadData() 回傳未完成的 Future 後，main() 並沒有用 await 等待，所以程式就繼續往下執行，並印出 4。過了一秒之後，Future.delayed 完成並從 loadData() 的 await 處往下執行，並印出 3。\n\n## 移除 loadData 中的 await\n\n我們稍微修改一下例子，讓 main() 同樣 await loadData()，但是 loadData() 不 await Future.delayed()\n\n```dart\nvoid main() async {\n  print(\"1\");\n  await loadData();\n  print(\"4\");\n}\n\nFuture loadData() async {\n  print(\"2\");\n  Future.delayed(Duration(seconds:1), () => \"data\");\n  print(\"3\");\n}\n```\n\n執行結果回到\n\n```dart\n1\n2\n3\n4\n```\n\n與第一個例子不同的是，當 loadData() 執行到 Future.delayed() 時，此處沒有使用 await 來中斷執行，而是繼續往下執行並印出 3。當loadData() 執行完 print(\"3\") 回傳 Future 到 main() 中，此時 main() 中的 await 發現 Future 已經執行完成，所以也就已同步的方式往下執行並印出 4。\n\n## 執行 await 後的工作\n\n如同之前提到的 Dart 非同步會使用 queue 來安排工作，從 await 處往下執行的這項工作也同樣會被排進 queue 中，也就是說在當前工作未完成之前，即使 await 處的工作已經完成，也無法繼續往下執行，讓我們來看看另外一個例子\n\n```dart\nvoid main() async {\n  print(\"1\");\n  loadData();\n  sleep(Duration(seconds: 2));\n  print(\"4\");\n\n\t// 讓程式不要太快結束，避免來不及印出 3\n  await Future.delayed(Duration(seconds: 5), () => {});\n}\n\nFuture loadData() async {\n  print(\"2\");\n  await Future.delayed(Duration(seconds: 1), () => \"data\");\n  print(\"3\");\n}\n```\n\n執行結果是\n\n```dart\n1\n2\n4\n3\n```\n\n執行完 main() 需要兩秒，而Future.delayed() 的工作只需要一秒，但是結果還是先印出4，再印出 3，因為一次只能有一項工作在執行，此時已經被 main() 方法佔住了，所以即便 Future.delayed() 已經執行完成，它也只能乖乖在 queue 中等待 main() 把 sleep() 和 print(\"4\") 執行完，然後才輪到 print(\"3\")。\n\n## 小結\n\n看了上面幾個例子之後，我們可以歸納一些結論\n\n1. 沒有 await 的 async 方法等於同步方法\n2. 當程式執行到 await 時，是否往下執行取決於當下 Future 的狀態\n3. 非同步的 Future 執行結束後會排入 queue 中等待執行",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 4:48 PM",
      "id": "106987e499184351b18378ccef8a722b",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Dart 非同步介紹(二) - Future 106987e499184351b18378ccef8a722b.md",
      "folderName": "Dart 非同步介紹(二) - Future"
    },
    {
      "title": "Widget Test的14種find方法",
      "summary": "[https://www.notion.so](https://www.notion.so) 上禮拜介紹了一個Widget Test所包含的流程，過程中用到Finder、Tester、和Matcher的部分方法...等，但是實際上這些元件都還有許多不同的操作，今天先介紹Finder的各種方法。 1....",
      "content": "[https://www.notion.so](https://www.notion.so)\n\n上禮拜介紹了一個Widget Test所包含的流程，過程中用到Finder、Tester、和Matcher的部分方法...等，但是實際上這些元件都還有許多不同的操作，今天先介紹Finder的各種方法。\n\n## find的方法們\n\n1. **text：**找到一個顯示特定字串的Text Widget\n    \n    ```dart\n    find.text(\"Hello World\");\n    ```\n    \n2. **textContaining**：找到一個顯示文字中包含特定字串的Text Widget\n    - 當文字可能不是固定字串時，例如：在一個棋局中顯示黑棋或白棋獲勝時，因為有可能會是\"Black Wins\"或\"White Wins\"，此時就會需要使用到textContaining做部分比較\n    \n    ```dart\n    find.textContaining(\"Wins\");\n    ```\n    \n    - 除了直接使用字串以外，也可使用正規表達式([RegExp](https://api.flutter.dev/flutter/dart-core/RegExp-class.html))來找尋\n    \n    ```dart\n    find.textContaining(RegExp(r\"Wins$\"));\n    ```\n    \n3. **widgetWithText**：找到一個包含特定字串Text Widget的Widget\n    - 假設有一個文字按鈕使用FlatButton，在FlatButton的child再放上Text，此時我們就可以用這個方法來找到FlatButton\n    \n    ```dart\n    find.widgetWithText(FlatButton, \"Hello World\")\n    ```\n    \n    - 以上面的例子來說，假設畫面中有兩個Widget包含Text(\"Hello World\")，一個是FlatButton，一個是Container，此時就會找到FlatButton，因為它符合第一個參數中的條件。\n    \n    ```dart\n    Column(\n    \tchildren: <Widget>[\n    \t\tFlatButton(\n    \t\t\tonPressed: _incrementCounter,\n    \t\t\tchild: Text(\"Hello World\"),\n    \t\t),      \n    \t\tContainer(\n    \t\t  child: Text(\"Hello World\"),\n    \t\t),\n    \t],\n    )\n    ```\n    \n4. **byKey**：找到一個符合Key值的Widget\n    \n    ```dart\n    find.byKey(ValueKey(\"First Hello World\"))\n    ```\n    \n    - 以上面的例子來說，假設有兩個一樣的Text，就能正確找到Key值符合的Widget\n    \n    ```dart\n    Column(\n    \tchildren: <Widget>[\n    \t\tText(\n    \t\t\t\"Increase\",\n    \t\t  key: ValueKey(\"First Hello World\"),\n    \t\t),\n    \t\tText(\n    \t\t\t\"Increase\",\n    \t\t),\n    \t],\n    )\n    ```\n    \n    ⇒ 如果是用UniqueKey這類的Key，因為無法在測試中產生一模一樣的Key，此時可以考慮使用其他find方法解決或者由外部注入Key的方式解決。\n    \n5. **byIcon：**找到一個Icon符合的Icon Widget\n    \n    ```dart\n    find.byIcon(Icons.add);\n    ```\n    \n6. **widgetWithIcon：**與widgetWithText類似，同樣是找到一個包含特定Icon Widget的Widget\n    \n    ```dart\n    find.widgetWithIcon(FlatButton, Icons.add);\n    ```\n    \n7. **byType**：找到一個類別符合的Widget\n    \n    ```dart\n    find.byType(FlatButton);\n    ```\n    \n8. **byWidget：**找到與傳入的Widget傳入Widget同一實例的Widget\n    \n    ```dart\n    find.byWidget(Text(\"Hello World\"))\n    ```\n    \n    - 假設我們想測試MyContainer是否有正常渲染child時，就可以使用byWidget找到預期的Widget並檢查\n    \n    ```dart\n    testWidgets('test my container', (WidgetTester tester) async {\n    \tvar text = Text(\"Hello World\");\n    \n      await tester.pumpWidget(\n        createTestingWidget(MyContainer(child: text)),\n      );\n    \n      await tester.pump();\n    \n      expect(find.byWidget(text), findsOneWidget);\n    });\n    ```\n    \n    ```dart\n    class MyContainer extends StatelessWidget {\n      final Widget child;\n    \n      MyContainer({this.child});\n    \n      @override\n      Widget build(BuildContext context) {\n        return Column(\n          children: [\n            Text(\"Header\"),\n            child,\n            Text(\"Footer\"),\n          ],\n        );\n      }\n    }\n    ```\n    \n9. **byWidgetPredicate：**找到一個符合predicate回傳true的Widget\n    - 參數是一個predicate方法，在方法中可以比較很多東西，例如類別或Widget中的資料，透過比較Widget中的屬性，並回傳boolean值表示這個widget是否是目標Widget，是一個十分泛用的方法\n    \n    ```dart\n    find.byWidgetPredicate(\n              (widget) => widget is Text && widget.data == \"Hello World\")\n    ```\n    \n10. **byTooltip：**找到符合message的[Tooltip](https://api.flutter.dev/flutter/material/Tooltip-class.html) Widget \n    \n    ```dart\n    find.byTooltip(\"Hello World\");\n    ```\n    \n    ⇒ 這個方法實際上是透過byWidgetPredicate實作的\n    \n11. **byElementType：**與byType相似，不同的這個方法會找的是符合類別的Element\n    \n    ```dart\n    find.byElementType(InheritedElement);\n    ```\n    \n12. **byElementPredicate：**與byWidgetPredicate相似，不同的是他的predicate參數傳入的是Element\n    - 這個方法可以用來比較Element中的屬性，例如自己做了一個MyCheckbox的StatefulWidget，就能用這個方法找出已選取的MyCheckbox\n    \n    ```dart\n    find.byElementPredicate((element) {\n    \tif(element is StatefulElement) {\n    \t  var state = element.state;\n        return state is MyCheckboxState && state.isChecked;\n      }\n      return false;\n    });\n    ```\n    \n    ```dart\n    class MyCheckbox extends StatefulWidget {\n    \n      @override\n      MyCheckboxState createState() => MyCheckboxState();\n    }\n    \n    class MyCheckboxState extends State<MyCheckbox> {\n      bool isChecked;\n    \n      @override\n      Widget build(BuildContext context) {\n        ...\n      }\n    }\n    ```\n    \n13. **ancestor：**在某個Widget的祖先中，找尋符合條件的Widget\n    - 從符合of參數的Widget開始往祖先找，直到找到符合matching參數的Widget，這兩個參數都可以使用前幾個find方法來決定條件\n    \n    ```dart\n    find.ancestor(of: find.byType(MyContainer), matching: find.byWidget(text));\n    ```\n    \n    ⇒ widgetWithText, widgetWithIcon也是用這個方法實作\n    \n14. **descendant：**在某個Widget的子孫中，找尋符合條件的Widget。\n    - 參數基本上與ancestor相似，只是搜尋的方向不同\n    \n    ```dart\n    find.descendant(of: find.byWidget(text), matching: find.byType(MyContainer));\n    ```\n    \n\n## **小結**\n\nFinder中有各式各樣的方法，在不同情境下使用不同的方法來找到想要的Widget，然後才能測試中正確的操作或驗證這些Widget，讓測試保護我們的產品代碼。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:26 PM",
      "id": "44325fd7e7ab4b4a93c1c06164398150",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "Widget Test的14種find方法 44325fd7e7ab4b4a93c1c06164398150.md",
      "folderName": "Widget Test的14種find方法"
    },
    {
      "title": "初探Flutter Widget Test",
      "summary": "Flutter可以使用 [test](https://pub.dev/packages/test) 來幫助我們寫單元測試，透過單元測試來幫忙檢查我們的核心邏輯是否正確。在我們實作需求或者是重構代碼時，常常會修改到過去已經寫好的代碼，當我們改壞邏輯時時，單元測試也能發出警訊，提醒我們改動可能有問題。 ...",
      "content": "![image.png](%E5%88%9D%E6%8E%A2Flutter%20Widget%20Test/image.png)\n\nFlutter可以使用 [test](https://pub.dev/packages/test) 來幫助我們寫單元測試，透過單元測試來幫忙檢查我們的核心邏輯是否正確。在我們實作需求或者是重構代碼時，常常會修改到過去已經寫好的代碼，當我們改壞邏輯時時，單元測試也能發出警訊，提醒我們改動可能有問題。\n\nFlutter是個前端框架，需求常常是需要表現在畫面上，在這種情境中，我們比較難使用單元測試來驗證畫面是否正確，為了解決這個問題，我們可以使用Flutter提供的Widget Test來幫助我們寫一些可以驗證畫面的測試。\n\n## Counter Ｗidget範例\n\n當使用 flutter create 創建一個project，裡面會自帶一個counter範例。在這個範例中，畫面中央會有當前的counter，每當我們按下 + 按鈕後，counter就會加1，如下圖所示。\n\n![](%E5%88%9D%E6%8E%A2Flutter%20Widget%20Test/widget_test.png)\n\n## 第一個Widget Test\n\n在剛剛創建出來的flutter proejct中，裡頭也包含了一個Widget Test，測試的正是按下 ＋ 按鈕後並在畫面上把 0 變成 1 ，也就是這個範例的核心邏輯。\n\n```dart\nvoid main() {\n  testWidgets('Counter increments smoke test', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n  });\n}\n```\n\n在main中，testWidgets表示一個測試，第一個參數是測試敘述，第二個參數則是實際的測試內容。在這個測試內容中，呼叫pumpWidget來建立與渲染ＭyApp。\n\n```dart\nawait tester.pumpWidget(MyApp());\n```\n\n當MyApp建立起來之後，就可以使用find方法來幫助找到想要的Widget。透過 find.text()來找到畫面中的包含 0 和 1 文字的Widget，透過expect驗證結果是否符合預期。以這個範例來說，當MyApp剛開起來時，因為還沒點下 + 按鈕，所以畫面應該是 0 而不是 1，所以能夠使用find.text()找到一個 0 的 Text Widget，找不到 1 的Text Widget。\n\n```dart\nexpect(find.text('0'), findsOneWidget);\nexpect(find.text('1'), findsNothing);\n```\n\n同樣地，也能透過 find.byIcon()來找到icon widget，找到之後就能用tester.tap來按下它。除了find.text()與find.byIcon()，find中還提供各式各樣的方法來幫助我們容易的找到我們想要的Widget，例如：find.byKey()、find.byWidget()… 等。\n\n```dart\nawait tester.tap(find.byIcon(Icons.add));\n```\n\n在這邊值得一提的是Widget Test不會幫我們自動rebuild widget，所以按下 + 按鈕後，State裡頭的 _counter 已經成功變成 1 了，但是MyApp也不會把 1 顯示在畫面上，此時需要呼叫test.pump()來觸發rebuild。\n\n```dart\nawait tester.pump();\n```\n\n最後就是驗證畫面上存在包含 1 的Text Widget，而不是 0 的Text Widget\n\n```dart\nexpect(find.text('0'), findsNothing);\nexpect(find.text('1'), findsOneWidget);\n```\n\n## 複雜的情境\n\nCounter範例是一個簡單的情境，相對的我們要對他寫Widget Test也不會太過困難。但在實際的開發過程中，我們會碰到各式各樣的狀況，例如：如何隔離網路讓測試可以總是使用我們想要的資料測試，又或者是如何在畫面切換情境中測試。未來我會跟大家分享一些自己在實際情境中碰到的一些例子，與我的處理方式。\n\n## 結論\n\n單元測試可以幫我們驗證狀態是否符合預期，Widget Test則是可以幫我們驗證畫面是否符合預期。雖然Widget Test除了驗證畫面，也同時驗證了邏輯。但是並不代表我們可以用Widget Test取代單元測試，反而是我們應該要用Widget Test專注在畫面上的驗證，更多是關注在給定狀態後畫面是否符合預期，減少驗證邏輯上的變化，讓單元測試專注在測試核心邏輯上面，兩者應該是相輔相成。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:26 PM",
      "id": "3c907ffe50cd4a81b82b52ffb7d309ec",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "初探Flutter Widget Test 3c907ffe50cd4a81b82b52ffb7d309ec.md",
      "folderName": "初探Flutter Widget Test"
    },
    {
      "title": "在 Null safety mockito 使用 any",
      "summary": "前陣子 Google release了 Dart 2.12，加入 null safety 特性，不可避免地，升級過後的產品代碼需要進行一些調整，除此之外，測試代碼也必須進行相對應的調整。在測試之中，如果有使用 mockito 中的 any 來 mock 物件方法與回傳，可能會碰到像是下面這種 err...",
      "content": "前陣子 Google release了 Dart 2.12，加入 null safety 特性，不可避免地，升級過後的產品代碼需要進行一些調整，除此之外，測試代碼也必須進行相對應的調整。在測試之中，如果有使用 mockito 中的 any 來 mock 物件方法與回傳，可能會碰到像是下面這種 error。\n\n```dart\ntype 'Null' is not subtype of type 'your class type' of 'type'\n```\n\n為此，官方給出[解決辦法](https://github.com/dart-lang/mockito/blob/master/NULL_SAFETY_README.md#problems-with-typical-mocking-and-stubbing)，讓我們的測試可以繼續使用 any 來進行 mock。\n\n## 解決辦法\n\n1. 在 pubspec.yaml 加入 build_runner\n    \n    ```dart\n    dev_dependencies:\n      build_runner: ^1.10.0\n    ```\n    \n2. 在測試中加入 GenerateMock 這個 annotation，並傳入想要 mock 的類別\n    \n    ```dart\n    import 'package:mockito/annotations.dart';\n    \n    @GenerateMocks([UserApi])\n    void main() {\n    \t...\n    }\n    ```\n    \n3. 在專案目錄中執行 build_runner\n    \n    ```dart\n    flutter pub run build_runner build\n    ```\n    \n\n當做完成以上步驟後，會在測試目錄中看到一個 xxx_test.mock.dart 的 mock 檔案，在原本的測試中 import 這個 mock 檔案後，就可以不在需要自己宣告 mock 類別，並且也可再次使用 any 了。\n\n```dart\nimport 'package:mockito/annotations.dart';\n\n@GenerateMocks([UserApi])\nvoid main() {\n\ttest('my test', () {\n\t\tvar mockUserApi = MockUserApi();\n\t\twhen(mockUserApi.getProfile(any)).thenReturn(Profile());\n\n\t\t...\n\t});\n}\n```\n\n## 作法解釋\n\n以原本的 mockito 的做法，mock 類別實作了目標類別，在 nullable 環境中，可以正常的把 any 當成方法參數，但是在 null safety 的環境中，想把 any 傳入 non-nullable 的參數就會造成編譯問題，因為 any 實際回傳的是 null。為了解決這個問題，所以必須透過 build_runner 來產生 mock 檔，透過 build_runner 產生出來的 mock 類別會把原本 non-nullable 的參數拓展成 nullable，以支持傳入 any。\n\nbuild_runner 這個套件會去偵測 test 中的 @GenerateMock，並取得需要 mock 的目標類別，然後就自動產生對應的 mock 類別，最後在原本測試中引用產生出來的 mock 檔，就能像之前一樣的操作 mock 類別，與之前不同的是，不需要在自己宣告 mock 類別了。\n\n## 自行產生 Mock 類別\n\n除了使用 build_runner 來幫忙產生 mock 類別，其實也是可以自己寫，不一定要使用 build_runner來幫忙產生。當有兩個測試檔案都使用了相同的 mock 類別時，在兩個檔案分別用 GenerateMocks mock 一樣的類別時，build_runner 會產生兩個測試的 mock 檔 ，並包含一樣的 mock 類別，如果自己寫的話，可以使用一份共用的 mock 檔，讓測試代碼稍微乾淨一點。\n\n```dart\nclass MockUserApi extends Mock implements UserApi {\n  @override\n  void getProfile(int? userId) =>\n      super.noSuchMethod(Invocation.method(#getProfile, [userId]));\n}\n```\n\n## 更改預設 mock 類別名稱\n\n預設 mock 類別名稱是在原本的類別前面加上 Mock 的前綴，但是想要客製化名稱，則不能使用第一個參數，而是需要改使用 @GenerateMock 的 customMocks 參數。\n\n```dart\nimport 'package:mockito/annotations.dart';\n\n@GenerateMocks([], customMocks: [MockSpec<UserApi>(as: #OtherMockUserApi)])\nvoid main() {\n\t...\n}\n```\n\n## 小結\n\n整體來說，在 null safety 中用 mockito 來 mock 類別的作法還是跟之前差不多，多了一個步驟要使用 build_runner 來幫忙產生 mock 類別。如果自己實作 mock 類別的話，則是需要在 mock 的時候，針對 mock 方法多寫一些代碼。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 4:57 PM",
      "id": "4df501b643a04bb29c701f53db896d45",
      "type": "輸出文章",
      "tag": "Flutter",
      "filename": "在 Null safety mockito 使用 any 4df501b643a04bb29c701f53db896d45.md",
      "folderName": "在 Null safety mockito 使用 any"
    },
    {
      "title": "改善迴圈的可讀性（一）",
      "summary": "不管是練習寫Kata或者是工作中，迴圈都是最常使用的語法之一。而在迴圈中很常出現一種Aggregation Pattern，例如：合計集合中的所有數字。 這種Pattern會大量的存在產品代碼中，雖然這些代碼行數通常不會太多，但是每次閱讀到都需要重新理解的話，就會顯得有點浪費時間。花些時間讓這些代碼...",
      "content": "![image.png](%E6%94%B9%E5%96%84%E8%BF%B4%E5%9C%88%E7%9A%84%E5%8F%AF%E8%AE%80%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89/image.png)\n\n## 情境介紹\n\n不管是練習寫Kata或者是工作中，迴圈都是最常使用的語法之一。而在迴圈中很常出現一種Aggregation Pattern，例如：合計集合中的所有數字。\n\n這種Pattern會大量的存在產品代碼中，雖然這些代碼行數通常不會太多，但是每次閱讀到都需要重新理解的話，就會顯得有點浪費時間。花些時間讓這些代碼更簡潔，更具可讀性是十分值得。\n\n## 簡單的情境\n\n例如下面這段代碼：合計集合中的所有數字，最容易想到的作法就是利用一個變數暫存合計數值，等到迴圈跑完就能得到所有數字的合計值。\n\n```csharp\nint sum = 0;\nfor (int i = 0; i < numbers.Length; i++) \n{\n\t\tsum += numbers[i];\n}\n```\n\n若是對語言或框架比較熟悉的人，可能就會用一些語言或框架提供的Aggregation方法來簡化代碼。例如：C#有Linq的Sum()能用，或者是Dart也有reduce()可以用。\n\n```csharp\nnumbers.Sum(); // C#\n\nnumbers.reduce((acc, number) => acc + number); //Dart\n```\n\n## 稍微複雜一點\n\n假設今天使用情境不是數字集合，而是物件集合，C#能透過Linq的Aggregate()、Dart也能使用fold()來簡化。例如要把一個產品訂單集合合併成一個購物車物件，把所有Order的屬性總和到ShoppingCart的屬性中。\n\n```csharp\norders.Aggregate(new ShoppingCart(), (shoppingCart, order) {\n\t\tshoppingCart.TotalPrice += order.Price;\n\t\tshoppingCart.OrderIds.Add(order.Id);\n\t\t...\n}); // C#\n\n```\n\n```dart\norders.fold(ShoppingCart(), (shoppingCart, order) {\n\t\tshoppingCart.totalPrice += order.price;\n\t\tshoppingCart.orderIds.add(order.id);\n\t\t...\n}); // Dart\n```\n\n利用語言提供的Aggregation方法來簡化代碼能滿有效的增加可讀性，一看到Aggregation方法就會知道這段代碼是要累計某些東西。上面這兩個例子中都是比較容易利用語言的Aggregation方法來簡化寫法。\n\n## 更多變的情境\n\n在實際產品代碼中，有一些情境讓人比較難想到可以使用Aggregation方法，還有另外一些情境則是不容易用Aggregation方法處理，下禮拜我會在整理這些情境並分享給大家，感謝大家耐心閱讀到這邊🤤。\n\n## 相關連結\n\n- [https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/supported-and-unsupported-linq-methods-linq-to-entities?redirectedfrom=MSDN](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/supported-and-unsupported-linq-methods-linq-to-entities?redirectedfrom=MSDN)\n- [https://api.dart.dev/stable/2.10.4/dart-core/List-class.html](https://api.dart.dev/stable/2.10.4/dart-core/List-class.html)",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:24 PM",
      "id": "69b4aa1a13df436794b511e5afe91f43",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "改善迴圈的可讀性（一） 69b4aa1a13df436794b511e5afe91f43.md",
      "folderName": "改善迴圈的可讀性（一）"
    },
    {
      "title": "改善迴圈的可讀性（二）",
      "summary": "在一些迴圈使用情境，我們比較難使用Aggregation方法來簡化。有一種使用情境是需要透過暫存變數來保存每一輪的狀態，並帶到下一輪計算，此時就會讓代碼變得複雜。 在下面這段[Josephus Survivor](https://www.codewars.com/kata/555624b601231...",
      "content": "![image.png](%E6%94%B9%E5%96%84%E8%BF%B4%E5%9C%88%E7%9A%84%E5%8F%AF%E8%AE%80%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89/image.png)\n\n在一些迴圈使用情境，我們比較難使用Aggregation方法來簡化。有一種使用情境是需要透過暫存變數來保存每一輪的狀態，並帶到下一輪計算，此時就會讓代碼變得複雜。\n\n## 舉個例子\n\n在下面這段[Josephus Survivor](https://www.codewars.com/kata/555624b601231dc7a400017a/)的Kata例子中，迴圈中會計算每一輪要移除受害者的位置，並把倖存者帶進下一輪迴圈中計算並找出下一輪的受害者。每一輪的迴圈中都需要把上一個受害者的位址紀錄在start裡。\n\n```csharp\npublic int Play(int count, int step)\n{\n    var candidates = Enumerable.Range(1, count).ToList();\n\n    int start = 0;\n    while (!HasSurvivor(candidates))\n    {\n        var victim = FindVictim(step, start, candidates);\n        candidates = NextCandidates(candidates, victim);\n        start = victim;\n    }\n\n    return candidates.First();\n}\n```\n\n此時可以發現迴圈中的代碼雖然不多，卻也不好理解。在這個例子中，start不只是最一開始的初始位置，而是迴圈中的每一輪的初始位置，這個資訊必須要來回反覆的閱讀才能夠理解。\n\n在累加數字的例子中，sum也是相似的情境，sum表示在每一輪迴圈中的暫時合計值。但是我們可以透過Aggregation方法讓sum這個暫存變數消失。與sum不同的是，start無法使用Aggregation方法簡化。\n\n雖然無法使用Aggregation方法，但是我們可以使用**遞迴**來隱藏start。\n\n```csharp\npublic int Play(int count, int step)\n{\n    var candidates = Enumerable.Range(1, count).ToList();\n\n    return FindSurvivor(candidates, 0, step);\n}\n\nprivate int FindSurvivor(List<int> candidates, int start, int step)\n{\n    if (HasSurvivor(candidates))\n    {\n        return candidates.First();\n    }\n\n    var victim = FindVictim(start, step, candidates.Count());\n\t\tvar nextCandiates = NextCandidates(candidates, victim);\n    return FindSurvivor(nextCandidates, victim, step);\n}\n```\n\n當透過遞迴來重構這個例子中，我們可消去迴圈並把start隱藏在參數中，並且只表示初始位址這個意義，讓代碼更容易閱讀。\n\n## 實際情況...\n\n在實際情況中，這種使用情境並不常見，多數是在演算法的情境下會比較常使用到，例如：在Quick Sort演算法中紀錄pivot、在多個商品與多種打折策略中計算最優惠的折扣組合。\n\n---\n\n迴圈最常使用到的語法之一，用起來也相當的容易，但是要如何寫得讓人容易理解，就不是一件容易的事情。所幸的是很多語言都支援好用的Aggregation方法，讓我們更容易從把一些常見的迴圈形式簡化，使代碼更專注在其職責，而不是迴圈本身。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:24 PM",
      "id": "ff23b70b497448d7addaae55200ed3af",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "改善迴圈的可讀性（二） ff23b70b497448d7addaae55200ed3af.md",
      "folderName": "改善迴圈的可讀性（二）"
    },
    {
      "title": "閱讀 IDE 給的提示",
      "summary": "現代的 IDE 很方便，當工程師編輯代碼時，IDE 會即時檢查代碼，並根據一些預設的規則，提示哪部分的代碼可能需要調整。不同的語言，不同的 IDE 提示狀況都不太一樣，但是或多或少都會有這個功能，提醒工程師可能要注意某段代碼是否有問題。 如果代碼總是穿插著不同顏色的提示，可能會讓工程師不想去處理這群...",
      "content": "![image.png](%E9%96%B1%E8%AE%80%20IDE%20%E7%B5%A6%E7%9A%84%E6%8F%90%E7%A4%BA/image.png)\n\n現代的 IDE 很方便，當工程師編輯代碼時，IDE 會即時檢查代碼，並根據一些預設的規則，提示哪部分的代碼可能需要調整。不同的語言，不同的 IDE 提示狀況都不太一樣，但是或多或少都會有這個功能，提醒工程師可能要注意某段代碼是否有問題。\n\n## 到處都是的提示和警告\n\n如果代碼總是穿插著不同顏色的提示，可能會讓工程師不想去處理這群成堆的提示，也不在乎自己寫的代碼是否多了一條提示，形成破窗效應。每種提示和警告都有不同的意義，有些是提醒拼錯字，有些是提示代碼存在 Side Effect。如果放任這些提示與警告蔓延在代碼中，除了會讓代碼品質日益下降，甚至會讓工程師忽略掉真正潛在的危險。\n\n![](%E9%96%B1%E8%AE%80%20IDE%20%E7%B5%A6%E7%9A%84%E6%8F%90%E7%A4%BA/sqknRNu.png)\n\n## 提示與警告的功用\n\n1. 提示不符合規則的寫法\n    - **拼字錯誤：**當變數名稱對不上某個英文單字時，IDE 就會提示你可能拼錯字。但是當單字是領域特有單字時，為了避免這種不必要的提示，就需要把這個單字加到 IDE 的預設字典中，讓提示可以認得這個單字。\n    - **語言的命名規則**，例如：以方法名稱為例，C# 預設方法名稱命名規則是開頭大寫的大駝峰命名法，而 Java 則是開頭小寫的小駝峰式命名法。當不符合這些規則時，IDE 就會提示你需要修改它。\n2. 更好的做法的提示\n    - 除了檢查拼字或命名規則，有些 IDE 還會建議更好的做法，例如：在 Rider 中，如果寫了下面這段代碼，一段由 for 處理的邏輯\n        \n        ```dart\n        var duplicateCount = 0;\n        foreach (var entry in cnt)\n        {\n            if (entry.Value > 1) duplicateCount++;\n        }\n        \n        return duplicateCount;\n        ```\n        \n        Rider 就會在 foreach 的部分提示使用 LINQ 改寫\n        \n        ```csharp\n        cnt.Count(entry => entry.Value > 1);\n        ```\n        \n        大多時候仔細閱讀這類型的提示，可以了解到什麼是更好的做法。尤其當自己是初學者的時候，這些提示都能幫助自己更好的了解這個語言的一些特性。\n        \n3. 潛在的風險的警告\n    - 有些時候，工程師可能寫出一寫有 Side Effect 的代碼，寫的時候沒有，以下面這段 C# 代碼為例，IDE 就提示了 gameResults 有重複執行多次的可能性，如果今天傳入這個方法的參數不是 List，而是 LINQ，就會導致 gameResults 跑了兩次迴圈，計算的卻是相同的東西。\n    \n    ![](%E9%96%B1%E8%AE%80%20IDE%20%E7%B5%A6%E7%9A%84%E6%8F%90%E7%A4%BA/CrCrOw8.png)\n    \n\n## **團隊特有的規則**\n\n這些提示都是根據每個語言的預設規則提示的，只要代碼不符合規則，IDE就會在代碼下方標註。但是有一種情況是開發團隊有自己一套規則，以 C# 為例，有些團隊習慣宣告變數時使用確定型別，讓閱讀代碼的人可以清楚知道這個變數是什麼型別。但是 IDE 會提示使用 var，因為 C# 能夠透過型別論來推斷變數型別，所以預設規則傾向於用更簡潔的寫法。\n\n```csharp\nCustomer customer = customerApi.Get(id);\n```\n\n在這種情況，就會產生團隊規則與 IDE 規則不同，導致代碼上出現不必要的提示。這時我們不應該放任警告與提示的存在畫面上，而是應該去調整自己的 IDE 設定，讓 IDE 不要因為這些命名規則持續地跳出警告。\n\n## 小結\n\n保持代碼沒有任何提示與警告，沒有無謂的波浪線與虛線，能讓閱讀代碼時能更專注，也能在真正需要的時候，讓 IDE 來提示你。除此之外，團隊的規則應該凌駕於所有寫法之上，畢竟代碼是團隊的，共同的寫法更是團隊協作的基礎，基本上除了可能造成 Side Effect 的提示之外，剩下的寫法優先度應該是以團隊共識為優先。\n\n## 題外話\n\n這篇原本是在鐵人賽的時候寫的，那是我第一次比較有系統地寫文章，也寫的比較倉促，所而有些凌亂。發在 Medium 的這篇則是整理一下原文，調整架構，並加上更多解釋。未來其他我覺得比較有意義文章整理到 Medium 這邊。",
      "createdAt": "August 11, 2021 1:07 PM",
      "updatedAt": "October 24, 2025 5:23 PM",
      "id": "3471f9df45444649a98266ce3842f52e",
      "type": "輸出文章",
      "tag": "極限編程",
      "filename": "閱讀 IDE 給的提示 3471f9df45444649a98266ce3842f52e.md",
      "folderName": "閱讀 IDE 給的提示"
    }
  ],
  "tags": [
    "AI Coding",
    "Flutter",
    "極限編程"
  ],
  "sideProjects": [
    {
      "name": "今彩 539 開獎資訊",
      "description": "用 Github Action + 爬蟲達成無後端式資訊收集與統計",
      "tags": [
        "React",
        "Python",
        "AI"
      ],
      "date": "2025/06",
      "websiteUrl": "https://easylive1989.github.io/ito539_analytics/",
      "sourceUrl": "https://github.com/easylive1989/ito539_analytics",
      "preview": "images/ito539_analytics.png"
    },
    {
      "name": "Breakout",
      "description": "按照教程練習 Flame，實作經典遊戲：打磚塊",
      "tags": [
        "Flutter",
        "Flame"
      ],
      "date": "2023/02",
      "websiteUrl": "https://easylive1989.github.io/flutter_breakout",
      "sourceUrl": "https://github.com/easylive1989/flutter_breakout",
      "preview": "images/breakout.png"
    },
    {
      "name": "NS-SHAFT",
      "description": "練習 Flame 開發，搭配 Firebase Hosting 部署，實作經典遊戲：小朋友下樓梯",
      "tags": [
        "Flutter",
        "Flame",
        "Firebase Hosting"
      ],
      "date": "2022/12",
      "websiteUrl": "https://playernsshaft.web.app/#/",
      "sourceUrl": "https://github.com/easylive1989/player_ns_shaft",
      "preview": "images/ns-shaft.png"
    },
    {
      "name": "Gomoku",
      "description": "嘗試用 Flutter 開發五子棋小遊戲，並且使用 Github Action 自動化部署到 Google Play",
      "tags": [
        "Flutter",
        "CI/CD"
      ],
      "date": "2021/03",
      "websiteUrl": "https://easylive1989.github.io/LittleFlowerApp/",
      "sourceUrl": "https://github.com/easylive1989/LittleFlowerApp",
      "preview": "images/gomoku.png"
    },
    {
      "name": "小遊戲 Line Bot",
      "description": "嘗試用 .Net Core + LINE 讓朋友們可用 Line 玩小遊戲，例如：猜數字、井字遊戲、五子棋",
      "tags": [
        ".Net Core",
        "Line Notify"
      ],
      "date": "2020/05",
      "websiteUrl": "",
      "sourceUrl": "https://github.com/easylive1989/LittleFlowerBot",
      "preview": "images/game_bot.png"
    }
  ],
  "tutorialSeries": [
    {
      "name": "30 天學會 Flutter 測試",
      "articles": [
        {
          "title": "Day 1 你準備好一起寫測試了嗎？",
          "summary": "隨著敏捷開發來越流行，我們需要越來越多的跨功能團隊，這些跨功能團隊可以端到端的完成需求，除了寫程式之外，也會需要自己測試功能，甚至有時也會需要處理產品維運的工作。當我們工作越來越多，越來越廣泛，我們的時間開始變得不夠了，如何高效的提升每一個環節的生產效率就變成很重要的工作。 大多數人都是寫完程式碼後...",
          "content": "隨著敏捷開發來越流行，我們需要越來越多的跨功能團隊，這些跨功能團隊可以端到端的完成需求，除了寫程式之外，也會需要自己測試功能，甚至有時也會需要處理產品維運的工作。當我們工作越來越多，越來越廣泛，我們的時間開始變得不夠了，如何高效的提升每一個環節的生產效率就變成很重要的工作。\n\n## 有測試，無懦夫\n\n大多數人都是寫完程式碼後，把程式執行起來，手動測試一下，確認這次完成的功能沒有問題後，就安心的提交程式碼，開始下一個任務。在大公司裡，我們的程式碼提交之後，會有自動化系統把新的程式碼包版交給 QA 測試，若 QA 有發現 Bug，QA 就會開 Ticket 回報給 RD，RD 就可能被迫中斷手上任務，優先處例 Bug。但是在小公司中，如果沒有 QA，而 RD 又沒有仔細回頭測試每一個功能，Bug 就會接變成線上 Bug，被迫加班解 Bug，更慘的是 Bug 越解越多。\n\n![05.jpg](Day%201%20%E4%BD%A0%E6%BA%96%E5%82%99%E5%A5%BD%E4%B8%80%E8%B5%B7%E5%AF%AB%E6%B8%AC%E8%A9%A6%E4%BA%86%E5%97%8E%EF%BC%9F/05.jpg)\n\n如果我們為了確保程式沒有問題，每次新增或修改程式碼後，都手動測試每一項功能，會非常花時間的，隨著功能越來越多，我們就會花越來越多時間在測試，也難以確保每一個行為都被測試到。為此，每當我們改完程式碼後，在花一些時間對這些需求加上測試，隨著一次一次的需求調整，我們的測試也會越來越多，即便未來加了新功能，我們再也不擔心程式出問題了，每晚都可以安心睡覺了。\n\n![p5_XnaKelaOW.jpg](Day%201%20%E4%BD%A0%E6%BA%96%E5%82%99%E5%A5%BD%E4%B8%80%E8%B5%B7%E5%AF%AB%E6%B8%AC%E8%A9%A6%E4%BA%86%E5%97%8E%EF%BC%9F/p5_XnaKelaOW.jpg)\n\n## 系列主題\n\n在這個系列文章中，我們主要會聊三大主題：**單元測試**、**Widget Test** 與 **測試心法**。在單元測試與 Widget Test 主題中，主要由淺入深的介紹單元測試與 Widget Test 如何使用，以會介紹如何處理比較困難的情況，最後我們會介紹一些測試心法，例如：我們該測試什麼，或者是測試要寫多少才夠等等議題，讓我們了解一些測試原則，才能根據自身的狀況靈活調整。\n\n## 單元測試\n\n測試方法有很多種，單元測試、特徵測試、探索測試… 等各種不同測試，不同測試方法的用途與技巧也各不相同，而其中對於開發人員來說，最常使用也比較簡單的就是單元測試。使用單元測試可以讓開發人員快速驗證自己的修改是否有問題，縮短回饋時間，加快開發的速度。如果速度夠快的話，甚至可以五到十分鐘完成測試 → 實作 → 重構循環，每一個循環都能確切地完成一小步，穩定的小步前進，而不是在功能做完之後才發現問題。\n\n![Untitled](Day%201%20%E4%BD%A0%E6%BA%96%E5%82%99%E5%A5%BD%E4%B8%80%E8%B5%B7%E5%AF%AB%E6%B8%AC%E8%A9%A6%E4%BA%86%E5%97%8E%EF%BC%9F/Untitled.png)\n\n出處 [https://agilemania.com/benefits-of-tdd-test-driven-development](https://agilemania.com/benefits-of-tdd-test-driven-development)\n\n## Widget Test\n\n大部分觀眾可能都聽過單元測試，但是對於 Widget Test 就比較陌生， 其實 Widget Test 是一種 UI 測試，更準確來說，是 Component Test，再測試金字塔中屬於最上層。與 UI 測試相同的是，Widget Test 主要測試使用情境，專注於功能操作的黑箱測試。而與 UI 測試不同的是，Widget Test 測試時會隔離外部依賴，讓測試更加穩定與快速。\n\n![test-pyramid.png](Day%2027%20%E6%B8%AC%E8%A9%A6%E8%B6%B3%E5%A4%A0%E4%BA%86%E5%97%8E%EF%BC%9F/test-pyramid.png)\n\n出處 [https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html)\n\n## 測試心法\n\n除了學習如何使用單元測試和 Widget Test 之外，了解測試的基本觀念也是十分重要的，就像天龍八部中的掃地僧說的，修習少林絕技需要學相應的佛法渡化，學寫程式與測試過程中，如果沒有了解一些基本觀念，難免讓技巧方法使用時間點不對，造成日後維護的困難。\n\n## 目標觀眾\n\n這系列文章主要針對如何在 Flutter 中進行測試，適合對測試有興趣的 Flutter 開發者閱讀，文章中也都會盡量舉簡單的例子。這系列文章希望讀者們透過一天的文章，從單元測試的基礎了解，並且搭配簡單的例子，讓讀者更容易理解。\n\n# **Dartpad**\n\n在每天的文章中，如果情況允許的話，我們也會盡量把例子放在 [Dartpad](https://dartpad.dev/?id) 上，讓觀眾可以直接透過 Dartpad 執行與修改，甚至可以動手修改看看。但是當有些套件 Dartpad 可能不支援，我們也會提供盡量提供完整程式碼，讓觀眾可以自行抓下來執行看看。\n\n## 小結\n\n無論單元測試或 Widget Test，或者是其他的端到端測試，都可以保護程式碼，持續驗證功能是否正常。當我們開發了新的功能，也需要即時的補上測試，避免將來因為新的需求去修改程式碼，反而改壞舊有功能而沒發現，每天就能安安穩穩地睡覺了。\n\n## 避免紙上談兵\n\n在本系列文章中，我們將會盡量使用 Dartpad 展示我們的範例，讓觀眾可以在學習的同時，直接打開 Dartpad 自己手動修改看看，理論搭配實踐才是最有效的學習方式。\n\n## DartPad\n\n在系列文章中，每天我們都會分享一種測試情境，在文章中我會盡量搭配 Dartpad 範例，讓讀者閱讀的時候，可以同時有一份可以立即執行的程式碼參考，甚至可以動手修改看看。\n\n如果每次都要讀者自己打開 IDE，然後複製程式碼貼到自己的 IDE，按下執行，其實是會些微的中斷學習效果。流暢的閱讀與實踐，能夠有效地增加學習效果。\n\n不過有些主題可能因為套件 Dartpad 暫時不支援",
          "id": "f82f44f844c549f0bddd52e21429f9da",
          "filename": "Day 1 你準備好一起寫測試了嗎？ f82f44f844c549f0bddd52e21429f9da.md",
          "folderName": "Day 1 你準備好一起寫測試了嗎？",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 2 動手寫一個單元測試",
          "summary": "單元測試是什麼呢？顧名思義，就是針對單元的測試。那什麼又是單元呢？若我們看維基百科的單元測試定義，可以發現在物件導向程式中，單元通常就是指類別裡面的方法。 > 一個單元就是單個程式、函數、過程等；對於物件導向程式設計，最小單元就是方法，包括基礎類別（超類）、抽象類、或者衍生類別（子類）中的方法。 >...",
          "content": "單元測試是什麼呢？顧名思義，就是針對單元的測試。那什麼又是單元呢？若我們看維基百科的單元測試定義，可以發現在物件導向程式中，單元通常就是指類別裡面的方法。\n\n> 一個單元就是單個程式、函數、過程等；對於物件導向程式設計，最小單元就是方法，包括基礎類別（超類）、抽象類、或者衍生類別（子類）中的方法。\n> \n\n所以回到最初的問題，單元測試就是針對一個類別裡面的方法的測試。\n\n## 待測程式\n\n那在開始寫測試之前，得先決定好我們要測試目標是什麼，假設我們已經寫好一個費柏納西數數列的類別，其包含一個 find 方法，輸入數字 n 取得數列第 n 個數字的位置。此時，Fibonacci 就是我們想測試的類別，稱為待測程式，也稱為 SUT ( System Under Test )。\n\n```dart\nclass Fibonacci {\n  int find(int index) {\n\t\tif (index == 0 || index == 1) {\n\t\t\treturn 1;\n\t\t}\n\t  return find(index - 2) + find(index - 1);\n  }\n}\n```\n\n值得注意的是，一個類別可以擁有不只一個測試檔案，當我們測試數量較多時，我們也可以依照不同行為來拆分測試檔案，避免一個測試檔案有過多個測試，造成閱讀測試困難。\n\n## 新增測試檔案\n\n一個類別的測試通常會放在另一個獨立檔案中，在開始寫單元測試之前，我們必須先新增一個檔案，檔案名稱必須以 test 結尾 Flutter 才能辨識這個檔案是測試檔案，當我們跑全測試時，這些測試檔案才會被跑到。在專案目錄底下有一個 test 的目錄，就是讓我們放置這些測試檔案的地方，新增一個 fibonacci_test.dart，然後我們就可以開始寫測試了。\n\n![Untitled](Day%202%20%E5%8B%95%E6%89%8B%E5%AF%AB%E4%B8%80%E5%80%8B%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/Untitled.png)\n\n## 測試執行的進入點\n\n與大多數程式語言相同，Dart 的程式進入點是 main 方法，在測試中也不例外，每個測試檔案中也都會有一個 main 方法，而我們會把測試寫在這個 main 方法中。\n\n```dart\nimport 'package:flutter_test/flutter_test.dart';\n\nmain() {\n  test(\"index 0 should be 1\", () async {\n    \n  });\n}\n```\n\nSUT 包含可能有很多行為，但一個測試就只會挑一個行為來測試，在這邊我們的第一個測試案例就測試費柏納西數列的第一個數字等於 1 吧。\n\n## 該如何寫測試呢？\n\n寫單元測試十分簡單，就跟我們手動測試新功能一樣，我們先想好要測試某個功能，我們會先進到某個頁面，然後操作想測試的功能，最後看看畫面變化是不是跟預期中一樣。\n\n首先，我們會建立 Fibonacci 物件\n\n```dart\nvar fibonacci = Fibonacci();\n```\n\n呼叫 find 方法並帶入參數 0，取得回傳值\n\n```dart\nvar actual = fibonacci.find(0);\n```\n\n最後檢查回傳值是不是等於 1\n\n```dart\nexpect(actual, 1);\n```\n\n最終測試完成之後也就像下面這段一樣\n\n```dart\ntest(\"index 0 should be 1\", () async {\n  var fibonacci = Fibonacci();\n  \n  var actual = fibonacci.find(0);\n  \n  expect(actual, 1);\n});\n```\n\n讓我們執行測試若我們執行 Dartpad 上的例子，測試通過，就完成了第一個單元測試。\n\n```\n00:00 +0: index 0 should be 1\n00:00 +1: All tests passed!\n```\n\n觀眾朋友也可以從 Dartpad 的 Console 中看到結果。\n\n## 3A 原則\n\n從準備、執行、到驗證，這三個步驟是單元測試基本的架構，也稱為 3A 原則：**Arrange**、**Act**、**Assert**。測試程式碼可能或長或短，但不變的是肯定會包含這三個步驟，有時候我們可能會重構測試，讓測試變得簡短，使得這三個步驟就沒有像上面例子那樣明顯分成三段，但是本質上還是三個步驟。\n\n```dart\ntest(\"index 0 should be 1\", () async {\n  expect(Fibonacci().find(0), 1);\n});\n```\n\n開始寫測試時，我們也可以先寫註解，簡單標示一下，依照 3A 原則的話，我們每一步應該要做什麼，當想測試的行為比較複雜時，有助我們更有條理的一步一步完成測試。\n\n```dart\ntest(\"index 4 should be 5\", () async {\n  // Arrang: 建立 Fibonacci\n\n  // Act: 輸入呼叫 get 方法輸入 4\n  \n  // Assert: 確認結果為 5\n});\n```\n\n## 結論\n\n今天介紹了我們如何從無到有的新增一個 Dart 單元測試，也談到單元測試應該有的基本架構，跟隨文章中的步驟，透過一步一步完成，最後就能完成一個簡單的單元測試。還沒寫過單元測試的觀眾朋友們，也可以嘗試在自己的 Side Project 或工作專案中嘗試加上第一個單元測試看看吧。",
          "id": "893744f19afe40c682e802faadfd0e3a",
          "filename": "Day 2 動手寫一個單元測試 893744f19afe40c682e802faadfd0e3a.md",
          "folderName": "Day 2 動手寫一個單元測試",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 3 單元測試不總是那麼容易",
          "summary": "備註: 介紹 Stub 昨天介紹了 Dart 單元測試，如何針對一個簡單的類別進行測試。但是在實務上，沒有任何依賴的類別可能並不多，大部分的類別都是會需要與其他類別協作，這些其他類別有可能是專案內的其他類別，也可能是第三方套件裡面包含的類別，今天就來嘗試針對這些類別寫寫測試吧。 假設我們有一個 Us...",
          "content": "備註: 介紹 Stub\n\n昨天介紹了 Dart 單元測試，如何針對一個簡單的類別進行測試。但是在實務上，沒有任何依賴的類別可能並不多，大部分的類別都是會需要與其他類別協作，這些其他類別有可能是專案內的其他類別，也可能是第三方套件裡面包含的類別，今天就來嘗試針對這些類別寫寫測試吧。\n\n## UserRepository 測試\n\n假設我們有一個 UserRepository，用以讀取使用者資料，這個 Repository 中有一個非同步的 get 方法。在 get 方法中，程式以非同步方式去使用 http 呼叫遠端 Server  的 API，當 Server 還沒有回應時，我們的程式碼並不會佔用資源，而是會繼續執行其他程式碼，例如更新畫面、或者回應使用者操作。最後當 Server 回應後，才會從 await 的部分繼續往下執行。\n\n```dart\nclass UserRepository {\n  Future<User> get(int userId) async {\n    var response = await http.get(Uri.parse(\"https://jsonplaceholder.typicode.com/users/$userId\"));\n\t\n    return User.fromJson(jsonDecode(response.body));\n  }\n}\n```\n\n寫非同步方法的測試跟寫同步方法的測試一樣，都可依照 3A 原則來實踐，唯一稍微不同的呼叫方法，我們在測試中用 async/await 去等待 SUT 的回傳值，寫起來就跟昨天的 Fibonacci 測試幾乎一樣。[[範例連結](https://gist.github.com/easylive1989/9fdbf6ddf7040af928736c0a004d211d)]\n\n```dart\nmain() {\n  test(\"get user ok from api\", () async {\n    var userRepository = UserRepository();\n\n    var user = await userRepository.get(1);\n\n    expect(user, const User(id: 1, name: \"Leanne Graham\"));\n  });\n}\n```\n\n當我們執行測試之後，測試也毫無疑外的成功了，得到了一個**綠燈**，由於大多時候測試通過的圖示都是綠色的，所以我們常使用綠燈表示測試通過。在上面這個測試中，測試跟正式程式碼一樣，執行到 get(1) 的時候，測試會去呼叫遠端 API 取得 User 1 的資料，最後拿著這個資料與預期結果比較。\n\n![Untitled](Day%203%20%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E4%B8%8D%E7%B8%BD%E6%98%AF%E9%82%A3%E9%BA%BC%E5%AE%B9%E6%98%93/Untitled.png)\n\n觀眾朋友一樣可以使用 [Dartpad 範例](https://dartpad.dev/?id=9fdbf6ddf7040af928736c0a004d211d)來執行，不過由於需要呼叫遠端 API，所以執行時間會稍微需要一點時間，不像 Fibonacci 測試那樣快速，這個部分我們未來會討論。\n\n## 確保測試能發揮作用\n\n大多時候，如果我們先寫程式，再寫測試，大多時候會直接得到一個綠燈。但是我們可以再多花一些時間，修改一下測試參數，嘗試把測試改壞，讓測試得到一個**紅燈**，與綠燈相反，因為測試失敗圖示大多為紅色，所以我們也使用紅燈待指測試失敗。\n\n```dart\ntest(\"get user ok from api\", () async {\n  ...\n\n  var user = await userRepository.get(2);\n\n  ...\n});\n```\n\n以 UserRepository 例子來說，只要我們呼叫 userRepository.get(2) 就會得到一個紅燈。\n\n![2.png](Day%203%20%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E4%B8%8D%E7%B8%BD%E6%98%AF%E9%82%A3%E9%BA%BC%E5%AE%B9%E6%98%93/2.png)\n\n那為什麼我們要大費周章的大測試改壞呢？如果我們寫了測試，直接得到一個綠燈，有些時候可能是測試並沒有測到東西，透過輸入錯誤參數來得到錯誤結果，確保未來商業邏輯被改壞時，測試真的能出錯提示我們。一個不會發生錯誤的測試，比完全沒有測試要來得更危險，它會讓我們誤以為我們有測試保護，而放心的重構。但是當我們改壞東西時，這些無用的測試不能及時給我們正確回饋，使我們往錯誤的方向越走越遠。\n\n## 有問題的單元測試\n\n雖然測試通過了，但是這個測試有點問題，那問題是什麼呢？答案是測試缺乏**可重復性**，由於測試在執行的過程中，是直接與遠端 Server 進行互動的，當我們的環境缺乏網路，或者遠端 Server 發生問題時，都會造成測試失敗。當測試有一個以上的失敗原因時，就是在提醒我們這個單元測試可能有問題的訊號。\n\n## 單元測試的特性之一：可重複\n\n單元測試是我們在開發中最頻繁執行的測試，當我們修改了程式碼，可以執行單元測試驗證我們是否有改壞東西，當我們完成需求，也可以執行單元測試驗證需求是否完成。如果執行單元測試時，常常都會因為其他原因造成測試失敗，例如：網路不通或者伺服器掛點，都會降低開發人員使用單元測試的意願，減損單元測試的價值。\n\n想像一下，當有個測試有時好有時壞，壞的原因是因為網路可能當下不通，之前執行個 100 次有 10 次因為網路不通壞掉，當你執行第 101 次壞掉時，你是否會覺得又是網路在搞鬼，而不是程式真的改壞了，然後就直接把程式碼推上去？\n\n單元測試必須能夠重複執行，執行 100 次，100 次都正確通過，避免誤報。當今天測試不通過時，就是真的就是程式碼有問題，這樣才是有效的單元測試。回到我們先前的例子中，由於它需要網路才能執行，可能因為遠端伺服器的好壞造成測試失敗，所以我們必須修改它，使她在每個人的本機上都要能穩定執行。\n\n## 缺乏可測試性\n\n那我們要怎麼讓這個測試具備可重複性呢？答案是沒辦法，由於程式本身就已經寫死用了 http 這個靜態變數，在完全不修改正式程式碼的情況下，我們是很難解決這個問題。若想檢驗設計是否優秀，我們可以觀察程式的可讀性、可維護性、可靠性 …等方面，而其中也包含了可測試性，優秀的程式碼勢必具備可測試性。\n\n為什麼可測試性很重要呢？當我們能在核心商業上加測試，測試重要的商業邏輯，確保這些邏輯沒有問題，最終反應在產品上的結果就是提高品質。除此之外，測試也能有益於團隊，當程式碼改壞時，也能更快的找到問題。\n\n除了我們的程式需要具備可測試性之外，使用第三方套套件時，選擇有支援測試的套件也是十分重要的，能我們的測試更容易寫，在未來的文章中也會談到。\n\n## 小結\n\n今天我們嘗試去測試一個呼叫 API 的情境，測試雖然也能通過，但卻不穩定，因為測試容易受到外部環境的影響，讓測試時好時壞，缺乏可重複性。也因為程式本身缺乏可測試性，我們也難以調整測試，讓測試穩定執行。明天我們就來談談如何修改程式與測試，讓程式具備可測試性，也讓測試具備可重複性。\n\n可能有觀眾朋友會好奇，為什麼測試可以直接加上 async 呢？如果我們直接去看 test 方法的簽章，就會發現 body 的型別是 dynamic Fucntion()，這也意味著我們可以傳各種有任意回傳值的無參數的方法給他，例如 void methodName()、int methodName()，甚至是 Future<int> methodName() …等等，也就解釋了我們怎麼可以隨意地加上 async。\n\n![截圖 2023-07-30 上午10.01.38.png](Day%203%20%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E4%B8%8D%E7%B8%BD%E6%98%AF%E9%82%A3%E9%BA%BC%E5%AE%B9%E6%98%93/%25E6%2588%25AA%25E5%259C%2596_2023-07-30_%25E4%25B8%258A%25E5%258D%258810.01.38.png)\n\n在上面的 async 範例中，我們使用了 Future.delay 來假裝非同步操作，但其實會造成一點小問題，如果我們把 delay 時間改長一點，就會造成測試時間也跟著變長，這就違反了單元測試要執行快速的核心思想，所以我們必須得避免這種情況，在之後的文章中，我們會談論到如何處理。",
          "id": "3d6dd37924f94aa887308d509695be51",
          "filename": "Day 3 單元測試不總是那麼容易 3d6dd37924f94aa887308d509695be51.md",
          "folderName": "Day 3 單元測試不總是那麼容易",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 4 測試替身與依賴注入",
          "summary": "在昨天文章中，我們直接測試了 UserRepository 的 get 方法，在測試中直接呼叫遠端伺服器取得 User 資訊，但是為了測試的**可重複性**，我們必須修改一下程式與測試，讓測試無論在什麼狀況都可以穩定執行，為了調整測試，我們需要兩樣東西的協助才能完成：**測試替身**與**依賴注入*...",
          "content": "在昨天文章中，我們直接測試了 UserRepository 的 get 方法，在測試中直接呼叫遠端伺服器取得 User 資訊，但是為了測試的**可重複性**，我們必須修改一下程式與測試，讓測試無論在什麼狀況都可以穩定執行，為了調整測試，我們需要兩樣東西的協助才能完成：**測試替身**與**依賴注入**。\n\n## 做一個假實作\n\n在原本的測試中，get 方法直接使用 http 套件去呼叫遠端 API，但是在測試中，為了讓測試穩定，我們必須想辦法讓在測試中，把 http 套件替換成假的 http，一個由我們全權控制的 http，讓我們可以控制它回傳假的 User 資料，也可以控制它失敗，所以我們必須測試中做一個假的 Client。\n\n```dart\nclass StubClient implements Client {\n  final http.Response response;\n\n  StubClient(this.response);\n\n  @override\n  Future<http.Response> get(Uri url, {Map<String, String>? headers}) async {\n    return response;\n  }\n\n  @override\n  dynamic noSuchMethod(Invocation invocation) {}\n}\n```\n\n現在我們有了一個假的 Client 了，現在我們得想辦法把它放進 UserRepository 中取代 http。\n\n## 注入假實作\n\n讓我們回顧一下先前的 UserRepository 實作，在原本 get 方法實作中，UserRepository 直接使用 http 呼叫遠端 Server 的 API。\n\n```dart\nclass UserRepository {\n  Future<User> get(int userId) async {\n    var response = await http.get(Uri.parse(\"https://jsonplaceholder.typicode.com/users/$userId\"));\n\t\n    return User.fromJson(jsonDecode(response.body));\n  }\n}\n```\n\n為了讓我們可以把假的 Client 放近 UserRepository 裡面取代 http，我們透過 UserRepository 建構子傳入 Client。在測試中，我們可放入假的 Client，在正式程式碼中，我們也能放入真的 Client，讓 UserRepository 可以正式 App 中呼叫遠端伺服器存取 User 資料。\n\n```dart\nclass UserRepository {\n  final Client _client;\n\n  UserRepository(Client client) : _client = client;\n\n  Future<User> get(int userId) async {\n    var response = await _client.get(Uri.parse(\"https://jsonplaceholder.typicode.com/users/$userId\"));\n    return User.fromJson(jsonDecode(response.body));\n  }\n}\n```\n\n## 調整測試\n\n最後我們調整一下測試，使用 StubClient 搭上一個假的 Response。在修改後的測試中，我們在製作，在這個測試中，我們可以制定任何 Response ，然後最後就可以根據假的 Response 驗證結果。\n\n```dart\nmain() {\n  test(\"get user ok from api\", () async {\n    var fakeClient = StubClient(Response(\"{\\\"id\\\":1, \\\"name\\\": \\\"Tom\\\"}\", 200));\n    \n    var userRepository = UserRepository(fakeClient);\n\n    var user = await userRepository.get(1);\n\n    expect(user, User(id: 1, name: \"Tom\"));\n  });\n}\n```\n\n這個修改過的測試呼叫 get 時，不再跟遠端伺服器互動，而是直接從 StubClient 中取得回傳值。最後，我們的單元測試無論在什麼狀況下，都可以穩定執行成功，再也不會受到其他因數影響導致失敗，測試無論執行幾次，或在誰的電腦上執行，都能有正確的結果。\n\n在我們上面例子中的假實作，我們把假的 Client 命名為 StubClient，那 Stub 是什麼呢？\n\n## Stub 是什麼？\n\n在單元測試中，為了測試的穩定，我們會需要各式各樣的假物件來協助測試，這些假的測試物件也稱為**測試替身**。Stub 就是一種測試替身，專門做假資料提供給 SUT，讓 SUT 可以走到預期的情境，最後驗證 SUT 的回傳值或狀態。\n\n![Untitled](Day%204%20%E6%B8%AC%E8%A9%A6%E6%9B%BF%E8%BA%AB%E8%88%87%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5/Untitled.png)\n\n出處:[http://xunitpatterns.com/Test Double.html](http://xunitpatterns.com/Test%20Double.html)\n\n在上面的圖中，我們一樣會在 Setup、Exercise、Verify 可以對應到 3A 原則的 Arrange、Act、Assert，在使用 Stub 的情境中，我們在 Act 階段，建立了 Stub 塞給 SUT，呼叫 SUT 執行之後，最後在 Verify 階段驗證 SUT 身上的屬性或回傳值。\n\n## 測試替身不只一種\n\n測試替身有很多種，除了 **Stub** 之外，包括 **Dummy**、**Fake**、**Mock**、**Spy**，他們分別在不同的測試場景中發揮功用。\n\nMock：驗證 SUT 與其依賴的互動行為\n\nFake：可以取代真正實作的簡單實作\n\nSpy：提供假資料給 SUT，最後驗證 Spy 身上的狀態\n\nDummy：對於測試沒有影響的假物件\n\n上面只是簡單介紹了測試替身的功用，在未來幾天裡，我們會更詳細的介紹其中幾種，有興趣的觀眾朋友也可以參考 [xUnit Patterns 網站](http://xunitpatterns.com/Test%20Double.html)。\n\n## 依賴注入\n\n光有測試替身是不夠的，我們還得想辦法把替身交給 SUT，讓 SUT 可以與我們的測試替身互動。在上面的例子中，，我們把 StubClient 放入 UserRepository 的方式也稱為依賴注入。在正式程式碼中，常見的方式就是透過套件或框架支援，在物件生成的時候自動透過建構子注入到物件中，在測試中，我們也只要從建構子傳入假物件即可，避免物件間直接耦合造成無法測試。\n\n使用依賴注入除了讓我們測試可以具備可測試性之外，依賴注入也在設計上提供了許多好處\n\n1. 分離製造與組合依賴的職責\n2. 分離控管依賴的生命週期的職責\n3. 對物件的攔截\n\n由於本系列文章主軸還是在測試，所以就不過多敘述，有興趣的朋友可以參考[**依賴注入：原理、實作與設計模式**](https://www.tenlong.com.tw/products/9789864344987)\n\n## 小結\n\n只有當程式具備可測試性，我們才能夠寫測試來保護它。在實務上，我們常常需要測試替身的輔助，但是光有測試替身，如果程式本身並不支援的話，也是巧婦難為無米之炊。所以我們在設計之初，就該考慮程式的可測試性，避免造成測試的麻煩。\n\n也為了讓我們可以把假物件注入待測物件中，我們必須待測物件符合依賴反轉原則，\n\n> 高層次的模組不依賴於低層次的模組的實現細節\n- 依賴反轉原則\n> \n\n[http://xunitpatterns.com/Test Double.html](http://xunitpatterns.com/Test%20Double.html)\n\n[https://stackoverflow.com/questions/28295625/mockito-spy-vs-mock](https://stackoverflow.com/questions/28295625/mockito-spy-vs-mock)\n\n[https://martinfowler.com/articles/mocksArentStubs.html](https://martinfowler.com/articles/mocksArentStubs.html)\n\n[https://dotblogs.com.tw/hatelove/2012/11/29/learning-tdd-in-30-days-day7-unit-testing-stub-mock-and-fake-object-introduction](https://dotblogs.com.tw/hatelove/2012/11/29/learning-tdd-in-30-days-day7-unit-testing-stub-mock-and-fake-object-introduction)",
          "id": "51d7a7b24f834a349495634fbe77feb2",
          "filename": "Day 4 測試替身與依賴注入 51d7a7b24f834a349495634fbe77feb2.md",
          "folderName": "Day 4 測試替身與依賴注入",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 5 這段程式碼改不了",
          "summary": "在昨天的文章中，我們分享了如何透過依賴注入的方式把假的依賴傳入待測物件中，但是如果轉案的程式碼本身沒有這樣的設計，就會很難注入假的依賴，如果我們想改，又可能會牽一髮動全身，容易變成到處都要調整，在 Working Effectively with Legacy Code 中，對於這種沒有測試保護的就...",
          "content": "在昨天的文章中，我們分享了如何透過依賴注入的方式把假的依賴傳入待測物件中，但是如果轉案的程式碼本身沒有這樣的設計，就會很難注入假的依賴，如果我們想改，又可能會牽一髮動全身，容易變成到處都要調整，在 Working Effectively with Legacy Code 中，對於這種沒有測試保護的就稱為 **Legacy Code，**今天就來聊聊如何用調整比較小的方式來解決問題。\n\n在昨天的例子中，UserRepository 的原始設計中並沒有注入 Client 的設計，如果我們像昨天一樣，直接在建構子注入 Client，將會導致所有用到 UserRepository 的地方都要改，如果這是一段 Legacy Code，改起來的風險又更高。\n\n```dart\nclass UserRepository {\n  Future<User> get(int userId) async {\n    var response = await http.get(Uri.parse(\"https://jsonplaceholder.typicode.com/users/$userId\"));\n\t\n    return User.fromJson(jsonDecode(response.body));\n  }\n}\n```\n\n那我們就必須想辦法讓修改的範圍小一點，改小一點，影響範圍可能就會小一些，更重要的是，我們也能針對這個修改的範圍加上測試。\n\n## 多個建構子\n\n首先，我們第一個處理方法就是使用多建構子，在原本 Legacy Code 中，使用 UserRepository 的物件使用前可能會直接使用無參數的建構子來建立 UserRepository，在我們修改 Legacy Code 時，如果想要小範圍的修改，那我們勢必就得維持這個無參數的建構子。\n\n```dart\nclass UserProfileController {\n\tfinal UserRepository _userRepository = UserRepository();\n\t\n\tFuture<User> readName(int userId) {\n\t\treturn (await userRepository.get(userId)).name;\n\t}\n}\n```\n\n讓我們來修改一下 UserRepository，首先我們加入一個注入 Client 的建構子，同時也維持原本的無參數建構子，但是需要注意的是這個無參數的建構子會呼叫注入 Client 的建構子，然後建立 Client 並注入。\n\n```dart\nclass UserRepository {\n  final Client _client;\n\n  UserRepository() : this.create(Client());\n\n  UserRepository.create(Client client) : _client = client;\n\n  Future<User> get(int userId) async {\n    var response = await client.get(Uri.parse(\"https://jsonplaceholder.typicode.com/users/$userId\"));\n    return User.fromJson(jsonDecode(response.body));\n  }\n}\n```\n\n修改完之後，我們除了先前新增的傳入 Client 的建構子之外，又新增了另一個無參數建構子，讓原本使用 UserRepository 無參數建構子的人，依舊可以繼續使用。在無參數建構子的實作中，它建立新的 Client 並傳入另外一個建構子完成類別建構。\n\n## 內在行為大不同\n\n### 生命週期管理失效\n\n使用多建構子來處理非常簡單，大多時候也不會有什麼大問題，但其實這樣的改法稍微地改變了原本的行為。那我們改變了什麼呢？簡單來說就是 Client 的生命週期，在原本使用 http 的邏輯中，http 會自動地去建立 Client，並且在 Client 用完之後關閉並釋放資源。\n\n```dart\n/// 部分 http.dart 原始碼\n\nFuture<Response> get(Uri url, {Map<String, String>? headers}) =>\n    _withClient((client) => client.get(url, headers: headers));\n\nFuture<T> _withClient<T>(Future<T> Function(Client) fn) async {\n  var client = Client();\n  try {\n    return await fn(client);\n  } finally {\n    client.close();\n  }\n}\n```\n\n但是當我們為了測試修改程式碼之後，由於我們自己建立的 Client 物件，Client 的物件再也不是由 http 套件控管，也就不會在呼叫 API 完成後關閉，可能會造成資源無法被釋放。\n\n### 建構物件消耗資源巨大\n\n在原本的 UserRepository 中，只有在真的要打 API 時，http 才會建立 Client。假設建立 Client 十分消耗資源，可能需要花費幾百毫秒，甚至幾千毫秒。那我們把建立 Client 移動到建構子，也會造成 Client 在一開始就被建立並佔據資源，如果後續程式碼沒有真的使用到 Client，就變成了浪費。\n\n## Extra and Override\n\n為了解決上述的問題，我們還可以使用另外一種技巧：**Extract and Override**。在 Dart 中，只要該類別不是 Sealed Class，我們就可以寫另外一個類別繼承它，並且複寫任意方法。 透過這個特性，我們可以使用 **Extract and Override** 來新增一個測試用的類別，讓我們先看看原本的 UserRepository。\n\n```dart\nclass UserRepository {\n  Future<User> get(int userId) async {\n\t  var response = await http.get(Uri.parse(\"https://jsonplaceholder.typicode.com/users/$userId\"));\n    return User.fromJson(jsonDecode(response.body));\n  }\n}\n```\n\n首先，我們先透過 Extract Method 的技巧把 http.get 這個外部依賴抽成另外一個方法。\n\n```dart\nclass UserRepository {\n  Future<User> get(int userId) async {\n    var response = await httpGet(Uri.parse(\"https://jsonplaceholder.typicode.com/users/$userId\"));\n    return User.fromJson(jsonDecode(response.body));\n  }\n\n  Future<http.Response> httpGet(Uri uri) => http.get(uri);\n}\n```\n\n接著我們就能新增一個測試用的 UserRepository，然後把 httpGet 複寫掉，讓他回傳我們想要的 Response。\n\n```dart\nclass TestUserRepository extends UserRepository {\n  final http.Response response;\n\n  TestUserRepository(this.response);\n\n  @override\n  Future<http.Response> httpGet(Uri uri) async => response;\n}\n```\n\n最後我們就能拿著這個 TestUserRepository 完成我們的單元測試了。\n\n```dart\nmain() {\n  test(\"get user ok from api\", () async {\n    var userRepository = TestUserRepository(Response(\"{\\\"id\\\":1, \\\"name\\\": \\\"Tom\\\"}\", 200));\n\n    var user = await userRepository.get(1);\n\n    expect(user, User(id: 1, name: \"Tom\"));\n  });\n}\n```\n\n昨天的測試一樣，測試並不直接跟遠端伺服器互動，而是在本地就能完成，與昨天的測試差別在於，我們是透過繼承與複寫的方式處理的外部依賴。這個技巧再處理 Legacy Code 的時候十分有用，尤其我們並不想修改這個類別的介面更有效。\n\n## 不好測，也意味著壞味道\n\n如果今天我們的程式碼是 Legacy Code，存在無法測試的問題，使得我們必須使用 Extra And Override 來解決問題，這是比較難避免的。但是如果我們新寫的程式碼也必須使用 Extra And Override 時，我們就必須回頭思考設計是否有問題。\n\n大多時候，不好測試也意味著設計可能存在問題，以剛才程式碼為例，UserRepository 違反了 SOLID 中的**依賴反轉原則**， UserRepository 與 http 僅僅耦合在了一起，當未來我們想把儲存 User 的方法從遠端 Server 換成 Local Storage 時，耦合的問題就會讓我們一個頭兩個大，因為修改的範圍可能很大。\n\n關於更多處理 Legacy Code 的技巧，有興趣的觀眾朋友有可以參考 [Working Effectively with Legacy Code : 管理、修改、重構遺留程式碼的藝術](https://www.tenlong.com.tw/products/9789864344000)。\n\n## 小結\n\n雖然使用多建構子的方式會稍微改變程式的行為，但其實處理得當的話，其實並不會造成太大的問題，這樣的作法也比較符合設計原則，往後處理更上層的 Legacy Code 之後，就有機會把無參數建構子拿掉。\n\n但是總有一些特別情況，我們幾乎無法做任何調整，比如說 API 已經開放給別人使用，或者我們一點都不想暴露測試用的 API 使用端，那至少我們還能選擇 Extra and Override 的方式來測試，避免我們先入因 Legacy Code 而無法測試的窘境。",
          "id": "a21ced0c1c2a4b0a90cb269ec28c93a2",
          "filename": "Day 5 這段程式碼改不了 a21ced0c1c2a4b0a90cb269ec28c93a2.md",
          "folderName": "Day 5 這段程式碼改不了",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 6 不改變狀態也不回傳，那我怎麼測試？",
          "summary": "備註: mockito mocktail 介紹 Mock 這幾天的文章中，我們談論如何處理那些頑劣的依賴，透過 Stub 的方式，注入我們設計過的資料到測試之中，最後驗證回傳值或者物件狀態來決定測試成功與失敗。再討論 Stub 的時候，我們介紹了測試替身，也講到測試替身有許多種，今天就介紹另一種測試...",
          "content": "備註: mockito mocktail 介紹 Mock\n\n這幾天的文章中，我們談論如何處理那些頑劣的依賴，透過 Stub 的方式，注入我們設計過的資料到測試之中，最後驗證回傳值或者物件狀態來決定測試成功與失敗。再討論 Stub 的時候，我們介紹了測試替身，也講到測試替身有許多種，今天就介紹另一種測試替身 **Mock** 與它的使用場景吧。\n\n## Mock 是什麼\n\n那 Mock 是什麼呢？在前幾天我們有稍微介紹 **Mock**：Mock 物件用來驗證 SUT 是不是有正確跟這個 Mock 物件正確的互動，如果有正確的呼叫 Mock 物件身上的方法，那測試就會綠燈，反之則會紅燈。那為什麼我們會需要 Mock，想像一下，假設我們想測試的方法沒有回傳值，也不會改變自身的狀態時，我們就無法透過驗證狀態或回傳值等方式來測試，我們只能依靠 Mock 來幫忙驗證互動。\n\n![Untitled](Day%206%20%E4%B8%8D%E6%94%B9%E8%AE%8A%E7%8B%80%E6%85%8B%E4%B9%9F%E4%B8%8D%E5%9B%9E%E5%82%B3%EF%BC%8C%E9%82%A3%E6%88%91%E6%80%8E%E9%BA%BC%E6%B8%AC%E8%A9%A6%EF%BC%9F/Untitled.png)\n\n出處：[http://xunitpatterns.com/Mock Object.html](http://xunitpatterns.com/Mock%20Object.html)\n\n在上圖中，跟 Stub 一樣，我們會在 Arrange 階段建立 SUT 與注入 Mock 物件，也會在 Act 階段呼叫 SUT 身上的方法，但是最後是驗證 Mock 物件，而不是驗證 SUT，讓我們透過實際例子來感受一下 Mock 吧。\n\n## 先舉個例子\n\n假設我們有一個 PurchaseProductService 的類別，當使用者購買商品時，程式會呼叫 PurchaseProductService，檢查錢包是否有足夠錢，然後透過 ProductRepository 呼叫後端 API 購買。往下看之前，有興趣的觀眾朋友可能可以想想看，我們要怎麼測試這個類別。\n\n```dart\nclass PurchaseProductService {\n  final ProductRepository productRepository;\n\n  PurchaseProductService(this.productRepository);\n\n  void execute(Product product, Wallet wallet) {\n    if (product.price > wallet.money) {\n      throw MoneyNotEnoughException();\n    }\n    \n    productRepository.purchase(product);\n  }\n}\n```\n\n這麼方法沒有回傳值，類別本身也沒有狀態可以拿來驗證，我們就沒辦法透過狀態驗證來決定是否成功，那我們要如何解決呢？讓我們手寫一個 Mock 物件來測試這個類別吧，新增一個假的 MockProductRepository 並設定預期的結果給它，然後這個 MockProductRepository 傳入 PurchaseProductService 之中呼叫完 execute 後，呼叫 MockProductRepository.verify 來確認結果是否符合預期，也就是 callCount 要等於 1 且 product 要是 Product(100)。\n\n```dart\nmain() {\n  test(\"purchase product success\", () {\n    var mockProductRepository = MockProductRepository();\n\n    mockProductRepository.setExpectedCallCount(1);\n    mockProductRepository.setExpectedProduct(const Product(100));\n\n    var purchaseProductService = PurchaseProductService(mockProductRepository);\n\n    purchaseProductService.execute(const Product(100), Wallet(200));\n\n    mockProductRepository.verify();\n  });\n}\n\nclass MockProductRepository implements ProductRepository {\n  int expectedCallCount = 0;\n  int actualCallCount = 0;\n  Product? expectedProduct;\n  Product? actualProduct;\n\n  void setExpectedProduct(Product product) {\n    expectedProduct = product;\n  }\n\n  void setExpectedCallCount(int count) {\n    expectedCallCount = count;\n  }\n\n  @override\n  Future<void> purchase(Product product) async {\n    actualProduct = product;\n    actualCallCount ++;\n  }\n\n  void verify() {\n    expect(actualProduct, expectedProduct);\n    expect(actualCallCount, expectedCallCount);\n  }\n}\n```\n\n是不是覺得寫 Mock 物件很累，其實如果真的要使用 Mock，我們有更輕鬆簡單的方式。包含前幾天介紹的 Stub 加上今天介紹的 Mock，當我們需要時，如果都得要花時間自己手刻，未免有點浪費時間，借助測試套件的幫助，讓我們能更快速的產生這些測試替身。\n\n## 讓製作測試替身更容易\n\nFlutter 測試相關的套件有許多，而其中常使用的肯定是 [mockito](https://pub.dev/packages/mockito) 了，與 Java 著名的 Mockito 套件一樣，可以協助我們在測試中製作各式各樣的測試替身。以今天的例子來說，我們可以用 mockito 改寫一下。\n\n```dart\n@GenerateNiceMocks([MockSpec<ProductRepository>()])\nmain() {\n  test(\"purchase product success\", () {\n    var mockProductRepository = MockProductRepository();\n\n    var purchaseProductService = PurchaseProductService(mockProductRepository);\n\n    purchaseProductService.execute(const Product(100), Wallet(200));\n\n    verify(mockProductRepository.purchase(const Product(100))).called(1);\n  });\n}\n```\n\n首先我們得先在 main 上面加上 @GenerateNiceMocks 的 annotation，主要是讓 build_runner 可以自動幫我們產生 Mock 物件，接著我們就能直接使用 MockProductRepository 了，是不是很神奇。如果細心的觀眾朋友可能會注意到，當我們執行完 build_runner，在測試檔案旁邊會多一個 mock 檔案，這裡頭其實就是 mockito 幫我們產生好的 MockProductRepository。\n\n```dart\nclass MockProductRepository extends _i1.Mock implements _i2.ProductRepository {\n  @override\n  _i3.Future<void> purchase(_i2.Product? product) => (super.noSuchMethod(\n        Invocation.method(\n          #purchase,\n          [product],\n        ),\n        returnValue: _i3.Future<void>.value(),\n        returnValueForMissingStub: _i3.Future<void>.value(),\n      ) as _i3.Future<void>);\n}\n```\n\n使用 mockito 來輔助製作 Mock 物件，能省去寫測試替身的時間，讓時間花在更有價值的事情上。雖然我們的例子中都用手寫測試替身來測試，但這只是希望方便大家了解測試替身的內涵，但實務中是不太會這樣做的，大多數語言都有方便製作測試替身的套件，使用這些套件節省時間，讓我們花更多時間專注實作與設計有效的測試案例是比較有價值的。\n\n## Stub 也能用 mockito\n\nmockito 除了可以用來產生 Mock 之外，還能於 Stub 假資料，讓我們改寫一下前幾天的 UserRepository 測試。\n\n```dart\n@GenerateNiceMocks([MockSpec<Client>()])\nmain() {\n  test(\"get user ok from api\", () async {\n    var mockClient = MockClient();\n\n    when(mockClient.get(Uri.parse(\"https://jsonplaceholder.typicode.com/users/1\"))).thenAnswer(\n      (_) async => Response(\"{\\\"id\\\":1, \\\"name\\\": \\\"Tom\\\"}\", 200),\n    );\n\n    var userRepository = UserRepository(mockClient);\n\n    var user = await userRepository.get(1);\n\n    expect(user, User(id: 1, name: \"Tom\"));\n  });\n}\n```\n\n還記得前幾天我們自己實作的 StubClient，我們修改一下測試，改用 mockito 產生一個 MockClient，接著我們能用 mockito 中的 when 方法來作假 MockClient 中的 API 回傳值。以上面的例子來說，我們就指定了 mockClient.get() 在測試中會回傳指定 Response 物件。\n\n## 狀態驗證 vs 行為驗證\n\n至此我們已經認識了兩個最常用的測試替身 Stub 與 Mock 之外，而這兩個測試替身其實也分屬於兩種不同的驗證方式：**狀態驗證**與**行為驗證**。顧名思義，狀態驗證的測試都是驗證物件身上的狀態或回傳值，來確認結果是否符合預期，而行為驗證則是確認 SUT 是否有呼叫依賴身上的方法，來決定結果是否符合預期。\n\n這兩種測試方法倒也沒有誰好誰壞，不同的開發方式，也各自傾向的測試方式，有時候我們會只能驗證狀態，有時候我們只能驗證行為。但是當兩個方法都容易使用的時候，通常會更傾向於使用狀態驗證的方式，使用狀態驗證的測試，比較不容易因為架構調整而需要修改，驗證行為會造成測試認識物件的實作，當實作方式改變時，造成**測試脆弱**的問題。\n\n## 除了 mockito 之外\n\n測試套件除了 mockito 之外，由 **Felix Angelov** 製作的 mocktail 也是不錯的選擇。與 mockito 用法十分類似，一樣是使用 when 來設定假資料，一樣可以用 verify 來驗證互動，只是寫法上稍微有些差別。比較大的不同是，mockito 是使用 @GenerateMocks 或者 @GenerateNiceMocks 加上 build_runner 來產生測試替身，而 mocktail 則是需要自己寫一個 Mock 類別。\n\n```dart\nclass MockClient extends Mock implements Client {}\n```\n\n雖然看似 mocktail 要自己寫比較麻煩，但實際上並不太花時間，有時候反而是反覆執行 build_runner 要更稍微花一點時間。\n\n```dart\nmain() {\n  test(\"get user ok from api\", () async {\n    var mockClient = MockClient();\n\n    when(() => mockClient.get(Uri.parse(\"https://jsonplaceholder.typicode.com/users/1\"))).thenAnswer(\n      (_) async => Response(\"{\\\"id\\\":1, \\\"name\\\": \\\"Tom\\\"}\", 200),\n    );\n\n    var userRepository = UserRepository(mockClient);\n\n    var user = await userRepository.get(1);\n\n    expect(user, User(id: 1, name: \"Tom\"));\n  });\n}\n```\n\n使用哪一個套件，還是可以根據觀眾自己的需求決定即可。\n\n## 小結\n\nMock 主要用於驗證 SUT 與依賴的互動狀況，當測試無法透過狀態驗證來檢查結果時，我們就會建立 Mock 物件來協助檢查互動結果。在實務中，我們常常會使用測試套件來減輕寫測試的負擔，使用測試套件快速建立測試替身。在 Flutter 中，我們可以選擇 mockito 或 mocktail 來 Stub 或 Mock，使用測試套件不但可以減少寫的時候的負擔，也可以減少我們維護的的成本。\n\n## Mock 是最後的選擇\n\n如果我們可以選擇測試回傳值，或者物件身上的狀態，那我們最好不要使用 Mock 的方式驗證。因為 Mock 驗證的 SUT 是否正確地與依賴互動，等同於在測試中指定 SUT 必須要該依賴互動，這會使得當我們未來想修改 SUT 的依賴時，測試也不得不修改，因為測試指定了 SUT 必須要與這個依賴互動。\n\n### 使用 any 讓測試更彈性\n\n在上面測試中，呼叫 when 方法時，我們指定了只有在當使用端傳入特定參數給 mockClient.get 時，才會回應特定回傳值。如果參數不符合，這個設定就不會生效。\n\n```dart\nwhen(mockClient.get(Uri.parse(\"https://jsonplaceholder.typicode.com/users/1\")))\n\nwhen(mockClient.get(any))\n```\n\n但是其實我也可以使用 any ，用以告訴 mockito 無論使用端傳入什麼參數，都一律回傳指定回傳值，這樣會使得測試更加有彈性。",
          "id": "e287e063d9f14227a5ea2e56ff949f6f",
          "filename": "Day 6 不改變狀態也不回傳，那我怎麼測試？ e287e063d9f14227a5ea2e56ff949f6f.md",
          "folderName": "Day 6 不改變狀態也不回傳，那我怎麼測試？",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 7 程式開發不只有正常路徑",
          "summary": "大多時候，我們在實現功能需求時，都是先完成正常流程，也就是順利執行原本預期要執行的操作的情境。在正常流程之外，還有一部份重要的任務需要關注，那就是**錯誤處理**。錯誤處理是什麼？通常我們在方法執行中拋出 Exception，用以表達**可預期的非正常流程，**今天就來聊聊這個錯誤處理的測試要怎麼做...",
          "content": "大多時候，我們在實現功能需求時，都是先完成正常流程，也就是順利執行原本預期要執行的操作的情境。在正常流程之外，還有一部份重要的任務需要關注，那就是**錯誤處理**。錯誤處理是什麼？通常我們在方法執行中拋出 Exception，用以表達**可預期的非正常流程，**今天就來聊聊這個錯誤處理的測試要怎麼做。\n\n## 非正常流程\n\n什麼是非正常流程呢？讓我們看看昨天的 PurchaseProductService 例子，在呼叫 ProductRepository.purchase 方法之前，程式會檢查使用者的錢包裡的餘額是否足夠，當餘額不足時，就拋出 MoneyNotEnoughException。\n\n這個 Exception 會一直往外拋，直到有人使用 try / catch 將它攔截下來處理，一種處理方式就是在 UI 層攔截 Exception，顯示訊息讓使用者知道餘額不足，而這就是**非正常流程**的一個例子。\n\n```dart\nclass PurchaseProductService {\n  final ProductRepository productRepository;\n  final WalletRepository walletRepository;\n\n  PurchaseProductService(this.productRepository, this.walletRepository);\n\n  Future<void> execute(Product product) async {\n    var wallet = await _getWallet();\n    if (product.price > wallet.money) {\n      throw MoneyNotEnoughException();\n    }\n\n    productRepository.purchase(product);\n  }\n\n\tFuture<Wallet> _getWallet() async {\n    return await walletRepository.get();\n  }\n}\n```\n\n當程式執行到這邊發現錢不夠時，程式透過 Exception 中斷操作，並通知呼叫者，這是一個預期會發生的狀況，所以我們也就得想法辦測試它，測試當這個非正常狀況發生時，我們的程式是否會如預期的拋出這個錯誤。\n\n## 如何測試 Exception\n\n測試 Exception 的方法也很簡單，我們可以簡單地在 Act 階段的邏輯上，包上一個 try / catch 攔截錯誤並檢查錯誤是不是 MoneyNotEnoughException，還得記得再 execute 後面多補上一句 assert，確保測試走到不預期的路徑上時，會發生錯誤。\n\n```dart\n@GenerateNiceMocks([MockSpec<ProductRepository>(), MockSpec<WalletRepository>()])\nmain() {\n  test(\"should throw money not enough exception\", () async {\n    var mockProductRepository = MockProductRepository();\n    var mockWalletRepository = MockWalletRepository();\n\n    when(mockWalletRepository.get()).thenAnswer((_) async => Wallet(50));\n\n    var purchaseProductService = PurchaseProductService(mockProductRepository, mockWalletRepository);\n\n    try {\n      await purchaseProductService.execute(const Product(100));\n      assert(false);\n    } catch (e) {\n      expect(e, isA<MoneyNotEnoughException>());\n    }\n  });\n}\n```\n\n上面示範的是測試方式是比較手工的方式，大多時候，我們會使用測試框架提供的更方便的方法，讓我們可以簡單的驗證 Exception，而不用寫太多程式碼，當測試發生錯誤時，訊息也會比較清楚一點。\n\n```dart\n@GenerateNiceMocks([MockSpec<ProductRepository>(), MockSpec<WalletRepository>()])\nmain() {\n  test(\"should throw money not enough exception\", () {\n    var mockProductRepository = MockProductRepository();\n    var mockWalletRepository = MockWalletRepository();\n\n    when(mockWalletRepository.get()).thenAnswer((_) async => Wallet(50));\n\n    var purchaseProductService = PurchaseProductService(mockProductRepository, mockWalletRepository);\n\n    expect(() => purchaseProductService.execute(const Product(100)), throwsA(isA<MoneyNotEnoughException>()));\n  });\n}\n```\n\n與一般驗證相同，我們都是使用 expect 來檢查結果，但在驗證 Exception 的情境中，我們第一個參數會傳入不是一個值，而是一個lambda 方法，在 expect 的部分，我們可以使用 throwsA(isA<ExceptionType>()) 來檢查，從方法名稱上我們就可以很直觀地看出，throwsA 表示預期拋出一個物件，那這個物件是什麼呢？就必須用 isA 來指明物件的型別為 MoneyNotEnoughException。整段合起來看就是，這個 lambda 會拋出一個型別為 MoneyNotEnoughException 的物件。[[範例連結](https://gist.github.com/easylive1989/a563db36e691d02f8b8175249f1dfa7a)]\n\n## Stubbing 一個 Exception\n\n有了測試套件的輔助，我們除了可以驗證 SUT 的非正常流程之外，我們也能設定測試替身丟出 Exception。在 PurchaseProductServcie 的例子中，當程式嘗試透過 WalletRepository 取得錢包時，也有可能會發生錯誤，假設我們修改需求，讓程式取 Wallet 失敗時  Retry 一次。( 只是舉例請勿模仿，這是 Bad Practice XD )\n\n```dart\nclass PurchaseProductService {\n  \n  ...\n\n  Future<Wallet> _getWallet() async {\n    try {\n      return await walletRepository.get();\n    } catch (e) {\n      return await walletRepository.get();\n    }\n  }\n}\n```\n\n讓我們測試當呼叫 WalletRepository.get() 發生錯誤，要再重打一次，總共打兩次的情境吧。\n\n```dart\ntest(\"retry when get wallet fail\", () {\n  var mockProductRepository = MockProductRepository();\n  var mockWalletRepository = MockWalletRepository();\n\n  when(mockWalletRepository.get()).thenThrow(Exception());\n\n  var purchaseProductService = PurchaseProductService(mockProductRepository, mockWalletRepository);\n\n  expect(() => purchaseProductService.execute(const Product(100)), throwsA(isA<Exception>()));\n  verify(mockWalletRepository.get()).called(2);\n});\n```\n\nwhen 除了可以用在 stubbing 假的回傳值之外，我們可以 when 來設定假物件拋出 Exception，藉此來模擬錯誤狀況。在上面的測試中，我們就設定了 mockWalletRepository.get() 會拋出一個 Exception，當程式收到 Exception 時，就會再打一次 mockWalletRepository.get()，包含第一次呼叫，所以驗證呼叫次數總共兩次。[[範例連結](https://gist.github.com/easylive1989/73f6ee540a785ea66f3cebfc442c61b7)]\n\n## 該測試什麼錯誤\n\n如果我們在程式中，主動在非正常流程中拋出 Exception，我們會直覺的為這個情境寫測試，那其他的情況呢？當我們使用 List.first 時，如果 List 中沒有任何元素，呼叫 first 就會丟出 No Element 的錯誤。\n\n```dart\nE get first {\n  Iterator<E> it = iterator;\n  if (!it.moveNext()) {\n    throw IterableElementError.noElement();\n  }\n  return it.current;\n}\n```\n\n那當我們使用 List.first 時，我們要不要處理這個錯誤情況呢？其實答案不一定，端看我們的需求而定，假設在我們的程式中，在不考慮有 Bug 情況下，如果 List 不會出現空的情況，那其實我們不需要測試這個錯誤，因為他不是我們預期的情境。\n\n但是當 List 真的有可能是空的時候呢？那其實我們應該使用 List.first 前檢查是否為空，分別為這兩種狀況做不同處理。\n\n```dart\nvar products = [];\nif (products.isNotEmpty) {\n\tvar firstProduct = products.first;\n\t// ...\n} else {\n\t// ...\n}\n```\n\n甚至也可以在判斷為空的時候，主動拋出 Exception 通知呼叫者。\n\n```dart\nvar products = [];\nif (products.isEmpty) {\n\tthrow ProductsEmptyException();\n}\n```\n\n這兩種處理方式都有各自適合的情境，依照需求選擇即可。有好奇的觀眾朋友可能會問，既然我都要丟 Exception，那我是不是也不用檢查了，反正 List.first 也會拋 Exception 啊？\n\n## Exception vs Error\n\n其實 List.first 拋得並不是 Exception，而是 **Error**，在 Flutter 中 Exception 說明中表示，Exception 可以被程式處理的錯誤，也就是**可預期的非正常流程**。\n\n```\nAn Exception is intended to convey information to the user about a failure, so that the error can be addressed programmatically.\n```\n\n出處：[https://api.flutter.dev/flutter/dart-core/Exception-class.html](https://api.flutter.dev/flutter/dart-core/Exception-class.html)\n\n但是 Error 則不同，Error 的說明表示，Error 是開發人員需要避免的錯誤，簡單來說就是 **Bug**。\n\n```\nAn Error object represents a program failure that the programmer should have avoided.\n```\n\n出處：[https://api.flutter.dev/flutter/dart-core/Error-class.html](https://api.flutter.dev/flutter/dart-core/Error-class.html)\n\n當我們的程式收到 Error 時，表示程式中出現了 Bug，我們要做的事情就是修好它，而不會利用 try / catch 攔截處理它，因為我們很難**正確的處理**我們不預期的狀況，我們最多只能讓他不要出錯，而這是另一個更進階的議題：**容錯處理**，這邊我們就暫時不討論。\n\n回到最初的問題，那我們要處理 List.first 可能會丟出的 Error 嗎？這時我們答案肯定就是否定的，因為 first 他丟出的 Error，我們如果不預期 List 是空的，那我們就該提前處理，而不是讓 Error 噴出，造成開發人員的誤以為有 Bug。\n\n## 小結\n\n錯誤處理是一個比較少被討論的議題，如何處理測試錯誤狀況就又更少討論了。正常流程的是最長被使用的情境，我們得確實地用測試保護它，而出非正常流程雖然是比較次要的，但是我們也不能忽略它，因為他還是使用者會遇到的情境。想像一下，如果程式每次走到非正常流程就當機，使用者體驗肯定不好。\n\n## 題外話\n\n昨天文章中的例子有誤值\n\n搭配 [Guard Clause](https://zh.wikipedia.org/zh-tw/%E5%8D%AB%E8%AF%AD%E5%8F%A5) 提早返回錯誤情況，不必準備太多資料就可以測試錯誤情境了。\n\n## \n\n還有 Error\n\n在 Flutter 中，我們有\n\n我們要測試 Error 嗎\n\n這段程式碼中我們除了丟出例外，還記錄了 在 log ,經驗豐富的觀眾或許知道這邊的 log 是否合適，我們先不談 \n\n這邊我們先討論 log 要測試嗎？想要一張繼續討論這個話題\n\n紀錄",
          "id": "a2c2ef6e973a474490407870c84ec5a1",
          "filename": "Day 7 程式開發不只有正常路徑 a2c2ef6e973a474490407870c84ec5a1.md",
          "folderName": "Day 7 程式開發不只有正常路徑",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 8 假的，都是假的，但不是業障重",
          "summary": "備註: shared preference, Drift 介紹 Fake 嚴謹的單元測試 與 Google 的 Small Test 我們介紹了許多單元測試技巧，可以幫助我們處理難測試的類別、做假資料或隔離外部依賴，這些手段可以處理絕大多數的狀況。如果我們設計物件的時候，都依照 CQS 的概念來把命...",
          "content": "備註: shared preference, Drift 介紹 Fake 嚴謹的單元測試 與 Google 的 Small Test\n\n我們介紹了許多單元測試技巧，可以幫助我們處理難測試的類別、做假資料或隔離外部依賴，這些手段可以處理絕大多數的狀況。如果我們設計物件的時候，都依照 CQS 的概念來把命令與查詢方法分開，當我們針對命令方法寫測試時，會發現常常需要使用 Mock。當我們針對查詢方法寫測試，則比較常使用 Stub，但是今天既不是要講 Stub，也不是 Mock，而是另一個測試替身 **Fake**。\n\n## 舉個例子\n\n假設今天想在電商產品中新增一個我的最愛的功能，使用者可以把喜歡的商品加入我的最愛，然後可以在我的最愛的頁面，看到曾經加入的商品。根據需求，我們做了一個 MyFavorites 類別，身上有一個 add 方法，當使用者在 UI 介面上加入商品到我的最愛時，程式就會來呼叫 MyFavorites 的 add 方法，並把商品 id 放到 SharedPreference 中，以持久化 MyFavorites 的資料。\n\n```dart\nclass MyFavorites {\n  final SharedPreferences _preferences;\n\n  MyFavorites(SharedPreferences preference) : _preferences = preference;\n\n  Future<void> add(Product product) async {\n    var favorites = getAll();\n    favorites.add(product);\n    await _preferences.setStringList(\"favorites\",\n        favorites.map((product) => product.id.toString()).toList());\n  }\n\n  List<Product> getAll() {\n    return _preferences\n            .getStringList(\"favorites\")\n            ?.map((id) => Product(int.parse(id)))\n            .toList() ??\n        [];\n  }\n}\n```\n\n當我們完成功能後，就可以應該順手加上一個測試，一方面驗證程式邏輯是否符合預期，一方面也避免後續重構壞掉，根據前面天介紹的技巧，由於這個方法沒有 return，我們使用 Mock 來測試它。\n\n```dart\ntest(\"add favorite\", () {\n  var mockSharedPreferences = MockSharedPreferences();\n\n  var myFavorites = MyFavorites(mockSharedPreferences);\n\n  myFavorites.add(const Product(1));\n\n  verify(mockSharedPreferences.setStringList(\"favorites\", [\"1\"]));\n});\n```\n\n在上面測試中，當我們呼叫了 add 方法之後，我們使用 Mock 來驗證 add 方法是否正確地與 MockSharedPreference 互動，也確認參數是否符合預期，綠燈通過，看起來也沒什麼問題，再來讓我們看看 getAll 的測試。\n\n```dart\ntest(\"getAll\", () {\n  var mockSharedPreferences = MockSharedPreferences();\n\n  when(mockSharedPreferences.getStringList(\"favorites\")).thenReturn([\"1\"]);\n\n  var myFavorites = MyFavorites(mockSharedPreferences);\n\n  expect(myFavorites.getAll(), [const Product(1)]);\n});\n```\n\n在 getAll 測試中，我們使用 Stub 來設定假資料 [”1”]，並呼叫 getAll 取得回傳值確認結果，也是綠燈通過。[[範例連結](https://gist.github.com/easylive1989/8d5e65a2af7f3c0f8ab4d99a55f6f12b)]\n\n不知道觀眾朋友看完兩個測試之後，有沒有覺得不太對勁的地方？若我們以[黑箱測試](https://zh.wikipedia.org/zh-tw/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95)的角度來看，外面的人對這個物件預期是塞了一個 id = 1 的 Product 進去，要能從 getAll 取回包含 id = 1 的 Product 的 List，那我們是不是能用這種方法測試呢？\n\n## 驗證狀態取代驗證行為\n\n在前幾天的文章中，我們有提到相比於使用驗證互動，我們更傾向於驗證狀態，我們希望能夠呼叫 MyFavorites 的 add 方法後，再驗證 MyFavorites 的 getAll 方法回傳的 MyFavorites，就像下面例子那樣。\n\n```dart\ntest() {\n\t...\n\n\tmyFavorites.add(Product(1));\n\n\texpect(myFavorites.getAll(), [Product(1)]);\n}\n```\n\n但是在 MyFavorites 的例子中，由於 MyFavorites 實際上是交給外部依賴儲存，所以在 Mock 測試中，我們呼叫 add 方法，卻無法用 getAll 方法來取回結果。如果想完成這個驗證狀態的測試，我們就必須請出其他測試替身來幫忙了。\n\n## 測試替身之一：Fake\n\nFake 是一種假的實作，一種可以工作的簡易實作，用來替代真正的產品程式碼。\n\n![Fake Object.gif](Day%208%20%E5%81%87%E7%9A%84%EF%BC%8C%E9%83%BD%E6%98%AF%E5%81%87%E7%9A%84%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%98%AF%E6%A5%AD%E9%9A%9C%E9%87%8D/Fake_Object.gif)\n\n出處：[http://xunitpatterns.com/Fake Object.html](http://xunitpatterns.com/Fake%20Object.html)\n\n同樣以 MyFavorites 例子來說，我們可以做一個 FakeSharePreference 來替代 MockSharePreference。\n\n```dart\nclass FakeSharedPreferences implements SharedPreferences {\n  List<String> fake = [];\n\n  @override\n  Future<bool> setStringList(String key, List<String> value) async {\n    fake = value;\n    return true;\n  }\n\n  @override\n  List<String>? getStringList(String key) {\n    return fake;\n  }\n\n  @override\n  dynamic noSuchMethod(Invocation invocation) => super.noSuchMethod(invocation);\n}\n```\n\n我們在測試中建立一個 FakeSharedPreference 之後，修改一下測試，讓他使用這個假的 SharePreference，最後就能用 getAll 方法取回結果並驗證，綠燈通過。\n\n```dart\ntest(\"add favorite\", () {\n  var fakeSharedPreferences = FakeSharedPreferences();\n\n  var myFavorites = MyFavorites(fakeSharedPreferences);\n\n  myFavorites.add(const Product(1));\n\n  expect(myFavorites.getAll(), [const Product(1)]);\n});\n```\n\n可以發現最後程式碼也變得更好懂一些，這個 FakeSharePreference 也能重複使用在其他與 SharePreference 相依的物件測試中。[[範例連結](https://gist.github.com/easylive1989/2d7090a0e4f52971559d60c906634a96)]\n\n## 使用 Fake 的優勢\n\n與 Mock 相比，在使用 Fake 的測試中，我們能更完整測試一個類別的使用行為。在正式程式碼的行為中，我們如果用 MyFavorites 存了一筆資料，我們就理所當然的能從 MyFavorites 取回一筆資料，在 Fake 測試中也是如此。但是如果我們使用 Mock 來測試的話，在 MyFavorites 中寫了一筆資料，我們是無法從 MyFavorites 中讀回一筆資料的，因為 MockSharedPreference 的 setStringList 方法是假的。\n\n使用 Fake 還有另外一個優點是，當我們調整 MyFavorites 的實作時，相關測試有機會不用跟著大調整。在 Mock 測試中，測試對於 MyFavorites 是如何實作有一定了解，因為測試知道MyFavorites 怎麼使用 SharedPreference 的 setStringList。\n\n讓我們修改一下程式碼，假設 Product 因需求調整多了 type 之後，需要在 SharedPreference 存 json 而非 id。\n\n```dart\nclass MyFavorites {\n  final SharedPreferences _preferences;\n\n  MyFavorites(SharedPreferences preference) : _preferences = preference;\n\n  Future<void> add(Product product) async {\n    var favorites = getAll();\n    favorites.add(product);\n    await _preferences.setStringList(\"favorites\",\n        favorites.map((product) => jsonEncode(product.toJson())).toList());\n  }\n\n  List<Product> getAll() {\n    return _preferences\n        .getStringList(\"favorites\")\n        ?.map((json) => Product.fromJson(jsonDecode(json)))\n        .toList() ??\n        [];\n  }\n}\n```\n\n如果我們執行一下原本的 Mock 程式之後就會發現測試錯了，因為呼叫 SharedPreference 的 setStringList 時所傳入的參數格式完全不一樣了。\n\n![Untitled](Day%208%20%E5%81%87%E7%9A%84%EF%BC%8C%E9%83%BD%E6%98%AF%E5%81%87%E7%9A%84%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%98%AF%E6%A5%AD%E9%9A%9C%E9%87%8D/Untitled.png)\n\n在 Mock 測試中，我們不只需要在 Product 物件上加上 type，還得修改 verify 的預期結果，遇上參數是 json 陣列又更難處理了。類似的事情也得在 getAll 測試上也要再做一次，必須要調整 MockSharedPreference 的 getStringList 方法的回傳值。\n\n```dart\ntest(\"add favorite\", () {\n  var mockSharedPreferences = MockSharedPreferences();\n\n  var myFavorites = MyFavorites(mockSharedPreferences);\n\n  myFavorites.add(const Product(1, \"book\"));\n\n  verify(mockSharedPreferences.setStringList(\"favorites\", ['{\"id\":1,\"type\":\"book\"}']));\n});\n\ntest(\"getAll\", () {\n  var mockSharedPreferences = MockSharedPreferences();\n\n  when(mockSharedPreferences.getStringList(\"favorites\")).thenReturn(['{\"id\":1,\"type\":\"book\"}']);\n\n  var myFavorites = MyFavorites(mockSharedPreferences);\n\n  expect(myFavorites.getAll(), [const Product(1, \"book\")]);\n});\n```\n\n如果我們使用 Fake 來測試，當我們調整需求後，其實也就只是在 Product 上加入新的 type 參數而已，調整幅度縮小許多。\n\n```dart\ntest(\"add favorite\", () {\n  var fakeSharedPreferences = FakeSharedPreferences();\n\n  var myFavorites = MyFavorites(fakeSharedPreferences);\n\n  myFavorites.add(const Product(1, \"book\"));\n\n  expect(myFavorites.getAll(), [const Product(1, \"book\")]);\n});\n```\n\n有興趣的觀眾朋友可以參考這邊 [[Mock 測試修改後範例](https://gist.github.com/easylive1989/ff7b8e6dc989d816a4d4456f0fac1c94)] [[Fake 測試修改後範例](https://gist.github.com/easylive1989/cf674cddffff65d56f6bdf32bbb286ba)]。\n\n## 支援測試的套件\n\n在實務上，我也們能將這個技巧用於資料庫上，比如我們能寫一個用 Memory 儲存資料的 FakeMemoryDB，在測試中讓 SUT 使用這個 FakeMemoryDB，像是真的資料庫一樣。我們先前提過，有些套件對測試有比較好的支援度，讓開發者可以省一些麻煩，例如：[drift](https://pub.dev/packages/drift) 有提供 Memory 版本的資料庫，需要在測試中 Fake 資料庫時就比較方便。\n\n```dart\ntest(\"add favorite\", () async {\n  MyDatabase database = MyDatabase(NativeDatabase.memory());\n\n  var myFavorites = MyFavorites(database);\n\n  await myFavorites.add(const Product(id: 1, type: \"book\"));\n\n  expect(await myFavorites.getAll(), [const Product(id: 1, type: \"book\")]);\n\n  await database.close();\n});\n```\n\n在上面的測試中，我們用 Memory 來替代真的資料庫放在測試中使用，更詳細的例子可以看[[這邊](https://gist.github.com/easylive1989/bfbdc3be0b5f4d552e8f674208942544)]。\n\n## 小結\n\n相比於 Stub 與 Mock，Fake 是比較少聽過的測試替身，但是其實 Fake 相當的好用，尤其是當類別行為會跟於外部依賴的狀態有關時，使用 Fake 能更完整的測試整個類別的行為，而不用把一個完整行為拆分成很多個測試，讓我們能直接測試一個類別的完整行為，除了測試數量可能會少一點之外，測試也不容易因為程式碼一改就壞。\n\n## 題外話\n\nshared_preference 套件本身也有提供 Mock 方法讓我們注入假實作，我們也不一定要選擇自己 Mock 一個 SharedPreference\n\n增加測試的可維護性。\n\n或者少用 mock 因為測試了互動 也同時測試了架構\n\n架構有調整 測試也得調整 造成測試脆弱\n\n##",
          "id": "274481b0fe7047b5993f9eb882a72f61",
          "filename": "Day 8 假的，都是假的，但不是業障重 274481b0fe7047b5993f9eb882a72f61.md",
          "folderName": "Day 8 假的，都是假的，但不是業障重",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 9 如何在 Dart 中輕鬆測試時間",
          "summary": "備註: clock 無論什麼樣的產品，或多或少都會需要時間，可能用來提示使用者，也可能用來計算優惠，說到這裡，聰明的觀眾朋友也就不難猜到今天想討論的一種情境：**時間**。當我們的測試與時間有關時，我們會採用 Stub 的方式做假時間，但是除此之外，在 Dart 中，我們還有可以使用套件來幫忙，話不...",
          "content": "備註: clock\n\n無論什麼樣的產品，或多或少都會需要時間，可能用來提示使用者，也可能用來計算優惠，說到這裡，聰明的觀眾朋友也就不難猜到今天想討論的一種情境：**時間**。當我們的測試與時間有關時，我們會採用 Stub 的方式做假時間，但是除此之外，在 Dart 中，我們還有可以使用套件來幫忙，話不多說，就先舉個例子吧。\n\n## 舉個例子\n\n在 Dart 中，若我們想取得時間，最簡單的方式是透過 DateTime，使用 DateTime 的 now 方法可取得當下時間，若我們想對時間做加減，也可以使用 DateTime 的 add 處理。DateTime 的 now 方法是一個靜態方法，十分方便，在程式的每個角落都可以直接使用。\n\n```dart\nvar now = DateTime.now();\n\nvar tomorrow = now.add(Duration(days: 1));\n```\n\n讓我們修改一下購買商品的例子，假設公司歡慶新年，贈送給每個使用者一張新年折價券，讓使用者在購買商品的時候可以帶入折價券，只限在 1/1 當天購買商品時才可以用，在其他時間則無法使用。\n\n```dart\nclass PurchaseProductService {\n  final ProductRepository productRepository;\n  final WalletRepository walletRepository;\n\n  PurchaseProductService(this.productRepository, this.walletRepository);\n\n  Future<void> execute(Product product, NewYearCoupon? coupon) async {\n    var now = DateTime.now();\n    if (_isUseCoupon(coupon) && !_isFirstOfJanuary(now)) {\n      throw CouponInvalidException();\n    }\n\n    var wallet = await walletRepository.get();\n    if (product.price > wallet.money) {\n      throw MoneyNotEnoughException();\n    }\n\n    productRepository.purchase(product, coupon);\n  }\n\n  bool _isFirstOfJanuary(DateTime now) => now.month == 1 && now.day == 1;\n\n  bool _isUseCoupon(NewYearCoupon? coupon) => coupon != null;\n}\n```\n\n當我們寫完程式，就準備開始寫測試來了，經過一番操作，測試也終於完成。\n\n```dart\n@GenerateNiceMocks([MockSpec<ProductRepository>(), MockSpec<WalletRepository>()])\nmain() {\n  test(\"use coupon when purchase product\", () async {\n    var mockProductRepository = MockProductRepository();\n    var mockWalletRepository = MockWalletRepository();\n\n    var purchaseProductService = PurchaseProductService(mockProductRepository, mockWalletRepository);\n\n    await purchaseProductService.execute(\n        const Product(100), \n        NewYearCoupon());\n\n    verify(mockProductRepository.purchase(\n        const Product(100), \n        NewYearCoupon()),\n    ).called(1);\n  });\n}\n```\n\n但實際執行後，測試卻是失敗的，execute 方法丟出了 CouponInvalidException，這時我們才想到，今天不是 1 月 1 號，所以測試才錯了。[[範例連結](https://gist.github.com/easylive1989/bd7d59b1675f7c608a43cee7408edfde)]\n\n![Untitled](Day%209%20%E5%A6%82%E4%BD%95%E5%9C%A8%20Dart%20%E4%B8%AD%E8%BC%95%E9%AC%86%E6%B8%AC%E8%A9%A6%E6%99%82%E9%96%93/Untitled.png)\n\n## DateTime 難以測試\n\nDateTime 的 now 方法就如同前面所說，是個靜態方法，如果我們沒有作假 DateTime，在實際執行測試時，就會依照當下的時間來測試，如果當下的間剛好符合測試要求，順利通過了，結果過兩天，這個測試又錯了，又過兩天，這個測試又通過了，就會造成 RD 無法得知道理是程式錯了，還是測試有問題，違反了單元測試的可重複性原則。\n\n![3379008-PH.jpg](Day%209%20%E5%A6%82%E4%BD%95%E5%9C%A8%20Dart%20%E4%B8%AD%E8%BC%95%E9%AC%86%E6%B8%AC%E8%A9%A6%E6%99%82%E9%96%93/3379008-PH.jpg)\n\n有些語言有套件可以協助我們作假靜態方法，但是在 Dart 中沒有，所以我們必須自己想辦法處理。\n\n## 注入 TimerRepository\n\n針對這個問題，我們手裡已經有許多方法可以應變，我們選擇注入的方式，建立一個 TimeRepository，其中包含取得 now 的方法，最後注入 PurchaseProductService 使用。\n\n```dart\nclass TimeRepository {\n   DateTime now() => DateTime.now(); \n}\n\nclass PurchaseProductService {\n  final ProductRepository productRepository;\n  final WalletRepository walletRepository;\n  final TimeRepository timeRepository;\n\n  PurchaseProductService(this.productRepository, this.walletRepository, this.timeRepository);\n\n  Future<void> execute(Product product, NewYearCoupon? coupon) async {\n    var now = timeRepository.now();\n    if (_isUseCoupon(coupon) && !_isFirstOfJanuary(now)) {\n      throw CouponInvalidException();\n    }\n\n    ...\n  }\n}\n```\n\n測試的時候就能透過 MockTimeRepository 來做假 now 的時間，最後得到一個綠燈。\n\n```dart\nmain() {\n  test(\"use coupon when purchase product\", () {\n    ...\n\n    var mockTimerRepository = MockTimerRepository();\n\n    when(mockTimerRepository.now()).thenAnswer((_) async => DateTime.parse(\"2023-01-01\"));\n    \n\t\t...\n  });\n}\n```\n\n跟先前談過的一樣，如果這段是 Legacy Code，我們不打算改動太大範圍，使用 Extract And Override 也能解決問題。在時間問題上，除了使用修改設計之外，Dart 官方有提供方便的時間套件，讓我們可以更好的處理這個問題。[[範例連結](https://gist.github.com/easylive1989/581d75fad68315f8d7bb2b6b92f0b46e)]\n\n## clock 套件\n\n[clock](https://pub.dev/packages/clock) 是 Dart 官方開發的的時間套件，主要功能是封裝了 DateTime，並且提供可測試接口，讓我們能可以在不修改程式碼的情況下，在測試中植入假時間，使用上我們只要把 [DateTime.now](http://DateTime.now)() 變成 clock.now()。\n\n```dart\n class PurchaseProductService {\n  ...\n\n  Future<void> execute(Product product, NewYearCoupon? coupon) async {\n    var now = clock.now();\n    if (_isUseCoupon(coupon) && !_isFirstOfJanuary(now)) {\n      throw CouponInvalidException();\n    }\n\n    ...\n  }\n}\n```\n\n測試的時候，我們在測試主體外圍包一個 withClock 並設定時間當下時間，實際執行的時候 clock 的 now 方法取得的時間就會是 withClock 中設定的時間。雖然 clock 與 DateTime 一樣都是靜態方法，但是不同的是 clock 在設計之初就有提供測試接口，讓開發時不必為了時間而多一個依賴，也能輕鬆測試。\n\n```dart\n@GenerateNiceMocks([MockSpec<ProductRepository>(), MockSpec<WalletRepository>()])\nmain() {\n  test(\"use coupon when purchase product\", () async {\n\n    withClock(Clock.fixed(DateTime.parse('2023-01-01')), () async {\n\n      var mockProductRepository = MockProductRepository();\n      var mockWalletRepository = MockWalletRepository();\n\n      when(mockWalletRepository.get()).thenAnswer((_) async => Wallet(100));\n\n      var purchaseProductService = PurchaseProductService(mockProductRepository, mockWalletRepository);\n\n      await purchaseProductService.execute(\n          const Product(100),\n          NewYearCoupon());\n\n      verify(mockProductRepository.purchase(\n          const Product(100),\n          NewYearCoupon()),\n      ).called(1);\n\n    });\n\n  });\n}\n```\n\n[[範例連結](https://gist.github.com/easylive1989/3008aea390455a660a7732bff4665dd2)]\n\n## 相對時間的的測試\n\n在上面的例子中，我們的商業邏輯與特定時間點相關，所以我們不得不在測試的時候給定絕對時間。但是有些時間相關的需求只需要處理時間差的問題即可，這是什麼意思呢？讓我們修改一下需求，當使用者購買商品時，只要優惠券沒有過期，就能照常使用。\n\n```dart\nclass PurchaseProductService {\n\n  ....\n\n  Future<void> execute(Product product, Coupon? coupon) async {\n    var now = DateTime.now();\n    if (coupon?.expiredAt.isBefore(now) ?? false) {\n      throw CouponInvalidException();\n    }\n\n\t\t...\n  }\n}\n```\n\n我們在寫測試的時候，就可以直接使用 DateTime 的 now 方法加上額外時間，模擬優惠未到期的情況。相反的，也可以 DateTime.now() 扣掉一些時間，模擬到期的情況。\n\n```dart\n@GenerateNiceMocks([MockSpec<ProductRepository>(), MockSpec<WalletRepository>()])\nmain() {\n  test(\"use coupon when purchase product\", () async {\n    ...\n    \n\n    const product = Product(100);\n    var coupon = Coupon(\n\t\t\tdiscount: 0.5, \n\t\t\texpiredAt: DateTime.now().add(const Duration(days: 10),\n\t\t));\n\n    await purchaseProductService.execute(product, coupon);\n\n    verify(mockProductRepository.purchase(product, coupon)).called(1);\n  });\n}\n```\n\n[[範例連結](https://gist.github.com/easylive1989/1c3a0f407cc430c8febfe69526ab88da)]\n\n## 靜態方法用與不用\n\nDateTime 的 now 是框架提供的靜態方法，當我們需要取得時間時，無可避免地就得用它，畢竟我們不太可能自己再花時間實現一個取時間的程式碼，對吧，框架都提供了，我們又何必重造輪子呢？但是從上面的例子來說，我們應該也能感受到靜態方法對於程式碼的可測性是有負面效果的。那我們是不是不該使用靜態方法呢？答案顯然不是，畢竟如果靜態方法只有壞處沒有好處的話，也早就消失在語言特性當中了。\n\n那什麼東西適合使用靜態方法呢？除了 DateTime 之外，其實我們在程式中也時常會見到靜態方法，例如：dart:math 中的各種 min、max …等數學運算方法，或者是 int.parse 這種轉換型別的工廠方法，都是適合可以使用靜態方法的例子。\n\n## 小結\n\n時間處理幾乎任何種類的產品都會遇到的問題，若語言本身的時間 API 沒有提供測試接口，那我們在設計之初就得考慮程式碼的可測試性。而在 Dart 中善用 clock 套件，我們能更簡單的解決時間 API 的靜態方法帶來的問題，讓程式具備在測試決定時間的能力。",
          "id": "c61a40d35cdf427b9619aeddfed62d0b",
          "filename": "Day 9 如何在 Dart 中輕鬆測試時間 c61a40d35cdf427b9619aeddfed62d0b.md",
          "folderName": "Day 9 如何在 Dart 中輕鬆測試時間",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 10 測試每執行五秒，開發者就少了五秒",
          "summary": "備註: fakeAsync 在開發的時候，有時候會需要 Scheduler 執行一些定期任務，例如：撈資料到本地端存放、檢查並繼續未完成任務 …等。今天主要討論如何測試 Schedler，這個主題也與時間有點關係，但是跟昨天的主題不太一樣，話不多說，我們直接看一下測試 Scheduler 會碰到什麼...",
          "content": "備註: fakeAsync\n\n在開發的時候，有時候會需要 Scheduler 執行一些定期任務，例如：撈資料到本地端存放、檢查並繼續未完成任務 …等。今天主要討論如何測試 Schedler，這個主題也與時間有點關係，但是跟昨天的主題不太一樣，話不多說，我們直接看一下測試 Scheduler 會碰到什麼問題吧。 \n\n## 假設有個 Scheduler\n\n我們常會用 Scheduler 來執行定期更新資料的任務，像下面這個例子中，我們每五秒會的更新使用者的錢包，讓使用者的錢包常常維持最新的狀態。(P.S. 其實更新資料用 Push 策略是比較效率的做法，而不是使用 Pull 策略，但這邊請先忽略這件事 )\n\n```dart\nclass UpdateWalletScheduler {\n  final WalletRepository walletRepository;\n\n  UpdateWalletScheduler(this.walletRepository);\n\n  void start() {\n    Timer.periodic(const Duration(seconds: 5), (timer) {\n      walletRepository.update();\n    });\n  }\n}\n```\n\n讓我們為這個 Scheduler 寫這個測試，如果之前的所有測試儀樣，準備測試替身，呼叫 SUT 方法，驗證結果。\n\n```dart\n@GenerateNiceMocks([MockSpec<WalletRepository>()])\nmain() {\n  test(\"update wallet after 5 seconds\", () {\n    var mockWalletRepository = MockWalletRepository();\n\n    UpdateWalletScheduler(mockWalletRepository).start();\n\n    verify(mockWalletRepository.update()).called(1);\n  });\n}\n```\n\n很快地就會發現測試失敗了，mockWalletRepository.update() 並沒有成功被呼叫到。[[範例連結](https://gist.github.com/easylive1989/4fc59087a431e71107b28d2f1a6b1b32)]\n\n![Untitled](Day%2010%20%E6%B8%AC%E8%A9%A6%E6%AF%8F%E5%9F%B7%E8%A1%8C%E4%BA%94%E7%A7%92%EF%BC%8C%E9%96%8B%E7%99%BC%E8%80%85%E5%B0%B1%E5%B0%91%E4%BA%86%E4%BA%94%E7%A7%92/Untitled.png)\n\n檢查一下後會發現，程式執行完 start 後，要等五秒之後才會執行 mockWalletRepository.update()，但是測試卻是在 start 之後就馬上驗證，那當然會驗證失敗。那我們應該怎麼修改測試呢？依照最直覺的方式，那我們就老老實實等五秒吧。\n\n```dart\n@GenerateNiceMocks([MockSpec<WalletRepository>()])\nmain() {\n  test(\"update wallet after 5 seconds\", () async {\n      var mockWalletRepository = MockWalletRepository();\n\n      UpdateWalletScheduler(mockWalletRepository).start();\n\n      await Future.delayed(const Duration(seconds: 5));\n\n      verify(mockWalletRepository.update()).called(1);\n  });\n}\n```\n\n在執行 start 之後等待五秒再驗證，測試確實成功了。[[範例連結](https://gist.github.com/easylive1989/e5e7b6a9986b572f6f67dbe4c60ff03b)]\n\n![Untitled](Day%2010%20%E6%B8%AC%E8%A9%A6%E6%AF%8F%E5%9F%B7%E8%A1%8C%E4%BA%94%E7%A7%92%EF%BC%8C%E9%96%8B%E7%99%BC%E8%80%85%E5%B0%B1%E5%B0%91%E4%BA%86%E4%BA%94%E7%A7%92/Untitled%201.png)\n\n但是這個測試執行花費時間很長，開發人員得真的等五秒才會通過，如果我們有很多需要等待一定時間的測試，整體執行時間會變得很長。一旦測試時間花得越久，開發人員就會越來越不願意頻繁執行。\n\n## 單元測試的特性之一：執行快速\n\n除了之前講到的可重複性之外，單元測試還必須執行快速，為什麼需要執行快速呢？當我們每修改一小段程式碼，我們就可以執行單元測試來確認，確認我們這次修改有沒有弄壞東西，快速執行，快速驗證。當測試錯誤的時候，因為我們只有改一小段程式碼，所以我們可以很快發現哪邊改壞了。執行快速的單元測試，可以提供開發人員即時的回饋，縮短開發回饋循環，可以讓我們每一個修改都更有信心。\n\n想像一下如果測試執行時間很長，我們肯定會懶得頻繁執行，想改多一點程式碼後，再來一次執行，結果測試錯了還要回頭找到底是哪裡改壞了，最初是想節省時間，最後反倒是花更多時間。還記得 UserRepository 在測試中直接呼叫遠端 Server 的例子嗎？如果遠端伺服器正在忙，沒空回應，也會卡著我我們的測試，讓測試時間執行很久。\n\n## 使用 fake_async 套件\n\n回到我們剛剛的範例，我們應該如何修改呢？與時間流逝有關的測試，我們可以使用 [fake_async](https://pub.dev/packages/fake_async) 套件，這個套件是由官方維護的套件，可以用於 Future、Stream、Timer 等非同步操作，讓我們用它來修改一下原本的測試。\n\n```dart\n@GenerateNiceMocks([MockSpec<WalletRepository>()])\nmain() {\n  test(\"update wallet after 5 seconds\", () async {\n    fakeAsync((async) {\n      var mockWalletRepository = MockWalletRepository();\n\n      UpdateWalletScheduler(mockWalletRepository).start();\n\n      async.elapse(const Duration(seconds: 5));\n\n      verify(mockWalletRepository.update()).called(1);\n    });\n  });\n}\n```\n\n而修改方法也很簡單，與 clock 的使用方式有點像，只要把測試包在 fakeAsync 方法中，然後當測試執行 start 之後，呼叫 async.elapse 假裝時間經過 5 秒，最後測試通過得到綠燈。[[範例連結](https://gist.github.com/easylive1989/ba7f1503e2b6e0223ab229ee19ef4398)]\n\n用套件雖然可以很好的解決我們的問題，那我們有沒有其他方式呢？\n\n## 讓測試避開框架\n\n讓我們想一下，為什麼這個測試會這麼不好測試？因為我們用到了 Timer 這個框架提供的物件，當我們使用框架或套件的東西時，有可能會變得不好測試，因為這些東西在設計之初可能沒有考慮測試場景。在寫單元測試中，我想要知道的是我們的邏輯是否正確，而不是去測試第三方套件的程式碼邏輯是否正確，在上面使用 fake_async 的測試中，在測試我們自己的邏輯過程中，也同時測試了 Timer 是不是經過五秒之後就會來呼叫我們的方法。\n\n所以我們也可以考慮直接測試任務內容即可。以下面的例子來說，我們可以透過抽取方法的方式，將主要任務抽出成獨立一個方法，並在測試中直接測試這個方法。\n\n```dart\nclass Scheduler {\n  final WalletRepository walletRepository;\n\n  Scheduler(this.walletRepository);\n\n  void start() {\n    Timer.periodic(\n      const Duration(seconds: 5),\n      (timer) => execute(),\n    );\n  }\n\n  void execute() {\n    walletRepository.update();\n  }\n}\n```\n\n修改之後，就像下面這個測試一樣，直接測試 execute 方法的正確性。[[範例連結](https://gist.github.com/easylive1989/2549d97ff58ce876c26772adee622d23)]\n\n```dart\n@GenerateNiceMocks([MockSpec<WalletRepository>()])\nmain() {\n  test(\"should update wallet\", () {\n    var mockWalletRepository = MockWalletRepository();\n\n    UpdateWalletScheduler(mockWalletRepository).execute();\n\n    verify(mockWalletRepository.update()).called(1);\n  });\n}\n```\n\n讓我們比較一下上面介紹這兩個方法\n\n**使用 fake_async**\n\n- 優點：可以完整測試 Scheduler 的行為\n- 缺點：我們要寫的程式碼比較多，如果不熟套件也還要花時間研究\n\n**只測主要任務**\n\n- 優點：測試簡潔易懂\n- 缺點：少測試了設定五秒的部分\n\n如何取捨使用 fake_async 模擬時間流逝，或者直接主要任務的部分，則由觀眾朋友的信心而定，未來的文章中應該會再次談論到這個問題，這邊就先不多說。\n\n## 小結\n\n當我們寫單元測試時，需要注意測試執行是否有過慢的問題，當測試執行太久，就應該思考是否有方法可以加速它，避免測試越跑越慢，使得開發人員不想執行。在時間流逝有關的測試當中，我們可以選擇使用 fake_async 來解決，也可以選擇測試主要任務的部分就好，端看開發者當下的狀況決定。",
          "id": "5317b1228d964fcd837c9122699b1c41",
          "filename": "Day 10 測試每執行五秒，開發者就少了五秒 5317b1228d964fcd837c9122699b1c41.md",
          "folderName": "Day 10 測試每執行五秒，開發者就少了五秒",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 11 我們會重構程式碼，那測試呢？",
          "summary": "備註: 沒講 stup 我們連續講了好幾天的測試，講了如何寫單元測試，如何隔離依賴，又如何測試錯誤，既然我們寫了這麼多測試，我們就得花時間維護。當測試回報錯誤的時候，我們回頭看測試，發現測試寫得一團亂，是不是就開始不太想處理了呢？加上問題可能來得又急又快，可能就直接放棄治療了。所以我們得在平常測試時...",
          "content": "備註: 沒講 stup\n\n我們連續講了好幾天的測試，講了如何寫單元測試，如何隔離依賴，又如何測試錯誤，既然我們寫了這麼多測試，我們就得花時間維護。當測試回報錯誤的時候，我們回頭看測試，發現測試寫得一團亂，是不是就開始不太想處理了呢？加上問題可能來得又急又快，可能就直接放棄治療了。所以我們得在平常測試時，就把測試整理乾淨，當問題來臨時，才不會手忙腳亂。\n\n## 乾淨的測試\n\n如果說重構程式碼，我們有許多設計原則可以遵循，例如：高內聚/低耦合、SOLID 原則 …等等，在正式程式碼中，我們十分在意程式碼是否耦合，是否容易維護，同時也要確保程式碼意圖是否明確。而在測試程式碼，我們首要在意的則是可讀性，畢竟當測試完成之後，我們下次看的時候可能就是出問題的時候，測試越容易理解，我們就能越快發現問題在哪邊。讓我們比兩段測試程式碼看看。\n\n```dart\ntest(\"purchase product success\", () async {\n  var mockProductRepository = MockProductRepository();\n  var mockWalletRepository = MockWalletRepository();\n\n  when(mockWalletRepository.get()).thenAnswer((_) async => Wallet(100));\n\n  var purchaseProductService = PurchaseProductService(\n    mockProductRepository,\n    mockWalletRepository,\n  );\n\n  var coupon = Coupon(discount: 0.5, expiredAt: DateTime.now().add(const Duration(days: 10)));\n  const product = Product(100);\n  await purchaseProductService.execute(product, coupon);\n\n  verify(mockProductRepository.purchase(product, coupon)).called(1);\n});\n```\n\n測試中寫了很多程式碼，包含建立測試替身，設定參數與執行，最後驗證等等。想像一下，三個月後回來看這段測試，可能就必須從頭開始理解。\n\n```dart\ntest(\"purchase product success\", () async {\n  given_wallet(Wallet(100));\n\n  const product = Product(100);\n  var coupon = Coupon(discount: 0.5, expiredAt: after(days: 10));\n\n  await when_purchase(product, coupon);\n\n  then_repository_should_be_call(product, coupon);\n});\n```\n\n比較這兩段程式碼後，可以發現後者比較明確呈現了測試的行為，把不重要的細節隱藏在方法中，並用方法名稱來呈現目的。\n\n在書籍或文章的架構中，作者會用標題概述一下本段內容，寫程式或者寫測試也是同樣的道理，方法名稱就是標題，好的標題能讓人一看就知道方法目的是什麼。當我們了解的重構測試的重要性之後，下一個問題就是，該如何重構測試。\n\n## Setup 與 Teardown\n\n大多數測試框架都會提供一些 Callback，讓我們可以在測試的前後時間點處理一些雜事。Flutter 提供幾個方法讓開發人員使用：\n\n- setUpAll：當**所有測試**開始之前被呼叫\n- setUp：**每一個測試**開始之前被呼叫\n- tearDown：**每一個測試**結束之後被呼叫\n- tearDownAll：當**所有測試**結束之後被呼叫\n\n```dart\nmain() {\n\tsetUp(() {\n\t  mockProductRepository = MockProductRepository();\n\t  mockWalletRepository = MockWalletRepository();\n\t  purchaseProductService = PurchaseProductService(mockProductRepository, mockWalletRepository);\n\t});\n}\n```\n\n在上面的例子中，我們就使用 setUp 來集中處理 Mock 與 SUT 的建立，把一些共用但是不重要的東西放到 Setup 與 Teardown 中，只讓重要的測試流程出現在測試案例中。\n\n## Group 相關測試\n\n當我們在測試某個方法時，可能會針對這個方法設計許多測試案例，而這些相關的測試案例，可以用 group 把他們放在一起，讓開發人員可以從測試中直觀地看出這組測試可能是在測試同一個方法的不同行為。\n\n```dart\nmain() {\n  group(\"purchase product\", (){\n    test(\"purchase success\", () async {\n      // ...\n    });\n\n    test(\"purchase fail\", () {\n      // ...\n    });\n  });\n}\n```\n\n## Given-When-Then 風格\n\n在實務上，我們可以借用 Given-When-Then 風格：Given、When、Then，這個語法通常用在 BDD 中，但是我們也可以把它運用在單元測試裡。Given 對應 3A 原則的 Arrange，而 When 是 Act，而 Then 則是 Assert，測試的細節封裝到方法中，用方法名稱解釋測試每一步的行為，閱讀時就能更快理解這一步驟對目的。\n\n```dart\ngiven_wallet(Wallet(100));\n\nawait when_purchase(product, coupon);\n\nthen_repository_should_be_call(product, coupon);\n```\n\n在上面的例子中，我們運用抽取方法把三個階段的程式碼整理一下，讓測試能直觀的呈現 3A 原則，每一行程式碼都在同一個抽象層次，讓測試更容易理解。\n\n## 用底線區分\n\n除了使用 Given-When-Then 風格之外，我們還在方法名稱上更進一步，若是不習慣看英文的觀眾，用[駝峰式命名法](https://zh.wikipedia.org/zh-tw/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB)來命名的話，可能會不太好閱讀，此時我們可以透過[蛇型命名法](https://zh.wikipedia.org/zh-tw/%E8%9B%87%E5%BD%A2%E5%91%BD%E5%90%8D%E6%B3%95)，在每一個單字之間加上底線，讓單字之間更清楚，幫助我們更快閱讀英文。\n\n```dart\ngiven_wallet(...)\n\nwhen_purchase(...)\n\nthen_repository_should_be_call(...)\n```\n\n這個技巧也是 91 在課堂中分享過的技巧，有興趣的朋友可以參考 [https://tdd.best/author/joeychen/](https://tdd.best/author/joeychen/)。\n\n值得注意的是，如果我們在測試中的方法使用蛇型命名法，可能會被 lint 警告，因為 Dart 預設的方法命名規則是小駝峰。此時我們可以在測試檔案中忽略這個 lint，讓測試中檔案不會到處都是警告。\n\n```dart\n// ignore_for_file: non_constant_identifier_names\n```\n\n以上方法並非強制，更多的是取決於團隊習慣，畢竟閱讀這些測試的是團隊，維護這些測試的也是團隊，如何能增進團隊對於測試的理解速度，也就依賴於團隊自身的習慣。\n\n## 小結\n\n雖然我們提了許多重構測試的方法，但其實重構測試倒是沒有一定要怎麼做才對，而是以團隊習慣為主，畢竟大多時候，閱讀測試的人就是團隊自己，任何有助於團隊閱讀測試或節省寫測試時間的做法，都是十分值得嘗試的。\n\n我們會重構我們的程式碼，讓程式碼增加可讀性與可拓展性，測試也是一樣的道理，我們也需要維護一下測試程式碼的品質，雖然不需要向程式碼一樣運用各式各樣的設計模式與架構，但是還是需要整理\n\n[https://stackoverflow.com/questions/61889572/how-to-ignore-a-lint-rule-for-entire-file-in-flutter](https://stackoverflow.com/questions/61889572/how-to-ignore-a-lint-rule-for-entire-file-in-flutter)",
          "id": "42bf915a378647eb943ea19eaca050c4",
          "filename": "Day 11 我們會重構程式碼，那測試呢？ 42bf915a378647eb943ea19eaca050c4.md",
          "folderName": "Day 11 我們會重構程式碼，那測試呢？",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 12 單元測試回顧",
          "summary": "我們講了這麼多天的單元測試，今天就來小結一下，除了回顧之前提到的一些原則之外，也順便簡單介紹一下一些漏網之魚，讓觀眾朋友們對單元測試原則的有基本了解。 在寫測試的第一天中，我們介紹由 [Bill Wake](https://xp123.com/articles/3a-arrange-act-asse...",
          "content": "我們講了這麼多天的單元測試，今天就來小結一下，除了回顧之前提到的一些原則之外，也順便簡單介紹一下一些漏網之魚，讓觀眾朋友們對單元測試原則的有基本了解。\n\n## 3A 原則\n\n在寫測試的第一天中，我們介紹由 [Bill Wake](https://xp123.com/articles/3a-arrange-act-assert/) 提出的 3A 原則，在測試中運用 3A 原則將測試分成三個部分 Arrange、Act、Assert，與 [Gerard Meszaros](http://xunitpatterns.com/gerardmeszaros.html) **提出的[四階段測試](http://xunitpatterns.com/Four%20Phase%20Test.html)的原理 (Setup、Exercise、Verify、Teardown) 是共通的。\n\n![Untitled](Day%2012%20%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E5%9B%9E%E9%A1%A7/Untitled.png)\n\n出處：[http://xunitpatterns.com/Four Phase Test.html](http://xunitpatterns.com/Four%20Phase%20Test.html)\n\n**Arrange / Setup 階段**\n\n在第一個階段中，我們會準備 SUT 與各式各樣的測試替身，並且設定測試替身的假回傳。\n\n**Act / Exercise 階段**\n\n在第二個階段中，測試會執行 SUT 的方法，並傳入相關參數\n\n**Assert / Verify 階段**\n\n在驗證階段中，我們會驗證結果，有時候使用 SUT 身上的狀態或回傳值來做狀態驗證，有時候則是用 Mock 物件來做行為驗證。\n\n**Teardown 階段**\n\n當測試結束後，我們會清除測試過程中產生的資料，避免這些資料干擾其他測試的結果，確保測試之間的獨立性。\n\n在[重構測試的文章](https://ithelp.ithome.com.tw/articles/10327836)中，我們也提到可以使用 Given-When-Then 風格來為每一階段中的方法命名，提升測試的可讀性。\n\n## FIRST 原則\n\n在[無瑕的程式碼](https://www.tenlong.com.tw/products/9789862017050)中，Uncle Bob 有提到單元測試的 FIRST 原則，這個原則是有五個單字的字首組合而成：**Fast、Independent、Repeatable、Self-Validating、Timely**，我們在過去某幾天的文章中有提到其中的幾個概念。\n\n### Fast 快速\n\nFast 如同字面上的意思一樣，我們也在[文章](https://ithelp.ithome.com.tw/articles/10326493)中談到，單元測試必須執行快速，讓開發人員可以快速檢查程式是不是有問題。當我們修改一段程式碼，馬上執行一下相關的單元測試，如果測試每次都要等個十幾分鐘，就會降低開發人員的執行意願。\n\n### **Independent 獨立**\n\n單元測試之間必須有獨立性，也就是 A 測試與 B 測試之間不能互相影響，也不能有順序性，必須保證 A 測試先執行或 B 測試先執行都沒有差別。那為什麼我們需要有這條呢？原因其實也很簡單，如果 A 與 B 測試之間有相依關係，那 A 測試錯了 B 測試很可能也跟著出錯，導致兩個測試都錯了，導致開發人員誤判兩個地方都有問題。\n\n```dart\nmain() {\n  Calculator calculator = Calculator();\n\n  test(\"0 + 2 = 2\", () {\n    calculator.add(2);\n\n    expect(calculator.result, 2);\n  });\n\n  test(\"2 - 2 = 0\", () {\n    calculator.add(-2);\n\n    expect(calculator.result, 0);\n  });\n}\n```\n\n在上面這個測試中，第一個測試 0 + 2 執行完後，又使用同一個物件繼續執行 2 - 2，雖然兩個測試都能正常通過，但是測試之間有相依性，必須先執行 0 + 2 才能執行 2 - 2 才會通過，反之則會發生錯誤。在 Dart 測試中，如果我們沒有特別設定參數，測試是會依照我們定義的順序執行的，即使如此，我們還是要避免貪圖方便而讓測試之間有關聯，畢竟將來轉換到其他語言或框架時，可能就沒有保證這個順序了。\n\n### Repeatable 可重複性\n\nRepeatable 也就是可重複的，我們在前面的[文章](Day%203%20%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E4%B8%8D%E7%B8%BD%E6%98%AF%E9%82%A3%E9%BA%BC%E5%AE%B9%E6%98%93%203d6dd37924f94aa887308d509695be51.md)有介紹到可重複的重要性，在程式碼沒有錯誤的情況下，測試無論執行幾次，測試都正確通過，開發人員對於測試才會有足夠的信心，\n\n### Self-Validating 自我驗證\n\n在這個原則中，我們希望單元測試可以自我驗證，成功或失敗，都必須要出明確的訊息，不需要開發人員手動的去檢查失敗原因。\n\n- **紅燈與綠燈**\n\n現在 IDE 很多都有整合測試 GUI，當測試成功時，我們可以在畫面上看到綠燈，相反的，測試失敗時，畫面上要出現紅燈，開發人員可以快速確認測試是成功或失敗。\n\n- **避免驗證過多場景**\n\n有時候我們會不自覺在測試中驗證了很多場景，比如說：在測試中同時測試儲值與扣款的行為，當測試失敗時，很難直接看出到底是儲值失敗，還是扣款失敗，這時開發人員就要手動介入檢查。\n\n- **清楚的錯誤訊息**\n\n當測試失敗時，畫面上除了顯示紅燈之外，還會有錯誤訊息也要明確，明確指出是哪個值不符合預期，在訊息中顯示實際值與預期值的差別。不同的測試套件，針對錯誤訊息的顯示方式也可能會不相同，觀眾朋友可以多多比較。\n\n### Timely 及時\n\n在這個原則中，寫正式程式碼之前，我們就應該寫好我們的測試。那為什麼我們要先寫測試呢？\n\n- **讓程式碼依照使用端來設計**\n\n有時候，我們如果先寫完正式程式碼再來測試，有時候會發現程式碼很難測試，此時我們就得回頭改程式碼，形成浪費。不如一開始就寫設計，從使用端來思考物件的介面該長什麼樣子，也讓物件在設計之初就具備可測試性。\n\n- **避免先射箭，再畫靶**\n\n那好奇的觀眾朋友可能會問，正式程式碼都還沒有，那我要測試什麼呢？其實會有這個疑問是因為我們習慣先寫程式，然後依照寫好的程式來設計測試。當我們漏做了某個需求時，我們也跟著忘了測試。但是我們應該反過來，先思考測試，想清楚我們馬上要完成的功能具備什麼行為，把行為寫成測試，然後才寫程式碼來通過測試。當我們熟悉這套流程之後，最後我們也開始往 TDD 的開發方式前進了。\n\n在本系列文章中，由於希望是偏新手向的文章，所以還是先寫程式再來寫測試，就像攀岩的**三點不動一點動**口訣一樣，如果學習的過程新的知識點太多，對於學習的幫助可能有反效果，所以我們在文章中還是維持大多數開發者的習慣，先寫完程式再來測試。\n\n## 測試替身\n\n測試替身這個詞是由 Gerard Meszaros **提出，從電影替身這個詞衍生而來。在單元測試中，我們會用各種不同的測試替身取代真實物件，測試替身根據測試情境需要，提供不同資料給 SUT，我們就能驗證 SUT 走到各種不同的情境後的結果。在前面的文章中我們介紹過，Stub、Mock 與 Fake，就不在講述一次，這邊就來簡單補充一下 Spy 與 Dummy 吧。\n\n### Spy\n\n有些時候，我們的呼叫 SUT 身上的方法後，SUT 做完事情沒有回傳值，也不改變自己身上的狀態，而是去改變依賴物件身上的狀態，在這種情況下，我們或許就可以使用 Spy 來測試。假設\n\n![Untitled](Day%2012%20%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E5%9B%9E%E9%A1%A7/Untitled%201.png)\n\n出處：[http://xunitpatterns.com/Test Spy.html](http://xunitpatterns.com/Test%20Spy.html)\n\n若我們修改一下 MyFavorites 的例子，改成使用 Spy 來測試，用起來其實與 Mock 有一點相似，但不同的是，Mock 在驗證方法是否被呼叫，怎麼被呼叫，而 Spy 則是提供身上的狀態給測試驗證。\n\n```dart\nmain() {\n  test(\"add favorite\", () {\n    var spySharedPreferences = SpySharedPreferences();\n\n    var myFavorites = MyFavorites(spySharedPreferences);\n\n    myFavorites.add(const Product(1));\n\n    expect(spySharedPreferences.fake, ['1']);\n  });\n}\n\nclass SpySharedPreferences implements SharedPreferences {\n  List<String> fake = [];\n\n  @override\n  Future<bool> setStringList(String key, List<String> value) async {\n    fake = value;\n    return true;\n  }\n\n  @override\n  List<String>? getStringList(String key) {\n    return fake;\n  }\n\n  @override\n  dynamic noSuchMethod(Invocation invocation) => super.noSuchMethod(invocation);\n}\n```\n\n### Dummy\n\n在製作 SUT 的過程中，我們會建立許多測試替身來幫忙測試，無論給假資料或者驗證結果。但有時候是 SUT 的建構子或方法的參數需要這個依賴，實際上這個有給或沒給都不影響測試行為時，我們就可以建立 Dummy 給 SUT，讓程式編譯通過即可，最簡單的方式可能就是給一個 null 或一個空物件。\n\n```dart\nmain() {\n\ttest(\"test something\", (){\n\t\t\t...\n\n\t\t\tvar purchaseProductService = PurchaseProductService(mockProductRepository, null);\n\n\t\t\t...\n\t});\n\n}\n```\n\n有興趣的朋友可以參考，[http://xunitpatterns.com/Dummy Object.html](http://xunitpatterns.com/Dummy%20Object.html)\n\n## 小結\n\n單元測試我們差不多就介紹到這邊，介紹的議題不多，但是其實單元測試還是有許多有趣的議題，有些應該也會在未來文章討論到。接下來我們準備進入 Widget Test 的部分了，歡迎有興趣的朋友繼續追蹤收看。\n\n我喜歡先從實踐開始，從實踐中感受到痛，然後才回頭講述理論，理論在工程領域，大多的理論都是由實踐整理歸納而來，若一開始先學習了理論，變成由理論指導實踐，一旦我們不是通盤的了解理論想解決的問題與限制，很容易就變成拿著錘子看什麼都是釘子，一通操作下來，程式反而更難維護了。\n\n[https://martinfowler.com/bliki/GivenWhenThen.html](https://martinfowler.com/bliki/GivenWhenThen.html)\n\n[https://xp123.com/articles/3a-arrange-act-assert/](https://xp123.com/articles/3a-arrange-act-assert/)",
          "id": "91b2ea7322104eb6b6b7b86bae0c60f4",
          "filename": "Day 12 單元測試回顧 91b2ea7322104eb6b6b7b86bae0c60f4.md",
          "folderName": "Day 12 單元測試回顧",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 13 Widget Test 是什麼？",
          "summary": "今天我們要從單元測試進入 Widget Test 的部分了，我們花了十幾天的時間介紹 Dart 的單元測試，也介紹了許多測試相關的概念與技巧，單元測試是最容易寫的測試，其中的概念多多少少也可以運用在 Widget Test 或其他類型測試中，讓我們直接開始介紹 Widget Test 吧。 在 [F...",
          "content": "今天我們要從單元測試進入 Widget Test 的部分了，我們花了十幾天的時間介紹 Dart 的單元測試，也介紹了許多測試相關的概念與技巧，單元測試是最容易寫的測試，其中的概念多多少少也可以運用在 Widget Test 或其他類型測試中，讓我們直接開始介紹 Widget Test 吧。\n\n## 什麼是 Widget Test\n\n在 [Flutter 官方文件](https://docs.flutter.dev/testing/overview#widget-tests)中介紹 Widget Test 是一種 [Component Test](https://martinfowler.com/bliki/ComponentTest.html)，透過模擬使用者操作 UI 的行為，然後驗證畫面結果是否符合預期，有點像是 End to End 測試。在 Widget Test 中，雖然測試會模擬使用者的操作畫面，但實際上在執行 Widget Test 並不會真的看到畫面，也不會真的去打遠端 Server 的 API，所以 Widget Test 的執行速度十分接近單元測試。\n\n|  | Unit | Widget | Integration |\n| --- | --- | --- | --- |\n| Confidence | Low | Higher | Highest |\n| Maintenance cost | Low | Higher | Highest |\n| Dependencies | Few | More | Most |\n| Execution speed | Quick | Quick | Slow |\n\n出處：[https://docs.flutter.dev/testing/overview](https://docs.flutter.dev/testing/overview)\n\n## 為什麼要寫 Widget Test\n\nFlutter 是一個 UI 框架，在開發的時候，假設架構使用 Clean Architecture，我們雖然可以把邏輯都封裝到 Adapter 層或 Use Case 層，甚至 Entity 層，但是 UI 層還是多少會存在著操作 Adapter 層 API 的整合邏輯。此時，使用 Widget Test 來測試，才能測試到這些整合邏輯，也會比單元測試要來的接近實際情況。\n\n那Widget Test 是不是可以取代單元測試呢？答案顯然不是，Widget Test 看起來美好，實際繼上還是有許多不方便的地方，像是除錯比較不方便，或者隨著測試的越外層，測試需要準備的資料也越多，寫起測試來肯定不像單元測試那樣順暢，維護比較麻煩。但是其實這些問題，隨著我們的持續增加我們的測試經驗與技巧，再加上善用 IDE 工具，還是能減少撰寫 Widget Test 的時間，降低開發成本。\n\n## 最簡單的例子\n\n在我們用 flutter 建新專案時，裡頭預設就會包含一個簡單的例子與 Widget Test，讓我們來看看這個簡單的例子。\n\n![](https://raw.githubusercontent.com/easylive1989/images/master/static/images/2023IThome/Day13/1.jpg)\n\n在這個簡單的例子中，每當使用者按一次按鈕，畫面中的數字就會加 1。在範例測試中，也是依循著這個邏輯。\n\n```dart\nvoid main() {\n  testWidgets('Counter increments smoke test', (WidgetTester tester) async {\n    await tester.pumpWidget(const MyApp());\n\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n  });\n}\n```\n\n與單元測試類似，我們一樣是把 Widget Test 的測試案例放在 main 方法中，但是與單元測試不一樣的是，Widget Test 使用 testWidgets 方法來測試，而不是 test。在 testWidgets 的第二個參數會傳入非同步方法，這個非同步方法中有一個 WidgetTester 的參數，這個 WidgetTester 就是我們主要拿來與 Widget 互動的工具。\n\n與單元測試建立 SUT 類似，我們在 Widget Test 中，需要決定要測試哪個 Widget，然後用 WidgetTester.pumpWidget 將 Widget 畫出來。\n\n```dart\nawait tester.pumpWidget(const MyApp());\n```\n\n接著就可以用 tester.tap 模擬使用者點擊 Icon，再 tap 方法中，我們需要使用 Finder 幫我們找出 Icon，把他傳入 tap 方法中，讓程式執行點擊後的動作，使 count 加 1。\n\n```dart\nawait tester.tap(find.byIcon(Icons.add));\n\n```\n\n雖然我們成功地把 count + 1，但是在測試中的畫面還是維持 0，因為 Widget Test 並不會自己刷新畫面，需要我們呼叫 WidgetTester.pump 方法，主動通知 WidgetTester 刷新畫面。\n\n```dart\nawait tester.pump();\n```\n\n最後我們就可以用 expect 來驗證畫面數字是不是變成 1 了\n\n```dart\nexpect(find.text('1'), findsOneWidget);\n```\n\n上面這個例子是十分簡單的 Widget Test 範例，在未來的幾天文章中，我們會介紹如何 Finder 找出各種不同的 Widget 與如何模擬各種使用者操作，透過組合 Finder 與 WidgetTester ，我們就能模擬大部分的情境了。\n\n## 單元測試 vs Widget Test\n\n- **一樣是 3A 原則**\n\nWidget Test 與單元測試在測試的結構上，兩者並沒有多大差別。在單元測試中，我們思考的是要怎麼測試 SUT 的行為，呼叫哪些方法，驗證哪些狀態。來到 Widget Test，我們則是在思考要測試哪個畫面的行為，點擊哪些按鈕，驗證畫面上出現哪些元素，本質上一樣是 3A 原則。\n\n- **測試的角度不同**\n\n寫單元測試時，只要熟悉單元測試的概念，即便不熟悉 Dart 語法或 API，我們寫起來也不會有太大問題，因為單元測試是測試邏輯，對於語言的依賴度不大。但是寫 Widget Test 時，我們測試的角度就是從畫面出發，思考使用者與畫面如何互動，最後在畫面上產生何種結果，這就與單元測試有很大不同。\n\n- **需要學會的測試 API 變多了**\n\n在單元測試中，我們使用的測試 API 基本上只有 expect 與測試替身，但是在 Widget Test 中，我們除了單元測試會用到的 API 之外，我們還要了解如何使用 Finder 找到想要找的 Widget，也要會使用 WidgetTester 的各種 API 模擬使用者操作，學習成本上多了不少。\n\n## 小結\n\n今天是介紹 Widget Test 的第一天，在開發 Flutter 程式的過程中，如果只有使用單元測試，一個完整的使用者行為，可能就會被拆分成好幾段段不同測試，適時使用 Widget Test 反而會比較好測試，維護測試簡單一點。\n\n為什麼需要 Widget Test\n\n假若我們都是使用最嚴謹單元測試的話，我們必須在測試中隔離 UI 的部分，Flutter 是一個 UI 的框架，也就是說我們在測試中不該使用到 Flutter。但不幸的是，有些時候，行為與 UI 可能會緊密相關，當我們去除了 UI 部分，反而會使得測試變得囉唆，甚至失去意義。\n\n沒啥間測試是假議題\n\n熟練測試 寫得快 不花時間\n\n包括善用工具\n\nLive template 快捷鍵\n\n3A 原則並不限制於的單元測試，連同之後我們會討論到 Widget，或者 BDD 等，架構上都是符合 3A 原則的，把在測試中清楚的表達 3A 原則也有助於測試的可讀性，之後我們會談論這個部分。\n\nWidget Test 並不是要測試 Widget 有沒有正常工作，而是我們有沒有正確的使用 Widget，正卻的把這些 Widget 組合起來完成我們的需求\n\n相比於前幾天提到的單元測試，在測試金字塔中 Widget 測試，要比單元測試更上層，穩定度與執行速度較慢。\n\n但是 Flutter 的 Widget 實際上並沒有真正的把畫面渲染出來，所以執行速度與穩定度會相當的接近單元測試，十分適合在開發 Flutter 的過程中一定程度的取代單元測試。\n\n[https://docs.flutter.dev/cookbook/testing/widget/introduction](https://docs.flutter.dev/cookbook/testing/widget/introduction)",
          "id": "aac41dabcbb94046947b76045911ce69",
          "filename": "Day 13 Widget Test 是什麼？ aac41dabcbb94046947b76045911ce69.md",
          "folderName": "Day 13 Widget Test 是什麼？",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 14 Finder 與他們的驗證方式",
          "summary": "在昨天的文章中，我們簡單認識了 Widget Test 什麼，也簡單介紹了一個 Widget Test 例子，但是這肯定遠遠不夠，在昨天的例子中，我們運用 find.text 來確認畫面中是否有預期的文字，驗證最終結果是否符合預期。但是 Finder 可不只能用來找畫面上的文字，今天就來介紹 Fin...",
          "content": "在昨天的文章中，我們簡單認識了 Widget Test 什麼，也簡單介紹了一個 Widget Test 例子，但是這肯定遠遠不夠，在昨天的例子中，我們運用 find.text 來確認畫面中是否有預期的文字，驗證最終結果是否符合預期。但是 Finder 可不只能用來找畫面上的文字，今天就來介紹 Finder 基礎用法吧。\n\n## 驗證 Finder 結果\n\n在 Widget Test 中，我們可以直接使用靜態變數 find 來取得 Finder，可以用來找到各式各樣的 Widget。值得注意的是，我們呼叫 Finder 身上的方法得到的物件並非 Widget 本身，以 find.text() 來說，回傳實作的型別是 _TextFinder ( 前面的底線表示該類別為私有類別 )，不同的方法取回的 Finder 型別也不同，根據想找到 Widget 而定。\n\n當我們呼叫 find.text 得到 Finder 後，與單元測試一樣是用 expect 驗證結果，但是在設定預期值則必須使用 Widget Test 專用的 Matcher。在下面的例子中，我們是使用 findsOneWidget，顧名思義，我們預期找到一個 Widget。\n\n```dart\nexpect(find.text(\"Hello World\"), findsOneWidget);\n```\n\nfindsOneWidget 是一個型別為 _FindsWidgetMatcher 的靜態變數，根據不同的測試情境，還有 findsNothing、findsNWidgets、findsAtLeastNWidgets …等，都是用來檢查畫面中的 Widget 數量是否正確。\n\n再來讓我們繼續看看 Finder 的用法吧。\n\n## 基本 Find 方法\n\nFinder 除了可以用來找畫面上的文字之外，我們可也可以找 Icon，更可以找某個 Widget 類別，甚至我們能直接取得 Widget 本人，讀取 Widget。當我們用 Finder 的方法找到結果時，可以拿來驗證，也可以拿來模擬使用者互動。\n\n```dart\nfind.byIcon(Icons.clear);\n\nfind.byType(ListTile);\n```\n\n以下面這個畫面來舉例，這是一個讓使用者可以更新名字與地址的功能，當使用者按下 Submit 之後，會跳出更新成功的訊息。[[範例連結](https://dartpad.dev/?id=b0c36eeedc6bc6195309044edce82ec9)]\n\n![Untitled](Day%2014%20Finder%20%E8%88%87%E4%BB%96%E5%80%91%E7%9A%84%E9%A9%97%E8%AD%89%E6%96%B9%E5%BC%8F/Untitled.png)\n\n我們可以用 find.byIcon 方法尋找畫面中是否存在正確的 Icon\n\n```dart\ntestWidgets('Counter increments smoke test', (WidgetTester tester) async {\n  await tester.pumpWidget(const MyApp());\n\n  expect(find.byIcon(Icons.abc_outlined), findsOneWidget);\n  expect(find.byIcon(Icons.signpost), findsOneWidget);\n});\n```\n\n也可以用 find.byType 方法尋找畫面中是否出現兩個 Submit 按鈕\n\n```dart\ntestWidgets('Counter increments smoke test', (tester) async {\n  await tester.pumpWidget(const MyApp());\n\n  expect(find.byType(ElevatedButton), findsNWidgets(2));\n});\n```\n\n不過以上這些測試只是舉例，展示一下 Finder 的用法，大多時候，只要畫面細節不具備重要意義，我們大多不太會檢查畫面細節。\n\n## 驗證行為\n\n我們大多時候更想驗證功能是正確，以上面例子來說，我們會想驗證使用者按下 Submit 按鈕之後，畫面有沒有出現更新成功的訊息。\n\n```dart\ntestWidgets('Counter increments smoke test', (tester) async {\n  await tester.pumpWidget(const MyApp());\n\n  await tester.tap(find.byType(ElevatedButton));\n  await tester.pump();\n\n  expect(find.text(\"更新成功\"), findsOneWidget);\n});\n```\n\n但是當我們寫完測試並執行後，測試出現了紅燈，因為畫面上有兩個 ElevatedButton，但是測試不知道要選哪個來按。\n\n```\n══╡ EXCEPTION CAUGHT BY FLUTTER TEST FRAMEWORK ╞════════════════════════════════════════════════════\nThe following assertion was thrown running a test:\nThe finder \"2 widgets with text \"Submit\" (ignoring offstage widgets): [Text(\"Submit\", dependencies:\n[DefaultSelectionStyle, DefaultTextStyle, MediaQuery]), Text(\"Submit\", dependencies:\n[DefaultSelectionStyle, DefaultTextStyle, MediaQuery])]\" (used in a call to \"tap()\") ambiguously\nfound multiple matching widgets. The \"tap()\" method needs a single target.\n```\n\n在 Widget Test 中，有很多方法可以處理這個問題，由於我們知道畫面上有兩個按鈕，而我們想按的是第一個，那我們可以簡單地在 find.byType() 加上 first，選擇第一個按鈕來點。\n\n```dart\nawait tester.tap(find.byType(ElevatedButton).first);\n```\n\n但是其實使用 first 來解決並不理想，還記得我們前面提到的測試可讀性嗎？當閱讀測試的人讀到這邊，看到 first 八成不會知道 first 是什麼？還得回頭去翻產品程式碼才會知道是編輯名字的提交按鈕。\n\n## 用 byKey 提升測試可讀性\n\n在這個例子上，我們也可以稍微修改一下程式碼，在目標 Widget 上加上 Key。\n\n```dart\nElevatedButton(\n  key: ValueKey(\"name-edit-submit-btn\")\n  onPressed: () => _showSuccess(context),\n  child: const Text(\"Submit\"),\n)\n```\n\n就像是 React 中在 DOM 元素上標記 data-testid 一樣，可以在測試中用 data-testid 找到相對應的 Component。在 Flutter 中，Key 除了可以解決 Widget 渲染的問題，也可以讓我們在測試中使用 find.byKey 去找到想要的 Widget。\n\n```dart\ntestWidgets('Counter increments smoke test', (tester) async {\n  await tester.pumpWidget(const MyApp());\n\n  await tester.tap(find.byKey(ValueKey(\"name-edit-submit-btn\")));\n  await tester.pump();\n\n  expect(find.text(\"更新成功\"), findsOneWidget);\n});\n```\n\n除了可以解決 Widget 重複的問題，我們也能同時提升測試的可讀性，測試自己就能表達模擬使用者按哪個按鈕。\n\n## 抽取獨立 Widget\n\n除此之外我們也可以用使用**抽取 Widget** 將 Submit 按鈕獨立抽成一個 Widget，就像抽取方法我們必須給一個適合的方法名稱一樣，我們也能給剛抽出來的 Widget 給一個適合的名字。[[範例連結](https://gist.github.com/easylive1989/88069a560a90317884f5371b0d9650c8)]\n\n```dart\nclass EditNameSubmitButton extends StatelessWidget {\n  const EditNameSubmitButton({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: () => _showSuccess(context),\n      child: const Text(\"Submit\"),\n    );\n  }\n\n  void _showSuccess(BuildContext context) async {\n    ScaffoldMessenger.of(context)\n        .showSnackBar(const SnackBar(content: Text(\"更新成功\")));\n  }\n}\n```\n\n當我們測試時，就可以直接用 byType 方法找到 EditNameSubmitButton。\n\n```dart\ntestWidgets('Counter increments smoke test', (tester) async {\n  await tester.pumpWidget(const MyApp());\n\n  await tester.tap(find.byType(EditNameSubmitButton));\n  await tester.pump();\n\n  expect(find.text(\"更新成功\"), findsOneWidget);\n});\n```\n\n## byKey 或 byType\n\nbyKey 和 byType 都能解決重複 Widget 問題，那我們該怎麼選擇呢？其實我們應該從程式碼來判斷，當一群 Widget 的職責足夠內聚，我們可以把這群 Widget 抽成另一個 Widget，根據其功能來給一個合適的名稱，最後我們就可以用 byType 來測試。反之，當今天 Widget 之間關聯性比較小，我們很難抽出一個獨立有意義的 Widget，就比較傾向於在目標 Widget 上加上 Key ，解決測試麻煩。\n\n只要情況允許，比較推薦使用抽取 Widget，因為抽取一個獨立 Widget 不只有助於測試，也有助於閱讀程式碼，讓簡化 Widget 的職責，就像我們會用抽取方法來隱藏實作細節，抽取 Widget 也會隱藏實作細節，無論是 UI 的細節或功能上的細節。以上面的例子來說，在 EditNameSubmitButton 的實作中只有一個 ElevatedButton，可能就沒什麼必要，因為 EditNameSubmitButton 幾乎等同於 ElevatedButton，此時抽取 Widget 就沒有太大好處。\n\n## 小結\n\n今天介紹了基本的 Finder 與如何在 Widget Test 中驗證結果，也討論到了如何在測試中避免重複 Widget 帶來的麻煩。在 Finder 的用法上還有許多更進階的用法，也會在明天繼續討論，也歡迎有問題留言一起討論。",
          "id": "e2c0a3c7a0dc4a848a277dda6c270973",
          "filename": "Day 14 Finder 與他們的驗證方式 e2c0a3c7a0dc4a848a277dda6c270973.md",
          "folderName": "Day 14 Finder 與他們的驗證方式",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 15 進階的 Finder 用法",
          "summary": "昨天介紹了怎麼用 Finder 與 Matcher 來驗證 Widget 有沒有出現在畫面，也介紹幾種基本的 Finder 用法，和如何解決 Widget 重複的問題。今天會接續昨天的內容，繼續探討 Finder 更多的用法，話不多說，我們馬上開始。 假設我們有一個顯示電器商品詳細資訊的頁面，在頁面...",
          "content": "昨天介紹了怎麼用 Finder 與 Matcher 來驗證 Widget 有沒有出現在畫面，也介紹幾種基本的 Finder 用法，和如何解決 Widget 重複的問題。今天會接續昨天的內容，繼續探討 Finder 更多的用法，話不多說，我們馬上開始。\n\n## 舉個例子\n\n假設我們有一個顯示電器商品詳細資訊的頁面，在頁面中會顯示各式各樣的資訊，包括電器型號、電器長寬高、價格、剩餘數量 …等等。[[範例程式](https://dartpad.dev/?id=a45636e30c4badd2b46cda677f66699f)]\n\n![截圖 2023-09-29 下午1.40.16.png](Day%2015%20%E9%80%B2%E9%9A%8E%E7%9A%84%20Finder%20%E7%94%A8%E6%B3%95/%25E6%2588%25AA%25E5%259C%2596_2023-09-29_%25E4%25B8%258B%25E5%258D%25881.40.16.png)\n\n假設我們想測試畫面上的剩餘數量是 60 這件事情，經過昨天的練習，我們馬上會發現畫面上有兩個 60，我們必須得驗證兩個 60。\n\n```dart\ntestWidgets(\"quantity should be correct\", (tester) async {\n  await tester.pumpWidget(const ProductInfoPage());\n\n  expect(find.text(\"60\"), findsNWidgets(2));\n});\n```\n\n雖然測試通過了，但是仔細一看，測試目的與測試內容並不相符合，我們是想測試剩餘數量，但是因為畫面上出現了兩個 60，使我們不得連同商品的寬一起驗證。\n\n## 組合式 Finder\n\n當畫面上有相同 Widget 重複出現時，我們除了可以使用之前介紹的 byType 或 byKey 處理，但是在上面這個例子中，我們重複的並不是 Widget，而是文字本身。如果我們用 byType 拿回來的東西是 _WidgetTypeFinder，這個 Finder 沒有辦法幫助我們驗證結果是不是 “60”。同樣的 byKey 拿回來的是 _KeyFinder 也沒有辦法解決問題。\n\n此時我們就必須依靠比較特別的 Finder：find.ancestor，顧名思義，這個 Finder 與 Widget 祖先有關。簡單來說，使用 find.ancestor 方法可以幫助我們找到具備指定祖先的 Widget，說起來還是有點複雜，讓我們修改一下上面測試吧，從實際案例中說明吧。\n\n```dart\ntestWidgets(\"quantity should be correct\", (tester) async {\n  await tester.pumpWidget(const ProductInfoPage());\n\n  expect(\n      find.ancestor(\n        of: find.text(\"60\"),\n        matching: find.byType(ProductQuantity),\n      ),\n      findsOneWidget);\n});\n```\n\n在上面的測試中，我們使用 find.ancestor，在 of 參數中傳入我們想找的 Widget，而 matching 參數則是指定想找的 Widget 有指定的祖先。讓我們看看下圖，Text(”60”) 這個 Widget 出現兩次，但是透過指定特聽祖先，我們就能過濾掉存在於 ProductWidth 中的 Text(”60”)，找到 ProductQuantity 中的 Text(”60”)。\n\n![Discuss - ancestor (2).jpg](Day%2015%20%E9%80%B2%E9%9A%8E%E7%9A%84%20Finder%20%E7%94%A8%E6%B3%95/Discuss_-_ancestor_(2).jpg)\n\n與 ancestor 類似方法還有一個，那就是 find.descendant，當我們理解了 ancestor 的用法後，我們就不難理解 descendant 了。同樣的在顯示商品資訊的需求中，畫面有三個 ProductSize，其中一個是顯示產品的寬，如果我們想找到顯示產品的寬的 ProductSize 時，我們就能用 descendant 指定存在特定子孫。\n\n```dart\nfind.descendant(\n  of: find.byType(ProductSize),\n  matching: find.text(\"寬\"),\n)\n```\n\n![Discuss - descendant.jpg](Day%2015%20%E9%80%B2%E9%9A%8E%E7%9A%84%20Finder%20%E7%94%A8%E6%B3%95/Discuss_-_descendant.jpg)\n\n當畫面變得越來越複雜，相同 Widget 被用在越來越多地方，想找到指定 Widget 就變得有些難度，幸好 Widget Test 的 Finder 設計得十分方便，讓我們可以不用花太多力氣就能找到想要的 Widget。但是有些時候，光是使用 Finder，還不夠達到我們的需求，需要真的拿到 Widget 的時後怎麼辦呢？讓我們繼續看下去。\n\n## 驗證 Widget 的屬性\n\n除了驗證 Widget 是否存在，有時我們會需要驗證 Widget 上的屬性是否符合預期。讓我們修改一下需求，在商品資訊畫面中，當數量低於 10 個時，數量文字的顏色要顯示成紅色 [[範例程式](https://dartpad.dev/?id=4363977def7f163c2a55f6c847985b2c)]。這時除了驗證剩餘數量是否顯示正確之外，可能還需要驗證數字的顏色到底對不對。\n\n![截圖 2023-09-29 下午1.53.21.png](Day%2015%20%E9%80%B2%E9%9A%8E%E7%9A%84%20Finder%20%E7%94%A8%E6%B3%95/%25E6%2588%25AA%25E5%259C%2596_2023-09-29_%25E4%25B8%258B%25E5%258D%25881.53.21.png)\n\n我們回顧之前學到的技巧，都是在講如何確認 Widget 有出現在畫面中，但是好像沒看到可以確認顏色有沒有出現在畫面中的 API，那我們要怎麼驗證顏色呢？讓我們先想一想，顏色的資訊是定義在哪邊？顏色資訊是放在 Text 中的 TextStyle 屬性中，所以我們驗證的方式就是確認 TextStyle 中的 color 是不是符合預期，那就來寫測試驗證顏色吧。\n\n```dart\nText(\n  quantity.toString(),\n  style: TextStyle(color: quantity < 10 ? Colors.red : Colors.black),\n),\n```\n\n首先，我們一樣得先用 Finder 找出目標 Widget，接著我們必須使用 Finder 身上的 evaluate 方法取得 Element List，先等一下，什麼是 Element 呢？簡單來說，Element 是 Flutter 框架中的核心，當中包含 Widget 與 RenderObject，控管狀態並決定何時更新畫面的元件，本次鐵人賽中也有許多優秀鐵人有詳細解釋，我們這邊暫不多討論，不然篇幅會過長。\n\n```dart\nvar text = find.text(\"5\").evaluate().single.widget as Text;\n```\n\n讓我們回到 evaluate 方法回傳 Element List 這邊，由於 Finder 可能會找到許多符合條件的 Widget，所以 evaluate 方法回傳的自然也是 List，但是在這個測試中，我們很確定 Text(”5”) 只會有一個，所以我們直接使用 List 的 single 方法取得唯一一個 Element，再從 Element 身上取得 Widget，並強制轉型成我們預期的類型。\n\n```dart\ntestWidgets(\"quantity should be correct\", (tester) async {\n  await tester.pumpWidget(const ProductInfoPage());\n\n  var text = find.text(\"5\").evaluate().single.widget as Text;\n\n  expect(text.style?.color, isSameColorAs(Colors.red));\n});\n```\n\n最後我們就能拿到 Text 本人，並驗證 Text 身上的 TextStyle 中的 color 是不是紅色。除了上面這種寫法之外，WidgetTester 也有提供 API 讓我們直接取得 Widget，裡頭實作一樣是使用 evaluate 方法來取得 Widget，但可以讓寫法變得比較簡潔。\n\n```dart\ntestWidgets(\"quantity should be correct\", (tester) async {\n  ...\n\n  var text = tester.widget<Text>(find.text(\"5\"));\n\n  ...\n});\n```\n\n其實當我們在呼叫 expect 加上 findsOneWidget 驗證 Widget 否出現在畫面上時，裡頭也是用 evaluate 方法拿回 Element List 並檢查數量是否符合預期的。\n\n## 驗證順序是誰的工作\n\n假設我們有一個使用者列表，我們希望畫面上的列表順序是按照使用者字母名稱來排序 [[範例程式](https://dartpad.dev/?id=3afc3270a0d96076ab3b7b4d8b3b9cd9)]。假設我們想驗證畫面上的使用者名稱真的有依照字母排序，我們該如何測試呢？有興趣的觀眾朋友也可以先試試看再繼續往下看。\n\n![截圖 2023-09-29 下午4.23.23.png](Day%2015%20%E9%80%B2%E9%9A%8E%E7%9A%84%20Finder%20%E7%94%A8%E6%B3%95/%25E6%2588%25AA%25E5%259C%2596_2023-09-29_%25E4%25B8%258B%25E5%258D%25884.23.23.png)\n\n其實方法有很多種，最簡單的方式，就是用 byType 方法找出所有 Text，再用 WidgetTester 的 widgetList 取得 Text 本人，然後我們就能檢查這群 Text 的 data 排法是否符合預期了。\n\n```dart\ntestWidgets(\"user should order by alphabetic\", (tester) async {\n  await tester.pumpWidget(const UserListPage(\n    users: [\"Paul\", \"Alex\", \"John\", \"Mary\", \"Bill\", \"Cindy\", \"David\"],\n  ));\n\n  var texts = tester.widgetList<Text>(find.byType(Text));\n\n  expect(\n    texts.map((text) => text.data),\n    [\"Alex\", \"Bill\", \"Cindy\", \"David\", \"John\", \"Mary\", \"Paul\"],\n  );\n});\n```\n\n當然測試方法不只一種，聰明的觀眾肯定能想到更好的辦法測試。但是我們必須小心一件事，跟單元測試一樣，當我們發現不好測試的時候，有可能是設計的問題。\n\n### 職責分離\n\n在上面這個例子中，如果我們的程式架構有分層的話，我們大可以把排序工作交給更內層，更核心的類別去處理，讓 View 專心處理如何組成畫面即可。這樣一來我們就能簡單地用單元測試來測試排序，而不用動用到 Widget Test 了。\n\n## 其他各種不同 Finder\n\n其實還有一個十分強大的 Finder：byWidgetPredicate，這個方法可以傳入一個 Predicate 的 lambda，當 Finder 呼叫 evaluate 得到結果時，讓開發人員可以在測試中動態的決定 Finder 能找到什麼樣的 Widget。\n\n```dart\nfind.byWidgetPredicate((widget) => widget is Text && widget.data == \"Alex\");\n```\n\n以上面這個例子來說，就會找回一個型別為 Text 且裡頭文字是 “Alex” 的 Widget。當 Finder 提供的大部分 API 都不好用時，我們可以考慮使用 byWidgetPredicate。\n\n## 小結\n\nWidget Tester 驗證結果主要是透過 Finder，有許多不同的 Finder 分別提供不一樣的功能，這些 Finder 甚至可以組合再一起使用，能應付各式各樣的情況。在寫 Widget Test 的過程中，熟悉 Finder 的用法幾乎是不可或缺的。\n\n把排序工作從 Widget 身上抽離\n\n在這裡我們無法直接\n\n錯誤圖片\n\n那我們要怎麼處理呢？\n\n畫面上顯示朋友清單，上面有幾個排序方法，讓使用者用 名字排序，國家排序等等\n\n用 Widget Test 側順序 \n\n我們是否可以用單元測試順序\n\n可以\n\n但是會發現，我把本來放在 View 的操作邏輯寫在單元測試裡了\n\n這方法是可以測試 Controller 裡面的邏輯是否正確\n\n## 再次使用隔離框架戰術\n\n那有沒有辦法讓我們隔離 Controller 進行測試呢？\n\n其實也是有的，但是由於 Flutter 框架特性，為了做到這件事，我們大多時候必須在測試中，依靠依賴注入的套件協助\n\n以 riverpod 來說，我們就得 override provider，同樣的使用 GetIt 或者 GetX 的觀眾，也能在測試準備工作中，透過這些套件注入假的 provider 或 controller\n\n## 小結\n\n相比於單元測試，Widget Test 的驗證方式比較複雜，不同的測試，可能需要的驗證方式也不同，學習起來難度比較高，需要靈活運用 FInder。隨著我們 Widget Test 越寫越熟練，我們\n\n有時可能需要思考畫面上出現多個相同元件時，我們要怎麼驗證，有時又可能是 \n\n廢案\n\n相反的，除了 find子孫 之外，我們還有 find祖先 方法可以使用，顧名思義，這個方法可以協助我們定位 parent 中包含 xxx 文字的祖先。當然也不一定只能找文字的祖先，而是可以組合前一個段落的基本 find 方法，例如：find.byIcon，find.byKey …等，可以有非常多種變化，觀眾們也可以自己嘗試看看。\n\n或expect 的第二個參數型態為 dynamic，類似於 Javascript 的動態型別，expect 根據第二個參數傳入不同類型的類別，很智慧的用不同的方式驗證結果。在 Widget Test 驗證時，主要使用，會才會去呼叫 _TextFinder 的。",
          "id": "c5a6cfa9fc274d6ebe34b5428ff07240",
          "filename": "Day 15 進階的 Finder 用法 c5a6cfa9fc274d6ebe34b5428ff07240.md",
          "folderName": "Day 15 進階的 Finder 用法",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 16 Widget Test 尬上測試替身",
          "summary": "大多時候，我們在開發 Flutter 程式時，我們都會依賴遠端 Server 或第三方協作，無論是獲取使用者資訊，或者其他重要資料。我們會直接呼叫遠端 Server 的 Web API，或者是透過套件去使用第三方的 API。在討論單元測試時，我們有談論到如何用測試替身去隔離這些依賴，而同樣的，同樣的...",
          "content": "大多時候，我們在開發 Flutter 程式時，我們都會依賴遠端 Server 或第三方協作，無論是獲取使用者資訊，或者其他重要資料。我們會直接呼叫遠端 Server 的 Web API，或者是透過套件去使用第三方的 API。在討論單元測試時，我們有談論到如何用測試替身去隔離這些依賴，而同樣的，同樣的 Widget Test 也可以，今天就來談談如何在 Widget Test 中使用測試替身吧。\n\n## 呼叫 API\n\n假設我們有一個顯示狗狗的各種品種的 Widget，在這個範例中我們會使用 [Dog API](https://dog.ceo/dog-api/) 取得品種的列表。\n\n![Untitled](Day%2016%20Widget%20Test%20%E5%B0%AC%E4%B8%8A%E6%B8%AC%E8%A9%A6%E6%9B%BF%E8%BA%AB/Untitled.png)\n\n實作一個 DogBreedsWidget 中，然後在 Widget 中建立 DogRepository 並呼叫 get 方法，最後由 FutureBuilder 等待與顯示畫面。[[範例連結](https://dartpad.dev/?id=2112109aa06767cb408c9c77f67bfb8c)]\n\n```dart\nclass DogBreedsWidget extends StatelessWidget {\n  const DogBreedsWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return FutureBuilder<List<String>>(\n      future: DogRepository().get(),\n      builder: (context, snapshot) {\n        if (!snapshot.hasData) {\n          return const CircularProgressIndicator();\n        }\n\n        return ListView.builder(\n          itemCount: snapshot.data!.length,\n          itemBuilder: (context, index) {\n            return ListTile(\n              title: Text(snapshot.data![index]),\n            );\n          },\n        );\n      },\n    );\n  }\n}\n\nclass DogRepository {\n  Future<List<String>> get() async {\n    var response = await http.get(Uri.parse(\"https://dog.ceo/api/breeds/list/all\"));\n    return jsonDecode(response.body)[\"message\"].keys.toList();\n  }\n}\n```\n\n如果我們直接為這個 Widget 寫 Widget Test 並執行，然後就會發現測試出現紅燈。\n\n```dart\nvoid main() {\n  testWidgets(\"show breed in dog app\", (tester) async {\n    await tester.pumpWidget(const MaterialApp(home: DogBreedsWidget()));\n\n    expect(find.text(\"affenpinscher\"), findsOneWidget);\n    expect(find.text(\"african\"), findsOneWidget);\n    expect(find.text(\"airedale\"), findsOneWidget);\n  });\n}\n```\n\n我們仔細看錯誤訊息的話，會發現 Widget Test 與單元測試不同，在 Widget Test 中並不會真的去打遠端 API，而是需要我們做假資料給他的。\n\n```\nWarning: At least one test in this suite creates an HttpClient. When\nrunning a test suite that uses TestWidgetsFlutterBinding, all HTTP\nrequests will return status code 400, and no network request will\nactually be made. Any test expecting a real network connection and\nstatus code will fail.\nTo test code that needs an HttpClient, provide your own HttpClient\nimplementation to the code under test, so that your test can\nconsistently provide a testable response to the code under test.\n```\n\n## 注入 DogRepository 到 Widget 中\n\n讓我們稍微修改一下程式碼，與單元測試的注入技巧一樣，把 DogRepository 傳入 Widget 中，讓 Widget 使用傳入的外部依賴，這樣一來，當我們測試 Widget 時，就能控制結果了。[[範例連結](https://dartpad.dev/?id=f5f93ee63223615b2f3c29bbad49bb1f)]\n\n```dart\nclass DogBreedsWidget extends StatelessWidget {\n  const DogBreedsWidget({super.key, required this.dogRepository});\n\n  final DogRepository dogRepository;\n\n  @override\n  Widget build(BuildContext context) {\n    return FutureBuilder<List<String>>(\n      future: dogRepository.get(),\n      builder: (context, snapshot) {\n        if (!snapshot.hasData) {\n          return const CircularProgressIndicator();\n        }\n\n        return ListView.builder(\n          itemCount: snapshot.data!.length,\n          itemBuilder: (context, index) {\n            return ListTile(\n              title: Text(snapshot.data![index]),\n            );\n          },\n        );\n      },\n    );\n  }\n}\n```\n\n同時，我們也修改測試，增加 MockDogRepository 做假資料，在測試中傳入 DogBreedsWidget 中，驗證結果部分沒有變動。\n\n```dart\n@GenerateNiceMocks([MockSpec<DogRepository>()])\nvoid main() {\n  testWidgets(\"show breed in dog app\", (tester) async {\n    MockDogRepository mockDogRepository = MockDogRepository();\n    when(mockDogRepository.get()).thenAnswer(\n      (invocation) async => [\"affenpinscher\", \"african\", \"airedale\"],\n    );\n\n    await tester.pumpWidget(MaterialApp(home: DogBreedsWidget(dogRepository: mockDogRepository)));\n    await tester.pump();\n\n    expect(find.text(\"affenpinscher\"), findsOneWidget);\n    expect(find.text(\"african\"), findsOneWidget);\n    expect(find.text(\"airedale\"), findsOneWidget);\n  });\n}\n```\n\n最後我們也成功得到一個綠燈了。\n\n## 層層注入的麻煩\n\n在其他框架例如 C# 的 .NET Core 或 Java 的 Spring Boot 中，都自帶有依賴注入，只要我們在類別的建構子定義好依賴，框架就會在需要的時候幫我們注入，我們幾乎不需要手動 new 一個類別。\n\n但是在 Flutter 中，由於 Flutter 的宣告式 UI 設計，讓我們開發畫面的時後，都必須在程式碼中 new Widget，然後管理 Widget 之間的上下層關係。也因為每個 Widget 都是自己 new 出來的，所以如果要從建構子注入依賴，也只能手動注入。像是上面例子，假設 DogBreedsWidget 外面還有一個 AnimalWidget 和 LiveBeingWidget 的話，那我們要怎麼把 DogRepository 交給 DogBreedsWidget 呢？\n\n![Discuss - Repository passing issue.jpg](Day%2016%20Widget%20Test%20%E5%B0%AC%E4%B8%8A%E6%B8%AC%E8%A9%A6%E6%9B%BF%E8%BA%AB/Discuss_-_Repository_passing_issue.jpg)\n\n我們在 main 方法建立所有依賴，然後把依賴傳給第一層 LiveBeingWidget，LiveBeingWidget 傳給第二層 AnimalWidget，以此累推，無窮無盡。當專案一大，帶來的維護麻煩肯定是超乎想像。\n\n為了處理這個問題，我們通常會找一些套件例如：Provider 或 getIt 來處理依賴注入，或者是使用 riverpod、Bloc 這種本身也提供依賴注入功能的狀態管理套件。\n\n## 使用 Provider\n\n如果我們使用 Provider 來修改一下，讓 DogBreedsWidget 不再傳入 DogRepository，而是從 Provider 身上取得。正式程式中，就可以在最上層 Widget 包上 Provider，此後在 Widget 的任何地方就都能使用 [context.read](http://context.read) 取得 Repository 了。[[範例連結](https://dartpad.dev/?id=e7ab076476a74d8188ee6d976f4a3af6)]\n\n```dart\nmain() {\n  runApp(\n    Provider(\n      create: (context) => DogRepository(),\n      child: const MaterialApp(home: DogBreedsWidget()),\n    ),\n  );\n}\n\nclass DogBreedsWidget extends StatelessWidget {\n  const DogBreedsWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    var repository = context.read<DogRepository>();\n\n    return Scaffold(\n\t\t\tbody: FutureBuilder<List<String>>(\n\t\t    future: repository.get(),\n\t\t    builder: (context, snapshot) {\n\t\t      ...\n\t\t    },\n\t\t\t),\n\t\t);\n  }\n}\n```\n\n而測試這邊也可以在 pumpWidget 時，再多包一個 Provider 注入 MockDogRepository，以達到控制輸入的目的。\n\n```dart\n@GenerateNiceMocks([MockSpec<DogRepository>()])\nvoid main() {\n  testWidgets(\"show breed in dog app\", (tester) async {\n    var mockDogRepository = MockDogRepository();\n    when(mockDogRepository.get()).thenAnswer(\n      (invocation) async => [\"affenpinscher\", \"african\", \"airedale\"],\n    );\n\n    await tester.pumpWidget(Provider<DogRepository>.value(\n      value: mockDogRepository,\n      child: const MaterialApp(home: DogBreedsWidget()),\n    ));\n\n    await tester.pump();\n\n    expect(find.text(\"affenpinscher\"), findsOneWidget);\n    expect(find.text(\"african\"), findsOneWidget);\n    expect(find.text(\"airedale\"), findsOneWidget);\n  });\n}\n```\n\n## 以 get_it 改寫\n\n但如果開發者是使用 get_it 的話，就比較接近傳統依賴注入的 [Service Locator 模式](https://zh.wikipedia.org/zh-tw/%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8%E6%A8%A1%E5%BC%8F)，Widget 會直接使用 getIt 取得依賴，而非透過 BuildContext 的協助。[[範例連結](https://gist.github.com/easylive1989/990f852383196ac1bffbd059dcf75139)]\n\n```dart\nclass DogBreedsWidget extends StatelessWidget {\n  const DogBreedsWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    var repository = getIt<DogRepository>();\n\n    return FutureBuilder<List<String>>(\n      future: repository.get(),\n      builder: (context, snapshot) {\n        ...\n      },\n    );\n  }\n}\n```\n\n在測試中，get_it 就不是使用包 Widget 的方式處理依賴，而是需要呼叫 getIt 的 register 方法，主動將依賴放到 DI 容器中。\n\n```dart\n@GenerateNiceMocks([MockSpec<DogRepository>()])\nvoid main() {\n  late MockDogRepository mockDogRepository;\n\n  setUp(() {\n    mockDogRepository = MockDogRepository();\n    getIt.registerSingleton<DogRepository>(mockDogRepository);\n  });\n\n  testWidgets(\"show breed in dog app\", (tester) async {\n    when(mockDogRepository.get()).thenAnswer(\n      (invocation) async => [\"affenpinscher\", \"african\", \"airedale\"],\n    );\n\n    await tester.pumpWidget(const MaterialApp(home: DogBreedsWidget()));\n\n    await tester.pumpAndSettle();\n\n    expect(find.text(\"affenpinscher\"), findsOneWidget);\n    expect(find.text(\"african\"), findsOneWidget);\n    expect(find.text(\"airedale\"), findsOneWidget);\n  });\n}\n```\n\n## 小結\n\n無論是使用 Provider 或 get_it，或者是其他依賴注入套件，都能解決 Widget Test 的依賴注入問題。但是相比於單元測試來說，Widget Test 處理起來還是稍微麻煩一點，我們需要在測試中使用依賴注入的套件來設定依賴，讓 Widget 在測試中能正確使用假資料。雖然麻煩，但我們卻獲得了比單元測試更接近真實的測試，同時保有單元測試的穩定性與快速執行的優點。\n\n## 不只有 Repository\n\n雖然在我們的例子中，我們都是用這些狀態管理套件來管理 Repository，但在實務中，我們也會用來管理 Controller/Presenter/ViewModel，甚至是 Use Case。\n\n![Untitled](Day%2016%20Widget%20Test%20%E5%B0%AC%E4%B8%8A%E6%B8%AC%E8%A9%A6%E6%9B%BF%E8%BA%AB/Untitled%201.png)\n\n## Provider 的小小限制\n\n雖然在我們的例子中，我們都把 Provider 拿來放 Repository，但是 Provider 也可以拿來被拓展成狀態管理套件，例如：[flutter_bloc](https://pub.dev/packages/flutter_bloc)。但是當我們用 Provider \n\nProvider 的機制看似很好的解決了注入的問題，但有時還是會碰到一些限制。當我們的依賴需要動態建立時，可能還是會在 Widget 中 new 出一個實例，此時外層 Widget 的測試依舊會碰到無法注入假依賴的問題。\n\n![Discuss - Frame 3 (4).jpg](Day%2016%20Widget%20Test%20%E5%B0%AC%E4%B8%8A%E6%B8%AC%E8%A9%A6%E6%9B%BF%E8%BA%AB/Discuss_-_Frame_3_(4).jpg)\n\n在這個例子中，UserListWidget 使用 Provider 建立 UserDetailRepository 並帶入 userId，當 UserWidget 需要 UserDetailRepository 時，就可以直接用 [context.read](http://context.read) 存取。但是當我們想直接測試 UserListWidget 就會，UserDetailRepository 就變成阻礙，因為 UserDetailRepository 是直接在 UserListWidget 中建立的，使得我們難以作假 UserDetailRepository，但若是我們改採用 get_it 則是可以使用 factory 處理，讓設計可以有更多選擇空間。",
          "id": "d093869be6e14b88a8c3f731e410f0aa",
          "filename": "Day 16 Widget Test 尬上測試替身 d093869be6e14b88a8c3f731e410f0aa.md",
          "folderName": "Day 16 Widget Test 尬上測試替身",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 17 模擬使用者互動",
          "summary": "在前幾天的 Widget Test 介紹中，我們只介紹了如何測試畫面結果，如何使用測試替身，幾乎沒有談到測試使用者互動的部分。當畫面上提供資訊給使用者，使用者就可以透過按下按鈕、滑動列表、長按等等操作與程式互動，今天就來介紹這些一些常見的操作吧。 假設今天我們想做一個聊天室 App，一進入 App ...",
          "content": "在前幾天的 Widget Test 介紹中，我們只介紹了如何測試畫面結果，如何使用測試替身，幾乎沒有談到測試使用者互動的部分。當畫面上提供資訊給使用者，使用者就可以透過按下按鈕、滑動列表、長按等等操作與程式互動，今天就來介紹這些一些常見的操作吧。\n\n## 舉個例子\n\n假設今天我們想做一個聊天室 App，一進入 App 有一個顯示所有聊天室的列表，當使用者點擊右下角的 Floating Action Button 時，會跳出一個創建聊天室的視窗。建立完聊天室後，回到聊天室列表就會看到新的聊天室。[[範例連結](https://dartpad.dev/?id=c02e50c24a20b0b29776101a96d5dd43)]\n\n![Discuss - 聊天室 App.jpg](Day%2017%20%E6%A8%A1%E6%93%AC%E4%BD%BF%E7%94%A8%E8%80%85%E4%BA%92%E5%8B%95/Discuss_-_%25E8%2581%258A%25E5%25A4%25A9%25E5%25AE%25A4_App.jpg)\n\n## 測試建立聊天室行為\n\n### 準備畫面\n\n在測試中我們使用 Fake 來輔助測試，讓呼叫創建聊天室 API 不需要真的去打後端就能測試。首先，我們先建立畫面跟測試替身。\n\n```dart\nmain() {\n  testWidgets(\"create chat room success\", (tester) async {\n    await tester.pumpWidget(Provider<ChatRoomRepository>.value(\n      value: FakeChatRoomRepository(),\n      child: const ChatRoomPage(),\n    ));\n  });\n}\n\nclass FakeChatRoomRepository implements ChatRoomRepository {\n  final List<ChatRoom> chatRooms = [];\n\n  @override\n  List<ChatRoom> get() => chatRooms;\n\n  @override\n  void add(ChatRoom chatRoom) {\n    chatRooms.add(chatRoom);\n  }\n}\n```\n\n### 按下 Floating Action Button\n\n我們在介紹 Widget Test 的第一天中，在 Counter 範例的測試中，已經用過 WidgetTester 的 tap 方法來模擬使用者點擊了，在這個測試中也是一模一樣的做法。\n\n```dart\nmain() {\n  testWidgets(\"create chat room success\", (tester) async {\n    await tester.pumpWidget(Provider<ChatRoomRepository>.value(\n      value: FakeChatRoomRepository(),\n      child: const ChatRoomPage(),\n    ));\n\n    await tester.tap(find.byIcon(Icons.add));\n\t\tawait tester.pump();\n\n    expect(find.text(\"建立\"), findsOneWidget);\n  });\n}\n```\n\n有觀眾朋友可能會好奇，為什麼要驗證建立按鈕有沒有出現呢？由於 Widget Test 在執行的時候，開發人員無法看到畫面，但是如果我們把測試寫完後，再來跑測試的話，最後發現測試錯了，開發人員會很難找到發生的原因，所以我們可以在中途用 expect 確保測試執行到這邊都是符合預期。\n\n回到測試，我們執行一下，也確實得到綠燈，那我們就可以進行下一步驟了。\n\n### 輸入聊天室名稱與說明\n\n在 Widget Test 中，大部分的動作都是透過 WidgetTester 這個物件幫忙完成，像是我們接下來要做的輸入文字，就可以使用 enterText 方法。呼叫 enterText 的時候，我們需要給它一個 Finder 參數，告訴他我們想在哪個 Widget 上輸入文字。畫面上有兩個 TextField，問題就回到我們前天討論的議題了，如果我們直接使用 find.byType 傳入 TextField 肯定是不行的，因為畫面上有兩個 TextField，這邊我們就用 find.byWidgetPredicate 吧，分別找到相對應的 TextField。\n\n接著我們就能在 enterText 的第二個參數放上要輸入的文字。\n\n```dart\ntestWidgets(\"create chat room success\", (tester) async {\n  ...\n\n  await tester.enterText(\n    find.byWidgetPredicate((widget) => widget is TextField && widget.decoration?.labelText == \"聊天室名稱\"),\n    \"地球暖化討論群\",\n  );\n  await tester.enterText(\n    find.byWidgetPredicate((widget) => widget is TextField && widget.decoration?.labelText == \"聊天室說明\"),\n    \"愛地球\",\n  );\n});\n```\n\n### 按下建立聊天室按鈕\n\n最後一樣是用 tap 方法點擊按鈕，完成聊天室創建。\n\n```dart\ntestWidgets(\"create chat room success\", (tester) async {\n  ...\n\n  await tester.tap(find.text(\"建立\"));\n  await tester.pump();\n\n});\n```\n\n### 執行測試\n\n完成測試之後並執行，最後也成功得到一個綠燈。\n\n```dart\ntestWidgets(\"create chat room success\", (tester) async {\n  await tester.pumpWidget(Provider<ChatRoomRepository>.value(\n    value: FakeChatRoomRepository(),\n    child: const ChatRoomPage(),\n  ));\n\n  await tester.tap(find.byIcon(Icons.add));\n  await tester.pump();\n\n  await tester.enterText(\n    find.byWidgetPredicate((widget) => widget is TextField && widget.decoration?.labelText == \"聊天室名稱\"),\n    \"地球暖化討論群\",\n  );\n  await tester.enterText(\n    find.byWidgetPredicate((widget) => widget is TextField && widget.decoration?.labelText == \"聊天室說明\"),\n    \"愛地球\",\n  );\n\n  await tester.tap(find.text(\"建立\"));\n  await tester.pump();\n\n  expect(find.text(\"地球暖化討論群\"), findsOneWidget);\n  expect(find.text(\"愛地球\"), findsOneWidget);\n});\n```\n\n接著我們重構一下測試，提升測試可讀性。\n\n```dart\ntestWidgets(\"create chat room success\", (tester) async {\n  await givenView(tester, const ChatRoomPage());\n\n  await whenTapAddButton(tester);\n\n  await whenEnterChatRoomName(tester, \"地球暖化討論群\");\n\n  await whenEnterChatRoomDescription(tester, \"愛地球\");\n\n  await whenTapCreateButton(tester);\n\n  thenShowText(\"地球暖化討論群\");\n  thenShowText(\"愛地球\");\n});\n```\n\n最後我們把原本中間驗證建立按鈕的測試程式碼刪掉，因為那只是我們在寫測試過程中的輔助，而不是我們真正想驗證個結果。假設今天建立按鈕真的沒有出現，測試也會壞在按下建立按鈕的那一行，使得測試失敗，所以我們不需要特別驗證建立按鈕有沒有出現。\n\n接下來讓我們繼續用其他測試案例來看看不同操作吧。\n\n## 取消建立聊天室\n\n假設使用者建立聊天室建立到一半，突然不想建了，點擊旁邊黑色區塊來關閉彈跳時窗，此時回到聊天室列表時，就應該看不到剛剛輸入的聊天室資訊。\n\n![Discuss - 取消聊天室情境.jpg](Day%2017%20%E6%A8%A1%E6%93%AC%E4%BD%BF%E7%94%A8%E8%80%85%E4%BA%92%E5%8B%95/Discuss_-_%25E5%258F%2596%25E6%25B6%2588%25E8%2581%258A%25E5%25A4%25A9%25E5%25AE%25A4%25E6%2583%2585%25E5%25A2%2583.jpg)\n\n在這個情境中，我們可以重複使用上一個測試的操作步驟，只有兩個地方不同，一是在原本按下建立按鈕的步驟改成點擊黑色背景關閉彈跳視窗，二則是要驗證聊天室名稱與說明沒有出現在聊天室列表中。\n\n```dart\ntestWidgets(\"cancel chat room creation\", (tester) async {\n  await givenView(tester, const ChatRoomPage());\n\n  await whenTapAddButton(tester);\n\n  await whenEnterChatRoomName(tester, \"地球暖化討論群\");\n\n  await whenEnterChatRoomDescription(tester, \"愛地球\");\n\n  // 關閉建立聊天室彈跳視窗\n\n  expect(find.text(\"地球暖化討論群\"), findsNothing);\n  expect(find.text(\"愛地球\"), findsNothing);\n});\n```\n\n那我們要怎麼點到黑色背景的部分呢？想要點擊某個 Widget 必須先用 Finder 找到，但是這個黑色背景是由 showDialog 這個 API 控制的，所以我們很難用 Finder 找到他。\n\n### 模擬點擊特定位置\n\n要解決這問題方法很簡單，在這邊我們可以使用 WidgetTester 的 tapAt 方法，在這個方法中，我們可以傳入一個座標，要模擬使用者點擊某個特定位置。在這個測試中，只要我們座標給得夠邊邊，其實我們就能模擬點到黑色背景了。\n\n```dart\ntestWidgets(\"cancel chat room creation\", (tester) async {\n  ...\n\n\t// 關閉建立聊天室彈跳視窗\n  await tester.tapAt(const Offset(0, 0));\n  await tester.pump();\n\n  expect(find.text(\"地球暖化討論群\"), findsNothing);\n  expect(find.text(\"愛地球\"), findsNothing);\n});\n```\n\n最後我們執行測試，也成功得到綠燈。\n\n## 測試移除聊天室\n\n讓我們繼續測試另一個情境，當使用者在聊天室列表對著某個聊天室左滑時，就能從列標中刪除聊天室。\n\n![Discuss - 刪除聊天室情境.jpg](Day%2017%20%E6%A8%A1%E6%93%AC%E4%BD%BF%E7%94%A8%E8%80%85%E4%BA%92%E5%8B%95/Discuss_-_%25E5%2588%25AA%25E9%2599%25A4%25E8%2581%258A%25E5%25A4%25A9%25E5%25AE%25A4%25E6%2583%2585%25E5%25A2%2583.jpg)\n\n這一次呢，我們直接在先準備資料的階段，就塞好一個聊天室，然後再測試中刪除這個準備好的聊天室。\n\n```dart\ntestWidgets(\"delete chat room\", (tester) async {\n  var fakeChatRoomRepository = FakeChatRoomRepository();\n  fakeChatRoomRepository.add(const ChatRoom(\"韭菜投資群組\", \"你不理財，財不理你\"));\n\n  await givenView(tester, const ChatRoomPage(), repository: fakeChatRoomRepository);\n\n  // 左滑刪除聊天室\n\n  expect(find.text(\"韭菜投資群組\"), findsNothing);\n  expect(find.text(\"你不理財，財不理你\"), findsNothing);\n});\n```\n\n### 模擬拖動效果\n\n那這次我們要怎麼實現左滑呢？聰明的觀眾朋友肯定也知道，一樣是要使用 WidgetTester 身上的方法，當我們模擬拖動效果時，就可以用 drag 方法。在 drag 方法中傳入 Finder 指定我們想拖動的個物件，然後用 Offset 來指定距離。在下面的例子中，Offset(-500, 0) 表示在 x 軸方向上，要移動 -500 的距離，在 y 軸則是不動，模擬使用者左滑的效果。\n\n```dart\ntestWidgets(\"delete chat room\", (tester) async {\n    ...\n\n    // 左滑刪除聊天室\n    await tester.drag(find.text(\"韭菜投資群組\"), const Offset(-500, 0));\n    await tester.pumpAndSettle();\n\n\t  expect(find.text(\"韭菜投資群組\"), findsNothing);\n\t  expect(find.text(\"你不理財，財不理你\"), findsNothing);\n  });\n```\n\n### pumpAndSettle 是什麼？\n\n有觀眾朋友可能會注意到，我們呼叫 drag 方法後，不是用 pump 方法更新畫面，而是用 [pumpAndSettle](https://api.flutter.dev/flutter/flutter_test/WidgetTester/pumpAndSettle.html) 方法更新畫面，那 pumpAndSettle 是什麼呢？其實簡單來說，pumpAndSettle 方法可以想像成不斷重複的呼叫 pump 方法，直到沒有新的畫面要更新為止。\n\n那好奇的人可能就會問，為什麼我們會需要一直更新畫面呢？不是滑完更新一次就好了嗎？其實最主要的原因是因為左滑刪除效果，在滑動過程中 Flutter 會不斷更新畫面，讓使用者體驗順暢。\n\n![Discuss - 左滑逐幀效果.jpg](Day%2017%20%E6%A8%A1%E6%93%AC%E4%BD%BF%E7%94%A8%E8%80%85%E4%BA%92%E5%8B%95/Discuss_-_%25E5%25B7%25A6%25E6%25BB%2591%25E9%2580%2590%25E5%25B9%2580%25E6%2595%2588%25E6%259E%259C.jpg)\n\n所以在測試中，如果我們只呼叫了一次 pump 方法，或許畫面才刷新到一半，此時聊天室還在畫面上，所以測試就會失敗了。當我們的畫面或操作會有動畫效果，我們測試的時候就會需要 pumpAndSettle 方法的幫助，幫我們重複的執行 pump 方法，直到畫面不再更新，我們才能準確驗證結果。\n\n## 其他操作方法\n\n與 Finder 類似，Widget Test 也支援模擬使用者各種不同的操作，除了上面幾個例子提到的之外，還有 longPress 方法模擬使用者長按，或者 sendKeyEvent 方法模擬使用者按下鍵盤按鍵 …等。有需要的觀眾朋友也可以自己嘗試看看。\n\n## 小結\n\n當我們熟悉幾個常用的 Finder 與 WidgetTester 的方法後，我們基本上就可以應付大部分的測試情境了，今天也還介紹了 pumpAndSettle 方法與其使用時機。從 pumpAndSettle 的使用也可看出 Widget Test 與單元測試很不同的地方，寫 Widget Test 需要對 Flutter 的機制有一定了解，我們才能正確的測試。",
          "id": "0ae154947a374c269c655aec94bbb593",
          "filename": "Day 17 模擬使用者互動 0ae154947a374c269c655aec94bbb593.md",
          "folderName": "Day 17 模擬使用者互動",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 18 如何用 Widget Test 測試 Routing",
          "summary": "開發 App 時，我們會在不同頁面呈現不同資訊，當使用者按下頁面的中的按鈕或者列表中的項目時，可能會把使用者導向另外一個頁面，提供使用者更詳細的資訊或開啟不同的操作流程。那我們該如何測試頁面是否正常導轉呢？今天就來聊聊這個議題吧。 我們修改一下昨天的聊天室例子，首頁一樣顯示聊天室列表，當使用者點擊創...",
          "content": "開發 App 時，我們會在不同頁面呈現不同資訊，當使用者按下頁面的中的按鈕或者列表中的項目時，可能會把使用者導向另外一個頁面，提供使用者更詳細的資訊或開啟不同的操作流程。那我們該如何測試頁面是否正常導轉呢？今天就來聊聊這個議題吧。\n\n## 頁面跳轉\n\n我們修改一下昨天的聊天室例子，首頁一樣顯示聊天室列表，當使用者點擊創建聊天室的按鈕，會開啟另一個創建聊天室的頁面，而不是顯示彈跳視窗。在創建聊天室時，我們還能選擇邀請好友一起加入。[[範例程式](https://dartpad.dev/?id=c02e50c24a20b0b29776101a96d5dd43)]\n\n![Discuss - 建立聊天室 (1).jpg](Day%2018%20%E5%A6%82%E4%BD%95%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%20Routing/Discuss_-_%25E5%25BB%25BA%25E7%25AB%258B%25E8%2581%258A%25E5%25A4%25A9%25E5%25AE%25A4_(1).jpg)\n\n程式已經有了，那我們要怎麼測試頁面跳轉呢？最簡單的方式，我們可以測試當使用者點下按鈕跳轉後，畫面是否出現下一個頁面的元素。還記得我們在測試建立聊天室功能的途中，也驗證過”建立”按鈕是否存在嗎？這邊就稍微換一下，改驗證是否出現建立聊天室的標題吧。\n\n```dart\n@GenerateNiceMocks([MockSpec<ChatRoomRepository>(), MockSpec<FriendRepository>()])\nmain() {\n  testWidgets(\"\", (tester) async {\n    await tester.pumpWidget(MultiProvider(\n      providers: [\n        Provider<ChatRoomRepository>(create: (context) => ChatRoomRepository()),\n        Provider<FriendRepository>(create: (context) => FriendRepository()),\n      ],\n      child: const MyApp(),\n    ));\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pumpAndSettle();\n\n    expect(find.text(\"建立聊天室\"), findsOneWidget);\n  });\n}\n```\n\n在這個測試中，我們模擬使用者真的操作畫面，打開**建立聊天室頁面**，最後成功驗證建立聊天室的標題有出現在畫面上。那我們有沒有其他測試方法呢？答案肯定是有的，讓我們利用 NavigatorObserver 來測試吧。\n\n## 什麼是 NavigatorObserver ?\n\nNavigatorObserver 是什麼呢？[NavigatorObserver](https://api.flutter.dev/flutter/widgets/NavigatorObserver-class.html) 是一個用來監聽 Route 變化的類別，身上有 didPush、didPop …等方法，當 Route 有變化時，相對應的方法就會被呼叫。在實務上，當我們有監聽 Route 變化的需求時，我們就可以繼承 NavigatorObserver 並覆寫我們想要監聽的方法。\n\n```dart\nclass MyNavigatorObserver extends NavigatorObserver {\n  @override\n  void didPush(Route route, Route? previousRoute) {\n    super.didPush(route, previousRoute);\n    \n    // do something\n  }\n}\n```\n\n在 [firebase_analytics](https://pub.dev/packages/firebase_analytics) 的套件中，也有提供 **FirebaseAnalyticsObserver** 協助我們追蹤使用者的頁面使用狀況，而 FirebaseAnalyticsObserver 其實也是繼承了 NavigatorObserver。\n\n當我們有自己的 NavigatorObserver 之後，就可以在 MaterialApp 的參數中設定使用。\n\n```dart\nMaterialApp(\n  navigatorObservers: [MyNavigatorObserver()],\n  routes: {\n    ChatRoomListPage.routeName: (context) => const ChatRoomListPage(),\n    CreateChatRoomPage.routeName: (context) => const CreateChatRoomPage(),\n  },\n)\n```\n\n## 用 NavigatorObserver 測試 Route 變化\n\n那我們要怎麼用 NavigatorObserver 來測試呢? 首先我們必須用 mockito 產生一個 MockNavigatorObserver。\n\n```dart\n@GenerateNiceMocks([MockSpec<ChatRoomRepository>(), MockSpec<NavigatorObserver>()])\nmain() {\n  testWidgets(\"open create chat room page\", (tester) async {\n    var mockNavigatorObserver = MockNavigatorObserver();\n\n  });\n}\n```\n\n接著我們就一樣需要在測試中把 MockNavigatorObserver 放到測試中的 MaterialApp 中。在 MaterialApp，我們除了設定 NavigatorObserver 之外，我們放入要測試的頁面，也就是 ChatRoomListPage，最後我們還得給 onGenerateRoute 一個 Dummy，讓測試可以任意 Route 到任何路徑都不會出錯。\n\n```dart\n@GenerateNiceMocks([MockSpec<ChatRoomRepository>(), MockSpec<NavigatorObserver>()])\nmain() {\n  testWidgets(\"open create chat room page\", (tester) async {\n    var mockNavigatorObserver = MockNavigatorObserver();\n\n    await tester.pumpWidget(\n      Provider<ChatRoomRepository>(\n        create: (context) => MockChatRoomRepository(),\n        child: MaterialApp(\n          home: const ChatRoomListPage(),\n          navigatorObservers: [mockNavigatorObserver],\n\t\t\t\t\tonGenerateRoute: (settings) => MaterialPageRoute(settings: settings, builder: (context) => const SizedBox()),        ),\n      ),\n    );\n    \n  });\n}\n```\n\n最後我們一樣點擊按鈕，假裝進入**建立聊天室頁面**，最後用 Mock 驗證 didPush 是否真的被呼叫到。\n\n```dart\n@GenerateNiceMocks([MockSpec<ChatRoomRepository>(), MockSpec<NavigatorObserver>()])\nmain() {\n  testWidgets(\"open create chat room page\", (tester) async {\n    ...\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pumpAndSettle();\n\n    var result = verify(mockNavigatorObserver.didPush(captureAny, any));\n    expect(result.captured[1].settings.name, CreateChatRoomPage.routeName);\n  });\n}\n```\n\n## mockito 的 capture 機制\n\n眼尖的朋友可會發現，這邊的 verify 用法不單純只是 verify，而是會會傳一個結果，還有後面的 didPush 呼叫中使用了 captureAny，這又是什麼呢？在這個測試中，我們使用 mocktio 的 capture 機制來輔助驗證參數，在 capture 機制中，我們可以用 capture 獲取傳進 didPush 的參數，在 verify 結束後用回傳值傳出來。後續測試就可以拿這個剛剛傳入 didPush 的參數繼續做更深入的驗證。\n\n```dart\nvar result = verify(mockNavigatorObserver.didPush(captureAny, any));\n```\n\n以這邊的例子來說，由於我們只想驗證 Route 的名稱是否正確，並不關心 Route 的其他狀態，所以我們用 capture 把參數抓出來，並單獨驗證 RouteSettings 的 name 而已。\n\n另外由於測試過程中，Mock 的方法可能被呼叫很多次，所以 result 中的 capture 是一個陣列，會記錄每一次傳入的參數。\n\n```dart\nexpect(result.captured[1].settings.name, CreateChatRoomPage.routeName);\n```\n\n那為什麼在這個測試中，我們抓取陣列中第二次呼叫的參數來比較，而不是第一次呢？因為第一次的 didPush 是發生在我們用 pumpWidget 建立畫面時，顯示初始頁面也是一種 Route 變化，所以在這個測試中，我們會抓取的是第二次頁面轉換的參數來驗證。\n\n最後執行測試，也正確的通過測試，得到綠燈。\n\n```dart\n@GenerateNiceMocks([MockSpec<ChatRoomRepository>(), MockSpec<NavigatorObserver>()])\nmain() {\n  testWidgets(\"open create chat room page\", (tester) async {\n    var mockNavigatorObserver = MockNavigatorObserver();\n\n    await tester.pumpWidget(\n      Provider<ChatRoomRepository>(\n        create: (context) => MockChatRoomRepository(),\n        child: MaterialApp(\n          home: const ChatRoomListPage(),\n          navigatorObservers: [mockNavigatorObserver],\n          routes: {CreateChatRoomPage.routeName: (context) => const SizedBox()},\n        ),\n      ),\n    );\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pumpAndSettle();\n\n    var result = verify(mockNavigatorObserver.didPush(captureAny, any));\n    expect(result.captured[1].settings.name, CreateChatRoomPage.routeName);\n  });\n}\n```\n\n## 重構測試\n\n測試寫完後，可以發現測試變得一大坨，肯定是不容易理解與維護。一樣的當我們寫完測試之後，我們必須重構一下，幫將來的自己節省時間。\n\n### DummyRoutes\n\n在 MaterialApp 中，為了避免在測試過程中跳轉到其他未定義的頁面，這邊我們有設定 onGenerateRoute，但是這個對於理解測試沒有什麼幫助，所以我們抽取方法抽了一個 dummyRouteGenerator。\n\n```dart\n@GenerateNiceMocks([MockSpec<ChatRoomRepository>(), MockSpec<NavigatorObserver>()])\nmain() {\n  testWidgets(\"open create chat room page\", (tester) async {\n    var mockNavigatorObserver = MockNavigatorObserver();\n\n    await tester.pumpWidget(\n      Provider<ChatRoomRepository>(\n        create: (context) => MockChatRoomRepository(),\n        child: MaterialApp(\n          home: const ChatRoomListPage(),\n          navigatorObservers: [mockNavigatorObserver],\n          onGenerateRoute: dummyRouteGenerator,\n        ),\n      ),\n    );\n\n    ...\n\n  });\n}\n\nRoute Function(RouteSettings) get dummyRouteGenerator =>\n    (settings) => MaterialPageRoute(settings: settings, builder: (context) => const SizedBox());\n```\n\n### RouteMatcher\n\n再來我們可以處理一下驗證的部分，還記得介紹[非正常流程的文章](https://ithelp.ithome.com.tw/articles/10324465)與介紹 [Finder 的文章](https://ithelp.ithome.com.tw/articles/10330221)中，我們提到放在 expect 二個參數的東西嗎？\n\n```dart\nexpect(() => server.execute(), throwsA(isA<MoneyNotEnoughException>()));\n\nexpect(find.text(\"Hello World\"), findsOneWidget);\n```\n\n我們在第二個參數中放的 throwsA 與 findsOneWidget 回傳的 Throws 與 _FindsWidgetMatcher 其實都是繼承於 Matcher 這個類別，Matcher 最主要的功能就是拿來驗證結果。如果我們走進 Matcher 的原始碼中，就可以看到其核心的方法 matches，不同的Matcher 都是繼承自 Matcher 然後實作各自的驗證方式，最後統一回傳 bool 決定測試成功或失敗。\n\n```dart\nabstract class Matcher {\n  const Matcher();\n\n  /// Does the matching of the actual vs expected values.\n  ///\n  /// [item] is the actual value. [matchState] can be supplied\n  /// and may be used to add details about the mismatch that are too\n  /// costly to determine in [describeMismatch].\n  bool matches(dynamic item, Map matchState);\n\n  /// Builds a textual description of the matcher.\n  Description describe(Description description);\n\n  /// Builds a textual description of a specific mismatch.\n  ///\n  /// [item] is the value that was tested by [matches]; [matchState] is\n  /// the [Map] that was passed to and supplemented by [matches]\n  /// with additional information about the mismatch, and [mismatchDescription]\n  /// is the [Description] that is being built to describe the mismatch.\n  ///\n  /// A few matchers make use of the [verbose] flag to provide detailed\n  /// information that is not typically included but can be of help in\n  /// diagnosing failures, such as stack traces.\n  Description describeMismatch(dynamic item, Description mismatchDescription,\n          Map matchState, bool verbose) =>\n      mismatchDescription;\n}\n```\n\n在我們了解 Matcher 是什麼之後，是時候來製作 RouteMatcher 了。在 Matcher 中，我們實作了比較 settings 的 name 是否符合預期。\n\n```dart\nclass RouteMatcher extends Matcher {\n  final String routeName;\n\n  RouteMatcher({required this.routeName});\n\n  @override\n  Description describe(Description description) {\n    return description.add('routeName: $routeName');\n  }\n\n  @override\n  bool matches(item, Map matchState) {\n    return item.settings.name == routeName;\n  }\n}\n```\n\n最後用法上就可以直接 captureThat 傳入 RouteMatcher 讓 mockito 直接依照 RouteMatcher 的規則去驗證就好，而不用自己把參數抓出來驗證。\n\n```dart\n@GenerateNiceMocks([MockSpec<ChatRoomRepository>(), MockSpec<NavigatorObserver>()])\nmain() {\n  testWidgets(\"open create chat room page\", (tester) async {\n\n    ...\n\n    verify(mockNavigatorObserver.didPush(\n      captureThat(RouteMatcher(routeName: CreateChatRoomPage.routeName)),\n      any,\n    ));\n  });\n}\n```\n\n再加上之前介紹過的重構技巧，最後測試就變得更好懂了。\n\n## 小結\n\n今天就先談到這邊，今天聊了 Route 的測試，也講到如何用 NavigatorObserver 輔助測試，不知道有沒有觀眾朋友好奇一件事，好像不用 NavigatorObserver 的測試看起來反而比較簡單，如果只是簡單的例子也確實是這樣，但是用 NavigatorObserver 有一個好處，這部分我們明天會繼續論。另外，明天會繼續討論 Route 測試的另一半：從其他頁面返回結果的情境，有興趣的觀眾朋友也歡迎繼續追蹤。\n\n## 讓頁面測試獨立\n\n看起來用 NavigatorObserver 來測試好像變得麻煩了，要處理的事情變得更多？\n\n當\n\n我們可以使用\n\n建立聊天室列表頁面，\n\n但是就需要準備下一個頁面需要的資料\n\n也可以測試路徑\n\n測試路徑會導致實作被綁死，我只能用 route 來顯示畫面\n\n與 mock 的意思相同\n\n在 pub.dev 中，有許多 Router 套件，使用不同的套件可能會有",
          "id": "821559d85da04684b247645992f12ad3",
          "filename": "Day 18 如何用 Widget Test 測試 Routing 821559d85da04684b247645992f12ad3.md",
          "folderName": "Day 18 如何用 Widget Test 測試 Routing",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 19 測試 Routing 回傳值",
          "summary": "昨天談到了如何測試頁面導轉，當使用者點了按鈕，我們就能驗證是否跳轉到新的頁面。而今天要繼續聊聊下半段，當使用者在新頁面完成任務後，帶著回傳值跳轉回上一個頁面，並且讓上一個頁面知道任務完成狀況，進而顯示任務完成畫面。 在昨天的例子中，當使用者建完聊天室後，畫面會跳轉回上一頁面後，就只是單純地在畫面上顯...",
          "content": "昨天談到了如何測試頁面導轉，當使用者點了按鈕，我們就能驗證是否跳轉到新的頁面。而今天要繼續聊聊下半段，當使用者在新頁面完成任務後，帶著回傳值跳轉回上一個頁面，並且讓上一個頁面知道任務完成狀況，進而顯示任務完成畫面。\n\n## 調整聊天室功能\n\n在昨天的例子中，當使用者建完聊天室後，畫面會跳轉回上一頁面後，就只是單純地在畫面上顯示新的聊天室列表。讓我們修改一下需求，當使用者建完聊天室後，除了更新聊天室列表之外，還要多顯示一個 SnackBar 訊息，讓使用者知道聊天室建立成功。\n\n![Discuss - 建立聊天室成功訊息.jpg](Day%2019%20%E6%B8%AC%E8%A9%A6%20Routing%20%E5%9B%9E%E5%82%B3%E5%80%BC/Discuss_-_%25E5%25BB%25BA%25E7%25AB%258B%25E8%2581%258A%25E5%25A4%25A9%25E5%25AE%25A4%25E6%2588%2590%25E5%258A%259F%25E8%25A8%258A%25E6%2581%25AF.jpg)\n\n為了完成這個需求，我們可以在聊天室建立成功後，透過 Navigator.pop 回傳建立成功的聊天室名稱。\n\n```dart\nNavigator.of(context).pop(_nameController.text);\n```\n\n接收到結果的**聊天室列表頁面**就顯示成功訊息，這邊就只展示部分程式碼，完整的可以參考[這邊](https://dartpad.dev/?id=ca861fc4fbaece90bc6f5f9dc6853a2b)。\n\n```dart\nvar createdChatRoomName = await Navigator.of(context).pushNamed(\"/create\");\nif (mounted && createdChatRoomName != null) {\n  ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(\"$createdChatRoomName 建立成功\")));\n}\n```\n\n## 直接測試\n\n最容易方式就是延續昨天第一個版本的測試，在**聊天室列表頁面**中，實際打開**建立聊天室頁面**，然後輸入名稱，按下建立，最終驗證訊息有出現在畫面上。\n\n```dart\n@GenerateNiceMocks([MockSpec<ChatRoomRepository>(), MockSpec<FriendRepository>()])\nmain() {\n  testWidgets(\"show chat room created message\", (tester) async {\n    await tester.pumpWidget(MultiProvider(\n      providers: [\n        Provider<ChatRoomRepository>(create: (context) => MockChatRoomRepository()),\n        Provider<FriendRepository>(create: (context) => MockFriendRepository()),\n      ],\n      child: const MyApp(),\n    ));\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pumpAndSettle();\n\n    await tester.enterText(\n      find.byWidgetPredicate((widget) => widget is TextField && widget.decoration?.labelText == \"聊天室名稱\"),\n      \"地球暖化討論群\",\n    );\n\n    await tester.tap(find.text(\"建立\"));\n    await tester.pumpAndSettle();\n\n    expect(find.text(\"地球暖化討論群 建立成功\"), findsOneWidget);\n\n  });\n}\n```\n\n與昨天類似的問題，我們有沒有其他辦法測試呢？其實也是有的，讓我們繼續看看不同做法吧。\n\n## 使用 Navigator 設定回傳\n\n在昨天 Route 到**建立聊天室頁面**的測試中，我們使用 MockNavigatorObserver 確認 Route 事件是不是真的有發生，以此來確立按鈕行為否正確，避免真的打開**建立聊天室頁面**。回到今天的測試中，我們想測試成功訊息，但是我沒有真正的打開**建立聊天室頁面**，怎麼讓**聊天室列表頁面**的邏輯繼續往下呢？\n\n```dart\n// 如何讓 pushNamed 返回，使得程式可以繼續往下\nvar createdChatRoomName = await Navigator.of(context).pushNamed(\"/create\");\n```\n\n答案其實很簡單，**建立聊天室頁面**怎麼做，在測試中就怎麼做，也就是我們在測試中呼叫 Navigator 的 pop 方法\n\n```dart\nNavigator.of(context).pop(\"地球暖化討論群\");\n```\n\n## 用 GlobalKey 取得 Navigator\n\n接下來要問的問題就是，那我要怎麼在測試中拿到 Navigator 呢？Navigator 也是一個 Widget，在正式程式碼中，當我們使用 MaterialApp 這個 Widget 時，裡面就已經包含一個 Navigator 了。而在 MaterialApp 的參數中，有一個 navigatorKey 的參數，讓使用端可以自己設定 Navigator 的 Key。當我們設定了 GlobalKey 給 Navigator 我們就能從 GlobalKey 中取得 Navigator ( 準確來說是 NavigatorState )。\n\n```dart\nvar navigatorKey = GlobalKey<NavigatorState>();\n\nnavigatorKey.currentState?.pop();\n```\n\n所以我們調整一下測試，新增一個 GlobalKey 並傳給 MaterialApp。\n\n```dart\n@GenerateNiceMocks([MockSpec<ChatRoomRepository>()])\nmain() {\n  testWidgets(\"open create chat room page\", (tester) async {\n    var navigatorKey = GlobalKey<NavigatorState>();\n\n    await tester.pumpWidget(\n      Provider<ChatRoomRepository>(\n        create: (context) => MockChatRoomRepository(),\n        child: MaterialApp(\n          home: const ChatRoomListPage(),\n          navigatorKey: navigatorKey,\n          onGenerateRoute: dummyRouteGenerator,\n        ),\n      ),\n    );\n  });\n}\n```\n\n接著我們就能用這個 GlobalKey 取回 Navigator，然後就可以呼叫 pop 方法並設定回傳值，最後就執行測試，得到綠燈。\n\n```dart\n@GenerateNiceMocks([MockSpec<ChatRoomRepository>()])\nmain() {\n  testWidgets(\"open create chat room page\", (tester) async {\n    var navigatorKey = GlobalKey<NavigatorState>();\n\n    await tester.pumpWidget(\n      Provider<ChatRoomRepository>(\n        create: (context) => MockChatRoomRepository(),\n        child: MaterialApp(\n          home: const ChatRoomListPage(),\n          navigatorKey: navigatorKey,\n          onGenerateRoute: dummyRouteGenerator,\n        ),\n      ),\n    );\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pumpAndSettle();\n\n    navigatorKey.currentState?.pop(\"地球暖化討論群\");\n    await tester.pumpAndSettle();\n\n    expect(find.text(\"地球暖化討論群 建立成功\"), findsOneWidget);\n  });\n}\n```\n\n如果我們比較使用 Navigator 的測試與一開始的測試會發現，好像用 Navigator 的測試也沒有簡單很多。昨天例子也是類似的情況，我們直接測試兩個頁面的協作，好像也比使用 MockNavigatorObserver 要來得簡單，那到底寫得這麼麻煩有什麼好處呢？\n\n## 整合型測試 vs 隔離型測試\n\n回到最一開始的測試目的，我們想測試都是**聊天室列表頁面**的行為。\n\n1. 點擊 ㊉ 按鈕，Route 到**建立聊天室頁面**\n2. 當從**建立聊天室頁面**回來時，要顯示成功訊息\n\n這當中其實我們一點都不關心**建立聊天室頁面**，無論是**建立聊天室頁面**的 UI 長什麼樣子，有沒有建立按鈕，有幾個輸入框，聊天室名稱有沒有規則限制 …等等。在第一版的測試中，測試會同時知道**聊天室列表頁面**與**建立聊天室頁面**，為了方便，我們暫時稱呼其為**整合型測試**。而在使用 MockObserver 與 Navigator 的測試中，測試不需要真的知道**建立聊天室頁面**，只需要知道 Route 路徑即可，讓我們暫時稱呼其為**隔離型測試。**\n\n### 頁面發生變化時\n\n在整合型的測試裡，測試過程中真的打開**建立聊天室頁面**，我們必須準備頁面需要的資料，也就是 FriendRepository。假設今天**建立聊天室頁面**的行為變得複雜，多了其他依賴時，測試也必須跟著調整，當聊天室名稱有一定規則，不能重複，或者建立過程中還需要去開其他頁面協作時，整合型的測試就會變得複雜，因為真實的建立流程就是這麼複雜。無論**聊天室列表頁面**或**建立聊天室頁面**的行為發生變化，這個測試都很有可能要跟著調整。\n\n相反的，在使用 Navigator/NavigatorObserver 版本的測試中，**聊天室列表頁面**的測試複雜度不會受到**建立聊天室頁面**的行為影響，無論未來**建立聊天室頁面**的行為如何變化，只要他們之間輸入輸出沒發生改變，測試也不會需要調整。\n\n就像單元測試一樣，我們之所以使用測試替身，就是希望我們可以單純的測試該類別的行為。如果我們在單元測試中，SUT 的依賴都跟正式程式碼用的一樣的話，需要測試的行為可能就會倍數性的成長，在聊天室的測試也是一樣的道理。\n\n### 如何選擇策略\n\n其實我們倒也不是一開始就得在兩種做法中選擇一條走到底，而是可以混合著使用，當今天頁面需求不那麼複雜時，先使用整合型版本的測試。當需求開始變得複雜的時候，我們再來調整成隔離型的測試也不遲。只要團隊有在兩種測試策略中切換得能力，需要的時候再來調整即可。\n\n## 小結\n\n今天介紹了 Route 測試的頁面返回情境，跟頁面跳轉一樣，我們展示了兩種不同的做法，整合型的作法與隔離型的作法。隔離型的 Route 測試雖然寫起來比較複雜，但是不容易受到其他頁面的需求異動而跟著異動，缺點就是寫法上比較麻煩。反之，整合型的作法寫起來比較快，但是未來如果碰上其他頁面的需求異動，測試就也得跟著調整，如何選擇最好還是根據當下情境決定。\n\n## 重複測試\n\n那重複測試會造成什麼問題？我們測的地方越多，不是對程式越有保護嗎？答案肯定不是，測試跟財富一樣，你不理財，才不理你，測試是需要我們花時間去維護的，所以如果測試能力相同的兩組測試，數量較少的肯定比較好，畢竟數量少，我們維護的成本也比較低\n\n[測試維護成本圖？]\n\n## 避免重複測試同樣行為？\n\n主要\n\n```dart\n\n```\n\n實際測試下來，可能會發現我們需要準備聊天室列表頁面的資料，也需要準備建立聊天室頁面的資料，就需要作假比較多東西，讓測試變得比較難寫。還有另外一個問題就是，當我們在製作建立聊天室功能時，也肯定為這個流程加上了測試，與上述的測試就重複測試了建立聊天室這一段。\n\n當我們修改建立聊天室功能時，除了修改它自己本身的測試，也不得不修改這個測試，雖然我們這個測試的主要目的並非測試建立聊天室，但是在測試過程中，無可避免地在測了一次。\n\n那我們有沒有辦法避免呢？答案肯定是有的，接下來就讓我們來看看怎麼調整吧",
          "id": "f774b9edcc2c4807ba55876fcb00fc72",
          "filename": "Day 19 測試 Routing 回傳值 f774b9edcc2c4807ba55876fcb00fc72.md",
          "folderName": "Day 19 測試 Routing 回傳值",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 20 再多的文字都比不上一張圖片",
          "summary": "備註: mockHttpNetworkImage 在開發 Flutter 程式的過程中，或多或少都會使用圖片或 Icon 來增加使用者體驗，畢竟人都是視覺動物，比起文字，豐富的圖片與動畫特效更加吸人眼球。今天就來看看在 Widget Test 中，在測試圖片時會遇到什麼問題吧。一樣讓我們先舉個簡單的...",
          "content": "備註: mockHttpNetworkImage\n\n在開發 Flutter 程式的過程中，或多或少都會使用圖片或 Icon 來增加使用者體驗，畢竟人都是視覺動物，比起文字，豐富的圖片與動畫特效更加吸人眼球。今天就來看看在 Widget Test 中，在測試圖片時會遇到什麼問題吧。一樣讓我們先舉個簡單的例子。\n\n## 舉個例子\n\n我們來看個簡單的程式，在程式中用圖片呈現葉問 2 的經典場景，畫面一開始顯示了葉問叫洪師傅切對手中路，然後使用者畫面中的按鈕看看洪師父怎麼回應。[[範例程式](https://gist.github.com/easylive1989/e99937ec3b59d56281af3d4e244e6504)]\n\n![葉問2.jpg](Day%2020%20%E5%86%8D%E5%A4%9A%E7%9A%84%E6%96%87%E5%AD%97%E9%83%BD%E6%AF%94%E4%B8%8D%E4%B8%8A%E4%B8%80%E5%BC%B5%E5%9C%96%E7%89%87/%25E8%2591%2589%25E5%2595%258F2.jpg)\n\n那我們想驗證假設我想驗證按鈕的功能是否正常要怎麼測呢？想必觀眾朋友應該都已經熟練了，我們可以驗證洪師父的圖片有沒有有沒有出現在畫面上。\n\n```dart\nmain() {\n  testWidgets(\"show master hong's reply\", (tester) async {\n      await tester.pumpWidget(const IpMan());\n\n      await tester.tap(find.text(\"看看洪師父怎麼說\"));\n\n      // 驗證洪師父圖片\n  });\n}\n```\n\n來到 3A 的最後一步，我們要怎麼驗證圖片呢？如果我們搜尋 Finder，可以找到 find.image 這個 Finder，看起來應該就是要用它了，再看看他的參數是 ImageProvider，如果我們再移至 ImageProvider 的定義，用 IDE 找到繼承 ImageProvider，就能找到一係列可能選擇。\n\n![Untitled](Day%2020%20%E5%86%8D%E5%A4%9A%E7%9A%84%E6%96%87%E5%AD%97%E9%83%BD%E6%AF%94%E4%B8%8D%E4%B8%8A%E4%B8%80%E5%BC%B5%E5%9C%96%E7%89%87/Untitled.png)\n\n在範例中，我們使用 Image.asset() 來顯示圖片，相對應的在測試中的我們就得使用 AssetImage 了。\n\n```dart\nmain() {\n  testWidgets(\"show master hong's reply\", (tester) async {\n    await tester.pumpWidget(const IpMan());\n\n    await tester.tap(find.text(\"看看洪師父怎麼說\"));\n    await tester.pump();\n\n    expect(find.image(const AssetImage(\"assets/master_hong.jpg\")), findsOneWidget);\n  });\n}\n```\n\n最後我們執行測試，得到綠燈。\n\n## 使用 flutter_gen 產生圖片路徑常數\n\n在上面的測試中，我們在正式程式碼與測試中都是手動寫死了圖片路徑，萬一兩邊寫的不相符，我們可能一時間可能檢查不出問題。所以我們可以使用 [flutter_gen](https://pub.dev/packages/flutter_gen) 來產生這些路徑的常數，預設產生出來的常數檔放在 lib/gen 目錄中，檔名為 Assets。\n\n![Untitled](Day%2020%20%E5%86%8D%E5%A4%9A%E7%9A%84%E6%96%87%E5%AD%97%E9%83%BD%E6%AF%94%E4%B8%8D%E4%B8%8A%E4%B8%80%E5%BC%B5%E5%9C%96%E7%89%87/Untitled%201.png)\n\n然後我們就能直接在正式與測試程式碼中使用這些常數，避免打錯字的問題。\n\n```dart\ntestWidgets(\"show master hong's reply\", (tester) async {\n  await tester.pumpWidget(const IpMan());\n\n  await tester.tap(find.text(\"看看洪師父怎麼說\"));\n  await tester.pump();\n\n  expect(find.image(AssetImage(Assets.masterHong.path)), findsOneWidget);\n});\n```\n\n## 載入網路圖片\n\nFlutter 的 Image 有許多 factory 方法，在上面的例子中，我們使用過 Image.asset()，而在眾多方法中，還有一個也是我們常用的，那就是 Image.netowrk()。在這個方法中，我們把遠端圖片網址當參數放到 Image.network() 中，在 Image 要顯示在畫面上時，Flutter 就會幫我們去讀取遠端圖片並顯示在畫面上。讓我們修改一下上面的例子，都改成使用 Image.network() 在來測試看看會發什麼事吧。[[範例程式](https://dartpad.dev/?id=4b7198602e416a97d75eab5fda5a9559)]\n\n修改完成之後，我們測試也跟著做相應的調整，之前我們查看 ImageProvider 的子類的時候，也有看到 NetworkImage 這個類別，剛好可以用在測試上。\n\n```dart\ntestWidgets(\"show master hong's reply\", (tester) async {\n  await tester.pumpWidget(const IpMan());\n\n  await tester.tap(find.text(\"看看洪師父怎麼說\"));\n  await tester.pump();\n\n  expect(find.image(const NetworkImage(\"https://raw.githubusercontent.com/easylive1989/images/master/static/images/2023IThome/Day20/master_hong.jpg\")), findsOneWidget);\n});\n```\n\n當我們改完測試並執行後會發現，測試得到了紅燈，查看錯訊息會發現，測試回報了讀取網路圖片失敗，無法正確載入葉問的圖片。\n\n![Untitled](Day%2020%20%E5%86%8D%E5%A4%9A%E7%9A%84%E6%96%87%E5%AD%97%E9%83%BD%E6%AF%94%E4%B8%8D%E4%B8%8A%E4%B8%80%E5%BC%B5%E5%9C%96%E7%89%87/Untitled%202.png)\n\n還記得我們在之前的[文章](https://ithelp.ithome.com.tw/articles/10331423)中有提到，在 Widget Test 預設是會擋掉所有遠端呼叫的，讀取遠端圖片也是一種遠端呼叫，所以自然的也行不通。那我們要怎麼處理呢？\n\n## 使用 errorBuilder\n\n在 Image.network() 的參數中，有一個 errorBuilder 參數，如果我們有設定參數，當圖片載入失敗時，就會呼叫 errorBuilder 顯示圖片載入失敗的畫面。\n\n```dart\nImage.network(\n  \"https://raw.githubusercontent.com/easylive1989/images/master/static/images/2023IThome/Day20/ipman.jpg\",\n  errorBuilder: (context, error, stackTrace) => const Text(\"圖片載入失敗\"),\n)\n```\n\n如果們修改一下正式程式碼，在使用 Image.network() 時都加上 errorBuilder，當圖片無法載入時，也能正常顯示 Widget，測試也就能正常通過。[[範例程式](https://dartpad.dev/?id=959d0e514a15695ef5cd4dae3162beb5)]\n\n那我們還有沒有其他方式處理 Widget Test 的錯誤呢？\n\n## 使用 **network_image_mock 避免錯誤**\n\n我們除了使用 errorBuilder 之外，還能使用 [network_image_mock](https://pub.dev/packages/network_image_mock) 套件，這個套件能協助我們避免因為 Image.network() 讀不到圖片而造成 Widget Test 報錯。只要在呼叫 pumpWidget 時，用 mockNetworkImages 包住即可。\n\n```dart\ntestWidgets(\"show master hong's reply\", (tester) async {\n  await mockNetworkImages(() => tester.pumpWidget(const IpMan()));\n\n  await tester.tap(find.text(\"看看洪師父怎麼說\"));\n  await tester.pump();\n\n  expect(find.image(const NetworkImage(\"https://raw.githubusercontent.com/easylive1989/images/master/static/images/2023IThome/Day20/master_hong.jpg\")), findsOneWidget);\n});\n```\n\n## 什麼時候會需要驗證圖片呢？\n\n其實大多時候，我們都不會驗證圖片作為結果，就像開頭講的，圖片大多時候只是增加使用者體驗，而非重要的資訊。既然這樣，我們在選擇驗證的什麼時候，應該是要選擇先驗證那些畫面上的重要資訊，只有當不得已的情況，畫面中只有圖片拿來做驗證的時候，我們才會選擇用圖片驗證。\n\n假設在建立聊天室的例子中，我們建立成功的時候不是顯示訊息，而是顯示一張圖時，若我們想從畫面檢查是否有出現成功訊息，那就只能檢查圖片了。\n\n## 小結\n\n今天介紹了跟圖片相關的議題，在驗證圖片時，我們可以使用 find.image，並根據正式程式碼使用的圖片載入方式，決定在測試中使用哪種 ImageProvider。我們也討論如何處理 Image.network() 在 Widget Test 中的錯誤與什麼時候需要驗證圖片，希望大家看完今天的文章都能都有一點收穫。",
          "id": "64753500be2f4682adbc17d929c77aeb",
          "filename": "Day 20 再多的文字都比不上一張圖片 64753500be2f4682adbc17d929c77aeb.md",
          "folderName": "Day 20 再多的文字都比不上一張圖片",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 21 測試在 Widget 打開外部連結",
          "summary": "備註: 測試 GoogleLogin 當我們在寫單元測試時，我們會需要作假外部依賴，例如：http、Dio 等呼叫 Web API 用的套件。相同的，當我們在寫 Widget 時，有時也會需要想辦法隔離一些外部套件，這個在之前的文章中有討論過，今天我們看看一些比較不一樣的例子。 [url_launc...",
          "content": "備註: 測試 GoogleLogin\n\n當我們在寫單元測試時，我們會需要作假外部依賴，例如：http、Dio 等呼叫 Web API 用的套件。相同的，當我們在寫 Widget 時，有時也會需要想辦法隔離一些外部套件，這個在之前的文章中有討論過，今天我們看看一些比較不一樣的例子。\n\n## **url_launcher 套件**\n\n[url_launcher](https://pub.dev/packages/url_launcher) 在開發 Flutter 的時候也是滿常用到的，這是一個 Flutter 官方開發的套件，當我想用瀏覽器開啟連結時，我們就會用 url_launcher 來幫忙處理。除此之外，像是 email 或手機號碼，也能用 url_launcher 開啟相對應的應用程式來處理。\n\n```dart\nlaunchUrl(Uri.parse(\"https://www.google.com\"));\n\nlaunchUrl(Uri(scheme: 'mailto', path: 'paul@gmail.com'));\n```\n\n而用法也很簡單，只要定義好 Uri 直接當參數呼叫 launchUrl 這個靜態方法即可。\n\n## 打開規範說明頁面\n\n大多時候，我們有 Web 也有 Mobile App 時，我們就會把網站的規範說明放在 Web 中，然後 Mobile App 使用瀏覽器或 WebView 打開這個網址，避免 Mobile App 需要在處理一次，在這邊我們就用 url_launcher 處理吧。[[範例程式](https://gist.github.com/easylive1989/ebafeb42141b188f892bf8d284b4b525)]\n\n```dart\nclass TermAndCondition extends StatelessWidget {\n  const TermAndCondition({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () {\n        launchUrl(Uri.parse(\"https://www.google.com\"));\n      },\n      child: const Center(\n        child: Text(\n          'Terms & Conditions',\n          style: TextStyle(\n            color: Colors.blue,\n            decoration: TextDecoration.underline,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n當我們開始測試時，寫完 pumpWidget，寫完 tap，最後當我們想驗證頁面有沒有被打開時就會卡住。我們可能會想用 Mock 的方式來驗證，但是因為 launchUrl 方法是第三方的套件，而且是使用全域方法，導致我們無法直接 Mock 它。\n\n```dart\nmain() {\n  testWidgets(\"should open t&c page when click t&c\", (tester) async {\n\t\tawait tester.pumpWidget(const MaterialApp(home: TermAndCondition()));\n\n    await tester.tap(find.text(\"Terms & Conditions\"));\n\n    // 如何驗證\n\n  });\n}\n```\n\n## 經典 Extra And Override\n\n為了解決，我們可以使用最經典的方式，Extra And Override 來處理，實作一個 TestTermAndCondition 繼承 TermAndCondition，覆寫並且攔截參數，最後就可以在測試中使用。\n\n```dart\nclass TestTermAndCondition extends TermAndCondition {\n  Uri? uri;\n\n  @override\n  void openUrl(Uri uri) {\n    this.uri = uri;\n  }\n}\n```\n\n可以看到在測試中我們就可以直接比較 testTermAndCondition 的 uri 是否正確。\n\n```dart\nmain() {\n  testWidgets(\"should open t&c page when click t&c\", (tester) async {\n    var testTermAndCondition = TestTermAndCondition();\n\n    await tester.pumpWidget(MaterialApp(home: testTermAndCondition));\n\n    await tester.tap(find.text(\"Terms & Conditions\"));\n\n    expect(testTermAndCondition.uri, Uri.parse(\"https://www.google.com\"));\n  });\n}\n```\n\n這個解法雖然有用，比較容易用在 StatelessWidget，而比較難在 StatefulWidget 中，因為 StatefulWidget 包含了兩個類別 Widget 類別與他相對應 State 類別。\n\n```dart\nclass TermAndCondition extends StatefulWidget {\n  const TermAndCondition({super.key});\n\n  @override\n  State<TermAndCondition> createState() => TermAndConditionState();\n}\n\nclass TermAndConditionState extends State<TermAndCondition> {\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () {\n        openUri(Uri.parse(\"https://www.google.com\"));\n      },\n      child: const Center(\n        child: Text(\n          'Terms & Conditions',\n          style: TextStyle(\n            color: Colors.blue,\n            decoration: TextDecoration.underline,\n          ),\n        ),\n      ),\n    );\n  }\n\n  void openUri(Uri uri) {\n    launchUrl(uri);\n  }\n}\n```\n\n這使得我們除了覆寫 TermAndCondition 之外，還得公開 TermAndConditionState 並覆寫。\n\n```dart\nclass TestTermAndCondition extends TermAndCondition {\n  @override\n  State<TermAndCondition> createState() => TestTermAndConditionState();\n}\n\nclass TestTermAndConditionState extends TermAndConditionState {\n  Uri? uri;\n\n  @override\n  void openUri(Uri uri) {\n    this.uri = uri;\n  }\n}\n```\n\n然後我們才能測試，但實際上要驗證的時候也是頗為麻煩，我們得找到 Element，接著從 Element 中找到存在 Element 中的 State，最後我們才能驗證 uri 是否預期。測試流程比起 StatelessWidget 來說，要複雜不只一倍。\n\n```dart\nmain() {\n  testWidgets(\"should open t&c page when click t&c\", (tester) async {\n    var testTermAndCondition = TestTermAndCondition();\n\n    await tester.pumpWidget(MaterialApp(home: testTermAndCondition));\n\n    await tester.tap(find.text(\"Terms & Conditions\"));\n\n    var element = tester.element<StatefulElement>(find.byWidget(testTermAndCondition)) ;\n    var state = element.state as TestTermAndConditionState;\n    expect(state.uri, Uri.parse(\"https://www.google.com\"));\n  });\n}\n```\n\n### Extra And Override 的缺點\n\nExtra And Override 看似方便，其實仔細想想，就會發現並不是最好的方式。因為我們可能會在許多 Widget 都使用 launchUrl，也意味著我們可能需要在每個需要的 Widget 都做一次重複的事情，這顯然提高了測試成本。\n\n## 避免直接依賴 url_launcher\n\n在這個問題上，當然我們也可以選擇避免直接 url_launcher，製作一個 UriRepository 封裝 launchUrl 的操作。然後使用依賴注入框架取得 UriRepository 使用。\n\n```dart\nclass TermAndCondition extends StatelessWidget {\n  const TermAndCondition({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () {\n        getIt<UriRepository>().open(Uri.parse(\"https://www.google.com\"));\n      },\n      child: ...,\n    );\n  }\n}\n\nclass UriRepository {\n  void open(Uri uri) => launchUrl(uri);\n}\n```\n\n這邊我們就不多做示範，相信看到這邊的觀眾應該知道該怎麼處理了。但是今天我們還想提另外一個作法，也就是使用 url_launcher 提供的 API 來注入 Mock 的 UrlLauncher，讓我們繼續看下去。\n\n## 做假的 UrlLauncher\n\n首先我們得在 dev 的相依中加入相關套件 [plugin_platform_interface](https://pub.dev/packages/plugin_platform_interface) 與 [url_launcher_platform_interface](https://pub.dev/packages/url_launcher_platform_interface)。\n\n```bash\nflutter pub add --dev plugin_platform_interface\nflutter pub add --dev url_launcher_platform_interface\n```\n\n為什麼需要這兩個套件呢？因為我們打算直接在測試中把假的 MockUrlLauncher 塞入 UrlLauncherPlatform 的 instance 單例變數，這樣就能讓測試執行到 UrlLauncher 時，使用的是 MockUrlLauncher。\n\n```dart\nUrlLauncherPlatform.instance = MockUrlLauncher();\n```\n\n回到最一開始的問題，需要這兩個套件的原因是 MockUrlLauncher 需要實作來自 url_launcher_platform_interface 中的 UrlLauncherPlatform，和 with 來自 plugin_platform_interface 的 MockPlatformInterfaceMixin。\n\n```dart\nclass MockUrlLauncher \n\t\t\textends Mock \n\t\t\twith MockPlatformInterfaceMixin \n\t\t\timplements UrlLauncherPlatform {\n}\n\n```\n\n為什麼需要 UrlLauncherPlatform 很好理解，因為這個就是 UrlLauncher 的介面，實作了這個介面，我們才能把 MockUrlLauncher 塞到 UrlLauncherPlatform 的 instance 中，那 MockPlatformInterfaceMixin 呢？\n\n如果們看 MockPlatformInterfaceMixin 的原始碼會發現他什麼實作都沒有。簡單來說，MockPlatformInterfaceMixin  只是拿來標示這個類別是測試用的。\n\n```dart\n@visibleForTesting\nabstract class MockPlatformInterfaceMixin implements PlatformInterface {}\n```\n\n當使用 MockUrlLauncher 塞到 UrlLauncherPlatform 的 instance 時，UrlLauncherPlatform 會做一些驗證，但是當塞進去的類別是 MockPlatformInterfaceMixin 時，UrlLauncherPlatform 就會跳過這些驗證，我們也就能避免測試因為這些驗證不通過而紅燈。\n\n最後我們就得到一個 MockUrlLauncher，並在其中監聽 lauchUrl 的呼叫狀況，就能輕鬆測試傳進來的 url 是否有正確了。\n\n```dart\nclass MockUrlLauncher extends Mock with MockPlatformInterfaceMixin implements UrlLauncherPlatform {\n  String? url;\n\n  @override\n  Future<bool> launchUrl(String url, LaunchOptions options) async {\n    this.url = url;\n    return true;\n  }\n}\n```\n\n## 用 MockUrlLauncher 測試\n\n最後我們只要建立 MockUrlLauncher 並它它塞到 UrlLauncherPlatform.instance 中，就能成功測試 launchUrl 的結果是否正確。\n\n```dart\nmain() {\n  setUp(()=> registerFallbackValue(const LaunchOptions()));\n\n  testWidgets(\"should open t&c page when click t&c\", (tester) async {\n    var mockUrlLauncher = MockUrlLauncher();\n    UrlLauncherPlatform.instance = mockUrlLauncher;\n\n    when(() => mockUrlLauncher.launchUrl(any(), any())).thenAnswer((invocation) async => true);\n\n    await tester.pumpWidget(const MaterialApp(home: TermAndCondition()));\n\n    await tester.tap(find.text(\"Terms & Conditions\"));\n\n    verify(() => mockUrlLauncher.launchUrl(\"https://www.google.com\", any()));\n  });\n}\n\nclass MockUrlLauncher extends Mock with MockPlatformInterfaceMixin implements UrlLauncherPlatform {}\n```\n\n與前面的測試方法相比，使用 MockUrlLauncher 除了讓測試變得十分簡單，不同 Widget 之間如果有相同的測試需求，也能重複使用 MockUrlLauncher，也不需要依賴注入框架輔助，讓測試更輕鬆。\n\nP.S 由於這邊需要自己製作 Mock 比較方便，所以我們使用 [mocktail](https://pub.dev/packages/mocktail) 來測試，語法上與 mocktio 有一些小差異，但應該不至於影響閱讀測試。\n\n## 小結\n\n若以 Clean Architecture 的設計分層來說，Widget 是處於為外層的部分，也自然與框架或外部依賴最深，測試也會變得不好測。大多時候我們可以用 Extra And Override 這個萬金油來解決，但同時也必須想想，套件開發者是不是已經為我們準備好可測試的攔截點了，善用這些別人已經造好的輪子，可以除了可以省去寫大量重複程式碼的時間，也可以簡化測試，提升測試的可讀性。",
          "id": "b76473c14c274d048c947afd79ac4f52",
          "filename": "Day 21 測試在 Widget 打開外部連結 b76473c14c274d048c947afd79ac4f52.md",
          "folderName": "Day 21 測試在 Widget 打開外部連結",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 22 在測試中也會畫面跑版？",
          "summary": "在開發 Flutter 時，我們有時會讓 Widget 自動延展，有時會讓 Widget 的大小固定，以應付不同設計需求，當固定大小的 Widget 碰上小一點的畫面，可能就會發生跑板問題。[[範例程式](https://dartpad.dev/?id=00d30888f7137cd35a4002f...",
          "content": "在開發 Flutter 時，我們有時會讓 Widget 自動延展，有時會讓 Widget 的大小固定，以應付不同設計需求，當固定大小的 Widget 碰上小一點的畫面，可能就會發生跑板問題。[[範例程式](https://dartpad.dev/?id=00d30888f7137cd35a4002fbc44082bb)]\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day21/1.png?raw=true)\n\n當我們在開發時看到畫面出現跑版的錯誤時，開發人員就會針對跑版的地方處理。但是有時候，我們測試的裝置畫面都正常，反而在測試出現了跑版的錯誤，那我們要怎麼處理呢？\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day21/2.png?raw=true)\n\n## 調整 Widget Test 中的畫面大小\n\n首先，先讓我們看一下 Widget Test 預設畫面的大小，我們可以在 WidgetTester 的 view 取得相關資訊。\n\n```dart\ntestWidgets(\"check screen size\", (tester) async {\n  print(\"devicePixelRatio: ${tester.view.devicePixelRatio}\");\n  print(\"physicalSize: ${tester.view.physicalSize}\");\n});\n\n// Result\n// devicePixelRatio: 3.0\n// physicalSize: Size(2400.0, 1800.0)\n```\n\n在這邊的 physicalSize 是指畫面的 pixel 長寬，與 devicePixelRatio 運算後的 800 x 600 才是實際 MediaQuery 中取得的大小。如果與模擬器或真實手機比較，可以發現 Widget Test 中的畫面大小其實不算大，我們調整測試中的畫面大小，讓測試通過。\n\n```dart\ntestWidgets(\"show wallet\", (tester) async {\n  tester.view.devicePixelRatio = 1;\n  tester.view.physicalSize = const Size(1080, 1920);\n\n  await tester.pumpWidget(const MyApp());\n\n  expect(find.text(\"5.69%\"), findsOneWidget);\n});\n```\n\n此時應該有觀眾朋友會思考，那我們要調整到多大呢？其實，我們應該思考我們想要支援的尺寸最小應該是多少，然後用所有測試都運行在這個尺寸之上。畢竟我們考量實際情況與成本，我們不可能真的花時間支援任意大小的畫面，而是只需要支援大多數使用者所使用的尺寸即可。\n\n當所有測試都運行在設定最小尺寸的畫面之上後，此時測試還是報了跑版的錯誤，我們就知道我們的畫面可能會有問題，我們就能即時處理。\n\n## 不只畫面，還有文字\n\n在 Widget Test 中的預設字型是 [Ahem font](https://web-platform-tests.org/writing-tests/ahem.html)，這是一種用於測試的文字，主要特點是所有字符都具有相同的寬度和高度，適合用於測試網頁的佈局和對齊。但其實這種文字比於其他文字來的大，所以容易造成在正式運行不會跑版的情況，在測試中跑版了。\n\n### 調整 textScaleFactorTestValue\n\n我們可以調整 textScaleFactorTestValue 來縮小測試中的文字大小，讓他不要過大影響，導致影響測試跑版。\n\n```dart\ntestWidgets(\"show wallet 2\", (tester) async {\n    tester.view.platformDispatcher.textScaleFactorTestValue = 0.5;\n\n    await tester.pumpWidget(const MyApp());\n\n    expect(find.text(\"5.69%\"), findsOneWidget);\n  });\n```\n\n如果是透過這種方式，其實是不夠精準，若想更精準的在測試中確保畫面狀況，我們可以下載程式中使用的字型放在專案中，然後在測試中把字型載入，讓測試也是使用真實字型，確保畫面更準確一點。\n\n```dart\ntestWidgets(\"show wallet\", (tester) async {\n  final robotoMedium = rootBundle.load('assets/fonts/Roboto-Medium.ttf');\n  final fontLoader = FontLoader('Roboto')..addFont(robotoMedium);\n  await fontLoader.load();\n\n  await tester.pumpWidget(const MyApp());\n\n  expect(find.text(\"5.69%\"), findsOneWidget);\n});\n```\n\n## 確保畫面沒有問題\n\n雖然我們 Widget Test 主要想測試的還是使用者行為，不是畫面是否完全符合設計，但並不表示畫面不重要。跑版的畫面大多時候雖然不影響使用者與程式互動，但是會帶來負面觀感。想像一下，如果我們常常在一個應用程式上看到跑版，一下子左邊凸出去，一下子右邊被截掉，是否會連帶覺得應用程式的品質也不佳？\n\n身為一個專業個工程師，我們必須盡量減少程式的缺陷，除了確保功能正確之外，也必須盡量減少畫面跑版帶來的不適感。Widget Test 不是最適合驗證畫面的工具，但是透過給定一些基本畫面設置，我們還是能在測試執行的過程中，幫忙找出一些可能的問題點。\n\n## 小結\n\n當我們 Widget Test 越寫越多時，我們開始容易碰到測試拋出畫面跑版的錯誤。Widget Test 執行的時候沒有畫面，有時候當測試拋出跑版錯誤時，難免需要透過猜測來確認問題出在哪邊。但是今天的討論過後，相信大家未來遇到跑版錯誤時，能有一些概念知道如何解決，問題可能發生在哪邊。\n\n雖然畫面設計大多時候屬於使用者體驗需求，但是我們也不忽略畫面的正確性。當我們有其他測試手段可以確保畫面設計時，此時 Widget Test 的跑版錯誤可能就不那麼嚴重。在 Widget Test 中，測試預設會用 FlutterError.onError 來處理錯誤，當畫面拋出跑版錯誤時，FlutterError.onError 就會收到錯誤進而結束測試。透過修改\n\n## 參考資料\n\n- https://github.com/flutter/flutter/issues/17700\n\n[https://remelehane.dev/posts/widget-testing-rendeflex-overflow/](https://remelehane.dev/posts/widget-testing-rendeflex-overflow/)\n\n[https://stackoverflow.com/questions/57499131/how-to-deactivate-or-ignore-layout-overflow-messages-in-flutter-widget-tests](https://stackoverflow.com/questions/57499131/how-to-deactivate-or-ignore-layout-overflow-messages-in-flutter-widget-tests)\n\n[https://stackoverflow.com/questions/62447898/flutter-widget-test-cannot-emulate-different-screen-size-properly/62460566#62460566](https://stackoverflow.com/questions/62447898/flutter-widget-test-cannot-emulate-different-screen-size-properly/62460566#62460566)\n\n[https://web-platform-tests.org/writing-tests/ahem.html](https://web-platform-tests.org/writing-tests/ahem.html)\n\n##",
          "id": "315fd7c3bc154432b47766983394213f",
          "filename": "Day 22 在測試中也會畫面跑版？ 315fd7c3bc154432b47766983394213f.md",
          "folderName": "Day 22 在測試中也會畫面跑版？",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 23 學會 Widget Test 用法只是開始",
          "summary": "備註: 測試狀態管理 測試通知 測試時間流逝 經過了十幾天的文章，我們介紹了 Finder 用法、模擬使用者操作與如何驗證方式，最後其實觀眾朋友可以發現，Widget Test 在測試的架構上與單元測試基本上沒什麼差異，執行速度也只比單元測試慢一點點。所有可以用在單元測試上的技巧，例如依賴注入或測試...",
          "content": "備註: 測試狀態管理 測試通知 測試時間流逝\n\n經過了十幾天的文章，我們介紹了 Finder 用法、模擬使用者操作與如何驗證方式，最後其實觀眾朋友可以發現，Widget Test 在測試的架構上與單元測試基本上沒什麼差異，執行速度也只比單元測試慢一點點。所有可以用在單元測試上的技巧，例如依賴注入或測試替身，也同樣的可以用在 Widget Test 中，讓開發人員可以精準控制 Widget Test。\n\n## 難在與畫面相關\n\n雖然我們介紹了十幾天的 Widget Test 相關議題，但其實這只是 Widget Test 的開始，真正開始寫 Widget Test 之後，可能會碰到許多大大小小的問題。由於 Widget Test 本身與畫面高度相關，但是在測試過程中我們是看不到畫面的，所以有時候當測試發生錯誤時，我們可能不太好排查問題在哪邊。\n\n在昨天的文章中，我們介紹了如何處理 Widget Test 中的跑版錯誤，但除此之外，還有許多在 Widget Test 可能會遇到的問題點，今天就來補充一下吧。\n\n## 找不到 Builder 中的 Widget\n\n假設我們有一個很長 ListView 列表，當中顯示 100 個項目。[[範例程式](https://dartpad.dev/?id=93afb3874931e8915155122cfdb3b4f8)]\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day22/1.gif?raw=true)\n\n如果測試中嘗試用 Finder 去找出列表中的第 99 項目來驗證時，會發現 Finder 找不不到想要的 Widget，那為什麼會發生這種情況呢？\n\n```dart\ntestWidgets(\"find item 99\", (tester) async {\n  await tester.pumpWidget(const MyApp());\n\n  expect(find.text(\"Title 99\"), findsOneWidget);\n});\n```\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day22/2.png?raw=true)\n\n因為 ListView.builder 為了節省資源，畫面並不會在第一時間就把所有 Widget 建出來，而是等到畫面滑到那個位置的時候，才會去建立 Widget，所以也導致 Finder  找不到 Widget。就像真實的使用者一開打程式也看不到第 99 的項目，必須往下一定距離後才會出現，所以在測試中必須也在模擬向下滑動來讓第 99 個項目出現。\n\n```dart\ntestWidgets(\"find item 99\", (tester) async {\n  await tester.pumpWidget(const MyApp());\n\n  await tester.fling(find.byType(ListView), const Offset(0, -100), 10000);\n  await tester.pumpAndSettle();\n\n  expect(find.text(\"Title 99\"), findsOneWidget);\n});\n```\n\n## 未結束的 Timer\n\n有時候我們會有任務需要延遲執行，例如：在畫面中放了一個 5 秒後會消失的 Hello World。[[範例程式](https://dartpad.dev/?id=f49d01a10702d3e3de3aeef1253336a5)]\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day22/3.gif?raw=true)\n\n如果我只想測試畫面中有沒有出現 Hello World，我們就會很簡單的像下面例子那樣。\n\n```dart\ntestWidgets(\"show hello world\", (tester) async {\n  await tester.pumpWidget(const MyApp());\n\n  expect(find.text(\"Hello World\"), findsOneWidget);\n});\n```\n\n但是實際執行卻發生了錯誤，為什麼呢？如果我們看錯訊息會發現，因為測試結束時還有 Pending 的 Timer 還在等待沒結束，以上面程式來說，就是五秒後要消失的任務還沒執行，裡頭的 Timer 在測試結束時還殘留。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day22/4.png?raw=true)\n\n而解決的辦法也很簡單，我們可以直接在測試的最後呼叫 WidgetTester 的 pump 方法加上時間，讓 Widget Test 直接往前五秒，讓等待的 Timer 執行完成。\n\n```dart\ntestWidgets(\"show hello world\", (tester) async {\n  await tester.pumpWidget(const MyApp());\n\n  expect(find.text(\"Hello World\"), findsOneWidget);\n\n  await tester.pump((const Duration(seconds: 5)));\n});\n```\n\n## 在測試中處理文字\n\n在處理圖片的測試的文章中，我們提到可以用 flutter_gen 來產生圖片常數，同樣的道理，放在驗證文字的情境中，我們也可以使用相同的技巧，避免在程式與測試中寫死重複的文字。假設我們使用 Flutter 官方文件中的方式處理文字，我們會在 MaterialApp 中設定 localizationsDelegates 設定翻譯。\n\n```dart\nMaterialApp(\n  localizationsDelegates: AppLocalizations.localizationsDelegates,\n\tsupportedLocales: AppLocalizations.supportedLocales,\n\t...\n)\n```\n\n在測試中，我們也可以根據不同語言，建立測試中所使用語言的 Localizations 物件，在下面的例子中，我們就建立了英文的 Localization 物件，直接拿著物件中的 hello_world 來驗證，我們想要測試的是畫面中是否有出現正確資訊，而不是文字翻譯的對錯與否。\n\n```dart\ntestWidgets(\"show hello world\", (tester) async {\n  var localization = await AppLocalizations.delegate.load(const Locale(\"en\"));\n\n  await tester.pumpWidget(const MyApp());\n\n  expect(find.text(localization.hello_world), findsOneWidget);\n})\n```\n\n這樣還有個優點，當文字內容發生改變時，我們只要更新了文字檔裡面的文字即可，測試並不需要跟著修改。在處理多國語言的問題上，除了官方內建處理方式，還有各種不同套件也可以協助處理，例如：[easy_localization](https://pub.dev/packages/easy_localization)，相信也是可以用類似的方法處理。\n\n## 小結\n\n今天是介紹 Widget Test 的最後一天，補充了一些 Widget Test 會遇到什麼問題，不過問題肯定不只這樣，像是使用了 [visibility_detector](https://pub.dev/packages/visibility_detector) 後，如果沒有仔細閱讀文件，可能也會在 Widget Test 遇到錯誤。Widget Test 雖然很強大，可以讓我們用簡單的 API 直接從使用者的角度測試程式的完整行為，但是也如一開始提到的，Widget Test 與畫面高度相關，使得要了解測試 API 比較多，碰到問題也比較難解決，需要多寫才能掌握。\n\nWidget Test 的部分就介紹到這邊，在未來的幾天中，我們會聊一些跟測試相關的議題，諸如，為什麼要寫測試或我該測試什麼 …等等，有興趣的觀眾朋友還歡迎繼續追蹤。",
          "id": "802b67cc93d640a5b350675dfe3b3f15",
          "filename": "Day 23 學會 Widget Test 用法只是開始 802b67cc93d640a5b350675dfe3b3f15.md",
          "folderName": "Day 23 學會 Widget Test 用法只是開始",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 24 為什麼要寫測試",
          "summary": "在過去二十幾天的文章中，我們討論了單元測試，討論了 Widget Test，不知道有沒有觀眾會好奇，到底我們為什麼要測試？工程師的工作不就是寫程式嗎？測試就交給更專業的 QA 去做就好了啊，QA 肯定更專業，能比我們測出更多問題，何必讓不是測試專業的工程師來做測試呢？今天我們就來聊聊這個話題。 在 ...",
          "content": "在過去二十幾天的文章中，我們討論了單元測試，討論了 Widget Test，不知道有沒有觀眾會好奇，到底我們為什麼要測試？工程師的工作不就是寫程式嗎？測試就交給更專業的 QA 去做就好了啊，QA 肯定更專業，能比我們測出更多問題，何必讓不是測試專業的工程師來做測試呢？今天我們就來聊聊這個話題。\n\n## 身為專業的工程師\n\n在 [The Clean Coder](https://www.tenlong.com.tw/products/9789862017883) 書中，Uncle Bob 認為開發人員不應該交付有問題的程式，當我們寫好程式之後，我們應該檢查程式有沒沒有問題，無論是手動測試或自動化測試，都應該盡可能的確認程式已經沒有問題之後才交付出去。若我們隨意地寫完程式就交付，QA 可能因為缺陷太多無法測試，只能回報基本的缺陷就退回給開發人員，直到開發人員修復了這些基本缺陷，QA 才能更進一步的測試，如此一來一回，就嚴重影響了產品的進度。在交付軟體之前仔細的檢查，確保軟體內在與外的的品質兼具，這才是專業的表現。\n\n## 交付價值\n\n想一想，如果我們日常使用的軟體，使用者用一用就會遇到問題，那這軟體對使用者還有足夠價值嗎？那我們更進一步想的話，如果開發人員交付的軟體是充滿缺陷的，是否也代表著開發人員的產出缺乏價值。程式碼並不等於價值，能真正交到使用者手上，幫使用者解決問題的程式碼才有價值。那我們怎麼知道我們正在交付有價值的東西？我們有測試時，每當我們要交付軟體時，測試會告訴我們軟體是能不能正常運作，我們就能更有信心地知道我們在交付有價值的東西。\n\n## 那是不是不需要 QA 了\n\n或許有人會好奇？那既然工程師都能寫測試了，那我們是不是就不需要 QA 了？雖然開發人員也可以寫測試，但是大多數開發人員都是依照需求來測試，測試正常路徑與非正常路徑。但是隨著軟體越來越複雜，功能與功能的交錯可能會引發意想不到的缺陷，根據不同的功能採取不同的測試策略，能有效找到比較難以發現的問題，這是專業 QA 能做到，而開發人員比較難做到的。當開發人員用自動化測試避免了基本的缺陷，QA 才更有時間能專注在發現難以發現的缺陷，更進一步的提升軟體品質。\n\n## 測試驅動開發\n\n測試除了能幫我們驗證程式是否正常運作之外，測試也能幫我設計軟體，**測試驅動開發**就是一門這樣的技術。在開始寫程式之前，我們先分析需求，把需求拆分成更小任務，寫程式之前，我們先寫測試，用測試決定好這一段時間內要產出的功能是什麼，避免一口氣完成整個需求。然後我們就能朝這個目標前進。在這過程中，自然而然的，我們的程式碼就具備了可測試性。當我們完成第一版後，有程式也有測試，然後我們就能安全的重構，最後得到品質更好的程式。其實測試驅動開發與做事情的態度一樣，我們應該先把事情做對，在把事情做好。\n\n## 開發時間不夠\n\n有時候，開發人員也知道要寫測試，但是許多外部因素導致我們不能寫測試，最常見的原因就是開發時間不夠了。老闆總是安排了太多工作，又壓了時程，導致開發人員完成需求就已經時間不夠了，更不用談測試，那我們開怎麼做呢？我們必須熟練各種程式與測試技巧，善用開發工具的快捷鍵，讓用工具幫忙做例行操作，自然而然就有時間寫測試了。\n\n當我們開始寫測試之後，測試是會幫我們節省開發時間的，當功能越來越複雜，協作人員越來越多，程式被改壞的機會也變高，我們可能有大半的時間都浪費在處理 Bug。當我們開始寫測試之後，測試達到一定的量，測試就會反過來節省處理 Bug 的時間。\n\n## 小結\n\n今天聊了許多應該寫測試的原因，但是我們也知道，或許公司沒有這樣的文化，或許開發時間不夠，或許開發人員沒學過，總總原因造成我們無法寫測試。但是這都不應該是阻止我們寫測試的理由，寫測試並不難，即便現在沒有，我們也可以在之後的開發中一點一點的加入測試，先從 0 到 1，再慢慢的從 1 到 10，到 100，我們才能慢慢從 Bug 海中脫離。\n\n如果觀察過去，幾乎沒有因為 Coding Bug 或許測試就可以寫少一點，只保護我們最重要的部分\n\n以終為始\n\n由於我們會從使用者行為，由於寫測試時，我們第一步就必須思考我們的功能要達到什麼目的，先把目標定義\n\n有助於在開發時專注目標，每一個測試都是一小步，透過多個測試與實作，逐步的完成功能。\n\n老闆不讓我寫測試\n\n逃了\n\n工程師的十大錯覺之一：我沒改壞",
          "id": "6186f819558b4534ae2cb6ad4c61cc6b",
          "filename": "Day 24 為什麼要寫測試 6186f819558b4534ae2cb6ad4c61cc6b.md",
          "folderName": "Day 24 為什麼要寫測試",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 25 我該測試什麼？",
          "summary": "當我們知道怎麼寫單元測試，怎麼寫 Widget Test 之後，很快就會碰到一個問題，那就是我該測試什麼？我們都知道，測試應該是要驗證需求，驗證功能是不是正確的，這個定義似乎很清楚，但是實際開始寫的時候，有時候就會遇到一些問題，今天就來談談。 讓我們看一段程式碼，在這個方法中，除了主要處理建立訂單的...",
          "content": "當我們知道怎麼寫單元測試，怎麼寫 Widget Test 之後，很快就會碰到一個問題，那就是我該測試什麼？我們都知道，測試應該是要驗證需求，驗證功能是不是正確的，這個定義似乎很清楚，但是實際開始寫的時候，有時候就會遇到一些問題，今天就來談談。\n\n## 要不要測試日誌記錄？\n\n讓我們看一段程式碼，在這個方法中，除了主要處理建立訂單的商業邏輯之外，方法裡還多 log 了起迄時間，以便未來查找問題。\n\n```dart\nvoid store(Product product) {\n\tlog(\"store ${product.id} start at ${DateTime.now()}\");\n\n\tif (product.price > wallet.money) {\n\t\tthrow MoneyNotEnoughException();\n\t}\n\t_orderRepository.create(product);\n\n\tlog(\"store ${product.id} end at ${DateTime.now()}\");\n}\n\n```\n\n在先前的練習中，我們會測試商品購買成功與購買失敗的行為，那我們要測試 log 嗎？再讓我們看個例子。\n\nPS. 請注意，上面 log 用法只是舉例，實務上會有更好的方式。\n\n## 要不要測試顏色是否正確？\n\n在先前的例子中，我們顯示剩餘數量的畫面中，當數量小於 10 時，會特別把文字標成紅色，讓強化使用者的感受。\n\n![](https://raw.githubusercontent.com/easylive1989/images/master/static/images/2023IThome/Day24/1.png)\n\n```dart\nText(\n  quantity.toString(),\n  style: TextStyle(color: quantity < 10 ? Colors.red : Colors.black),\n),\n\n```\n\n在這個例子中，我們要不要測試文字顏色呢？甚至是長寬高的顏色，或者按鈕的顏色，是不是都需要測試呢？\n\n回到一開始的目的，我們要測試的程式功能有沒有正常，是不是跟需求一致。\n\n## 什麼是需求？\n\n開發人員在開工前可能參加 Planning，討論這個 Sprint 要做什麼，針對不同的任務討論這邊的功能是如何如何，那邊的功能是如何如何，可能也會收到一份設計稿，上面標示了按鈕要多大，對話框要放在什麼位置，背景要什麼顏色，字體要用多大。我們從設計師手中拿到設計稿。接著回到團隊，又會從系統角度開始討論任務要如何完成，架構應該怎麼調整，出錯時怎麼送出通知 …等。最後每個任務都包含了很多各種需求，其中有商業需求，有工程需求，有增加使用者體驗的需求。\n\n## 把時間花在刀口上\n\n如果我們擁有無限的時間，那我們當然可以把商業需求與增加使用者體驗的需求都加上測試，既確保了功能正常，也確保了使用者可以有最好的體驗。但現實總是殘酷的，只要產品還在發展，我們就會有無止盡的工作，必須評估每個任務的價值。如果我們發現花時間寫的東西的效益不高，那我們可以與團隊討論，決定是否轉頭去做更有價值的事情。\n\n## 顏色就不重要嗎？\n\n那是不是顏色或字體大小就不重要了呢？非也，想像一下，假設我們今天是在開發一個小畫家的功能，那我們需不需要測試使用者用紅色畫筆在畫布上畫出紅色線條呢？或者是我們的程式可以讓使用者調整字體大小，在這種情況下，我們是不是該測試使用者調整過後，字體有沒有如預期的變大變小呢？\n\n其實我們無法一概而論的說什麼東西一定不用測試，什麼東西一定要測試，更多時候是依據價值來決定，什麼東西重要，什麼東西不重要，都是根據需求的不同，而會有不同的情況。\n\n## 不要測試套件\n\n同樣的，在測試的時候，我們大多情況下會隔離框架或第三方套件，我們只測試我們必須要維護的程式碼，大多時候我們會傾向於相信第三方的程式碼正常運作，甚至是有測試過的，畢竟如果我們不相信它的話？那我們為什麼還使用它呢？。這邊需要注意的是，我們不測試的是第三方套件 API 的行為，但是我們還是有可能會需要測試我們是否正確地使用了第三方套件。\n\n## 不測試 Private 方法\n\n一個類別會包含各種 scope 的方法：public、private、protect 方法 …等。那我們是否該測試類別中的所有方法呢？答案是不需要，以單元測試來說，我們想測試的是類別行為。只要程式中不存在冗余的程式碼，類別中的除了 public 之外的所有方法，最終應該都被某個 public 方法使用到，透過測試這個 public 方法，private 方法的行為自然也能被測試到。\n\n如果我們硬是要測試某個 private 反倒是破壞了類別的封裝，讓測試對類別的認識過於細節，也將容易導致[測試脆弱](http://xunitpatterns.com/Fragile%20Test.html)的問題。\n\n或許有些時候，開發人員會發現從 public 方法開始測試的話，會需要準備很多資料，讓測試變得難寫，所以乾脆就直接測試 private 方法或者索性把 private 方法改成 public 方法。但其實都是不好的，就前面文章一再提到的，不好測試的時候，我們應該回頭檢視設計，而非妥協不好的設計。\n\n## 小結\n\n確保我們在寫有用的測試，也是身為專業開發人員的職責，畢竟我們得把時間花在有價值的地方。就像 Kent Beck 說「I get paid for code that works, not for tests」，我們寫測試的最終目的還是為了可用的程式，追求每一個角落都要被測試，可能反而本末倒置。\n\n[https://software-engineering-at-google.gh.miniasp.com/?fbclid=IwAR3zyMiYz2j9eoSdh6WHHYF4uq_-FIWPQM1BqP9az2P8O2cWVL_-v9tTOio#/zh-cn/Chapter-1_What_Is_Software_Engineering/Chapter-1_What_Is_Software_Engineering?id=policies-that-scale-well-規模化策略](https://software-engineering-at-google.gh.miniasp.com/?fbclid=IwAR3zyMiYz2j9eoSdh6WHHYF4uq_-FIWPQM1BqP9az2P8O2cWVL_-v9tTOio#/zh-cn/Chapter-1_What_Is_Software_Engineering/Chapter-1_What_Is_Software_Engineering?id=policies-that-scale-well-%e8%a6%8f%e6%a8%a1%e5%8c%96%e7%ad%96%e7%95%a5)\n\n## 以終為始\n\n當我們寫測試時，我們可以從 Assert 的步驟開始思考，思考想要驗證什麼結果，然後往回思考 Act 的步驟，為了得到這個結果，我們應該測試哪個方法，最終才根據情況來決定 Arrrage 的步驟應該建立物件與準備什麼資料，以終為始的思考方式，可以讓我們的測試案例更加精準\n\n## 什麼需求\n\n當我們\n\n在前幾天的文章我們談到測試錯誤，在其中\n\nLog 不是需求\n\n該測試私有方法嗎\n\n我該測試 Color 嗎\n\n談論我們該測試什麼\n\n碧昂絲法則\n\n應該測試功能需求 而不是工程需求\n\n談論用價值決定該不該測試\n\n壞了會不會死人\n\n我要測試 Scheduler 嗎？還是只需要測試執行任務的方法？依照商業需求而定，如果她很重要，那就測試，如果他錯了也不會造成太大影響，就可以選擇是否測試\n\n處理 Legacy Code 的注意事項\n\n我們在處理 Legacy Code 時，盡量從小範圍開始慢慢修改，慢慢往外擴張，而不是一次的把整個專案都翻過來重寫。",
          "id": "771747c54c3444b496386bd02b2f2f26",
          "filename": "Day 25 我該測試什麼？ 771747c54c3444b496386bd02b2f2f26.md",
          "folderName": "Day 25 我該測試什麼？",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 26 我該怎麼測試？",
          "summary": "前兩天談論了測試的 Why 與 What，今天我們就來談談測試的 How 了，首先就讓我們來討論測試案例的議題吧。 在寫測試的時候，如果測試目標的行為很簡單，裡頭只有一個 if 判斷，我們很容易就能列出兩個測試案例，if 成立的狀況與 if 不成立的狀況。 ```dart Future<void> ...",
          "content": "前兩天談論了測試的 Why 與 What，今天我們就來談談測試的 How 了，首先就讓我們來討論測試案例的議題吧。\n\n## 設計測試案例\n\n在寫測試的時候，如果測試目標的行為很簡單，裡頭只有一個 if 判斷，我們很容易就能列出兩個測試案例，if 成立的狀況與 if 不成立的狀況。\n\n```dart\nFuture<void> purhcase(Product product) async {\n\tvar wallet = _walletRepository.get();\n\tif (product.price > wallet.money) {\n\t\tthrow MoneyNotEnough();\n\t}\n\n\t_productRepository.purchase(product);\n}\n```\n\n在上面的例子中，我們很容易的可以列出兩種情境。\n\n1. 餘額不足\n2. 餘額足夠\n\n當然我們甚至還會測試取得餘額失敗與購買失敗的非正流程。\n\n大多時候，我們從客戶那邊了解的是需求的規則，到了開發階段，我們直接拍腦袋思考正常路徑有哪些情況，非正常路徑有哪些情況，轉成一個一個的測試案例，那每次我們拆解測試案例都這麼簡單嗎？\n\n## 稍微複雜一點的邏輯\n\n假設我們正在設計一個計算遊樂園票價的計算機，票種可以分成全票 100 元、半票 50 元，購買時如果身份是軍警可以打 8 折，如果是學生則可以 7 折。由於規則比較複雜，所以測試案例也隨著越來越多，那我們要怎麼知道測試案例否準備的足夠完整呢？會不會還有重要的情境沒考慮到？其實我們是可以依靠一些分析測試案例的方法來解決問題。\n\n### 列出所有組合\n\n分析測試案例最簡單的方式，就是就是把所有可能的變因組合都列出來，以上面的例子來說，我們就可列出 2 * 3  = 6 種組合。\n\n|  | 票種 | 職業 |\n| --- | --- | --- |\n| 1 | 全票 | 軍警 |\n| 2 | 全票 | 學生 |\n| 3 | 全票 | 其他職業 |\n| 4 | 半票 | 軍警 |\n| 5 | 半票 | 學生 |\n| 6 | 半票 | 其他職業 |\n\n但其實聰明的觀眾很快就會發現，一旦變因多的時候，例如身分證字號有符合 3 碼的人免費。此時，可以發現測試案例也會跟著暴增，此時我們可以考慮使用其他的測試方式。\n\n### **Pairwise Testing**\n\n在 Pairwise Testing 中，不要求列出所有組合，而是讓兩兩一組的變因組合至少出現在某個測試案例中。例如：軍警 x 全票就是一種組合。\n\n|  | 職業 | 職業 | 是否身分證字號符合 3 碼 |\n| --- | --- | --- | --- |\n| 1 | 軍警 | 全票 | Yes |\n| 2 | 軍警 | 半票 | No |\n| 3 | 學生 | 全票 | Yes |\n| 4 | 學生 | 半票 | No |\n| 5 | 其他職業 | 全票 | Yes |\n| 6 | 其他職業 | 半票 | No |\n| 7 | 其他職業 | 半票 | Yes |\n\n可以發現，使用 Pairwise Testing 方法，讓原本需要 2 * 3 * 2 = 12 個測試案例可以減少到 7 個，當變因更多時，能更有效地減少案例。那好奇的觀眾朋友可能會問，這樣會不會錯誤就發生在其他組合呢？答案是有可能會，所以在使用 Pairwise Testing 時，我們還是得檢查一下設計組合，增加明顯有意義的組合，或去除掉一些可能沒有意義的組合，例如軍警 x 半票的組合。\n\n不過 Pairwise Testing 看似好像美好，但實際上還是有一些限制，如果我們的例子是幾乎是舉不完的時候，就很難使用這種方式，假設買門票可以使用折價券，折數在 1折~9折之間，可能有 88 折，可能有55 折，顯然我們不太可能真的窮舉可能的折數。\n\n### **Boundary-Value Analysis**\n\n當我們測試變因跟數字有關時，我們就可以使用這個邊界值分析方法，在選擇合法與不合法邊界的值來測試，可能會比較容易找到有沒處理到的情境。以上面的例子來說 0.9 折 、1 折、1.1 折、8.9 折、9 折、9.1 折 …等等或許就是可能的測試選項。\n\n![Untitled](Day%2026%20%E6%88%91%E8%A9%B2%E6%80%8E%E9%BA%BC%E6%B8%AC%E8%A9%A6%EF%BC%9F/Untitled.png)\n\n出處：[https://en.wikipedia.org/wiki/Boundary-value_analysis](https://en.wikipedia.org/wiki/Boundary-value_analysis)\n\n不同的測試方法也可以混合著使用，例如我們就可以用邊界值分析法找出幾個有用的值，再來做 Pairwise Testing。\n\n### 更多的測試案例分析方法\n\n其實我們只舉了一些簡單常見的方法，每個方法都有他的限制與適用情境，並沒有一個方法可以用在各種情況，所以如果想更好的分析測試案例，我們還需要認識許多其他的分析測試案例方法，例如：Decision Table、Equivalence partitioning、State Transition Testing …等，這些方法除了可以拿來分析測試案例，也可以拿來在開發之前，分析需求的各種情境，有興趣的朋友也可以參考 [David Ko 的學習之旅](https://kojenchieh.pixnet.net/blog)。\n\n## 兩種不同的測試策略\n\n當我們設計好測試案例之後，接下來就是寫測試的時間了。關於怎麼寫測試，我們在前面的文章講了很多，這邊我們補充兩種不同的測試策略：社交性測試與孤島型測試。\n\n### 孤島型測試\n\n寫單元測試時，我們會用測試替身取代 SUT 以外的所有依賴，並設定假資料給測試替身，使得 SUT 可以走不同流程，這個稱為**孤島型測試**。\n\n![solatry_test.jpg](Day%2026%20%E6%88%91%E8%A9%B2%E6%80%8E%E9%BA%BC%E6%B8%AC%E8%A9%A6%EF%BC%9F/solatry_test.jpg)\n\n出處：[https://martinfowler.com/bliki/UnitTest.html](https://martinfowler.com/bliki/UnitTest.html)\n\n但是我們也可以想想，最初我們使用測試替身的目的是為了取代難以控制的依賴，來讓測試穩定快速，若今天我們使用真的依賴放進 SUT 中也不會造成問題，那我們是否還需要測試替身？\n\n### 社交型測試\n\n在**社交型測試**的策略中，我們僅僅會在難以測試的時候，才使用測試替身協作。其他時候都是讓 SUT 與真正的類別互動。當然，在這種策略之下，雖然我們依賴是使用正式程式碼在用的類別，但是我們測試的主角還是 SUT 本身，而不是依賴。\n\n![sociable_test.jpg](Day%2026%20%E6%88%91%E8%A9%B2%E6%80%8E%E9%BA%BC%E6%B8%AC%E8%A9%A6%EF%BC%9F/sociable_test.jpg)\n\n出處：[https://martinfowler.com/bliki/UnitTest.html](https://martinfowler.com/bliki/UnitTest.html)\n\n### 兩種測試有什麼差別？\n\n在孤島型測試中，測試除了知道 SUT 和 SUT 有哪些依賴之外，測試也對於 SUT 怎麼用測試替身是有一定了解的，因為我們要在測試中對測試替身設定一些假資料。但是在社交型測試中，測試只會知道 SUT 與 SUT 有哪些依賴，測試不會認識 SUT 怎麼與測試替身互動。那測試知不知道 SUT 與依賴如何互動有什麼差別呢？其中一個差別會發生在重構的時候，使用孤島型測試時，如果我們修改了 SUT 與依賴的互動方式，測試也需要跟著修改。相反的，社交型測試則有比較大的機會不用修改。\n\n這兩種測試策略其實也沒有誰好誰壞，因為我們的最終目的都是測試可以快又穩定，有時候我們會發現使用真依賴的社交型測試比較方便，也時候我們會發現寫孤島型的測試比較方便，需要開發人員根據不同的情況選擇。\n\n## 小結\n\n雖然我們介紹了二十幾天的測試技巧，但其實與測試相關的議題並不只這些，隨著我們測試越寫越多，我們開始會碰觸到各種不同的議題，寫測試與寫程式一樣，都有許多十分值得深入討論的議題，需要持續不斷的學習與思考，才能讓提高寫測試的效率。\n\n[https://martinfowler.com/articles/is-tdd-dead/](https://martinfowler.com/articles/is-tdd-dead/)\n\n## 測試也是需求文件\n\n當然還有許多其他種設計測試案例的方法，\n\n### 這是單元測試嗎？\n\n或許有人會認為這個不能稱為單元測試，而是整合測試，確實，若是以最嚴謹的單元測試定義來看，這個確實不能算是單元測試。由於測試的範圍涵蓋較大，在將來測試錯誤時，也比較難以追蹤問題根源。但是這類測試也並非全是壞處，由於我們的測試是以使用者角度來設計測試案例，相比於傳統的單元測試，所以從這種**小型測試**的測試案例中，我們能更直觀的了解一個完整流程的行為，而非片段的行為。\n\n## 因果清晰的資料\n\nKent Beck 測試驅動開發\n\n### \n\n[https://martinfowler.com/bliki/UnitTest.html](https://martinfowler.com/bliki/UnitTest.html)\n\n[https://software-engineering-at-google.gh.miniasp.com/?fbclid=IwAR3zyMiYz2j9eoSdh6WHHYF4uq_-FIWPQM1BqP9az2P8O2cWVL_-v9tTOio#/](https://software-engineering-at-google.gh.miniasp.com/?fbclid=IwAR3zyMiYz2j9eoSdh6WHHYF4uq_-FIWPQM1BqP9az2P8O2cWVL_-v9tTOio#/)\n\n[https://software-engineering-at-google.gh.miniasp.com/?fbclid=IwAR3zyMiYz2j9eoSdh6WHHYF4uq_-FIWPQM1BqP9az2P8O2cWVL_-v9tTOio#/zh-cn/Chapter-11_Testing_Overview/Chapter-11_Testing_Overview](https://software-engineering-at-google.gh.miniasp.com/?fbclid=IwAR3zyMiYz2j9eoSdh6WHHYF4uq_-FIWPQM1BqP9az2P8O2cWVL_-v9tTOio#/zh-cn/Chapter-11_Testing_Overview/Chapter-11_Testing_Overview)",
          "id": "142c204d9a994d6db2bd0a7fac02914c",
          "filename": "Day 26 我該怎麼測試？ 142c204d9a994d6db2bd0a7fac02914c.md",
          "folderName": "Day 26 我該怎麼測試？",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 27 測試足夠了嗎？",
          "summary": "在前幾天的文章中，我們知道了需求有很多種，有功能需求，有工程需求，有增加使用者體驗的需求 …等，測試肯定也不會少寫，那我們到底要寫多少測試才夠呢？畢竟隨著我們測試越寫越多，維護的成本也越來越高，今天就來聊聊測試是否夠多了的問題吧 在單元測試中，有一些指標可以讓我們參考測試夠完整，其中**測試覆蓋率*...",
          "content": "在前幾天的文章中，我們知道了需求有很多種，有功能需求，有工程需求，有增加使用者體驗的需求 …等，測試肯定也不會少寫，那我們到底要寫多少測試才夠呢？畢竟隨著我們測試越寫越多，維護的成本也越來越高，今天就來聊聊測試是否夠多了的問題吧\n\n## 單元測試夠了嗎？\n\n在單元測試中，有一些指標可以讓我們參考測試夠完整，其中**測試覆蓋率**是一個滿常見的指標，用來指出我們專案中的有多少行程式碼、多少類別是有被測試到的。\n\n### 產生測試覆蓋率報告\n\n在 Flutter 中，我們可以下面指令來跑一次測試，並產出測試覆蓋率的報告。\n\n```bash\nflutter test --coverage\n```\n\n預設報告放在專案根目錄中的 coverage 資料夾，裡頭有個 lcov.info 就是測試覆蓋率報告。\n\n![Screenshot 2023-10-11 at 10.16.04 AM.png](Day%2027%20%E6%B8%AC%E8%A9%A6%E8%B6%B3%E5%A4%A0%E4%BA%86%E5%97%8E%EF%BC%9F/Screenshot_2023-10-11_at_10.16.04_AM.png)\n\n有許多工具可以讀取覆蓋率報告檔案，這邊我們使用 Intellij Idea 來展示，打開工具列中，Run ⇒ Show Coverage Data，最後選擇讀取剛剛產生的 lcov 檔案，就能看到測試覆蓋率了。\n\n![Screenshot 2023-10-11 at 10.17.21 AM.png](Day%2027%20%E6%B8%AC%E8%A9%A6%E8%B6%B3%E5%A4%A0%E4%BA%86%E5%97%8E%EF%BC%9F/Screenshot_2023-10-11_at_10.17.21_AM.png)\n\n除此之外，macOS 的朋友也能安裝 lcov 套件，然後用 genhtml 命令來產生更網頁版的報告。\n\n```bash\nbrew install lcov\n\ngenhtml coverage/lcov.info -o coverage/html\n```\n\n![Screenshot 2023-10-11 at 10.24.09 AM.png](Day%2027%20%E6%B8%AC%E8%A9%A6%E8%B6%B3%E5%A4%A0%E4%BA%86%E5%97%8E%EF%BC%9F/Screenshot_2023-10-11_at_10.24.09_AM.png)\n\n### 測試覆蓋率並不重要\n\n我們可以用測試覆蓋率來確認測試是不是夠完整，但是需要注意的是，測試覆蓋率並不適合作為唯一指標，畢竟我們很可能為了讓覆蓋率數字漂亮，就去會寫許多意義不大的測試，或者在重要的地方只有一兩個測試。那除了測試覆蓋率之外，我們還有什麼指標可以使用呢？\n\n我們可以回頭思考測試的目的是什麼？測試其中一個目的是增加產品的品質，所以我們可以觀察每週的 Bug 數量是否有變少的趨勢，或者是近幾次產品 Release 是否順利，出問題的次數有沒有變少，這些都是一些可以觀察的指標。\n\n除此之外，開發人員的信心也是一項指標，可以想一想我們是否有足夠的信心在放假前 Release 產品。如果我們測試足夠完整，開發人員有信心通過測試的產品不太會有什麼大問題，願意在放假前 Release 產品，其實也是一種測試足夠完整的表現。\n\n## 測試金字塔\n\n我們都知道自動化測試有很多種，有 UI 測試、有整合測試、也有單元測試 …等。不同的測試的測試目的也不相同，維護的成本自然也不相同。維護成本越高的測試，我們能寫的數量也會越少，大多時候是用來測試最重要的功能。以 UI 測試來說，雖然我們可以從使用者的角度來測試最真實的狀況，但也容易受到各種原因導致測試失敗，可能是功能真的有問題，也可能是網路波動導致 API 回錯造成測試失敗，開發人員得花時間檢查才能知道原因，這也是為什麼維護成本高的原因。越下層的測試執行起來越穩定，速度越快，維護成本較低，所以測試數量也能比較多，最後形成金字塔的形狀，也是比較健康的比例。\n\n![test-pyramid.png](Day%2027%20%E6%B8%AC%E8%A9%A6%E8%B6%B3%E5%A4%A0%E4%BA%86%E5%97%8E%EF%BC%9F/test-pyramid.png)\n\n出處 [https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html)\n\n### 冰淇淋筒狀\n\n與測試金字塔相反的是冰淇淋測試，在下面圖片中，我們可以看到最大量的是手動測試，往下依序是數量最多 UI 測試、數量次之的整合測試、數量最少單元測試。當我們發現專案的測試數量比例是冰淇淋筒狀的時候，我們可能會花很多時間在維護測試，每次都需要執行大量的手動測試來確保產品品質，而無法透過單元測試來避免基本問題。\n\n![Untitled](Day%2027%20%E6%B8%AC%E8%A9%A6%E8%B6%B3%E5%A4%A0%E4%BA%86%E5%97%8E%EF%BC%9F/Untitled.png)\n\n出處：[https://abseil.io/resources/swe-book/html/ch14.html](https://abseil.io/resources/swe-book/html/ch14.html)\n\n當然解決方法也就跟處理遺留代碼的方式一樣，我們透過迭代的方式，逐步在專案中引入更多的單元測試，讓專案可以透過單元測試避免一些基本的問題，然後才在此之上用整合測試和 UI 測試保護重要流程。\n\n### 沙漏型的測試\n\n在工具越來越優化，機器性能越來越好的今天，很多過去可能要花很久的而且不穩定的 UI 測試，用新的工具或框架來測試都能有效提高執行效率與穩定性。像是我們可以在本地端把所有前端、後端、資料庫都建起來，跑起 UI 測試就比較不會受到外在因素干擾，也會比較穩定，這在過去機器性能比較差的時候，可能比較難做到。\n\n當我們的 UI 測試有一定的穩定度，那我們可能就會減少整合測試，畢竟如果 UI 測試穩定度與執行速度都能跟整合測試一樣，那我們就沒什麼理由做整合測試。像是在開發 Flutter 的時候，Widget Test 的數量是可以寫比較多的，因為 Widget Test 無論是執行速度或穩定性，其實運行起來速度都十分快，此時檢視測試數量之間的比例可能就會變成沙漏型。\n\n![截圖 2023-10-10 下午10.27.56.png](Day%2027%20%E6%B8%AC%E8%A9%A6%E8%B6%B3%E5%A4%A0%E4%BA%86%E5%97%8E%EF%BC%9F/%25E6%2588%25AA%25E5%259C%2596_2023-10-10_%25E4%25B8%258B%25E5%258D%258810.27.56.png)\n\n其實無論是金字塔型、冰淇淋筒狀、或者是沙漏型，我們最終需要確保的是測試的維護成本是在合理的範圍，只要我們能使用最合適的方式，控制測試維護成本落在合理範圍，維持產品品質，最後我們的測試數量比例呈現什麼形狀倒不是太重要。\n\n## 不只單元測試\n\n雖然我們整個系列都在談論單元測試和 Widget Test 等自動化測試，但其實自動化測試只能測試我們已經想到的情境，那些我們想都沒想過的情境，我們肯定也不會為它寫測試。如果專案不大，或許問題不大，但是隨著功能越加越多，需求越來越複雜，不同功能交叉在一起可能會有意想不到的問題發生，這些問題幾乎不太可能用自動化測試找出來。\n\n### 各種不同的測試方法\n\n除了我們常見的單元測試、整合測試、UI 測試，其實測試還有許多不同的測試方法，例如探索性測試、冒煙測試，不同的測試方法的目的與效果也不相同，可以把不同的測試想像成不同的網子，不同網子可以捕捉到的問題也不同，把各種不同的網子一起使用，最後真正能露出去問題就都只是小問題，產品品質也由此而生。\n\n### 自己的狗糧自己吃\n\n除了測試之外，我們也應該**吃自己的狗糧**，什麼是吃自己狗糧呢？簡單來說就是真正的去使用自己開發的產品。有時候，產品雖然不會出錯，但卻不好用，可能是流程不順暢，提示不明確 …等的使用者體驗問題，這些問題可能不會被歸類為 Bug，但是開發人員也應該要關心這些問題，畢竟我們寫程式的目的是解決使用者的問題，如果使用者最後因為體驗不佳而離開，我們寫的程式也失去了存在的意義。\n\n![Untitled](Day%2027%20%E6%B8%AC%E8%A9%A6%E8%B6%B3%E5%A4%A0%E4%BA%86%E5%97%8E%EF%BC%9F/Untitled%201.png)\n\n## 小結\n\n無論是自動化測試，或手動測試，其最終的目的都是提昇產品品質，比起一昧使用單元測試，組合使用不同的測試方式，能更有效的達到目的。但是雖然我們可以使用各種不同的測試來測試產品，但是還是注意每一種測試方式的成本，透過調配不同測試之間的比例，才能讓在有限的時間裡發揮最大的效益。\n\nKent Beck 的測試哲學\n\n[https://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests/153565?fbclid=IwAR0umHMTEmVBjdY0FNyBP_BUR1nULITSGFHIK1UBFQtJ8a612QJOAC8zp0g](https://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests/153565?fbclid=IwAR0umHMTEmVBjdY0FNyBP_BUR1nULITSGFHIK1UBFQtJ8a612QJOAC8zp0g)\n\n反之，如果我們花了太多時間在改測試，則是一種測試可能太多了的訊號，但在這之前，請先確保已經盡可能地善用工具的加快修改過程，不然可能只是單純的寫程式太慢。",
          "id": "af3e58a5629a4d368bc3b03ac92b7b97",
          "filename": "Day 27 測試足夠了嗎？ af3e58a5629a4d368bc3b03ac92b7b97.md",
          "folderName": "Day 27 測試足夠了嗎？",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 28 設計與測試同樣重要",
          "summary": "在這系列的文章中，我們鮮少聊到設計與重構，但是我們增加測試的目的，是為了就產品的品質，而產品的品質要好，高品質的程式碼是必不可少的。測試可以支持我們進行重構，調整設計，把程式碼調整成更好維護調整的狀態，以支持產品未來新增需求，讓產品有足夠的動能持續盈利。 只要我們的產品持續盈利，我們就會每天在現有產...",
          "content": "在這系列的文章中，我們鮮少聊到設計與重構，但是我們增加測試的目的，是為了就產品的品質，而產品的品質要好，高品質的程式碼是必不可少的。測試可以支持我們進行重構，調整設計，把程式碼調整成更好維護調整的狀態，以支持產品未來新增需求，讓產品有足夠的動能持續盈利。\n\n## 支持持續修改\n\n只要我們的產品持續盈利，我們就會每天在現有產品加新功能。持續的新增與修改功能，也意味了我們得每天面對我們舊的程式碼，思考如何調整以應付新的需求。無論是軟體缺乏測試，抑或是設計不良，都會一步一步的減緩我們的開發速度，直到完全改不動的那一天，就只剩下翻掉重寫的可能性了。翻掉重寫需要花費許多的物力與人力，卻沒能對使用者帶來真正的價值。\n\n為了避免落入這樣的情況，我們就得常常重構我們的程式碼，就像種植花草樹木一樣，需要澆水，需要修剪，重構程式碼能讓程式更容易維護。想要常常要重構，我們就要有測試的保護，畢竟我們不可能每一次修改就手動測試過所有功能。\n\n## 有了測試之後\n\n當我們有測試保護之後，就可以開始重構程式碼，我們得先察覺程式碼中的 [Code Smell](https://refactoring.guru/refactoring/smells)，根據不同的 Code Smell 採取不一樣的措施，讓程式碼符合各種的設計原則，例如：[SOLID 原則](https://zh.wikipedia.org/zh-tw/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1))、[DRY 原則](https://zh.wikipedia.org/zh-tw/%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1) …等。除了設計原則之外，我們也得注意程式碼的可讀性是否足夠，在 [Kent Beck 的實作模式](https://www.tenlong.com.tw/products/9789862018088)中就有談到，簡單程式設計的四個原則，其中第二條就 **Reveals Intent (Self-Documenting Code) 程式能夠表達出意圖**，我們必須花時間重構，直到程式簡單到**顯然沒有缺陷**，而不是複雜到**沒有明顯的缺陷**。\n\n除了知道要重構成什麼樣子之外，如何重構也很重要，再[重構 : 改善既有代碼的設計](https://www.tenlong.com.tw/products/9787115508645)中，詳細介紹了各種不同重構手法，也有討論哪些 Code Smell 適合哪些重構手法，也是開發人員必須學會的技能之一。重構技巧同樣可以用在開發 Flutter 上，例如在其他程式語言中，會透過抽取方法來隱藏實作細節，拆分方法的職責，在 Flutter 中使用抽取 Widget 也是相同的效果。\n\n## 盡量避免在沒有測試的狀況下重構\n\n重構的定義的是「**在不改變軟體外部行為的前提下，改變其內部結構，使其更容易理解且易於修改**」，那我們怎麼知道行為沒有被改變呢？首先，我們得確保程式是在有測試保護情況下開始，畢竟如果沒有測試，開發人員就必須頻繁的手動測試，才能確保重構後的程式行為沒有被破壞。但是當我們碰到遺留代碼的時候該怎麼辦呢？先重構與先寫測試就變成雞生蛋，蛋生雞的問題。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day25/1.png?raw=true)\n\n其實，遺留代碼還是能透過一些其他測試方法來測試，例如：[特徵測試](https://en.wikipedia.org/wiki/Characterization_test)，什麼是特徵測試呢？簡單來說，就是我們在修改程式碼之前，先用執行一次程式並紀錄結果，當修改完程式碼之後，在測試一次，期望重構前與重構後的結果一致。在 Flutter 中本身有提供[方法](https://github.com/flutter/flutter/wiki/Writing-a-golden-file-test-for-package:flutter)讓開發人員用特徵測試，也有許多套件可以支持我們做特徵測試，例如：[alchemist](https://pub.dev/packages/alchemist)，透過比較修改前與修改後的畫面差異，來確認重構是否破壞了原有行為。\n\n## 沒有測試也想改\n\n不過想當然爾，如果真的碰到要處理遺留代碼狀況時，這些程式碼九成也不會有特徵測試可以使用，當情況一緊急，我們也只能在沒有測試的情況下硬著頭皮改，但是這並不意味著我們可以大翻修，而是必須依照安全的修改步驟來小範圍的修改，然後再小範圍的加上測試，一點一點的讓整個專案的程式碼都有測試保護，在之前介紹過的 [Working Effectively with Legacy Code](https://www.tenlong.com.tw/products/9789864344000) 有更詳細的說明。小範圍的調整，除了能控制程式改壞的風險之外，也能讓這次修改的時間控制在合理範圍之中，畢竟我們修改程式碼是為了對客戶產生價值，不應該浪費時間在修改不需要修改的功能上面。\n\n## 小結\n\n如果寫測試只是單純的為了檢查產品有沒有問題，未免過於可惜，測試除了確保產品品質之外，也能幫我們優化程式碼的品質。畢竟程式改壞了測試會提醒，我們就能放心重構，即便功能越來越多，越來越複雜，也不至於拖垮開發進度，讓產品得以穩定成長持續盈利。\n\n在這系列的文章中，我們鮮少聊到設計與重構，但是我們增加測試的目的，是為了就產品的品質，而產品的品質要好，高品質的程式碼是必不可少的。測試可以支持我們進行重構，調整設計，把程式碼調整成更好維護調整的狀態，以支持產品未來新增需求，讓產品有足夠的動能持續盈利。\n\n## 支持持續修改\n\n只要我們的產品持續盈利，我們就會每天在現有產品加新功能。持續的新增與修改功能，也意味了我們得每天面對我們舊的程式碼，思考如何調整以應付新的需求。無論是軟體缺乏測試，抑或是設計不良，都會一步一步的減緩我們的開發速度，直到完全改不動的那一天，就只剩下翻掉重寫的可能性了。翻掉重寫需要花費許多的物力與人力，卻沒能對使用者帶來真正的價值。\n\n為了避免落入這樣的情況，我們就得常常重構我們的程式碼，就像種植花草樹木一樣，需要澆水，需要修剪，重構程式碼能讓程式更容易維護。想要常常要重構，我們就要有測試的保護，畢竟我們不可能每一次修改就手動測試過所有功能。\n\n## 有了測試之後\n\n當我們有測試保護之後，就可以開始重構程式碼，我們得先察覺程式碼中的 [Code Smell](https://zh.wikipedia.org/zh-tw/%E4%BB%A3%E7%A0%81%E5%BC%82%E5%91%B3)，根據不同的 Code Smell 採取不一樣的措施，讓程式碼符合各種的設計原則，例如：[SOLID 原則](https://zh.wikipedia.org/zh-tw/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1))、[DRY 原則](https://zh.wikipedia.org/zh-tw/%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1) …等。除了設計原則之外，我們也得注意程式碼的可讀性是否足夠，在 [Kent Beck 的實作模式](https://www.tenlong.com.tw/products/9789862018088)中就有談到，簡單程式設計的四個原則，其中第二條就 **Reveals Intent (Self-Documenting Code) 程式能夠表達出意圖**，我們必須花時間重構，直到程式簡單到**顯然沒有缺陷**，而不是複雜到**沒有明顯的缺陷**。\n\n除了知道要重構成什麼樣子之外，如何重構也很重要，再[重構 : 改善既有代碼的設計](https://www.tenlong.com.tw/products/9787115508645)中，詳細介紹了各種不同重構手法，也有討論哪些 Code Smell 適合哪些重構手法，也是開發人員必須學會的技能之一。重構技巧同樣可以用在開發 Flutter 上，例如在其他程式語言中，會透過抽取方法來隱藏實作細節，拆分方法的職責，在 Flutter 中使用抽取 Widget 也是相同的效果。\n\n## 盡量避免在沒有測試的狀況下重構\n\n重構的定義的是「**在不改變軟體外部行為的前提下，改變其內部結構，使其更容易理解且易於修改**」，那我們怎麼知道行為沒有被改變呢？首先，我們得確保程式是在有測試保護情況下開始，畢竟如果沒有測試，開發人員就必須頻繁的手動測試，才能確保重構後的程式行為沒有被破壞。但是當我們碰到遺留代碼的時候該怎麼辦呢？先重構與先寫測試就變成雞生蛋，蛋生雞的問題。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day25/1.png?raw=true)\n\n其實，遺留代碼還是能透過一些其他測試方法來測試，例如：[特徵測試](https://en.wikipedia.org/wiki/Characterization_test)，什麼是特徵測試呢？簡單來說，就是我們在修改程式碼之前，先用執行一次程式並紀錄結果，當修改完程式碼之後，在測試一次，期望重構前與重構後的結果一致。在 Flutter 中本身有提供[方法](https://github.com/flutter/flutter/wiki/Writing-a-golden-file-test-for-package:flutter)讓開發人員用特徵測試，也有許多套件可以支持我們做特徵測試，例如：[alchemist](https://pub.dev/packages/alchemist)，透過比較修改前與修改後的畫面差異，來確認重構是否破壞了原有行為。\n\n## 沒有測試也想改\n\n不過想當然爾，如果真的碰到要處理遺留代碼狀況時，這些程式碼九成也不會有特徵測試可以使用，當情況一緊急，我們也只能在沒有測試的情況下硬著頭皮改，但是這並不意味著我們可以大翻修，而是必須依照安全的修改步驟來小範圍的修改，然後再小範圍的加上測試，一點一點的讓整個專案的程式碼都有測試保護，在之前介紹過的 [Working Effectively with Legacy Code](https://www.tenlong.com.tw/products/9789864344000) 有更詳細的說明。小範圍的調整，除了能控制程式改壞的風險之外，也能讓這次修改的時間控制在合理範圍之中，畢竟我們修改程式碼是為了對客戶產生價值，不應該浪費時間在修改不需要修改的功能上面。\n\n## 小結\n\n如果寫測試只是單純的為了檢查產品有沒有問題，未免過於可惜，測試除了確保產品品質之外，也能幫我們優化程式碼的品質。畢竟程式改壞了測試會提醒，我們就能放心重構，即便功能越來越多，越來越複雜，也不至於拖垮開發進度，讓產品得以穩定成長持續盈利。",
          "id": "49a0c92e5fd44b1aae4a0d0397c9677e",
          "filename": "Day 28 設計與測試同樣重要 49a0c92e5fd44b1aae4a0d0397c9677e.md",
          "folderName": "Day 28 設計與測試同樣重要",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 29 善用工具加速測試",
          "summary": "許多人沒有寫測試的習慣，而當問到為什麼不寫測試時，可能大多數的答案都是開發時間不夠，無法寫測試。寫測試的時間過長，有些時候是因為不熟悉如何測試，導致測試時間太長，有些時候則是因為工具不熟練，導致花很多時間在寫固定樣板的程式碼。前者我們只要多思考多寫就能緩解，但是後者可能就需要一點技巧了，今天就來談談...",
          "content": "許多人沒有寫測試的習慣，而當問到為什麼不寫測試時，可能大多數的答案都是開發時間不夠，無法寫測試。寫測試的時間過長，有些時候是因為不熟悉如何測試，導致測試時間太長，有些時候則是因為工具不熟練，導致花很多時間在寫固定樣板的程式碼。前者我們只要多思考多寫就能緩解，但是後者可能就需要一點技巧了，今天就來談談如何用 Intellij IDEA 或 Android Studio 的工具加速寫測試速度吧。\n\n由於 Android Studio 也是由 Intellij IDEA 衍生而來，以下我們就直接只說明 Intellij IDEA 如何操作，使用 Android Studio 的朋友也可以用相同的方式操作。\n\n## 快速建立測試檔案\n\n如果沒有使用工具，當我們想寫測試的時候，我們就得打開長長的目錄，用滑鼠慢慢地移動到目標資料夾，點開右鍵建立新檔案，輸入名稱，整個過程大概也得花上三十秒。或許三十秒看起來不長，但是卻嚴重中斷了我們思考，我們得從原本要寫什麼測試的思考中，跳轉怎麼到建立測試，最後又跳回來想要我測什麼，這當中也會有一些 Context Switch 的成本。\n\n### 使用 IDE 外掛套件建立套件\n\n使用 Intellij IDEA 的朋友，可以使用 [Dart Test](https://plugins.jetbrains.com/plugin/16299-dart-test) 這個外掛套件。當我們想建立測試時，只要 IDE 編輯器中按右鍵，選擇 Dart Test File 就能輸入測試名稱產生測試。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day29/1.png?raw=true)\n\n更快一點，我們也可以在把輸入標停留在類別名稱上，按 Alt + Enter 並選擇 Create Dart test file 也能在相對應的目錄產生測試，減少手動操作的負擔。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day29/2.png?raw=true)\n\n除了 Dart Test 外，還有另外一個 [**Flutter Test File Creator](https://plugins.jetbrains.com/plugin/19381-flutter-test-file-creator)** 也有類似功能，有興趣的讀者也可以嘗試看看。不過呢，這兩個套件都不支援 Intellij IDEA 2023.2 + 以上的版本，而 Android Studio 最新版目前還能使用。\n\n### 運用 Live Template\n\n當我們產生一個測試檔案後，裡頭肯定還是空空的，那我們馬上需要的就是建立一個 main 方法與 test，而這些程式碼每次都是一模一樣的，每次手動輸入也是令人厭煩的過程。利用 IDE 的 Live Template 用於產生就能快速產生測試程式碼，以下面影片來說，我們只輸入了 mytest 就能產生 main 方法與一個測試方法。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day29/3.gif?raw=true)\n\n那我們要如何設定 Live Template 呢？方法很簡單，從 **Setting** ⇒ **Editor ⇒ Live Templates** 進入編輯。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day29/4.png?raw=true)\n\n接著可以選擇在 Dart 或 Flutter 的群組中按下右側 + 新增一個 Live Templates。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day29/5.png?raw=true)\n\n接著我們依序輸入指令名稱與功能描述，接著在樣板中輸入基本的測試架構，最後選擇語言並按下 OK 之後，我們就直接使用了。指令名稱是什麼呢？當我們在編輯時打出指令名稱，IDE 就會跳出選單讓我們使用指定的名稱來產生對應的樣板程式碼，就如果們我們在開頭影片示範的一樣，輸入 mytest 這個指令名稱，就能產生測試程式碼。\n\n在樣板中我們可以設定一些變數或關鍵字，讓樣板更方便使用，例如上面圖片的 $END$ 就是當樣板產生之後，我們游標會停在 $END$ 的地方。例子中 $TEST_NAME$ 則是變數，變數可以讓我們在樣板產生時自己修改內容，也可以讓樣板幫我們產生一些預設值。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day29/6.png?raw=true)\n\n處了建立測試架構的樣板之外，我們也可以用樣板幫我們產生其他各式各樣常用的程式碼，例如產生新增一個測試、產生 Mock 類別 …等，這邊就不繼續示範，有興趣的朋友可以自己試試。\n\n## 快速執行 build_runner\n\n在開發 Flutter 程式時，我們會大量使用 [build_runner](https://pub.dev/packages/build_runner) 來產生一些工具程式碼，例如產生 DTO 類別的 Json 解析的方法，或者產生 mockito 的測試替身 …等等，都需要使用 build_runner。\n\n```dart\nflutter pub run build_runner build\n```\n\n如果每次要產生時，都要使用打開終端機一個字一個字書入未免有些浪費時間，甚至如果不記得指令話，還要花時間打開網頁搜尋指令，而這種工作就很適合使用外掛或 IDE 的功能來處理了。\n\n### Flutter-Toolkit 外掛\n\n在 Intellij IDEA  中，我們可以使用 Flutter-Toolkit 這個外掛，他會在 IDE 右上角多幾個功能按鈕，其中就包含 build_runner 執行的動作，也可以在編輯時右鍵來選擇使用。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day29/7.png?raw=true)\n\n但是比較可惜的是，這個套件對於新版的 Intellij IDEA 一樣缺乏支援。\n\n### 使用 External Tools\n\n除了套件之外，我們也能用 External Tool 來設定一個可以執行 build_runner 的功能。首先我們一樣從 Setting ⇒ Tools ⇒ External Tools 打開設定畫面。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day29/8.png?raw=true)\n\n接著按下 + 新增一個 External Tools，並設定成使用 build_runner，最後按下 ok 儲存。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day29/9.png?raw=true)\n\n最後我們就能在 IDE 上方菜單中的 Tools 找到剛剛設定的工具並執行，就不用每次都手動打指令了。\n\n![](https://github.com/easylive1989/images/blob/master/static/images/2023IThome/Day29/10.png?raw=true)\n\n同樣的 External Tools 除了拿來執行 build_runner，也能拿來執行很多其他動作，例如使用新版 Intellij IDEA 而無法使用 Dart Test 的朋友，就能用 External Tools 來產生測試檔案。\n\n## 就算寫快一點，但是效果也有限？\n\n在真正熟練工具或快捷鍵之前，可能很多人會想的是，我就算打字打得快，快捷鍵或工具用的熟練，也省不了多少時間，我還是得花大把時間思考邏輯，感覺上也省不了多少時間。但事實可能並非如此，我們之所以思考的慢，有一部份是因為思考常常被中斷，被什麼東西中斷呢？正是被打字與移動滑鼠的操作中斷。\n\n寫程式時，雖然我們開始前先想好大概要怎麼做，但開始寫的時候，還是一段一段完成的。我們會想一下這段要怎麼寫，寫一段程式碼，可能還要查找其他類別，最後終於完成程式碼，接下來繼續思考下一段要怎麼寫。在上一段思考與下一段思考之間的間隔時間越長，我們就要花越多時間回想再來要做什麼，導致整體思考時間更長。\n\n熟練 IDE 快捷鍵與工具，能顯著的減少寫程式碼的時間，最小化思考與思考之間的中斷時間，讓思考可以更連貫順暢，無形中也縮短了思考的時間。\n\n## 小結\n\n熟練 IDE 快捷鍵或工具看起來好像很困難，好像要花很多腦力去背誦，但其實只要日復一日的持續使用就會形成肌肉記憶，自然而然的就能提升開發速度，降低開發成本。以測試來說，我們可以減少寫測試的時間，讓開發者更專注在設計測試案例上。",
          "id": "27992e95af09445786e8e4a772ac1bf3",
          "filename": "Day 29 善用工具加速測試 27992e95af09445786e8e4a772ac1bf3.md",
          "folderName": "Day 29 善用工具加速測試",
          "seriesName": "30 天學會 Flutter 測試"
        },
        {
          "title": "Day 30 第三十天之後",
          "summary": "終於到了最後一天，在開發 Flutter 程式的過程中，少不了寫測試來確保程式正常運作，通過三十天的分享，除了可以將過去開發過程中碰到的問題與解法分享給大家之外，也能通過寫作，能更深入探索議題之前沒想到的部分。 在這三十天中，我們講了很多單元測試與 Widget Test 的技巧，也談論了很多測試相...",
          "content": "終於到了最後一天，在開發 Flutter 程式的過程中，少不了寫測試來確保程式正常運作，通過三十天的分享，除了可以將過去開發過程中碰到的問題與解法分享給大家之外，也能通過寫作，能更深入探索議題之前沒想到的部分。\n\n## 尚未提及的部分\n\n在這三十天中，我們講了很多單元測試與 Widget Test 的技巧，也談論了很多測試相關的新法。但是這些都只是滄海一粟，例如：Flutter 的 Integration Test 該怎麼寫、如何在 CI/CD 執行測試並回報錯誤，或者是如何用 Firebase Test Lab 來讓測試跑在雲端設備上，這些都是在落實測試到專案上可能會碰到的問題。\n\n除了工具的使用之外，寫測試也與實例化需求息息相關，當我們在拆解需求時，可以使用實例化需求來減少不同角色對於需求的認知差距，除此之外，這些實例化需求例子，也是十分適合拿來衍生測試案例。\n\n由於 Flutter 還算是比較新的框架，相關的學習資源還是比較多在網路上，例如：Flutter 的 [Youtube 官方頻道](https://www.youtube.com/@flutterdev)或 [Codelab](https://docs.flutter.dev/codelabs)。\n\n## 邁向職業工程師\n\n就像在職業運動領域中，職業運動選手除了領薪水上場打球之外，會在平常通過各種訓練提升球技，才能在競爭激烈的球場上脫穎而出。同樣的，如果我們想成為更好的工程師，也應該向職業運動選手，平時就要練習尚未熟練的技術，無論是框架使用，重構或者測試都是技術，很難只看過一次文章，上過一次課就能熟練的運用在實務上的，而是需要透過不斷的刻意練習與思考，重複的犯錯與調整，才能在實務上熟練使用。\n\n## 沒有對錯\n\n隨著電腦速度越來越快與 AI 工具的出現，許多以前的我們熟知的方式可能在未來已不再適用，像是我們能用 [welltested](https://www.notion.so/e5e2e54fe66b48058e51d269ae2c133c?pvs=21) 來幫忙產生測試，那是不是一些簡單的情境，我們可以用 AI 來幫忙測試就好，甚至不需要測試？或者是以 Widget Test 來說，以前 UI 相關的測試運起來可能都會不穩定，寫起來也不麻煩，那 Widget Test 的數量是不是能比單元測試多了呢？\n\n我們可以多方的嘗試不同的作法，然後頻繁的檢視結果，看看是否做法能有效解決問題，有沒有縮短開發時間，有沒有減少 Bug 數量。當然發現沒用的話，我們就得馬上調整採用其他做法了。透過一次一次的迭代，我們的開發也會越來越順暢，以小步快跑的節奏，小範圍的調整，然後回顧解法是否有效，有效則繼續，無效則馬上換個方法，持續優化整個開發流程。\n\n## 感謝我的好同事\n\n能完成三十天的鐵人賽文章，特別感謝我的好同事們，透過 Pair Programming 與 Code Reivew，除了提高產出的品質之外，也能在開發過程中與夥伴互相學習，有句話說「一個人可以走得很快，一群人可以走得很遠。」，如果我們想要持續的進步，除了自己持續努力之外，有志同道合的夥伴也是很重要的，其中特別推薦優質同事的粉絲團 [Kuma的軟體工程murmur集](https://www.facebook.com/kukumamaya/)，有興趣的朋友也可以按讚訂閱加分享起來 XD。\n\n## 最後\n\n無論是手動測試或自動化測試，再交付產出之前，我們都必須想辦法確保我們是在交付價值，而不是交付垃圾。我們很難寫一寫完程式後，程式就直接是最好的狀態，更多的是需要用測試確保功能沒有問題，支持後續的重構與功能調整。感謝三十天持續追蹤的觀眾朋友們，也歡迎有興趣的朋友追蹤我的 [Medium](https://medium.com/@easylive1989)，未來也會持續分享許多 Flutter 開發上的的技巧。\n\n## 小步快跑\n\n在學習排序演算法時，我們一定會學到一個概念：**Divide And Conquer**，將長陣列拆解成一個一個的小陣列並排序，排序玩小陣列之後在合併回大陣列。在開發的時候，我們也會把大功能拆解成小任務，透過解決一個一個的小任務，最終解決大問題。當我們把任務拆小之後，我們也能做完一個小任務就確認狀況，確認是不是東西有做對，例如：我們想完成一個從 API 取回資料並顯示在畫面的功能，那我們就能把這個需求拆解成幾個小任務依序完成。\n\n1. 根據設計制作製作畫面，資料的部分直接寫死在 Widget 中\n2. 建立 Value Object 把寫死的資料整理放到 Value Object 中\n3. 把寫死的 Value Object 從 ViewModel 層透過 Data Binding 機制傳給 Widget\n4. 從 Repository 打 API 取得 API 轉成 Value Object 傳給 View Model\n\n每一步驟結束後，我們都可以從畫面或測試我們有沒有走在對的路上，不需要整個功能做完才能進行確認。把功能拆小，每做完一個小任務都能確認我們是否再往正確的方向前進，看起來好像沒省時間，但其實時間是省在少走彎路，從而讓開發速度變快。",
          "id": "e37c83a406b54ed7a68b20bfc95f7ee1",
          "filename": "Day 30 第三十天之後 e37c83a406b54ed7a68b20bfc95f7ee1.md",
          "folderName": "Day 30 第三十天之後",
          "seriesName": "30 天學會 Flutter 測試"
        }
      ]
    },
    {
      "name": "30 天學會 Flutter 設計",
      "articles": [
        {
          "title": "Day 1 - 大家都喜歡簡單的程式碼，但是簡單卻不容易",
          "summary": "id: 1 只要給足夠的時間，我們都可以正確地完成功能，但過段時間再回頭來看，未經適當重構與設計的程式碼，早已滿目瘡痍，想改也改不動，只能一直 Workaround。如何在每一次的需求開發中，不斷地檢視設計並重構，時時維護一份容易維護的程式碼，則是一種藝術。 程式設計的世界裡，有許多大師們提出許多設...",
          "content": "id: 1\n\n只要給足夠的時間，我們都可以正確地完成功能，但過段時間再回頭來看，未經適當重構與設計的程式碼，早已滿目瘡痍，想改也改不動，只能一直 Workaround。如何在每一次的需求開發中，不斷地檢視設計並重構，時時維護一份容易維護的程式碼，則是一種藝術。\n\n## 本系列文章想說什麼\n\n程式設計的世界裡，有許多大師們提出許多設計原則，例如：\n\nDRY：不要重複你自己\n\nSOLID：單一職責原則、開放封閉原則、里氏替換原則、介面隔離原則、開放封閉原則\n\nKent Beck 設計規範：通過測試、呈現意圖、去除重複、最小化設計\n\n甚至是 GoF 提出的各種設計模式 ...等等族繁不及備載。\n\n我們常常通過書籍或文章了解原則之後，卻不知道如何使用，處於一種似懂非懂的概念。大多時候書本中的例子自己沒有碰過，感受不到書中例子的 Force，使得自己在實際工作場景中難以應用。\n\n## 本系列文章適合誰\n\n每天的文章中，我們會選擇一個開發 Flutter 可能會碰到的問題展開討論，從畫面開發、狀態管理、到呼叫 API，所以對於同樣使用 Flutter 的朋友可能會比較有共鳴。相反的是，文章中不會討論如何使用各式各樣的 Widget ，或者如何製作各種酷炫效果。\n\n在描述問題之後，我們會針對問題，提出一些做法，並盡量分析作法的優缺點，讓讀者能根據自己的情境，選擇適合的作法。\n\n## 搭配實際執行的範例\n\n在文章中，我們也盡量把每一個例子放到 [DartPad](https://dartpad.dev/) 上，讓讀者可以透過實際執行與比較程式碼，感受不同作法的差別。也能及時的動手自己調整，看看有沒有什麼不同，也歡迎讀者分享自己的想法，或者修改過的程式碼。\n\n![it_img_0_1.png](Day%201%20-%20%E5%A4%A7%E5%AE%B6%E9%83%BD%E5%96%9C%E6%AD%A1%E7%B0%A1%E5%96%AE%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%EF%BC%8C%E4%BD%86%E6%98%AF%E7%B0%A1%E5%96%AE%E5%8D%BB%E4%B8%8D%E5%AE%B9%E6%98%93/it_img_0_1.png)\n\n## 參考\n\n- DRY：[https://zh.wikipedia.org/zh-tw/一次且仅一次](https://zh.wikipedia.org/zh-tw/%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1)\n- SOLID：[https://zh.wikipedia.org/zh-tw/SOLID_(面向对象设计)](https://zh.wikipedia.org/zh-tw/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1))\n- Kent Beck 設計原則：[https://martinfowler.com/bliki/BeckDesignRules.html](https://martinfowler.com/bliki/BeckDesignRules.html)\n- DartPad：[https://dartpad.dev/](https://dartpad.dev/)",
          "id": "43166d914a444ce1a98cbfcb79a9e36d",
          "filename": "Day 1 - 大家都喜歡簡單的程式碼，但是簡單卻不容易 43166d914a444ce1a98cbfcb79a9e36d.md",
          "folderName": "Day 1 - 大家都喜歡簡單的程式碼，但是簡單卻不容易",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 2 - 使用適合的 Widget，省時又省力",
          "summary": "note: 不要重複造輪子 增加可讀性 id: 2 tag: 設計 Flutter 是一個可以建構跨平台應用程式的框架，在開發的過程中，我們會透過組合各式各樣 Widget 來實現各式各樣的畫面。隨著需求越來越複雜，View 的程式碼也會需要組裝越多的層 Widget ，導致程式碼越變越長，從而影響...",
          "content": "note: 不要重複造輪子 增加可讀性\nid: 2\ntag: 設計\n\nFlutter 是一個可以建構跨平台應用程式的框架，在開發的過程中，我們會透過組合各式各樣 Widget 來實現各式各樣的畫面。隨著需求越來越複雜，View 的程式碼也會需要組裝越多的層 Widget ，導致程式碼越變越長，從而影響了可讀性。\n\n## 舉個例子\n\n當我們今天從客戶那邊收到一個需求，要在 App 中顯示好友清單。Flutter 提供了許多基本 Widget，例如：Container、Row、Column …等，讓開發者透過組合這些 Widget 來完成自己想要的畫面。\n\n![截圖 2022-09-16 下午10.38.58.png](Day%202%20-%20%E4%BD%BF%E7%94%A8%E9%81%A9%E5%90%88%E7%9A%84%20Widget%EF%BC%8C%E7%9C%81%E6%99%82%E5%8F%88%E7%9C%81%E5%8A%9B/%25E6%2588%25AA%25E5%259C%2596_2022-09-16_%25E4%25B8%258B%25E5%258D%258810.38.58.png)\n\n[https://dartpad.dev/?id=ce4cdb6143e009d67fad0629d4b5d358](https://dartpad.dev/?id=ce4cdb6143e009d67fad0629d4b5d358)\n\n經過一頓操作之後，我們完成了我們的程式碼，通過了驗收測試，並交付給客戶。經過一個月之後，客戶又提出了另一個需求，要調整這個畫面的設計。此時我們翻開這一長串程式碼，一時間發現不知重何改起，此時我們可以深刻感受到程式碼發出壞味道：[Large Class](https://refactoring.guru/smells/large-class) 。\n\n## 使用適合的 Widget\n\n我們有許多方法可以解決 Large Class，一個最簡單的方法就是：搜尋是否存在適合的內建 Widget。Flutter 內建了許多 Widget，在開發的過程中，我們應該盡量這些內建 Widget 來完成我們的工作，讓我們來使用內建 Widget 來修改上面的例子。\n\n![截圖 2022-09-16 下午10.38.23.png](Day%202%20-%20%E4%BD%BF%E7%94%A8%E9%81%A9%E5%90%88%E7%9A%84%20Widget%EF%BC%8C%E7%9C%81%E6%99%82%E5%8F%88%E7%9C%81%E5%8A%9B/%25E6%2588%25AA%25E5%259C%2596_2022-09-16_%25E4%25B8%258B%25E5%258D%258810.38.23.png)\n\n[https://dartpad.dev/?id=3710044cc15b9ec83fc135dcd5a08703](https://dartpad.dev/?id=3710044cc15b9ec83fc135dcd5a08703)\n\n修改之後，可以發現程式碼短了非常多，，也可以透過 Widget 名稱，和其參數概略了解這個 Widget 大概是什麼。由此我們可以發現，使用內建 Widget 有一些好處：\n\n1. 提升可讀性：內建的 Widget 名稱通常也與設計名稱相同\n2. 提升可維護性：寫越少代碼，你維護會越輕鬆\n\n如何知道 Flutter 有哪些內建 Widget 呢？大家可以到 [Widget catalog](https://docs.flutter.dev/development/ui/widgets) 或觀看 [Widget of the week](https://www.youtube.com/playlist?list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG) 都能學習一些可能自己從沒用過的 Widget。\n\n## 使用第三方套件\n\n萬一今天很不幸的，想實現的功能 Flutter 並未提供，也可以先到 [pub.dev](http://pub.dev) 找找。與其自己動手造輪子，或許直接使用套件是比較合理的選擇。相比於自己實現功能，直接使用第三方套件也能提升可讀性與可維護性，但是也同時帶來一個缺點：你的程式碼與套件產生了相依性。使用套件可能產生一些問題\n\n1. 由於你的程式引用了套件，當第三方套件發生變化時，你也被迫做出改變，或者當你想升級新版而套件不支援時，也同樣帶來麻煩。\n2. 套件中可能有許多你並不需要的東西，使得建置速度變慢，甚至最終應用程式變得臃腫。\n\n使用套件之前，必須評估使用套件帶來的效益是否大過自己實現。如果不是太過複雜的功能，或許可以考慮自己實現。\n\n## 結論\n\n無論是使用 Flutter 內建的 Widget 或第三方套件，都能夠有效的提升程式碼的可維護性。當今天考慮使用第三方套件前，應該謹慎的評估並合理的使用，才能真的享受好處而不是上了賊船。然而，有些情況是 Flutter 提供的 Widget 並不符合設計要求，而第三方套件中也沒有符合需求的套件，所以我們得自己實作。在這種情況下，還是可以透過一些方式來讓程式碼更好維護，我們會在明天討論到這個主題\n\n## 參考\n\n- Large Class：[https://refactoring.guru/smells/large-class](https://refactoring.guru/smells/large-class)\n- Widget catalog：[https://docs.flutter.dev/development/ui/widgets](https://docs.flutter.dev/development/ui/widgets)\n- Widget of the week：[https://www.youtube.com/playlist?list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG](https://www.youtube.com/playlist?list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG)",
          "id": "0fdd89a195a44fd5be9bcefe9036d520",
          "filename": "Day 2 - 使用適合的 Widget，省時又省力 0fdd89a195a44fd5be9bcefe9036d520.md",
          "folderName": "Day 2 - 使用適合的 Widget，省時又省力",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 3 - Widget 你已經長大了，是該獨立自主了",
          "summary": "note: 提升效能 增加可讀性 id: 3 tag: 設計 昨天我們提到一個狀況：有些情況是 Flutter 提供的 Widget 並不符合設計要求，而第三方套件中也沒有符合需求的套件，所以我們得自己實作。我們依照設計師所要求，完成了畫面。但是看看這段程式碼，雖然我們完成了功能，如同昨天討論問題一...",
          "content": "note: 提升效能 增加可讀性\nid: 3\ntag: 設計\n\n昨天我們提到一個狀況：有些情況是 Flutter 提供的 Widget 並不符合設計要求，而第三方套件中也沒有符合需求的套件，所以我們得自己實作。我們依照設計師所要求，完成了畫面。但是看看這段程式碼，雖然我們完成了功能，如同昨天討論問題一樣，這段程式碼並不具備可讀性和存在壞味道。\n\n![it_img_2_1.png](Day%203%20-%20Widget%20%E4%BD%A0%E5%B7%B2%E7%B6%93%E9%95%B7%E5%A4%A7%E4%BA%86%EF%BC%8C%E6%98%AF%E8%A9%B2%E7%8D%A8%E7%AB%8B%E8%87%AA%E4%B8%BB%E4%BA%86/it_img_2_1.png)\n\n[https://dartpad.dev/?id=4206cf5a29e1aa93c2cd39d31f342130](https://dartpad.dev/?id=4206cf5a29e1aa93c2cd39d31f342130)\n\n## 抽取方法\n\n為了解決這個問題，我們可以使用重構技巧：[抽取方法](https://refactoring.guru/extract-method)，把一長串的程式碼吃拆分成一個一個的私有方法。至此，程式碼也確實提高了可讀性，可從 build 方法可以明顯看出，我們使用 ListView 來 build 出一個一個的 Message，如果再移至 _buildMessage 的定義，就能看到根據不同情況，程式碼會 build 出三種不同設計的 Message Widget。透過使用抽取方法，能夠有效改善程式碼的可讀性。\n\n![it_img_2_2.png](Day%203%20-%20Widget%20%E4%BD%A0%E5%B7%B2%E7%B6%93%E9%95%B7%E5%A4%A7%E4%BA%86%EF%BC%8C%E6%98%AF%E8%A9%B2%E7%8D%A8%E7%AB%8B%E8%87%AA%E4%B8%BB%E4%BA%86/it_img_2_2.png)\n\n[https://dartpad.dev/?id=23f6e6d7019d15f7a4ce9b256b9cacb4](https://dartpad.dev/?id=23f6e6d7019d15f7a4ce9b256b9cacb4)\n\n## 抽取 Widget\n\n除了抽取方法之外，我們也可以透過抽取 Widget 來解決這個問題。抽取 Widget 在概念上與抽取方法別無二致，我們都能藉由給定更清楚的名稱與隱藏實作細節來提升可讀性。\n\n![it_img_2_3.png](Day%203%20-%20Widget%20%E4%BD%A0%E5%B7%B2%E7%B6%93%E9%95%B7%E5%A4%A7%E4%BA%86%EF%BC%8C%E6%98%AF%E8%A9%B2%E7%8D%A8%E7%AB%8B%E8%87%AA%E4%B8%BB%E4%BA%86/it_img_2_3.png)\n\n[https://dartpad.dev/?id=3265ea97bcacb9b50eded2521ac0023f](https://dartpad.dev/?id=3265ea97bcacb9b50eded2521ac0023f)\n\n## 抽取方法  vs 抽取 Widget\n\n雖然在程式碼的可讀性上，兩個做法都可以解決問題。有些時候，使用抽取 Widget 會好一些，由於 Flutter 在重 build 畫面時，可以透過比較 Widget 前後是否一致，來決定是否重用或產生新的，反之如果使用抽取方法則比較難享受到這個好處，想知道原理的朋友，可以參考[這邊](https://medium.com/flutter-community/why-is-flutter-fast-part-1-sublinear-building-317572cd6b47)。另外，抽取 Widget 除了更容易重複使用之外，在 IDE 也會幫忙 highlight Widget 讓程式碼稍微比較容易閱讀。\n\n## 結論\n\n使用抽取 Widget 或者抽取方法，實際上並不會差很多，如何根據實際狀況來衡量使用哪個，就要得靠讀者們在實際工作中自行評估。\n\n## 參考\n\n- 抽取方法：[https://refactoring.guru/extract-method](https://refactoring.guru/extract-method)\n- Why is Flutter Fast? — Part 1: Sublinear Building：[https://medium.com/flutter-community/why-is-flutter-fast-part-1-sublinear-building-317572cd6b47](https://medium.com/flutter-community/why-is-flutter-fast-part-1-sublinear-building-317572cd6b47)\n- Widgets vs helper methods | Decoding Flutter**：**[https://www.youtube.com/watch?v=IOyq-eTRhvo](https://www.youtube.com/watch?v=IOyq-eTRhvo)\n\nprefer separate widget\n\n1. setState 多 create 幾個 widget 幾乎不會影響效能，但是每次重 build 時，都要重 build 整個畫面則會影響，如果今天畫面上有動畫，就會更頻繁的去重複畫面\n2. 可以用 const\n3. 分離  widget 也更容易測試\n4. BuildContext 可以使用的更準確，省去使用 builder widget\n\nClass have a better default behavior. The only benefit of method is having to write a tiny bit less code. There is no functional benefit. - Remi Rousselet\n\nclean code\n\n不要把 controller 傳進去，讓 Widget 容易重用\n\n注意參數\n\n注意內聚力\n\n不要讓 widget 強制依賴某個 vo 會讓 widget 難以重複利用\n\n如果參數可以往 Widget 內放，就盡量往 Widget 內放\n\n類似於變數 scope 的問題",
          "id": "cc43093c1e7d42039dc485edd681ee59",
          "filename": "Day 3 - Widget 你已經長大了，是該獨立自主了 cc43093c1e7d42039dc485edd681ee59.md",
          "folderName": "Day 3 - Widget 你已經長大了，是該獨立自主了",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 4 - 把 Widget 作為參數，增加設計彈性",
          "summary": "note: 抽取 layout widget  好萊烏法則 id: 4 tag: 設計 在前兩天的文章中，我們討論到使用抽取方法，或者抽取 Widget 處理 Large Class 的壞味道。在昨天的 Chat Room 例子中，原本過大的 ChatRoomScreen 經過重構之後，細節被隱藏在...",
          "content": "note: 抽取 layout widget \n好萊烏法則\nid: 4\ntag: 設計\n\n在前兩天的文章中，我們討論到使用抽取方法，或者抽取 Widget 處理 Large Class 的壞味道。在昨天的 Chat Room 例子中，原本過大的 ChatRoomScreen 經過重構之後，細節被隱藏在抽取的 MyMessage、OtherMessage …等中。假設今天 PO 想要新增一個需求，讓有 VIP 使用者的 Message 的背景顏色有漸層。\n\n![it_img_3_1.png](Day%204%20-%20%E6%8A%8A%20Widget%20%E4%BD%9C%E7%82%BA%E5%8F%83%E6%95%B8%EF%BC%8C%E5%A2%9E%E5%8A%A0%E8%A8%AD%E8%A8%88%E5%BD%88%E6%80%A7/it_img_3_1.png)\n\n[https://dartpad.dev/?id=f0e1255f304222c707e4f1fd1220266e](https://dartpad.dev/?id=f0e1255f304222c707e4f1fd1220266e)\n\n閱讀這段程式碼，可以發現，我們把新的 isVip 傳入 Widget 中，讓 Message 決定如何渲染畫面。如果大家 Review 這段程式碼時，肯定一些問題。\n\n## 重複的邏輯判斷\n\n如果我們仔細看 Message 的實作，可以發現每個 Message 都需要判斷 isVip，決定使用 VipMessageBubble 或 MessageBubble。\n\n![it_img_3_3.png](Day%204%20-%20%E6%8A%8A%20Widget%20%E4%BD%9C%E7%82%BA%E5%8F%83%E6%95%B8%EF%BC%8C%E5%A2%9E%E5%8A%A0%E8%A8%AD%E8%A8%88%E5%BD%88%E6%80%A7/it_img_3_3.png)\n\n想解決重複的判斷邏輯，相信大家一定都能想到許多方法解決，例如：抽一個 Helper 類別，或者使用繼承，來放置這些重複的邏輯，讓程式碼符合 DRY 原則。\n\n> DRY：Don't repeat yourself\n> \n\n## 缺乏彈性\n\n使用 Helper 類別或者繼承，雖然能解決邏輯重複的問題，但是確少了一些彈性。想像一下，今天如果我們想新增一個 VVIP 的層級，我們除了需要修改 Helper 的類別，還需要修改 Message Widget 的參數，新增一個 isVVIP 的參數，導致我們修改的範圍並沒有變小。無論我們想改 Message 的排版樣式，或者新增圖片訊息，需要改動這群 Message Widget，這就違反了[單一職責](https://zh.wikipedia.org/zh-tw/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99)，因為我們有太多種情況會動到這群 Message 了。\n\n> 單一職責原則：一個類或者模塊應該有且只有一個改變的原因。\n> \n\n## 從參數注入 Widget\n\n為了解決這些問題，我們可以 Message Bubble 抽成獨立的 Widget，把 Message Bubble 傳入 Message  中。\n\n![it_img_3_2.png](Day%204%20-%20%E6%8A%8A%20Widget%20%E4%BD%9C%E7%82%BA%E5%8F%83%E6%95%B8%EF%BC%8C%E5%A2%9E%E5%8A%A0%E8%A8%AD%E8%A8%88%E5%BD%88%E6%80%A7/it_img_3_2.png)\n\n[https://dartpad.dev/?id=c28419cd611772d207ccfaf3ac4a9458](https://dartpad.dev/?id=c28419cd611772d207ccfaf3ac4a9458)\n\n此時，我們可以發現 Message 負責排版，而 Message Bubble 負責顯示內容，透過任意組合這兩類 Widget，我們就能有職責單一的 Widget。由於 Message 的參數型別是 Widget 介面，而不是特定 Widget，也增加了設計的彈性，未來我們有更多樣化的訊息內容時，只要讓他實作 Widget 介面並傳入 Message 中，完全不需要修改 Message 。本來是包在外層的 Message 相依於 Widget 介面，而不是具體實作，也符合依賴反轉原則。\n\n> 依賴反轉原則：高層次的模組不應該依賴於低層次的模組，兩者都應該依賴於抽象介面\n> \n\n## 結論\n\n當我們直接把 Widget A 傳入 Widget B，藉此替換 Widget B 裡面的內容，能讓邏輯判斷可以集中在使用端，避免重複的判斷邏輯。並且，因為 Widget B 依賴了 Widget 這個介面，就表示任何實作 Widget 介面的類別，都能傳入 Widget B，替換 Widget B 的內容，增加了設計的彈性。\n\n## 參考\n\n- DRY：[https://zh.wikipedia.org/zh-tw/一次且仅一次](https://zh.wikipedia.org/zh-tw/%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1)\n- 單一職責原則：[https://zh.wikipedia.org/zh-tw/单一功能原则](https://zh.wikipedia.org/zh-tw/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99)\n- 依賴反轉原則：[https://zh.wikipedia.org/zh-tw/依赖反转原则](https://zh.wikipedia.org/zh-tw/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99)",
          "id": "38902aae127440c99abc93e138c729c9",
          "filename": "Day 4 - 把 Widget 作為參數，增加設計彈性 38902aae127440c99abc93e138c729c9.md",
          "folderName": "Day 4 - 把 Widget 作為參數，增加設計彈性",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 5 - 令人煩躁的按鈕事件傳遞",
          "summary": "note: 1. 傳遞 callback 2. 使用 context.of 注意耦合 注意 widget 的生命週期 id: 5 tag: 設計 開發 UI 畫面的過程中，常見的功能開發情境有很多，除了顯示資訊以外，另外一個常見的情境是提供一個按鈕，讓使用者執行特定功能了。在 Flutter 中，如...",
          "content": "note: 1. 傳遞 callback\n2. 使用 context.of 注意耦合\n注意 widget 的生命週期\nid: 5\ntag: 設計\n\n開發 UI 畫面的過程中，常見的功能開發情境有很多，除了顯示資訊以外，另外一個常見的情境是提供一個按鈕，讓使用者執行特定功能了。在 Flutter 中，如果要製作一個 UI 讓使用者可以點擊，我們通常會使用 [GestureDetector](https://www.youtube.com/watch?v=WhVXkCFPmK4) 並在其 onTap 參數中給定執行方法。\n\n## 跨層傳遞 Callback\n\n在經歷過前幾天討論的主題，有時候我們會發現，經過不斷地重構，最終按鈕事件是在子 Widget 中綁定。在下面的例子中，GameItemView 是列表中的每一個 Item，而當中包含一個購買按鈕。為了讓按鈕能正常工作，我們把 buyGame 方法當作參數，一路向子 Widget 傳，直到購買按鈕裡頭的 GestureDetetor。\n\n![it_img_4_2.png](Day%205%20-%20%E4%BB%A4%E4%BA%BA%E7%85%A9%E8%BA%81%E7%9A%84%E6%8C%89%E9%88%95%E4%BA%8B%E4%BB%B6%E5%82%B3%E9%81%9E/it_img_4_2.png)\n\n[https://dartpad.dev/?id=a78b57b5a2225b2344376eddd537a86b](https://dartpad.dev/?id=a78b57b5a2225b2344376eddd537a86b)\n\n![it_img_4_2_1.png](Day%205%20-%20%E4%BB%A4%E4%BA%BA%E7%85%A9%E8%BA%81%E7%9A%84%E6%8C%89%E9%88%95%E4%BA%8B%E4%BB%B6%E5%82%B3%E9%81%9E/it_img_4_2_1.png)\n\n這種做法十分簡單，也十分易懂。但是隨著 Widget 越抽越多層，Callback 方法需要透過參數，一路往子層傳遞，使用起來就不是這麼方便。而且中間層的 GameItemView，自己不需要這個方法，卻被迫開出這個 onTap 參數，只為了把他傳遞給 GamePurchaseButton。\n\n## 利用 BuildContext 取得執行方法\n\n為了解決這個問題，讓我們來嘗試另外一個作法，我們利用 BuildContext 來取得 GameListScreen，並直接執行其身上的 buyGame 方法。\n\n![it_img_4_3.png](Day%205%20-%20%E4%BB%A4%E4%BA%BA%E7%85%A9%E8%BA%81%E7%9A%84%E6%8C%89%E9%88%95%E4%BA%8B%E4%BB%B6%E5%82%B3%E9%81%9E/it_img_4_3.png)\n\n[https://dartpad.dev/?id=f40b2e09b5a5756236c3627ff96464a3](https://dartpad.dev/?id=f40b2e09b5a5756236c3627ff96464a3)\n\n![it_img_4_3_1.png](Day%205%20-%20%E4%BB%A4%E4%BA%BA%E7%85%A9%E8%BA%81%E7%9A%84%E6%8C%89%E9%88%95%E4%BA%8B%E4%BB%B6%E5%82%B3%E9%81%9E/it_img_4_3_1.png)\n\n透過這個方式，我們可以消除掉中間 Widget 身上的 onTap。當使用者按下按鈕，嘗試執行方法時，子 Widget 就會透過 BuildContext 尋找目標 Widget，然後呼叫其身上的方法。\n\n## 沒有完美的解法\n\n這個方式十分方便，消除了中間 Widget 的多餘參數，但是這個做法也帶來了比較明顯的缺點：子 Widget 直接依賴了目標 Widget，造成子 Widget 比較難以被重複使用。以上面的例子來說，假設今天有一個 Other 也同樣使用了 GameItemView，當 GamePurchaseButton 被按下時，由於找不到 GameListScreen，所以按鈕無法正常運作。\n\n![it_img_4_6.png](Day%205%20-%20%E4%BB%A4%E4%BA%BA%E7%85%A9%E8%BA%81%E7%9A%84%E6%8C%89%E9%88%95%E4%BA%8B%E4%BB%B6%E5%82%B3%E9%81%9E/it_img_4_6.png)\n\n因為祖先 Widget 中不存在 GameListScreen，context.findAncestorWidgetOfExactType 時就會找回 null，我們也必須多檢查 null，避免不預期的錯誤。\n\n## 結論\n\n如果執行方法的 Widget 與擁有方法的 Widget 距離並不是太遠，使用參數傳遞可能是比較合適的方式。如果真的發現參數需要傳遞太多層，或許可以思考是否 Widget 拆了太多層了，可以適時考慮合併。雖然 context.findAncestorWidgetOfExactType 可以解決 onTap 傳太多層的問題，但也讓 Widget 難以重用，如非必要，還是優先考慮傳遞參數為主，畢竟傳遞參數的一大優點就是能清晰的呈現意圖。\n\n## 參考\n\n- GestureDetector：[https://www.youtube.com/watch?v=WhVXkCFPmK4](https://www.youtube.com/watch?v=WhVXkCFPmK4)\n- findAncestorWidgetOfExactType: [https://api.flutter.dev/flutter/widgets/BuildContext/findAncestorWidgetOfExactType.html](https://api.flutter.dev/flutter/widgets/BuildContext/findAncestorWidgetOfExactType.html)",
          "id": "c1ea0097a3644e9f94fc6e735facf267",
          "filename": "Day 5 - 令人煩躁的按鈕事件傳遞 c1ea0097a3644e9f94fc6e735facf267.md",
          "folderName": "Day 5 - 令人煩躁的按鈕事件傳遞",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 6 - 用 NotificationListener 處理按鈕事件",
          "summary": "id: 6 tag: 設計 在昨天的文章中，我們討論了兩種實現按鈕行為的方法。大多數的情況下，我們可以直接透過傳遞 onTap 參數解決。但是軟體會隨著需求不斷地演進，在昨天的例子中，假設需求多了一個按鈕，此時我們需要把新按鈕的事件處理一層一層傳遞至 GameActionSection 中，使得我們...",
          "content": "id: 6\ntag: 設計\n\n在昨天的文章中，我們討論了兩種實現按鈕行為的方法。大多數的情況下，我們可以直接透過傳遞 onTap 參數解決。但是軟體會隨著需求不斷地演進，在昨天的例子中，假設需求多了一個按鈕，此時我們需要把新按鈕的事件處理一層一層傳遞至 GameActionSection 中，使得我們不得不修改每一層 Widget。\n\n![it_img_6_1.png](Day%206%20-%20%E7%94%A8%20NotificationListener%20%E8%99%95%E7%90%86%E6%8C%89%E9%88%95%E4%BA%8B%E4%BB%B6/it_img_6_1.png)\n\n[https://dartpad.dev/?id=428479322a5666614b1e5def43ea4e78](https://dartpad.dev/?id=428479322a5666614b1e5def43ea4e78)\n\n![it_img_6_1_1.png](Day%206%20-%20%E7%94%A8%20NotificationListener%20%E8%99%95%E7%90%86%E6%8C%89%E9%88%95%E4%BA%8B%E4%BB%B6/it_img_6_1_1.png)\n\n以上面這個例子來說，除了原本的 onPurchaseButtonTap 之外，我們修改了大部分 Widget，為了新增 onCheckButtonTap。如果將來預計在 GameActionSection 上面新增越來越多的操作，那我們就不得不頻繁的修改不相關的 Widget。\n\n## 使用 BuildContext 解決嗎？\n\n若我們嘗試使用昨天主題中的另外一個作法：使用 BuildContext 呼叫方法來。在這個作法中，我們可以在 Widget 中新增操作，並且保證只修改相關的 Widget，而缺點在昨天的文章中討論過了，就不再次贅述。今天我們來聊聊另外一個作法，可以保有 BuildContext 解法的好處，並且有效解決 BuildContext 作法耦合過高的問題。\n\n## NotificationListener\n\nFlutter 提供的眾多 Widget，有一個 Widget 叫做 [NotificationListener](https://api.flutter.dev/flutter/widgets/NotificationListener-class.html)，他可以被用來接收從子 Widget 派送出來的 Notification，然後執行使用者定義的操作。最直接的例子就是，當我們想知道使用者是否正在滑動畫面上的 ListView 的時候，就可以用 NotificationListener 來接收 ScrollNotification。\n\n![it_img_6_2.png](Day%206%20-%20%E7%94%A8%20NotificationListener%20%E8%99%95%E7%90%86%E6%8C%89%E9%88%95%E4%BA%8B%E4%BB%B6/it_img_6_2.png)\n\n[https://dartpad.dev/?id=ea83de65e9a49cad81afc93426a37f4e](https://dartpad.dev/?id=ea83de65e9a49cad81afc93426a37f4e)\n\n## 客製 Notification\n\n利用 NotificationListener 和自定義的 GameNotification，我們就能在 GameButton 中派送 PurchaseGameNotification 或 CheckGameNotification，然後 GameListScreen 使用 NotificationListener 去監聽 GameNotification，當收到 Notification 時，執行 buyGame 或 checkGame。\n\n![it_img_6_3.png](Day%206%20-%20%E7%94%A8%20NotificationListener%20%E8%99%95%E7%90%86%E6%8C%89%E9%88%95%E4%BA%8B%E4%BB%B6/it_img_6_3.png)\n\n[https://dartpad.dev/?id=ea83de65e9a49cad81afc93426a37f4e](https://dartpad.dev/?id=ea83de65e9a49cad81afc93426a37f4e)\n\n![it_img_6_4.png](Day%206%20-%20%E7%94%A8%20NotificationListener%20%E8%99%95%E7%90%86%E6%8C%89%E9%88%95%E4%BA%8B%E4%BB%B6/it_img_6_4.png)\n\n透過 Notification 來處理按鈕觸發的事件，我們就能避免層層傳遞按鈕事件。讓使用者按下按鈕時，按鈕送出相對應 Notification，而上層的 Widget 可以自行決定是否監聽 Notification。以上面的例子來說，GameButtonSection 能在任何地方重複使用，而無需擔心是否有人接收 Notification，使用起來也比較靈活。\n\n## 結論\n\n使用 Notification 來處理按鈕事件，可以避免按鈕 Widget 與執行方法的 Widget 耦合，保持設計彈性，當需求是新增操作時，只要定義新的 Notification 並在適當的地方送出與接收，就能最小幅度的修改的程式碼。但是相反的，程式碼相比於傳遞 onTap 的作法，就沒有這麼直接易懂。選擇哪個作法，需要根據當下的需求情境，選擇使用合適的作法。\n\n## 參考\n\n- NotificationListener: [https://api.flutter.dev/flutter/widgets/NotificationListener-class.html](https://api.flutter.dev/flutter/widgets/NotificationListener-class.html)",
          "id": "b1fb0883ac5046f39bd9874245c71e0d",
          "filename": "Day 6 - 用 NotificationListener 處理按鈕事件 b1fb0883ac5046f39bd9874245c71e0d.md",
          "folderName": "Day 6 - 用 NotificationListener 處理按鈕事件",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 7 - 跨元件分享狀態",
          "summary": "note: 避免使用 static，讓程式具備可測試性 id: 7 tag: 設計 在前幾天的 Game List 的例子中，我們消除了 onTap 層層傳遞的問題。但是，如果我們仔細觀察的話，會發現 Game 也是同樣的情況，只要底層的哪個 Widget 需要 Game，中間層的 Widget 就...",
          "content": "note: 避免使用 static，讓程式具備可測試性\nid: 7\ntag: 設計\n\n在前幾天的 Game List 的例子中，我們消除了 onTap 層層傳遞的問題。但是，如果我們仔細觀察的話，會發現 Game 也是同樣的情況，只要底層的哪個 Widget 需要 Game，中間層的 Widget 就需要當中間人，代為傳遞參數。\n\n![it_img_7_1.png](Day%207%20-%20%E8%B7%A8%E5%85%83%E4%BB%B6%E5%88%86%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_7_1.png)\n\n[https://dartpad.dev/?id=831bf7d1714ef8d70daa0e473d5e2bed](https://dartpad.dev/?id=831bf7d1714ef8d70daa0e473d5e2bed)\n\n中間的 Widget 傳遞這個參數，自己卻是用不到，這個問題在上一張討論如何傳遞 callback 時也有討論到。今天就來聊聊如何簡化設計。\n\n## InheritedWidget\n\nFlutter 有提供許多基礎類型的 Widget，例如：StatelessWidget, StatefulWidget，而其中有一類 Widget 稱作 InheritedWidget。透過 InheritedWidget，我們能有效地讓子層可以跨過父層，直接存取 InheritedWidget。使用這個特性，我們就能避免層層傳遞 Game 的問題了。\n\n![it_img_7_2.png](Day%207%20-%20%E8%B7%A8%E5%85%83%E4%BB%B6%E5%88%86%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_7_2.png)\n\n![it_img_7_3.png](Day%207%20-%20%E8%B7%A8%E5%85%83%E4%BB%B6%E5%88%86%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_7_3.png)\n\n[https://dartpad.dev/?id=90fdfc781c4d43360eeb178174918381](https://dartpad.dev/?id=90fdfc781c4d43360eeb178174918381)\n\n經過修改之後，在上面的程式碼中，我們在頂層使用 GameInfo 這個 InheritedWidget，讓 GameInfoSection 和 GameActionSection 自己去取得 GameInfo，最後 GameItemView 也不需要幫忙傳遞 Game 了。\n\n## Provider\n\n當我們每次想要在 Widget Tree 中，縱向的分享資料時，我們都得寫一個 Widget 並讓他繼承 InheritedWidget，但是其實在 Flutter 眾多套件中，有一個能幫助我更簡單的使用 InheritedWidget，那就是 Provider。\n\n![it_img_7_4.png](Day%207%20-%20%E8%B7%A8%E5%85%83%E4%BB%B6%E5%88%86%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_7_4.png)\n\n![it_img_7_5.png](Day%207%20-%20%E8%B7%A8%E5%85%83%E4%BB%B6%E5%88%86%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_7_5.png)\n\n[https://dartpad.dev/?id=1ec4a9a9cb445e7b50bfb6974628d62d](https://dartpad.dev/?id=1ec4a9a9cb445e7b50bfb6974628d62d)\n\n可以發現使用 Provider 之後的程式碼，簡潔非常多，不需要使用繼承，也不需要特別定義一個新的 Widget，直接使用 Provider 並放入 game 就好。由於 Provider 裏頭其實就是 InheritedWidget，透過 Provider 我們能用組合的方式去使用 InheritedWidget，而不是繼承，想比喻繼承，我們傾向於使用組合，也是一個有名的規則：以[組合取代繼承](https://en.wikipedia.org/wiki/Composition_over_inheritance)。\n\n值得一提的是，InheritedWidget 是狀態管理的基礎，所以也使得作為 InheritedWidget 的 Wrapper，Provider 也被[大量套件引用](https://pub.dev/packages?q=dependency%3Aprovider)，其中最知名的就是 Bloc 了。\n\n## 用 Provider 傳遞按鈕事件\n\n回想前兩天的[主題](https://ithelp.ithome.com.tw/articles/10294365)，按鈕傳遞我們也能把 callback 放在 Provider，當子 Widget 渲染時，從 Provider 身上讀取 callback。但其實這個作法並不太合適，因為當我們從 Provider 讀取 callback 時，也意味著使用這個按鈕必須提供相應的 Provider，即使用他的人不需要按鈕有行為。大多時候，使用 Provider 傳遞狀態會比較合理，因為畫面顯示與資料是一致的，不同的資料會有不同的畫面。相比於資料，按鈕行為就很可能會因為畫面不同，而有不同的功能，所以使用 Provider 來傳遞按鈕事件，就會降低按鈕元件通用性。\n\n## 結論\n\nInheritedWidget 讓我們可以往子層 Widget 共享資料，避免過多的傳遞參數，畢竟沒有參數的方法或物件最好用。雖然 InheritedWidget 好用，但是在實戰中，我們還是傾向於使用 Provider，畢竟組合還是比繼承要來得有彈性。\n\n## 參考\n\n- InheritedWidget：[https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html](https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html)\n- Provider：[https://pub.dev/packages/provider](https://pub.dev/packages/provider)\n- Dependency of Provider：[https://pub.dev/packages?q=dependency%3Aprovider](https://pub.dev/packages?q=dependency%3Aprovider)\n- 組合取代繼承：[https://en.wikipedia.org/wiki/Composition_over_inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance)\n\nFlutter 的設計特性，Widget 具有上下層關係，子孫 Widget 如果想與祖先 Widget 享用共同的資料，必須得從祖先 Widget 把資料透過參數一路往下子孫 Widget 傳，直到傳到目標 Widget。\n\nex: code\n\n在上面這段程式碼中，我們可以發現一個問題，那就是路途中的所有 Widget 都會需要開出這個參數的接口，只會了接力傳遞這個參數，自己卻是用不到。這個問題在上一張討論如何傳遞 callback 時也有討論到\n\n為了解決這個問題，Flutter 提供了 InheritedWidget 來幫助我們解決這個問題。\n\nex: code\n\n透過這個方法，Widget 就能在縱向的方向共享狀態。\n\nWidget 縱向的共享狀態圖\n\n除了直接使用 IneritedWidget 之外，推薦直接使用 Provider 套件，這個套件讓是一個 InheritedWidget 的 Wrapper，簡化其使用方式。\n\n不過使用這個方法的壞處也顯而易見，就是 Widget 比較難以重複使用。假設今天有兩個與商品有關的頁面，一個顯示商品詳細資訊，一個顯示商品的 xxx，而這兩個頁面都需要顯示商品的名稱與圖片。\n\n今天 A 頁面在頂層共享了 DataA，而 B 頁面在頂層與他的子孫 Widget 共享了 DataB，此時共用的 Widget C 就會不知道應該使用 Inherited Widget A 或者 Inherited Widget B 來讀取資料。\n\n或許有讀者想到一個做法，那就是在 Widget C 中使用 if 來判斷今天是否能 Inherited Widget Ａ 或 Inhertied Widget Ｂ 是否存在，來決定使用哪一個資料。\n\n但是這個做法存在的開放封閉原則，當今天又出現了一個新的頁面想使用 Widget C，則開發者又必須修改 Widget Ｃ 以符合需求。\n\n另外一個做法是採用 IOC 的概念，利用 Flutter 萬物皆是 Widget 的特性，把子孫 Widget 當作參數傳給祖父 Widget，讓祖父 Widget 無需擔心子孫 Widget 如何實作，需要用什麼參數。樣板方法 像是 AppBar",
          "id": "e77047a76eb04c6aa6eba7f14833a4d3",
          "filename": "Day 7 - 跨元件分享狀態 e77047a76eb04c6aa6eba7f14833a4d3.md",
          "folderName": "Day 7 - 跨元件分享狀態",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 8 - 共享狀態加上複雜邏輯",
          "summary": "note: 跨頁面共享資料 id: 8 tag: 設計 當我們在開發 Flutter 時，有些時候我們會需要不斷的改變狀態，並把改變後的狀態渲染至畫面上。當隨著需求越來越複雜，改變狀態的邏輯也會開始變得複雜。假設今天有一個選擇相片的功能：畫面中有一個相片列表，使用者可以透過點擊相片選取，並且選取有些...",
          "content": "note: 跨頁面共享資料\nid: 8\ntag: 設計\n\n當我們在開發 Flutter 時，有些時候我們會需要不斷的改變狀態，並把改變後的狀態渲染至畫面上。當隨著需求越來越複雜，改變狀態的邏輯也會開始變得複雜。假設今天有一個選擇相片的功能：畫面中有一個相片列表，使用者可以透過點擊相片選取，並且選取有些限制。\n\n![it_img_8_2.png](Day%208%20-%20%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B%E5%8A%A0%E4%B8%8A%E8%A4%87%E9%9B%9C%E9%82%8F%E8%BC%AF/it_img_8_2.png)\n\n[https://dartpad.dev/?id=dd689d7e21bfadcb7c2df8805552a3b6](https://dartpad.dev/?id=dd689d7e21bfadcb7c2df8805552a3b6)\n\n一開始，我們會嘗試使用 StatefulWidget 來實現，但是從上面的程式碼可以得知，使用 StatefulWidget 會造成一個問題：那就是邏輯與畫面樣式混再一起，造成 Widget 違反了單一職責。\n\n## 抽取類別\n\n為了解決這個問題，我們來嘗試使用傳統物件導向的方式來解決。運用[抽取類別](https://refactoring.guru/extract-class)的技巧，將複雜的選取邏輯抽到 SelectedPhotos 中，讓 SelectedPhotos 自己決定照片是否能被選取。\n\n![it_img_7_2.png](Day%208%20-%20%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B%E5%8A%A0%E4%B8%8A%E8%A4%87%E9%9B%9C%E9%82%8F%E8%BC%AF/it_img_7_2.png)\n\n[https://dartpad.dev/?id=886bcbddaf299475a141d22e7d099a4e](https://dartpad.dev/?id=886bcbddaf299475a141d22e7d099a4e)\n\n當我們把 SelectPhotos 的狀態與邏輯抽取至獨立類別後，原本的 Widget 就變得簡單許多。將 SelectPhotos 獨立成一個類別，我們也更好對其邏輯進行[單元測試](https://zh.wikipedia.org/zh-tw/单元测试)。關於測試的議題，我們會在未來的文章進行討論，這邊就不延伸討論。\n\n## 狀態管理\n\n在開發客端應用程式時，我們時常會需要在程式中維護狀態。使用者通過 UI 介面操作狀態，程式根據使用者的操作來改變狀態，最後把最終狀態渲染在畫面上。我們可以使用 StatefulWidget 來進行狀態管理，就像上面的例子一樣，但是當邏輯變得複雜，就會造成 Widget 變大而難以修改。\n\n除了使用傳統的物件導向技巧處理，我們還可以選擇引入狀態管理套件，幫助我們簡化設計，在這邊我們使用 Riverpod 來修改上面的例子。\n\n![it_img_7_3.png](Day%208%20-%20%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B%E5%8A%A0%E4%B8%8A%E8%A4%87%E9%9B%9C%E9%82%8F%E8%BC%AF/it_img_7_3.png)\n\n[https://dartpad.dev/?id=427c1a2f44a98474a89f35e10aa9f313](https://dartpad.dev/?id=427c1a2f44a98474a89f35e10aa9f313)\n\n相比於抽取類別的作法，使用狀態管理的作法會與前者有兩處不同\n\n1. 由狀態管理維護狀態：顧名思義，狀態管理主要關心的就是狀態，使用狀態管理，我們就不需要維護自己的 selectedPhotos 陣列，而是交由狀態管理維護，我們只需關注如何操作。\n2. 由狀態管理更新畫面：大多數的狀態管理套件都有一個重要的功能，那就是偵測狀態變化，一旦變化，就觸發畫面更新，而不需要我們自己使用 setState。\n\n雖然在程式碼的長度並不會差很多，但實際上，使用狀態管理套件能讓我們更專注在操作狀態即可，是否重新渲染畫面則交由狀態管理決定，減輕 Widget 的負擔。\n\n## 結論\n\n當程式邏輯開始變得複雜時，適時的引入狀態管理套件，能有效的簡化設計。雖然在上面的例子中，我自己是使用 riverpod 解決問題，但是 Flutter 還有許多非常優秀的的狀態管理套件，例如：Bloc、Redux …等，Flutter 官方也有給出一些選項：[List of state management approaches](https://docs.flutter.dev/development/data-and-backend/state-mgmt/options)，大家在開發時，也可以參考看看。\n\n## 參考\n\n- 抽取類別：[https://refactoring.guru/extract-class](https://refactoring.guru/extract-class)\n- 單元測試：[https://zh.wikipedia.org/zh-tw/单元测试](https://zh.wikipedia.org/zh-tw/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)\n- List of state management approaches：[https://docs.flutter.dev/development/data-and-backend/state-mgmt/options](https://docs.flutter.dev/development/data-and-backend/state-mgmt/options)\n\n在開發像是 App 或 Web 前端時，一個無可避免的議題就是，如何管理狀態。由於需要提供使用者更好的體驗，我們常常會需要把資料暫存在前端，當畫面重新渲染時，我們就不需要再打一次 API 拿資料。\n\n在 Flutter 中，最簡單的狀態管理作法就是使用 StatefulWidget  \n\n```dart\n\n```\n\n這也是最簡單方便的解法。\n\n隨著狀態越來越複雜，我們可能希望把從 API 取得的資料進行一些處理\n\n例如把資料進行 sort \n\n就會造成 StatefulWidget 的邏輯越來越複雜\n\n當我們想要跨頁面存取資料時，\n\n有些時候，我們想讓\n\n橫向存取資料圖\n\nworst practice\n\n使用 Global\n\n使用 Provider\n\n使用其他狀態管理套件\n\n[https://www.reddit.com/r/FlutterDev/comments/p4t2ct/comment/h91ui6q/](https://www.reddit.com/r/FlutterDev/comments/p4t2ct/comment/h91ui6q/)\n\n[https://twitter.com/remi_rousselet/status/1281157412448276480?lang=zh-Hant](https://twitter.com/remi_rousselet/status/1281157412448276480?lang=zh-Hant)\n\n[https://stackoverflow.com/questions/65248439/dependency-injection-in-flutter-repercussions-of-different-approaches](https://stackoverflow.com/questions/65248439/dependency-injection-in-flutter-repercussions-of-different-approaches)\n\n**TL;DR: Don’t use setState if you already use a state management solution.** After two years of using flutter extensively, separating between the logic and UI parts is a must. my first project is not using any state management at all, and when I encounter a bug in the logic part, I fixed the bug in the same file with the UI part. It will be fine when you deal with a simple app, but when you have a larger app, it will be a headache for you and your team. It will eventually slow down your development process. My recommendation is to use [cubit](https://pub.dev/packages/flutter_bloc) as your state management because it is less boilerplate than BloC and provides a nice way of handling state in the app (and also scalable).\n\n> If you have already implemented any state management, my advice is to not use setState method in any of your code because it means that you need to add business logic in your UI code, except if you can not achieve it otherwise (I rarely encounter such a problem).\n> \n\n[https://medium.com/@zharfan104/top-10-flutter-developer-tips-i-learned-after-2-million-users-ab03eda10a55](https://medium.com/@zharfan104/top-10-flutter-developer-tips-i-learned-after-2-million-users-ab03eda10a55)\n\nFlutter itself doesn’t impose any state management by default, so it’s easy to end up with a messy combination and might depend on parameter passing or storing everything in persistent storage for storing state.\n\nWhile using a simple solution for state management is always recommended, we should also **consider the scalability and maintainability of the app** to select it.\n\nFurthermore, even though stateful widgets offer the simplest solution for state management, it can not scale when we want to maintain the state across multiple screens. e.g. Authentication state of User.\n\nState management comes really handy here. It allows to have central store of things that we can use to store anything and when anything in store changes, all the widgets dependent on that will be changed automatically.\n\nThere are so **many options available** for state management. Depending on the experience and level of comfort of the team, we can use any of the available solutions as mentioned [here](https://flutter.dev/docs/development/data-and-backend/state-mgmt/options). For instance, one powerful option for State Management with Flutter is the [BloC pattern](https://pub.dev/packages/flutter_bloc).",
          "id": "35772960a37b4b358dd43017e2b4bae3",
          "filename": "Day 8 - 共享狀態加上複雜邏輯 35772960a37b4b358dd43017e2b4bae3.md",
          "folderName": "Day 8 - 共享狀態加上複雜邏輯",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 9 - 跨頁面共享狀態",
          "summary": "id: 9 在昨天的文章中，我們提到了狀態管理套件可以用來簡化設計。今天我們來聊聊狀態管理套件的另一個用途：共享狀態。假設今天 App 有一個 Home 頁面，且在頁面登入之後，需要顯示 User 資訊。 [https://dartpad.dev/?id=dc1f03148a17057141d4f7...",
          "content": "id: 9\n\n在昨天的文章中，我們提到了狀態管理套件可以用來簡化設計。今天我們來聊聊狀態管理套件的另一個用途：共享狀態。假設今天 App 有一個 Home 頁面，且在頁面登入之後，需要顯示 User 資訊。\n\n![it_img_9_1.png](Day%209%20-%20%E8%B7%A8%E9%A0%81%E9%9D%A2%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_9_1.png)\n\n![it_img_9_2.png](Day%209%20-%20%E8%B7%A8%E9%A0%81%E9%9D%A2%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_9_2.png)\n\n[https://dartpad.dev/?id=dc1f03148a17057141d4f75e223459a0](https://dartpad.dev/?id=dc1f03148a17057141d4f75e223459a0)\n\n當我們需要再新增其他需要 User 資訊頁面時，很容易的就透過 Route 參數把 User 傳給其他頁面。\n\n![it_img_9_3.png](Day%209%20-%20%E8%B7%A8%E9%A0%81%E9%9D%A2%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_9_3.png)\n\n[https://dartpad.dev/?id=dd76ad4f477465befa9e9b43f61ae259](https://dartpad.dev/?id=dd76ad4f477465befa9e9b43f61ae259)\n\n這種作法有個的缺點：想打開那些需要 User 的頁面時，就需要準備好 User 給他，當大部分的頁面都需要 User 時，User 物件就會在這些頁面之間傳來傳去，使得我們不好管理。\n\n![it_img_9_3_1.png](Day%209%20-%20%E8%B7%A8%E9%A0%81%E9%9D%A2%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_9_3_1.png)\n\nRoute 參數跟方法參數一樣，參數越多，我們就越難使用。如同 Clean Code 裡頭提到的，我們應該盡量避免過多的參數。\n\n> 最理想的參數數量是 0 個，其次是 1 個，再不然是 2 個。\n> \n\n## 全域物件\n\n為了解決這個問題，最容易的辦法就是把 User 放到全域變數的層級。\n\n![it_img_9_4.png](Day%209%20-%20%E8%B7%A8%E9%A0%81%E9%9D%A2%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B/it_img_9_4.png)\n\n[https://dartpad.dev/?id=27f3abc9782600bfc6f9dec99395b394](https://dartpad.dev/?id=27f3abc9782600bfc6f9dec99395b394)\n\n透過全域變數，所有 Screen 或 Widget 都能得知當前 User 的狀態，讓使用 Widget 時，不必再帶 User 參數，使用上會方便許多，但是這種作法有一些缺點：\n\n1. 由於 User 是任何地方可以存取，當 User 被錯誤的修改時，App 將會變得難以除錯。\n2. 當 User 發生變化時，與 User 依賴的畫面無法被及時的修改。\n\n## 狀態管理\n\n我們使用狀態管理套件來解決這兩個問題，透過狀態管理套件，我們可以封裝 User，並開出適當的方法讓 Widget 操作，避免 Widget 直接存取 User。而在通知變化的問題上，大多狀態管理套件都有提供 API，讓 Widget 可以在狀態發生變化時，重 build 一次畫面。\n\n![it_Img_9_5.png](Day%209%20-%20%E8%B7%A8%E9%A0%81%E9%9D%A2%E5%85%B1%E4%BA%AB%E7%8B%80%E6%85%8B/it_Img_9_5.png)\n\n[https://dartpad.dev/?id=d746a86024f49e27a255932be88f5095](https://dartpad.dev/?id=d746a86024f49e27a255932be88f5095)\n\n在這邊我們一樣使用 riverpod 修改上面的例子，使用 riverpod 的 watch 方法後，當 User 發生變化時，畫面就會即時的重 build。同樣方式，除了使用 riverpod 以外，使用 Provider、Bloc 等其他狀態管理套件，也能達到一樣的效果，只是寫法上可能不同，但是概念卻是一致的。\n\n## 結論\n\n原本屬於 StatefulWidget 的狀態，可以透過狀態管理套件，把 scope 提升到更高的層次，藉此讓整個 App 都能使用，又能有效的管理，並且即時根據狀態變換畫面。經過兩天的文章，我們介紹了狀態管理的一些使用情境，但是我們是否能無腦把狀態通通移到狀態管理上呢？明天我們就來討論這個議題。\n\n## 參考\n\n- Clean Code：[https://www.tenlong.com.tw/products/9789862017050?list_name=srh](https://www.tenlong.com.tw/products/9789862017050?list_name=srh)\n\n[https://codewithandrea.com/articles/global-access-vs-scoped-access/](https://codewithandrea.com/articles/global-access-vs-scoped-access/)",
          "id": "e3ef9f5deee74790a18c965c7b12b035",
          "filename": "Day 9 - 跨頁面共享狀態 e3ef9f5deee74790a18c965c7b12b035.md",
          "folderName": "Day 9 - 跨頁面共享狀態",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 10 - 暫存狀態 vs 程式狀態",
          "summary": "id: 10 tag: 設計 當我們使用狀態管理之後，可能會思考，是否再也不需要使用 StatefulWidget 了？今天我們就來談談這個問題。首先，我們先看一個例子，假設今天畫設計師設計了一個按鈕，當按鈕被壓著時，按鈕需要變個顏色，讓使用者感知自己有按到按鈕 [https://dartpad.d...",
          "content": "id: 10\ntag: 設計\n\n當我們使用狀態管理之後，可能會思考，是否再也不需要使用 StatefulWidget 了？今天我們就來談談這個問題。首先，我們先看一個例子，假設今天畫設計師設計了一個按鈕，當按鈕被壓著時，按鈕需要變個顏色，讓使用者感知自己有按到按鈕\n\n![it_img_10_1.jpg](Day%2010%20-%20%E6%9A%AB%E5%AD%98%E7%8B%80%E6%85%8B%20vs%20%E7%A8%8B%E5%BC%8F%E7%8B%80%E6%85%8B/it_img_10_1.jpg)\n\n![截圖 2022-09-23 下午11.15.23.png](Day%2010%20-%20%E6%9A%AB%E5%AD%98%E7%8B%80%E6%85%8B%20vs%20%E7%A8%8B%E5%BC%8F%E7%8B%80%E6%85%8B/%25E6%2588%25AA%25E5%259C%2596_2022-09-23_%25E4%25B8%258B%25E5%258D%258811.15.23.png)\n\n[https://dartpad.dev/?id=1ce393e000000b9df586a11d7c6ae495](https://dartpad.dev/?id=1ce393e000000b9df586a11d7c6ae495)\n\n在上面的例子中，我們使用狀態管理來實現這個設計，可以發現在 ButtonStatus 中，我們維護了一個按鈕是否被按下的布林值，並且宣告了一個相對應的 Provider。雖然我們可以用狀態管理套件，完成這個功能，但實際上，會發現其實 ButtonStatus 並沒有多大的意義，形成一個壞味道：[Lazy Class](https://refactoring.guru/smells/lazy-class)。\n\n## 把職責合併回 StatefulWidget\n\n我們來看看使用 StatefulWidget 實現會變得如何？\n\n![it_img_10_3.png](Day%2010%20-%20%E6%9A%AB%E5%AD%98%E7%8B%80%E6%85%8B%20vs%20%E7%A8%8B%E5%BC%8F%E7%8B%80%E6%85%8B/it_img_10_3.png)\n\n[https://dartpad.dev/?id=4c56071a63fa7416c4c22578694fa1e0](https://dartpad.dev/?id=4c56071a63fa7416c4c22578694fa1e0)\n\n可以發現在這個場景中，使用 StatefulWidget 實現的話，我們只要在 State 維護一個布林值，並利用 setState 更新按鈕狀態與重 build 畫面。\n\n## 暫存狀態 vs 程式狀態\n\n客端程式中，大多時候都要維護各式各樣的狀態，我們可以把狀態分為兩種：暫存狀態和程式狀態。在按鈕的例子中，isPressed 的布林值就比較屬於暫存狀態，當 Button 消失時，這 isPressed 也隨之消失。在昨天顯示 User 的例子中，即便畫面關閉了，User 這個狀態還是需要存在程式中，以便其他畫面使用。\n\n## 暫存狀態一定使用 StatefulWidget？\n\n那是否暫存狀態就得永遠使用 StatefulWidget 呢？那倒也不是，管理狀態的邏輯比較複雜時，我們適當的使用狀態管理套件，將邏輯與畫面分開，能夠將一個比較複雜的類別，簡化成兩個比較簡單的類別，是具有意義的。在前天的選擇照片的例子中，選擇的照片在離開了選擇照片頁面之後，可能也不存在意義了。但是我們還是使用了狀態管理來改善，也是基於上述理由。\n\n反之亦然，是否所有程式狀態也並非一定要使用狀態管理。在按鈕的例子中，假設需求變得複雜了，我們需要一個時間倒數的按鈕，並且擁有倒數/暫停等較複雜的行為時，使用狀態管理還是有一定好處。\n\n![it_img_10_4.png](Day%2010%20-%20%E6%9A%AB%E5%AD%98%E7%8B%80%E6%85%8B%20vs%20%E7%A8%8B%E5%BC%8F%E7%8B%80%E6%85%8B/it_img_10_4.png)\n\n[https://dartpad.dev/?id=c93d29f9a38a0482a15ba028155d681e](https://dartpad.dev/?id=c93d29f9a38a0482a15ba028155d681e)\n\n## 結論\n\n如何選擇使用 StatefulWidget 或者狀態管理套件，可以先判斷情境屬於暫存狀態或者程式狀態，並決定使用哪種實現，當實現一版之後，發現暫存狀態的邏輯過於複雜，還是可以改用狀態管理套件。\n\n## 參考\n\n- Lazy Class：[https://refactoring.guru/smells/lazy-class](https://refactoring.guru/smells/lazy-class)\n- Differentiate between ephemeral state and app state：[https://docs.flutter.dev/development/data-and-backend/state-mgmt/ephemeral-vs-app](https://docs.flutter.dev/development/data-and-backend/state-mgmt/ephemeral-vs-app)\n\n## 再也不需要 StatefulWidget?\n\n當我們熟悉使用狀態管理套件之後，或許會感覺自己再也不需要寫 StatefulWidget 了。我自己的觀點是：如果 Widget 本身的邏輯並不複雜，也沒有共用的需求，應該是以使用 StatefulWidget 為優先選擇。假設今天設計師製作一個 Button 按下時需要變換顏色的設計，此時如果還是使用狀態管理套件來維護按鈕狀態，像下面這段程式碼一樣，就有點大材小用了。\n\n既然狀態管理套件這麼好用，那是否再也不需要 stateful widget\n\n有時候我們會開發一個比較複雜的畫面 例如按鈕的 press Hoover 要不同顏色\n\n或許有人會問 有了狀態管理套件 是否再也不需要 stateful widget\n\n並非如此 有些狀態與widget 緊緊相依 讓他們在 ui 裡面有助於理解 也讓狀態管理比較好測試\n\n違反 feature envy\n\n若是擔心 setState 作用範圍太大 應該是要使用抽取 widget 抽到合適大小\n\n## 參考\n\n- Differentiate between ephemeral state and app state：[https://docs.flutter.dev/development/data-and-backend/state-mgmt/ephemeral-vs-app](https://docs.flutter.dev/development/data-and-backend/state-mgmt/ephemeral-vs-app)",
          "id": "6aa14bb95f7f44b0b780c8fa183035e5",
          "filename": "Day 10 - 暫存狀態 vs 程式狀態 6aa14bb95f7f44b0b780c8fa183035e5.md",
          "folderName": "Day 10 - 暫存狀態 vs 程式狀態",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 11 - 四處可見地倒數計時",
          "summary": "id: 11 tag: 設計 有時候，我們需要根據時間來渲染畫面，並時時刻刻的更新。一個經典的例子就是顯示倒數時間，例如：商品打折的剩餘時間，比賽開始的倒數時間 …等等。我們使用最簡單的 StatefulWidget + Timer 來完成第一版的程式碼。 [https://dartpad.dev/...",
          "content": "id: 11\ntag: 設計\n\n有時候，我們需要根據時間來渲染畫面，並時時刻刻的更新。一個經典的例子就是顯示倒數時間，例如：商品打折的剩餘時間，比賽開始的倒數時間 …等等。我們使用最簡單的 StatefulWidget + Timer 來完成第一版的程式碼。\n\n![it_img_11_1.png](Day%2011%20-%20%E5%9B%9B%E8%99%95%E5%8F%AF%E8%A6%8B%E5%9C%B0%E5%80%92%E6%95%B8%E8%A8%88%E6%99%82/it_img_11_1.png)\n\n[https://dartpad.dev/?id=95c6e97373a5fce940e29b336cb57057](https://dartpad.dev/?id=95c6e97373a5fce940e29b336cb57057)\n\n運行上面的程式碼之後，可以發現程式如我們預期的一秒一秒倒數。如果今天畫面上只有一個倒數時間，我們就可以收工下班了。但是，有些時候畫面可能會同時出多個倒數時間，此時我們會發現一些問題。\n\n## 當畫面上有多個倒數時間時\n\n當我們滑動畫面，就會發現畫面的倒數時間跳動，變得非常不整齊。原因是每個 CountdownWidget 建立的時間不一致，導致每個 Widget 的 Timer 之間的更新頻率無法對齊，時間更新也就變得不整齊。\n\n![螢幕錄製_2022-09-20_下午11_35_57_AdobeExpress.gif](Day%2011%20-%20%E5%9B%9B%E8%99%95%E5%8F%AF%E8%A6%8B%E5%9C%B0%E5%80%92%E6%95%B8%E8%A8%88%E6%99%82/%25E8%259E%25A2%25E5%25B9%2595%25E9%258C%2584%25E8%25A3%25BD_2022-09-20_%25E4%25B8%258B%25E5%258D%258811_35_57_AdobeExpress.gif)\n\n[https://dartpad.dev/?id=f163e5e37cf44378aacfc1fc133079e7](https://dartpad.dev/?id=f163e5e37cf44378aacfc1fc133079e7)\n\n## Global Timer\n\n為了解決這個問題，最簡單的方式是將 Timer 移出 Widget，以全域變數的形式存在程式中。在 Timer 中，我們使用[觀察者模式](https://zh.m.wikipedia.org/zh-tw/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F)，讓 Widget 向 Timer 註冊與監聽時間的跳動，並在接收到通知時更新畫面。這樣一來，Widget 能盡量在相同的時間進行時間跳動。\n\n![it_img_11_3.png](Day%2011%20-%20%E5%9B%9B%E8%99%95%E5%8F%AF%E8%A6%8B%E5%9C%B0%E5%80%92%E6%95%B8%E8%A8%88%E6%99%82/it_img_11_3.png)\n\n[https://dartpad.dev/?id=e031a0ec59b156c3e176b68b60c2d6ce](https://dartpad.dev/?id=e031a0ec59b156c3e176b68b60c2d6ce)\n\n在這個作法中，Timer 必須維護 Observer 列表，而 Widget 本身也需要自己處理 Observer 的註冊與註銷。假設我們今天不使用 Flutter 而是單純的使用 Dart 來開發其他應用，這個作法並不算太差。但假設我們是使用 Flutter 的話，我們可以利用 Flutter 的框架機制，讓我們少維護一些程式碼。\n\n## InheritedWidget / Provider\n\n在前幾天的[文章](https://ithelp.ithome.com.tw/articles/10295663)中，我們討論到使用 InheritedWidget / Provider 來共享參數。同樣的，我們也可以透過 InheritedWidget / Provider 來共享 Timer，當更新時間到了的時候，透過 InheritedWidget / Provider 幫助我們更新所有倒數計時的畫面。\n\n在這邊我們使用 Provider 來改寫上面的例子，在 CountdownWidget 中，使用 context.watch 讀取並監聽變化。當更新時間到了的時候，Provider 會透過 notifyListeners 通知所有畫面。\n\n![it_img_11_4.png](Day%2011%20-%20%E5%9B%9B%E8%99%95%E5%8F%AF%E8%A6%8B%E5%9C%B0%E5%80%92%E6%95%B8%E8%A8%88%E6%99%82/it_img_11_4.png)\n\n[https://dartpad.dev/?id=82d7e6a3cc2e2ede3106138f6c3401c8](https://dartpad.dev/?id=82d7e6a3cc2e2ede3106138f6c3401c8)\n\n使用這個作法，我們可以省去維護自己的 Observer List，Widget 也能使用 StatelessWidget 就好，讓程式碼變得更簡潔。\n\n無論是 GlobalTimer 作法或 InheritedWidget / Provider 作法，都有一個明顯的問題：那就是 CountdownWidget 必須依賴於 CountdownTimer 才能工作，每當我想要使用 CountdownWidget 時，想辦法提供他 CountdownTimer。\n\n![it_img_11_5.png](Day%2011%20-%20%E5%9B%9B%E8%99%95%E5%8F%AF%E8%A6%8B%E5%9C%B0%E5%80%92%E6%95%B8%E8%A8%88%E6%99%82/it_img_11_5.png)\n\n## 使用 Ticker\n\n大家如果有在 Flutter 中使用過 Tab 的話，肯定對 Ticker 不陌生，使用 TabController 時，需要傳一個 vsync，而 vsync 的其實就是 TickerProvider。Ticker 人如其名，讓我們就像時鐘一樣滴搭滴搭的執行某個方法，讓我們使用 Ticker 來改寫倒數計時吧。\n\n![it_img_11_6.png](Day%2011%20-%20%E5%9B%9B%E8%99%95%E5%8F%AF%E8%A6%8B%E5%9C%B0%E5%80%92%E6%95%B8%E8%A8%88%E6%99%82/it_img_11_6.png)\n\n[https://dartpad.dev/?id=7fd27c9317101180fb3b8fff201511ca](https://dartpad.dev/?id=7fd27c9317101180fb3b8fff201511ca)\n\n使用 Ticker 的話，我們可以解決時間同步的問題，也不需要把 Timer 往 Widget 外搬。用法上，與 Timer 一樣，需要在 initState / dispose 處理 Ticker 的生命週期，卻不會有 Timer 更新不同步的問題。相比於 Global 與 InheritedWidget / Provider 作法，使用 Ticker 能提升 Widget 的內聚力，自己就可以完成所有事情，不需要靠外部的物件來協助自己更新畫面。\n\n## 結論\n\n如果今天我們的需求只是倒數計時，那我們考慮優先使用 Ticker 解決問題。當未來倒數可能不只是倒數，需要加上一些商業邏輯時，使用 InheritedWidget / Provider 或其他狀態管理套件就比較合適。無論什麼作法，都需要優先考慮需求與情境，其次才是討論什麼是最適合的作法，讓開發與維護變得更容易。\n\n## 參考\n\n- 觀察者模式：[https://zh.m.wikipedia.org/zh-tw/观察者模式](https://zh.m.wikipedia.org/zh-tw/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F)\n- 內聚力：[https://zh.m.wikipedia.org/zh-tw/內聚性_(計算機科學)](https://zh.m.wikipedia.org/zh-tw/%E5%85%A7%E8%81%9A%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))",
          "id": "dd8b59d4253c4a77a54fac1bbdf829f0",
          "filename": "Day 11 - 四處可見地倒數計時 dd8b59d4253c4a77a54fac1bbdf829f0.md",
          "folderName": "Day 11 - 四處可見地倒數計時",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 12 - 用 Nested Navigation 處理耦合的頁面",
          "summary": "note: 讓頁面可重複使用 也增加可讀性 id: 12 tag: 設計 隨著功能越來越多，App 的頁面也會越來越多，我們常常就會引入路由管理設計。在 Flutter 中，我們會在 MaterialApp 裡面定義整個 App 的路由，透過 Navigator 使用 push 和 pop 來決定當...",
          "content": "note: 讓頁面可重複使用 也增加可讀性\nid: 12\ntag: 設計\n\n隨著功能越來越多，App 的頁面也會越來越多，我們常常就會引入路由管理設計。在 Flutter 中，我們會在 MaterialApp 裡面定義整個 App 的路由，透過 Navigator 使用 push 和 pop 來決定當前頁面。有時候我們會發現，有些流程需要複數的頁面組合再一起，才能完成一個完整的使用者行為。\n\n## 舉個例子\n\n假設我們有一個傳輸檔案的需求，如下圖所示，在這個需求中，我們需要讓使用者選擇裝置與檔案，最後傳輸。\n\n![it_img_13_1.png](Day%2012%20-%20%E7%94%A8%20Nested%20Navigation%20%E8%99%95%E7%90%86%E8%80%A6%E5%90%88%E7%9A%84%E9%A0%81%E9%9D%A2/it_img_13_1.png)\n\n在這個例子中，我們可以發現一些問題：由於頁面的切換是一層一層的 push 疊上去，當流程結束時，也就只能一層一層的 pop 回來。而在需求中，我們需要把傳輸結果顯示在一開始的畫面上，所以在 pop 的過程中，我們也需要把結果夾帶回來。\n\n![it_img_13_2.png](Day%2012%20-%20%E7%94%A8%20Nested%20Navigation%20%E8%99%95%E7%90%86%E8%80%A6%E5%90%88%E7%9A%84%E9%A0%81%E9%9D%A2/it_img_13_2.png)\n\n[https://dartpad.dev/?id=d7bfd62a06a0d9ab1d1a74ab154503ef](https://dartpad.dev/?id=d7bfd62a06a0d9ab1d1a74ab154503ef)\n\n## 耦合的頁面\n\n我們從程式碼中可以發現，Search Devices 和 Select Device 頁面中，除了實現自身頁面的功能之外，還需要幫忙傳遞結果。\n\n![it_img_13_3.png](Day%2012%20-%20%E7%94%A8%20Nested%20Navigation%20%E8%99%95%E7%90%86%E8%80%A6%E5%90%88%E7%9A%84%E9%A0%81%E9%9D%A2/it_img_13_3.png)\n\n![it_img_13_4.png](Day%2012%20-%20%E7%94%A8%20Nested%20Navigation%20%E8%99%95%E7%90%86%E8%80%A6%E5%90%88%E7%9A%84%E9%A0%81%E9%9D%A2/it_img_13_4.png)\n\n最後在 HomePage 取得 isTransferOk 結果，並把 Transfer success 顯示在畫面上。\n\n![it_img_13_5.png](Day%2012%20-%20%E7%94%A8%20Nested%20Navigation%20%E8%99%95%E7%90%86%E8%80%A6%E5%90%88%E7%9A%84%E9%A0%81%E9%9D%A2/it_img_13_5.png)\n\n這會造成什麼問題呢？Search Devices 和 Select Device 頁面在 pushNamed 時，必須得知道下一個頁面想回傳什麼結果。假設今天我們想顯示更多傳輸結果，成功、沒有權限、無法連線 …等更多結果時，我們必須連帶一起修改。\n\n也因為這個原因，導致 Search Devices 和 Select Device 頁面難以被重複只用，因為他與某個特定的傳輸結果耦合，我們很難其他流程中重複使用這個頁面。\n\n## 使用 Nested Navigation\n\n為了解決這個問題，我們建立了一個 TransferFileFlow 的頁面，並使用 [Nested Navigation](https://docs.flutter.dev/cookbook/effects/nested-nav) 來管理 Search Devices、Select Device 和 Select File 頁面。在執行流程的過程中，每個頁面會專注於完成自己的工作，並把工作結果傳回給 TransferFileFlow，由 TransferFileFlow 來決定下一步是什麼。最終，TransferFileFlow 會統合所有資訊，完成傳輸，並把結果告訴 Home 頁面。\n\n![it_img_13_6.png](Day%2012%20-%20%E7%94%A8%20Nested%20Navigation%20%E8%99%95%E7%90%86%E8%80%A6%E5%90%88%E7%9A%84%E9%A0%81%E9%9D%A2/it_img_13_6.png)\n\n透過 Nested Navigation 的作法，TransferFileFlow 把相對應的 callback 傳入 Search Devices、Select Device 和 Select File 頁面，當每個子頁面完成工作時，則呼叫 callback 通知 TransferFileFlow，也就是“搜尋裝置結果”、“使用者選擇的裝置” 與 “使用者選擇的檔案”。最後 TransferFileFlow 則是負責組合這些資訊，完成傳輸工作。\n\n## 分離控制流程的職責\n\nNested Navigation 的作法有個好處，它把控制流程的職責從 Search Devices、Select Device 和 Select File 頁面中拆出來了，並放在 TransferFileFlow 中，原本的子頁面就只要專注在如何完成當前頁面的工作即可。這也使得這些子頁面可以在其他流程中被重複使用。\n\n![it_img_13_7.png](Day%2012%20-%20%E7%94%A8%20Nested%20Navigation%20%E8%99%95%E7%90%86%E8%80%A6%E5%90%88%E7%9A%84%E9%A0%81%E9%9D%A2/it_img_13_7.png)\n\n假設今天我們有一個刪除檔案的流程，我們就能重複使用 Select File 頁面，只要給他相對應的 callback，當頁面完成工作時，就會通知結果。正因為 Select File 頁面不參與任何頁面轉換或流程控制，也就讓我們有機會在任何流程中重複使用。\n\n## 結論\n\nNested Navigation 十分適合使用在這種固定流程的工作上，如果頁面沒辦法單獨提供功能，而是需要多個頁面共同組合出一個功能的話，就很適合使用 Nested Navigation 這種做法。當一個頁面能提供完整的功能，例如顯示比賽資訊，顯示裝置詳細資訊，或者是更新使用暱稱這種單一頁面就可以完成的，或許就不太需要使用 Nested Navigation。\n\n## 參考\n\n- 耦合：[https://zh.wikipedia.org/zh-tw/耦合性_(計算機科學)](https://zh.wikipedia.org/zh-tw/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))\n- Nested Navigation：[https://docs.flutter.dev/cookbook/effects/nested-nav](https://docs.flutter.dev/cookbook/effects/nested-nav)\n\nFlutter 在最頂層的 MaterialApp 中統一定義整個 app 的路由管理。當我們把所有頁面的路由管理都放在最頂層時，就會讓它變得很長，不容易維護。或許應該適時思考，是否某些頁面的路由不應該被管理在最頂層。今天就來分享工作上遇到的一個情境，以及它存在什麼問題，而我們又是如何解決的。\n\n，讓頁面只知道自己需要的訊息，並且輸出他工作後的結果，至於如何使用就讓使用方來決定。\n\n我們使用上面的例子進行修改，先創建一個 TransferFileFlow，並在其中使用 Navigator Widget，給定一個 GlobalKey 放進 Navigator 中，我們需要使用 GlobalKey 來進行 Nested Navigator 的頁面切換。",
          "id": "f73fde307f454aa7ac523656d45e01c4",
          "filename": "Day 12 - 用 Nested Navigation 處理耦合的頁面 f73fde307f454aa7ac523656d45e01c4.md",
          "folderName": "Day 12 - 用 Nested Navigation 處理耦合的頁面",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 13 - 非同步處理怎麼寫？有差嗎？",
          "summary": "id: 13 在開發 App 的過程中，我們的程式常常會需要與外部服務互動，例如：利用 http 像後端 API 拿回一些資料，或者把一些資料存到 Local storage 中。在這些情境中，我們無可避免地需要使用非同步來處理，因為這些互動往往需要一些時間，而我們不能讓程式因為等待結果而卡住。 在...",
          "content": "id: 13\n\n在開發 App 的過程中，我們的程式常常會需要與外部服務互動，例如：利用 http 像後端 API 拿回一些資料，或者把一些資料存到 Local storage 中。在這些情境中，我們無可避免地需要使用非同步來處理，因為這些互動往往需要一些時間，而我們不能讓程式因為等待結果而卡住。\n\n## 使用 .then 處理\n\n在非同步呼叫回傳 Future 後，我們可以呼叫 Future.then，並傳入我們想要的後續操作，來完成非同步處理。也可以繼續使用 .catchError 處理錯誤情況。\n\n![it_img_12_1.png](Day%2013%20-%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%99%95%E7%90%86%E6%80%8E%E9%BA%BC%E5%AF%AB%EF%BC%9F%E6%9C%89%E5%B7%AE%E5%97%8E%EF%BC%9F/it_img_12_1.png)\n\n[https://dartpad.dev/?id=631e48f94fc4932beb2f8d6ca0ffbd30](https://dartpad.dev/?id=631e48f94fc4932beb2f8d6ca0ffbd30)\n\n## 使用 async / await\n\n除了使用 .then 之外，Dart 還提供 async/await 的方式來處理非同步。使用 async/await 來處理非同步的呼叫，可以把程式碼寫的與同步程式碼一樣，閱讀上非常直觀。而在錯誤處理的方面，能像同步程式碼一樣，使用 try / catch 處理。\n\n![it_img_12_2.png](Day%2013%20-%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%99%95%E7%90%86%E6%80%8E%E9%BA%BC%E5%AF%AB%EF%BC%9F%E6%9C%89%E5%B7%AE%E5%97%8E%EF%BC%9F/it_img_12_2.png)\n\n[https://dartpad.dev/?id=61b515070bef07ebb8d5694fca43af52](https://dartpad.dev/?id=61b515070bef07ebb8d5694fca43af52)\n\n再看了 .then 和 async/await 的作法之後，大家可能會思考，到底用哪個比較好呢？\n\n## async/await 無法使用？\n\n有些時候，我們不得不使用 .then：當我們在 StatefulWidget 中的 initState 裏，想呼叫非同步方法來初始化狀態時，由於 initState 本身回傳值 void，使得我們無法在其中使用 await。此時，我們必須使用 .then 來處理。\n\n![it_img_12_3.png](Day%2013%20-%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%99%95%E7%90%86%E6%80%8E%E9%BA%BC%E5%AF%AB%EF%BC%9F%E6%9C%89%E5%B7%AE%E5%97%8E%EF%BC%9F/it_img_12_3.png)\n\n[https://dartpad.dev/?id=50d3d9e4f54c6ec3047780ea4eec715f](https://dartpad.dev/?id=50d3d9e4f54c6ec3047780ea4eec715f)\n\n雖然我們可以硬把 initState 加上 async，實際上執行卻會發生錯誤\n\n![it_img_12_4.png](Day%2013%20-%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%99%95%E7%90%86%E6%80%8E%E9%BA%BC%E5%AF%AB%EF%BC%9F%E6%9C%89%E5%B7%AE%E5%97%8E%EF%BC%9F/it_img_12_4.png)\n\n## 使用 .then V.S. 使用 async/await\n\n大多數時候，用 .then 或用 async/await 並不會差很多，但是我自己強烈推薦使用 async/await，原因如下\n\n1. 可讀性：async/await 讓寫法是一行一行的往下執行，也比較容易閱讀，上一行的非同步處理結果，可能在下一行就直接使用，省去 .then 與其 callback 參數的包裝，程式碼變得比較簡潔。\n2. 可拓展性：當我們今天需要循序的使用多個非同步呼叫時，.then 會變得十分複雜，從下面程式碼中，我們可以看出，隨著非同步呼叫數量越多，.then 寫法則越複雜，當再加上錯誤處理時，程式碼就變得幾乎無法理解。相反的，而 async/await 的作法能維持一行一個操作的寫法，使其維持一定的可讀性。\n\n![it_img_12_5.png](Day%2013%20-%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%99%95%E7%90%86%E6%80%8E%E9%BA%BC%E5%AF%AB%EF%BC%9F%E6%9C%89%E5%B7%AE%E5%97%8E%EF%BC%9F/it_img_12_5.png)\n\n[https://dartpad.dev/?id=fa2f7f3786ad656b894153e59a4a027b](https://dartpad.dev/?id=fa2f7f3786ad656b894153e59a4a027b)\n\n[https://dartpad.dev/?id=966b04b98c4b2a37ae09a3ffb928e65f](https://dartpad.dev/?id=966b04b98c4b2a37ae09a3ffb928e65f)\n\n## 結論\n\n非同步處理是開發過程中很常使用到的技巧之一，如果此時程式碼寫的不夠清楚，往往在實現時忽略執行邏輯而造成 Bug，當程式碼又不好讀時，更是雪上加霜。使用 async/await 能讓我們把非同步處理寫的像同步處理一樣，讓程式碼變得更好讀，也易於新手學習。\n\nDart 的非同步處理與 Javascript 十分相似，我們有兩種方式可用來實現非同步的處理，一種\n\n.then vs async await\n\nAwait 對其他語言來說比較容易讀\n\n包多層 async \n\n比較容易把邏輯拆小",
          "id": "2123179cf2924866b9138956d33ee058",
          "filename": "Day 13 - 非同步處理怎麼寫？有差嗎？ 2123179cf2924866b9138956d33ee058.md",
          "folderName": "Day 13 - 非同步處理怎麼寫？有差嗎？",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 14 - 使用 Extension 偽裝成外部類別的方法",
          "summary": "id: 14 開發時，我們時常使用框架或套件的 API 幫助我們完成需求。使用外部 API 時，我們常常會根據需求，使用外部物件的狀態或方法。 [https://dartpad.dev/?id=2df0ffe731895985bac15b96774feac8](https://dartpad.dev...",
          "content": "id: 14\n\n開發時，我們時常使用框架或套件的 API 幫助我們完成需求。使用外部 API 時，我們常常會根據需求，使用外部物件的狀態或方法。\n\n![it_img_14_0.png](Day%2014%20-%20%E4%BD%BF%E7%94%A8%20Extension%20%E5%81%BD%E8%A3%9D%E6%88%90%E5%A4%96%E9%83%A8%E9%A1%9E%E5%88%A5%E7%9A%84%E6%96%B9%E6%B3%95/it_img_14_0.png)\n\n[https://dartpad.dev/?id=2df0ffe731895985bac15b96774feac8](https://dartpad.dev/?id=2df0ffe731895985bac15b96774feac8)\n\n由於我們並沒有外部物件的修改權，所以當使用的行為變得複雜或者常常用到時，我們會把這些行為封裝在 Utils 或 Helper。\n\n![it_img_14_1.png](Day%2014%20-%20%E4%BD%BF%E7%94%A8%20Extension%20%E5%81%BD%E8%A3%9D%E6%88%90%E5%A4%96%E9%83%A8%E9%A1%9E%E5%88%A5%E7%9A%84%E6%96%B9%E6%B3%95/it_img_14_1.png)\n\n[https://dartpad.dev/?id=d210965ff52ec9aba9282d7764b03d4e](https://dartpad.dev/?id=d210965ff52ec9aba9282d7764b03d4e)\n\n## 迪米特法則\n\n在第一段程式碼中，我們為了取得螢幕的寬高，使用了 MediaQuery.of(context).size.width。這段程式碼使得 HomePage 除了認識 BuildContext 之外，還需知道 MediaQuery 與其內部細節，也就違反了[迪米特法則](https://zh.wikipedia.org/zh-tw/得墨忒耳定律)。如果 BuildContext 是我們自己建立的類別，為了解決問題，我們可以在 BuildContext 加入 screenWidth 與 screenHeight 方法來封裝這段操作。\n\n```dart\ncontext.screenWidth(0.5)\ncontext.screenHeight(0.5)\n```\n\n但困難的是，無論是 BuildContext 或 MediaQuery 都是 Flutter 框架提供的物件，我們無法對它進行修改。所以我們常常使用 Utils 或 Helper 來解決這類問題。在 Dart 中，我們除了可以使用 Uitls 來解決，還可以使用 Extension 來改善。\n\n## 使用 Extension\n\nDart 提供 extension 方法，讓我們能把寫自己方法，並把它掛在我們想要的類別身上，即使這個類別是外部物件，功能也跟 C# 的 Extension 如出一徹。\n\n![it_img_14_2.png](Day%2014%20-%20%E4%BD%BF%E7%94%A8%20Extension%20%E5%81%BD%E8%A3%9D%E6%88%90%E5%A4%96%E9%83%A8%E9%A1%9E%E5%88%A5%E7%9A%84%E6%96%B9%E6%B3%95/it_img_14_2.png)\n\n[https://dartpad.dev/?id=e3b8ae39e5f9ffeb99a5bccbda09a9c4](https://dartpad.dev/?id=e3b8ae39e5f9ffeb99a5bccbda09a9c4)\n\n當我們完成了 Extension 並掛在 BuildContext 身上之後，就會發現就好像直接在 BuildContext 有 screenWidth 和 screenHeight 方法，能讓程式碼變得更加簡潔，提升可讀性。\n\n![it_img_14_3.png](Day%2014%20-%20%E4%BD%BF%E7%94%A8%20Extension%20%E5%81%BD%E8%A3%9D%E6%88%90%E5%A4%96%E9%83%A8%E9%A1%9E%E5%88%A5%E7%9A%84%E6%96%B9%E6%B3%95/it_img_14_3.png)\n\n## 另一個例子\n\n我們常常使用 List 的一些操作，例如：map、where …等等，透過這些操作來達到轉換或過濾 List 的目的。在下面這段程式碼中，我們希望找出 interviewees 和 acceptedInterviewees 的交集，藉此知道誰才是最後要招聘的人。\n\n![it_img_14_4.png](Day%2014%20-%20%E4%BD%BF%E7%94%A8%20Extension%20%E5%81%BD%E8%A3%9D%E6%88%90%E5%A4%96%E9%83%A8%E9%A1%9E%E5%88%A5%E7%9A%84%E6%96%B9%E6%B3%95/it_img_14_4.png)\n\n此時我們能透過使用 extension 並給他一個適合的名字，達到簡短且有效表達的程式碼。\n\n![it_img_14_5.png](Day%2014%20-%20%E4%BD%BF%E7%94%A8%20Extension%20%E5%81%BD%E8%A3%9D%E6%88%90%E5%A4%96%E9%83%A8%E9%A1%9E%E5%88%A5%E7%9A%84%E6%96%B9%E6%B3%95/it_img_14_5.png)\n\n## 結論\n\n有很多時候，我們無可避免地必須使用外部物件來完成功能，導致許多時候，我們的程式碼寫法會受限於外部物件的 API，讓程式碼可能不那麼好讀。當我們嘗試使用 Utils 來解決時，可以先思考是否能用 Extension 來完成，提升程式碼可讀性。\n\n## 參考\n\n- 迪米特法則：[https://zh.wikipedia.org/zh-tw/得墨忒耳定律](https://zh.wikipedia.org/zh-tw/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B)\n- Dart Extension：[https://dart.dev/guides/language/extension-methods](https://dart.dev/guides/language/extension-methods)",
          "id": "3c6b414c974f457fbd51588ebab4010e",
          "filename": "Day 14 - 使用 Extension 偽裝成外部類別的方法 3c6b414c974f457fbd51588ebab4010e.md",
          "folderName": "Day 14 - 使用 Extension 偽裝成外部類別的方法",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 15 - 用樣板模式處理多平台設計",
          "summary": "note: cupertino or material id: 15 tag: 設計 Flutter 是一個可以用同一份 Codebase 建構不同平台的應用程式的框架，例如：Android、iOS … 甚至 Web、Windows 等等。每個平台的使用者行為與設計原則並非完全相同。有時候我們會為了...",
          "content": "note: cupertino or material\nid: 15\ntag: 設計\n\nFlutter 是一個可以用同一份 Codebase 建構不同平台的應用程式的框架，例如：Android、iOS … 甚至 Web、Windows 等等。每個平台的使用者行為與設計原則並非完全相同。有時候我們會為了優化個平台使用者的體驗，而在不同平台使用不同設計樣式。以下面的例子來說，Android 上常見的開關樣式與 iOS 長得十分不同。\n\n![switch-states-default.png](Day%2015%20-%20%E7%94%A8%E6%A8%A3%E6%9D%BF%E6%A8%A1%E5%BC%8F%E8%99%95%E7%90%86%E5%A4%9A%E5%B9%B3%E5%8F%B0%E8%A8%AD%E8%A8%88/switch-states-default.png)\n\n為了完成這個功能，我們在 build 方法中當前平台，來決定使用哪種設計。\n\n![it_img_16_1.png](Day%2015%20-%20%E7%94%A8%E6%A8%A3%E6%9D%BF%E6%A8%A1%E5%BC%8F%E8%99%95%E7%90%86%E5%A4%9A%E5%B9%B3%E5%8F%B0%E8%A8%AD%E8%A8%88/it_img_16_1.png)\n\n[https://dartpad.dev/?id=418d5126a81bf9a1926245a64b90c2fb](https://dartpad.dev/?id=418d5126a81bf9a1926245a64b90c2fb)\n\n## 使用 adaptive 方法\n\n在 Flutter 中，一些 Widget 提供了 adaptive 方法，讓開發者更容易實現不同樣式，例如 Switch.adaptive、Slider.adaptive、CircularProgressIndicator.adaptive 等等。使用 Widget 前，查看一下 API 文件，避免重造輪子是一個務實的做法。\n\n![it_img_16_2.png](Day%2015%20-%20%E7%94%A8%E6%A8%A3%E6%9D%BF%E6%A8%A1%E5%BC%8F%E8%99%95%E7%90%86%E5%A4%9A%E5%B9%B3%E5%8F%B0%E8%A8%AD%E8%A8%88/it_img_16_2.png)\n\n[https://dartpad.dev/?id=ca3739f1104d0eca8b2a1232b9f75bf9](https://dartpad.dev/?id=ca3739f1104d0eca8b2a1232b9f75bf9)\n\n若我們修改一下上面的例子，使用 adaptive 方法的話，就會省事許多。但並非所有情況我們都能使用 adaptive，有些時候是 Widget 本身沒有 adaptive 的設計，有些時候我們想要的情況更為複雜，此時我們只好自己判斷平台自己決定如何顯示。\n\n## 判斷平台\n\n當今天有很多地方都需要根據平台製作不同樣式時，我們可能會在許多 Widget 中，都有判斷平台的程式碼。\n\n![it_img_16_3.png](Day%2015%20-%20%E7%94%A8%E6%A8%A3%E6%9D%BF%E6%A8%A1%E5%BC%8F%E8%99%95%E7%90%86%E5%A4%9A%E5%B9%B3%E5%8F%B0%E8%A8%AD%E8%A8%88/it_img_16_3.png)\n\n[https://dartpad.dev/?id=b63ab14d0523afb6810b3c74c592abd8](https://dartpad.dev/?id=b63ab14d0523afb6810b3c74c592abd8)\n\n此時為了解決這個問題，我們可以使用[樣板模式](https://zh.wikipedia.org/zh-tw/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95)來解決，把重複的判斷邏輯到放 PlatformWidget 中，並提供 buildMaterial 和 buildCupertino 的方法讓實作決定。\n\n![it_img_16_4.png](Day%2015%20-%20%E7%94%A8%E6%A8%A3%E6%9D%BF%E6%A8%A1%E5%BC%8F%E8%99%95%E7%90%86%E5%A4%9A%E5%B9%B3%E5%8F%B0%E8%A8%AD%E8%A8%88/it_img_16_4.png)\n\n[https://dartpad.dev/?id=89ff992117cc2a0a90d0b3fb3ff032a0](https://dartpad.dev/?id=89ff992117cc2a0a90d0b3fb3ff032a0)\n\n![it_img_16_4_5.png](Day%2015%20-%20%E7%94%A8%E6%A8%A3%E6%9D%BF%E6%A8%A1%E5%BC%8F%E8%99%95%E7%90%86%E5%A4%9A%E5%B9%B3%E5%8F%B0%E8%A8%AD%E8%A8%88/it_img_16_4_5.png)\n\n當今天需要新增一個跨平台的 Widget 時，我們就能繼承這個方法，並提供不同平台的實現，就在每個跨平台 Widget 中重複判斷了。\n\n![it_img_16_5.png](Day%2015%20-%20%E7%94%A8%E6%A8%A3%E6%9D%BF%E6%A8%A1%E5%BC%8F%E8%99%95%E7%90%86%E5%A4%9A%E5%B9%B3%E5%8F%B0%E8%A8%AD%E8%A8%88/it_img_16_5.png)\n\n當我們使用 PlatformWidget 來修改上一段例子後，原本的判斷平台邏輯就不見了 MyInfoScreen 只要專注於如何實現兩個平台的設計。\n\n## 結論\n\n今天討論如何讓設計支援多個 Platform 的問題，也討論如何使用繼承與樣板模式來解決問題。但其實問題不只限於如何判斷 Platform，我們常常都會使用 if else 來協助處理流程的分岔，如何在需要的時候善用方法來解決散落各地的流程分岔是一個難題，並非總是要使用繼承來解決問題，需要讀者在開發時多多思考，並選擇最合適的方式。\n\n## 參考\n\n- 樣板模式：[https://zh.wikipedia.org/zh-tw/模板方法](https://zh.wikipedia.org/zh-tw/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95)\n\n### P.S.\n\n今天的範例，大多無法使用 Dartpad 執行，還請想要動手試試的讀者們，自行複製程式碼到自己的 IDE 上執行。\n\n方法一\n\nView\n\nbuild \n\nif\n\nreturn A\n\nelse if \n\nreturn B\n\nelse\n\nreturn C\n\n[https://medium.flutterdevs.com/factory-design-patterns-for-dart-and-flutter-a215ffa2407f](https://medium.flutterdevs.com/factory-design-patterns-for-dart-and-flutter-a215ffa2407f)\n\n方法二",
          "id": "33369d6e2d8d4aa0b4bb445f73aab915",
          "filename": "Day 15 - 用樣板模式處理多平台設計 33369d6e2d8d4aa0b4bb445f73aab915.md",
          "folderName": "Day 15 - 用樣板模式處理多平台設計",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 16- 老生常談的組合取代繼承",
          "summary": "id: 16 在昨天的例子中，我們談論到使用樣板模式來建立 PlatformWidget，並讓子類別實作 buildMaterial 與 buildCupertino，實現不同平台不同樣式的設計。但是在實際開發中，並非只有 Widget 有可能有多平台的設計，有些時候，我們的商業流程可能也會與平台相...",
          "content": "id: 16\n\n在昨天的例子中，我們談論到使用樣板模式來建立 PlatformWidget，並讓子類別實作 buildMaterial 與 buildCupertino，實現不同平台不同樣式的設計。但是在實際開發中，並非只有 Widget 有可能有多平台的設計，有些時候，我們的商業流程可能也會與平台相關。\n\n## 流程處理也分平台\n\n假設我們今天有應用程式內購需求，在 Android 與 iOS 的內購流程可能不盡相同，此時，我們會在 InAppPurchaseService 中，加入平台的判斷，讓相同的方法使用不同的流程。同時也有些畫面顯示也需要根據平台顯示不同樣式。\n\n![it_img_17_0.png](Day%2016-%20%E8%80%81%E7%94%9F%E5%B8%B8%E8%AB%87%E7%9A%84%E7%B5%84%E5%90%88%E5%8F%96%E4%BB%A3%E7%B9%BC%E6%89%BF/it_img_17_0.png)\n\n[https://dartpad.dev/?id=26b2c1158741a8c7f6e4b04acdc112cf](https://dartpad.dev/?id=26b2c1158741a8c7f6e4b04acdc112cf)\n\n在上面這段例子中，我們可以發現裡頭的平台判斷，與昨天 PlatformWidget 中的判斷一致，但此時我們卻無法繼承 PlatformWidget 來重複利用這段程式碼。原因想必聰明的讀者一定知道，因為我們的 InAppService 並不是一個 Widget，讓他繼承 PlatformWidget 顯然不合理。那我們如何解決這個問題呢？\n\n## 使用組合取代繼承\n\n所幸 Dart 除了繼承之外，還有提供 [Mixin](https://dart.dev/guides/language/language-tour#adding-features-to-a-class-mixins)，讓我們可透過組合其他類別的方式，來利用相同的邏輯。以下就讓我們使用 Mixin 建立一個判斷平台的方法吧。\n\n![it_img_16_6.png](Day%2016-%20%E8%80%81%E7%94%9F%E5%B8%B8%E8%AB%87%E7%9A%84%E7%B5%84%E5%90%88%E5%8F%96%E4%BB%A3%E7%B9%BC%E6%89%BF/it_img_16_6.png)\n\n[https://dartpad.dev/?id=22ecb1510e33f5cf84ef4f59071884aa](https://dartpad.dev/?id=22ecb1510e33f5cf84ef4f59071884aa)\n\n透過使用 Mixin，我們利用組合的方式，將判斷平台的邏輯使用在原本的 HomeScreen 和非 Widget 的類別，以下面的例子來說，InAppPurchaseService 也能使用 handleByPlatform 處理不同平台的購買流程。\n\n![it_img_17_2.png](Day%2016-%20%E8%80%81%E7%94%9F%E5%B8%B8%E8%AB%87%E7%9A%84%E7%B5%84%E5%90%88%E5%8F%96%E4%BB%A3%E7%B9%BC%E6%89%BF/it_img_17_2.png)\n\n相比於繼承來說，組合要更加來的有彈性。在 Flutter 中，Widget 有時候可能不是繼承 StatelessWidget，此時原本設計的 PlatformWidget 就變得不那麼實用。相反的，如果使用組合的方式，我們就能把判斷平台的邏輯在需要的地方使用，而不會被繼承所受限。\n\n## 用 Widget 來組合\n\n在昨天的例子中，我們讓 MyInfoScreen 繼承 PlatformWidget，並實作 buildMaterial 和 buildCupertino，解決達到不同平台不同樣式的問題。但是其實這個問題，同樣可透過組合 Widget 的方式解決。讓我們修改一下昨天的例子，看看會有什麼不同。\n\n![it_img_17_3.png](Day%2016-%20%E8%80%81%E7%94%9F%E5%B8%B8%E8%AB%87%E7%9A%84%E7%B5%84%E5%90%88%E5%8F%96%E4%BB%A3%E7%B9%BC%E6%89%BF/it_img_17_3.png)\n\n[https://dartpad.dev/?id=fb03fdb200b11a72c437c0436b58c111](https://dartpad.dev/?id=fb03fdb200b11a72c437c0436b58c111)\n\n若我們今天只有畫面需要判斷，單純使用組合 Widget 的方式，也能達到控制流程的效果，並不是一定要抽成 Mixin 或使用繼承。\n\n## 結論\n\n大多數時候，當我們只想共用的時候，可已先嘗試使用組合法方式解決問題。運用組合，每個物件可以任意挑選自己想要的元件或模組來重用。同樣的不同平台不同畫面的問題，我們同樣可以透過組合方式解決，讓設計可以更有彈性。\n\n## 參考\n\n- 組合取代繼承：[https://en.wikipedia.org/wiki/Composition_over_inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance)\n- Add features to a class：[https://dart.dev/guides/language/language-tour#adding-features-to-a-class-mixins](https://dart.dev/guides/language/language-tour#adding-features-to-a-class-mixins)",
          "id": "3db3dc9447c04372bca401b1b25e612d",
          "filename": "Day 16- 老生常談的組合取代繼承 3db3dc9447c04372bca401b1b25e612d.md",
          "folderName": "Day 16- 老生常談的組合取代繼承",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 17 - 使用 Value Object 的眉眉角角",
          "summary": "id: 17 Dart 是強型別語言，我們會宣告各式各樣的物件，來幫助我們完成功能。所有物件最頂層雖然是 [Object](https://api.flutter.dev/flutter/dart-core/Object-class.html)，但實際上使用時，卻能分出許多不同的物件，有 Widge...",
          "content": "id: 17\n\nDart 是強型別語言，我們會宣告各式各樣的物件，來幫助我們完成功能。所有物件最頂層雖然是 [Object](https://api.flutter.dev/flutter/dart-core/Object-class.html)，但實際上使用時，卻能分出許多不同的物件，有 Widget、有 Controller，有些負責打 API，有些負責處理流程。在這之中，我們常常使用到其中之一種的就是 Value Object，讓不同物件之間可以傳遞資料，一個經典的情境就是，當我們打 Web API 取回 json 資料後，我們會把它轉成一個相對應的 Value Object，以便畫面顯示或者使用者操作功能。\n\n```dart\nfinal response = await dio.get(\"my/api\");\nreturn User.fromJson(response.data);\n```\n\n在上面的例子中，response.data 是個 dynamic 物件，我們會把 dynamic 物件轉成 User 物件。\n\n## 使用強型別\n\n大多數時候，我們用在外部 API 取回資料物件時，會把它轉成強型別，能讓我們享受幾個好處：\n\n1. 讓我們更清楚每個物件中每個成員的型別，幫助我們正確使用物件成員，也讓我們能在編譯期間更快的發現問題，不必等到實際執行才發現錯誤。\n2. 我們也可以在 Value Object 建立一些方法，讓職責更加內聚。\n\n![it_img_18_0_1.png](Day%2017%20-%20%E4%BD%BF%E7%94%A8%20Value%20Object%20%E7%9A%84%E7%9C%89%E7%9C%89%E8%A7%92%E8%A7%92/it_img_18_0_1.png)\n\n## 實現 fromJson\n\n雖然 Dart 有反射功能，但是 Flutter 由於因為一些原因，在 Flutter 禁用反射。所以當我們取回 http reposone 時，我們必須自己針對每個物件實現 fromJson。\n\n![it_img_18_0.png](Day%2017%20-%20%E4%BD%BF%E7%94%A8%20Value%20Object%20%E7%9A%84%E7%9C%89%E7%9C%89%E8%A7%92%E8%A7%92/it_img_18_0.png)\n\n[https://dartpad.dev/?id=71f5603a74f415f800339d3af816a458](https://dartpad.dev/?id=71f5603a74f415f800339d3af816a458)\n\n當我們的程式需要常常與不同 API 互動時，我們會產生大量的 fromJson 程式碼，每個物件中的 fromJson 的細節不同，但整體的行為都是把 dynamic 轉成特定類別。Flutter 雖然沒有反射，但是我們還是有一些辦法來讓我們不用每次都寫一次 fromJson。\n\n## 產生 Json 序列化程式碼\n\nGoogle 在 [pub.dev](http://pub.dev) 中提供了 json_serializable 套件，讓我們可以自動產生 Json 序列化的程式碼。當我們在程式中引用 json_serializable 與 build_runner 之後，然後在 User 類別上加上 @JsonSerializable ，最後執行 build_runner。\n\n![it_Img_18_1.png](Day%2017%20-%20%E4%BD%BF%E7%94%A8%20Value%20Object%20%E7%9A%84%E7%9C%89%E7%9C%89%E8%A7%92%E8%A7%92/it_Img_18_1.png)\n\n[https://dartpad.dev/?id=8556bc9249cbfd8c31d291170411409d](https://dartpad.dev/?id=8556bc9249cbfd8c31d291170411409d)\n\n```bash\nflutter pub run build_runner\n```\n\n最後我們可以在檔案中看到自動產生的 user.g.dart 程式碼。\n\n![it_img_18_2.png](Day%2017%20-%20%E4%BD%BF%E7%94%A8%20Value%20Object%20%E7%9A%84%E7%9C%89%E7%9C%89%E8%A7%92%E8%A7%92/it_img_18_2.png)\n\n[https://dartpad.dev/?id=1b68fbc60c6f0e4494632cc8f36db818](https://dartpad.dev/?id=1b68fbc60c6f0e4494632cc8f36db818)\n\n## 使用 freezed\n\n除此了使用 json_serializable 之外，我們也可以選擇使用 [freezed](https://pub.dev/packages/freezed)。freezed 除了能幫我們自動產生 json 序列化的方法之外，也能幫我們產生 Value Object 也常常需要複寫的方法，例如用來比較兩個物件是否相同的 == 運算子，或者是複製並修改的 copyWith 方法。\n\n![it_img_18_3.png](Day%2017%20-%20%E4%BD%BF%E7%94%A8%20Value%20Object%20%E7%9A%84%E7%9C%89%E7%9C%89%E8%A7%92%E8%A7%92/it_img_18_3.png)\n\n[https://dartpad.dev/?id=0265a639151c710f3b3f69836dd9ce77](https://dartpad.dev/?id=0265a639151c710f3b3f69836dd9ce77)\n\n[https://dartpad.dev/?id=32f3dbcc5819c8387b54672562ef0da3](https://dartpad.dev/?id=32f3dbcc5819c8387b54672562ef0da3)\n\n## 避免包山包海的物件\n\n有些時候，我們可能會在兩個頁面使用相同的 API，拿回相同的物件，但用不同的資料來處理每個頁面的畫面或流程。在下面的例子中，UserInfoScreen 與 VipProductListScreen 都會呼叫 User API 取回 User 物件，兩個頁面都分別只使用部分 User 的成員。\n\n![it_img_18_4.png](Day%2017%20-%20%E4%BD%BF%E7%94%A8%20Value%20Object%20%E7%9A%84%E7%9C%89%E7%9C%89%E8%A7%92%E8%A7%92/it_img_18_4.png)\n\n![it_img_18_5.png](Day%2017%20-%20%E4%BD%BF%E7%94%A8%20Value%20Object%20%E7%9A%84%E7%9C%89%E7%9C%89%E8%A7%92%E8%A7%92/it_img_18_5.png)\n\n[https://dartpad.dev/?id=e4e5838f7c188cb545af329f618f8973](https://dartpad.dev/?id=e4e5838f7c188cb545af329f618f8973)\n\n在這上面的例子中，假設今天我們建立了一個新的 API，讓我們可以直接呼叫取得 User 的 isVip，此時當我們想要替換原本 API 時，需要改動的範圍就比較大，因為 VipProductListScreen 直接引用了 User。假設今天 VipProductListScreen 只從 RemoteApi 拿回來只有 isVip，而不是整個 User 物件，那我們就能更容易抽換實作。\n\n![it_img_18_6.png](Day%2017%20-%20%E4%BD%BF%E7%94%A8%20Value%20Object%20%E7%9A%84%E7%9C%89%E7%9C%89%E8%A7%92%E8%A7%92/it_img_18_6.png)\n\n[https://dartpad.dev/?id=8f96dfd25748069648e6aba58bb12fe8](https://dartpad.dev/?id=8f96dfd25748069648e6aba58bb12fe8)\n\n雖然 Value Object 並不繼承任何介面，但讓所有地方都直接使用 User，也是不太符合介面隔離原則的概念。\n\n> 客戶不應被迫使用對其而言無用的方法或功能。\n> \n\n## 結論\n\n在開發的過程中，我們常常會設計各式各樣的 Value Object，如何善用工具節省開發時間，是一項直得研究的課題。雖然 Value Object 很容易使用，但是開發時也要思考一下，是否當前的 Value Object 是最適合的設計，持續的檢視與改善，讓程式永遠維持在一個容易維護的狀態。\n\n## 參考\n\n- JSON and serialization：[https://docs.flutter.dev/development/data-and-backend/json](https://docs.flutter.dev/development/data-and-backend/json)\n- json_serializable：[https://pub.dev/packages/json_serializable](https://pub.dev/packages/json_serializable)\n- 介面隔離：[https://zh.wikipedia.org/zh-tw/接口隔离原则](https://zh.wikipedia.org/zh-tw/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99)\n- Flutter 反射的相關討論：[https://github.com/flutter/flutter/issues/1150](https://github.com/flutter/flutter/issues/1150)",
          "id": "5f5dcf4dc7914db1a501042341fdd6f6",
          "filename": "Day 17 - 使用 Value Object 的眉眉角角 5f5dcf4dc7914db1a501042341fdd6f6.md",
          "folderName": "Day 17 - 使用 Value Object 的眉眉角角",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 18 - 事不關己，高高”掛“起",
          "summary": "id: 18 在開發 Flutter 的過程中，我們常常會使用到各式各樣的 Controller，從 AnimationController、TabController、TextEditingController …等。在使用這些 Controller 時，我們通常需要搭配使用 StatefulWi...",
          "content": "id: 18\n\n在開發 Flutter 的過程中，我們常常會使用到各式各樣的 Controller，從 AnimationController、TabController、TextEditingController …等。在使用這些 Controller 時，我們通常需要搭配使用 StatefulWidget 使用，避免畫面重 build 時，遺失當下的狀態。\n\n![it_img_15_1.png](Day%2018%20-%20%E4%BA%8B%E4%B8%8D%E9%97%9C%E5%B7%B1%EF%BC%8C%E9%AB%98%E9%AB%98%E2%80%9D%E6%8E%9B%E2%80%9C%E8%B5%B7/it_img_15_1.png)\n\n[https://dartpad.dev/?id=453c74adf88bc82728e5e05dd88a2927](https://dartpad.dev/?id=453c74adf88bc82728e5e05dd88a2927)\n\n在上面的例子中，我們使用 AnimationController 來幫助我們實現動畫，Controller 中會保存動畫當前的進度，並透過 AnimatedBuilder 即時更新動畫。\n\n## Controller 們的樣板程式碼\n\n在上面的例子中，我們在 initState 與 dispose 中處理 controller 生命週期的開始與終結。當我們每次需要這些 Controller 時，我們都得初始化與終止 Controller，這些程式碼不斷的重複在每個需要 Controller 的場景。\n\n```dart\n@override\nvoid initState() {\n  super.initState();\n  // init controller\n}\n\n@override\nvoid dispose() {\n  // dispose controller\n  super.dispose();\n}\n```\n\n為了解決這些煩人的初始與終止問題，我們可以嘗試使用 flutter_hook 套件。\n\n## 使用 Hook\n\n當我們引入 flutter_hook 後，讓 Widget 繼承 HookWidget，我們就能在 build 方法中，直接使用 useAnimationController 取得 Controller 並使用，無需擔心 controller 的初始化與終止。\n\n![it_img_15_2.png](Day%2018%20-%20%E4%BA%8B%E4%B8%8D%E9%97%9C%E5%B7%B1%EF%BC%8C%E9%AB%98%E9%AB%98%E2%80%9D%E6%8E%9B%E2%80%9C%E8%B5%B7/it_img_15_2.png)\n\n[https://dartpad.dev/?id=2059f9f3c0e203703b6ff8e93259995f](https://dartpad.dev/?id=2059f9f3c0e203703b6ff8e93259995f)\n\n透過 Hook 讓套件幫助我們管理 controller 的生命週期，開發上只要專注於如何與 controller 互動即可。能簡化程式碼，讓程式碼更加簡潔，畢竟維護的程式碼越少，我們的工作就越輕鬆。\n\n## 各式 useController\n\n在 flutter_hook 中，除了 useAnimationController 之外，還有其他 Controller 可以使用，例如：當我們想使用 TabBar 與 TabBarView 時，少不了要使用 useTabController 來連動這兩個 Widget。\n\n![it_img_15_3.png](Day%2018%20-%20%E4%BA%8B%E4%B8%8D%E9%97%9C%E5%B7%B1%EF%BC%8C%E9%AB%98%E9%AB%98%E2%80%9D%E6%8E%9B%E2%80%9C%E8%B5%B7/it_img_15_3.png)\n\n[https://dartpad.dev/?id=ab7fb38e4e0b6ba3646a7255085ad4dd](https://dartpad.dev/?id=ab7fb38e4e0b6ba3646a7255085ad4dd)\n\n## 還有 useState\n\n除此之外，由於 flutter_hook 的設計概念借鑒了 React Hook，所以我們也能在 flutter_hook 中找到像是 useState、useEffect 等 API。當我們使用了 flutter_hook 時，會發現由於我們繼承了 HookWidget，而不是 StatefulWidget，此時就需要改用 useState 來管理狀態了。\n\n![it_img_15_4.png](Day%2018%20-%20%E4%BA%8B%E4%B8%8D%E9%97%9C%E5%B7%B1%EF%BC%8C%E9%AB%98%E9%AB%98%E2%80%9D%E6%8E%9B%E2%80%9C%E8%B5%B7/it_img_15_4.png)\n\n[https://dartpad.dev/?id=b2e265303bfe73fe95d7ca7dd2a5548e](https://dartpad.dev/?id=b2e265303bfe73fe95d7ca7dd2a5548e)\n\n在上面的例子中，我們就把經典的 counter 範例，改用 flutter_hook 實現，在 useState 放入 counter 的初始值，當按下 ＋ 按鈕後，數字就會不停的往上加。即時 build 方法不斷被執行，也能 counter 的狀態也不會被重設。\n\n## 利用 Ｍixin 抽取共用\n\nMixin 除了能讓我們共用方法之外，也能共用繼承而來的方法。在下面的例子中，我們有一個 HpPrinter 繼承了 Printer 並使用了 PrinterMixin，當我們呼叫 printDoc 時，程式會先呼叫 PrinterMixin 中的 printDoc，然後才呼叫 HpPrinter 中的 printDoc。\n\n![it_img_15_5.png](Day%2018%20-%20%E4%BA%8B%E4%B8%8D%E9%97%9C%E5%B7%B1%EF%BC%8C%E9%AB%98%E9%AB%98%E2%80%9D%E6%8E%9B%E2%80%9C%E8%B5%B7/it_img_15_5.png)\n\n[https://dartpad.dev/?id=425f36a353fb1f47849faff22edce7e8](https://dartpad.dev/?id=425f36a353fb1f47849faff22edce7e8)\n\n了解 Mixin 的運作流程之後，我們就能使用同樣的方式來抽取一個控制 Controller 生命週期的 Mixin 了。在下面就讓我們修改 TabController 的例子，改成使用客製的 Mixin，讓 Mixin 來控制 controller 的生命週期。\n\n![it_img_15_6.png](Day%2018%20-%20%E4%BA%8B%E4%B8%8D%E9%97%9C%E5%B7%B1%EF%BC%8C%E9%AB%98%E9%AB%98%E2%80%9D%E6%8E%9B%E2%80%9C%E8%B5%B7/it_img_15_6.png)\n\n [https://dartpad.dev/?id=d697ef651a67d59eed739d56595613eb](https://dartpad.dev/?id=d697ef651a67d59eed739d56595613eb)\n\n## 結論\n\n如果熟悉 React Hook 的讀者，想入門 Flutter 的話，在了解了 Flutter 基本概念之後，可以考慮使用 flutter_hook 來幫助開發。透過 useState、useController …等 API，簡化程式碼的寫法，讓程式碼更好讀易懂。\n\n## 參考\n\n- Flutter Hook：[https://pub.dev/packages/flutter_hooks](https://pub.dev/packages/flutter_hooks)",
          "id": "bfae496743b34f80be44dd35d754e00a",
          "filename": "Day 18 - 事不關己，高高”掛“起 bfae496743b34f80be44dd35d754e00a.md",
          "folderName": "Day 18 - 事不關己，高高”掛“起",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 19 - 不好好讀文件，會踩好多坑",
          "summary": "id: 19 在開發 Flutter 過程中，總是會需要使用到各種不同的 Widget 或 API，名稱與使用方式也十分易懂。但是總在開發的過程中，才發現有許多時候，Widget 的運作行為與我們想像的不太一樣。直到我們去看了原始碼或者文件，才發現是自己腦補了他的運作原理。今天就來聊聊幾個 Flut...",
          "content": "id: 19\n\n在開發 Flutter 過程中，總是會需要使用到各種不同的 Widget 或 API，名稱與使用方式也十分易懂。但是總在開發的過程中，才發現有許多時候，Widget 的運作行為與我們想像的不太一樣。直到我們去看了原始碼或者文件，才發現是自己腦補了他的運作原理。今天就來聊聊幾個 Flutter 可能與你想的不太一樣的地方。\n\n## Sort 方法是否 stable ?\n\n我們常常為了畫面顯示，而排序各種資料，為了完成功能，我們可能先看看 list 或從 stackoverflow 找尋如何排序陣列，也如期地找到 List 身上有個 sort 方法可排序。\n\n![it_img_21_1.png](Day%2019%20-%20%E4%B8%8D%E5%A5%BD%E5%A5%BD%E8%AE%80%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9C%83%E8%B8%A9%E5%A5%BD%E5%A4%9A%E5%9D%91/it_img_21_1.png)\n\n[https://dartpad.dev/?id=985f6b2339e5e81ecf32986e18f626e6](https://dartpad.dev/?id=985f6b2339e5e81ecf32986e18f626e6)\n\n但有些時候，我們設定排序的條件時，會想讓資料先以條件 A 排序，接著再以條件 B 排序，此時我們會連續呼叫兩個 sort 方法，來得到我們想要的結果。\n\n![it_img_21_2.png](Day%2019%20-%20%E4%B8%8D%E5%A5%BD%E5%A5%BD%E8%AE%80%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9C%83%E8%B8%A9%E5%A5%BD%E5%A4%9A%E5%9D%91/it_img_21_2.png)\n\n[https://dartpad.dev/?id=b21a85b82cd0e2d02b951411f0151efd](https://dartpad.dev/?id=b21a85b82cd0e2d02b951411f0151efd)\n\n當我們完成需求中，也進行了單元測試，自然覺得一切都沒問題。可是呢，忽然有一天使用者回報了一個問題，說畫面排序不太對，我們回頭看程式碼，卻也無法發現問題所在。明明單元測試也通過了，測試環境也通過了，但正式環境卻還是出了問題。\n\n![it_img_21_3.png](Day%2019%20-%20%E4%B8%8D%E5%A5%BD%E5%A5%BD%E8%AE%80%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9C%83%E8%B8%A9%E5%A5%BD%E5%A4%9A%E5%9D%91/it_img_21_3.png)\n\n[https://dartpad.dev/?id=1808a94cf31bc1c96a437c66466966c0](https://dartpad.dev/?id=1808a94cf31bc1c96a437c66466966c0)\n\n原來在[官方文件](https://api.flutter.dev/flutter/dart-core/List/sort.html)有提到 List 的 sort 並不是 stable 的排序方法，導致使得我們第二個 sort 有可能打亂第一個 sort 的結果，使得排序結果不如預期。而如果我們進一步去看原始碼的話，就會發現原來只有在陣列長度超過一定長度時，sort 方法才會使用 unstable 的 Quick Sort，這也是為什麼我們的單元測試會失效。\n\n![it_img_21_4.png](Day%2019%20-%20%E4%B8%8D%E5%A5%BD%E5%A5%BD%E8%AE%80%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9C%83%E8%B8%A9%E5%A5%BD%E5%A4%9A%E5%9D%91/it_img_21_4.png)\n\n## Container 忽大忽小\n\nContainer 是我們開發 Flutter 中最常使用到的 Widget 之一，我們常常使用它來設定背景顏色，設定 Padding 或 Margin。雖然 Container 非常容易使用，但是好用的背後，卻也隱藏了許多行為。如果開發者沒有仔細閱讀文件的話，可能有時候會對於 Container 的大小有點疑惑，讓我們來看看一個例子。\n\n![it_img_21_5.png](Day%2019%20-%20%E4%B8%8D%E5%A5%BD%E5%A5%BD%E8%AE%80%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9C%83%E8%B8%A9%E5%A5%BD%E5%A4%9A%E5%9D%91/it_img_21_5.png)\n\n[https://dartpad.dev/?id=4b422ab818d97c6a3de68c8347ed0c72](https://dartpad.dev/?id=4b422ab818d97c6a3de68c8347ed0c72)\n\n在上面的例子中，我們給了 Container 綠色背景與 Padding，並把一個 Button 放在裡頭，Container 的大小我們也能從畫面上看到，就只比 Button 大一些。讓我們再來看看另外一個例子。\n\n![it_img_21_6.png](Day%2019%20-%20%E4%B8%8D%E5%A5%BD%E5%A5%BD%E8%AE%80%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9C%83%E8%B8%A9%E5%A5%BD%E5%A4%9A%E5%9D%91/it_img_21_6.png)\n\n[https://dartpad.dev/?id=296be610230a63ea3e5fdcd9391f93da](https://dartpad.dev/?id=296be610230a63ea3e5fdcd9391f93da)\n\n在上面這個例子中，我們加了一個 Alignment 之後，Container 的大小竟然擴大到整個螢幕，此時如果對 Container 的行為不熟悉的開發者，可能會有點摸不著腦袋，不知道為什麼會變成這樣。其實在 [Container 的文件](https://api.flutter.dev/flutter/widgets/Container-class.html)中就有提到\n\n> If the widget has an [alignment](https://api.flutter.dev/flutter/widgets/Container/alignment.html), and the parent provides unbounded constraints, then the [Container](https://api.flutter.dev/flutter/widgets/Container-class.html) tries to size itself around the child.\n> \n\n## 閱讀文件\n\nFlutter 是一個 UI 框架，大多時候我們會與 Widget 互動，除了 Container 之外，許多 Layout 型的 Widget，例如 Stack、Scaffold、ListView …等等，都有許多可能大家比較少注意到的行為。如果我們沒有仔細閱讀文件，就開始寫程式，就會很難從使用過程中了解其行為。很多時候，身為一個工程師，我們喜歡動手試試而不是看文件，卻也常常忽略一些問題，或不自覺地以過往經驗腦補了外部 API 的行為。只有當線上 Bug 發生時，才回頭看原始碼或者文件，然後才恍然大悟。\n\n## 結論\n\n我們在開發程式時，許多時候都會用到各式各樣的外部 API，只有正確了解外部 API 如何運作，有什麼細節，我們才能讓我們更了解我的程式。當發生問題時，才不會手忙腳亂，或者是使用錯誤的方法來解決問題，從而隱藏真正的問題。\n\n## 參考\n\nContainer：[https://api.flutter.dev/flutter/widgets/Container-class.html](https://api.flutter.dev/flutter/widgets/Container-class.html)\n\nSort：[https://api.flutter.dev/flutter/dart-core/List/sort.html](https://api.flutter.dev/flutter/dart-core/List/sort.html)",
          "id": "af79a28b617b4b3ea980f81f65c81177",
          "filename": "Day 19 - 不好好讀文件，會踩好多坑 af79a28b617b4b3ea980f81f65c81177.md",
          "folderName": "Day 19 - 不好好讀文件，會踩好多坑",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 20 - 讓設計與程式碼統一",
          "summary": "id: 20 在開發 App 的過程中，我們會有許多常數，例如圖片位置、文字樣式、元件顏色等等。如果我們把所有顏色，樣式或路徑都寫死在程式中，就會造成後續修改十分不方便，也降低得了程式碼的可讀性。 在開發應用程式的過程中，我會從設計手中拿到設計稿，其中標注了各式各樣的字型大小與顏色樣式，我們把依照設...",
          "content": "id: 20\n\n在開發 App 的過程中，我們會有許多常數，例如圖片位置、文字樣式、元件顏色等等。如果我們把所有顏色，樣式或路徑都寫死在程式中，就會造成後續修改十分不方便，也降低得了程式碼的可讀性。\n\n## 在程式中 Hard Code 設計\n\n在開發應用程式的過程中，我會從設計手中拿到設計稿，其中標注了各式各樣的字型大小與顏色樣式，我們把依照設計稿，把顏色與樣式帶入程式碼中，最終完成畫面。\n\n![it_img_23_2.png](Day%2020%20-%20%E8%AE%93%E8%A8%AD%E8%A8%88%E8%88%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%B5%B1%E4%B8%80/it_img_23_2.png)\n\n[https://dartpad.dev/?id=ac17d00aad388ac473e8698d81b923c0](https://dartpad.dev/?id=ac17d00aad388ac473e8698d81b923c0)\n\n大多時候，我們會在同一個應用程式中，維持相似的設計，以提供使用者一致的體驗。所以相同的字體、樣式、或顏色會重複的出現在不同畫面中。若我們在每個地方再複製一次，當今天想為應用程式更換設計時，就會需要到每個實作的地方修改。\n\n除此之外，我們也常常會使用到圖片，無碖是各式各樣的 Icon 或者是背景圖，免不了的一定會使用圖片。\n\n![it_img_23_1.png](Day%2020%20-%20%E8%AE%93%E8%A8%AD%E8%A8%88%E8%88%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%B5%B1%E4%B8%80/it_img_23_1.png)\n\n如果我們直接在程式碼中使用路徑，容易造成幾個問題：\n\n1. 當圖片名稱異動，我們必須到每個使用到的地方修改。\n2. 容易因為 typo，造成圖片找不到。\n\n## 為樣式賦予意義\n\n為了解決這些問題，我們可以把這些共用的設計樣式，抽取一個共同的樣式清單，並為每一個樣式給予一個符合設計意義的名稱。\n\n![it_img_23_3.png](Day%2020%20-%20%E8%AE%93%E8%A8%AD%E8%A8%88%E8%88%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%B5%B1%E4%B8%80/it_img_23_3.png)\n\n[https://dartpad.dev/?id=63908ad88cb4a8fb200b6fce1482bd13](https://dartpad.dev/?id=63908ad88cb4a8fb200b6fce1482bd13)\n\n當實際使用時，除了共用這些相同意義的設計之外，也能讓程式碼與設計稿有更直觀連結。\n\n![it_img_23_4.png](Day%2020%20-%20%E8%AE%93%E8%A8%AD%E8%A8%88%E8%88%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%B5%B1%E4%B8%80/it_img_23_4.png)\n\n甚至我們也可以使用先 extension 簡化寫法。\n\n![it_img_23_5.png](Day%2020%20-%20%E8%AE%93%E8%A8%AD%E8%A8%88%E8%88%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%B5%B1%E4%B8%80/it_img_23_5.png)\n\n![it_img_23_6.png](Day%2020%20-%20%E8%AE%93%E8%A8%AD%E8%A8%88%E8%88%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%B5%B1%E4%B8%80/it_img_23_6.png)\n\n[https://dartpad.dev/?id=2964d51eb07b99ee4ee673c28838b911](https://dartpad.dev/?id=2964d51eb07b99ee4ee673c28838b911)\n\n## 使用 flutter_gen 簡化圖片顯示\n\n當我們處理完文字樣式與顏色之後，我們還可以使用 [flutter_gen](https://pub.dev/packages/flutter_gen) 簡化顯示圖片的程式碼。當我們按照指示引用 flutter_gen 與 build_runner 之後，執行 build_runner 就能幫我們產生程式碼。\n\n![it_img_23_7.png](Day%2020%20-%20%E8%AE%93%E8%A8%AD%E8%A8%88%E8%88%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%B5%B1%E4%B8%80/it_img_23_7.png)\n\n[https://dartpad.dev/?id=f6a5b8263d0db41e8487f071dec59741](https://dartpad.dev/?id=f6a5b8263d0db41e8487f071dec59741)\n\n而使用實際只用只要呼叫 Assets 的程式碼，就能像是使用 Image.asset() 一樣，在畫面上顯示圖片。\n\n```dart\nAssets.icons.addFriend.image(width: 20)\n```\n\n使用程式碼來選擇圖片，有一個很大的優點就是，寫程式時搭配 IDE 的功能，讓我們按最少的按鍵，以最有效率的方式寫完我們想要的程式碼。\n\n## 我們得到了什麼？\n\n當我們做完了上述工作，把樣式、顏色、圖片等等資源，抽成常數之後，我們程式碼有了兩個主要好處。\n\n1. 提升可讀性：當我們抽取常數之後，並為其使用一個與設計吻合的名稱之後，閱讀到這段程式碼時，就再也不是看到如何實作，而是從名稱了解到這是什麼設計。\n2. 提升可維護性：當我們想更換設計時，只要更換常數的實作，所有相同樣式的地方也一併更換，讓程式碼更好修改。\n\n## 動態切換設計\n\n在上面的例子中，我們把設計放在一個靜態類別中，在渲染畫面時，直接飲用這些靜態變數。如果樣式在程式執行時不會動態切換，那直接引用這個靜態的設計類別並不會有太大的問題。但真實的情況是，假設我們想為我們的 App 製作 Light/Dark 模式，並讓使用者可以動態切換。此時，由於我們的 Widget 直接引用了靜態類別，使得我們難以動態改變樣式。為了解決這個問題，我們可以使用 [ThemeExtension](https://api.flutter.dev/flutter/material/ThemeExtension-class.html) 來解決問題。\n\n![it_img_23_8.png](Day%2020%20-%20%E8%AE%93%E8%A8%AD%E8%A8%88%E8%88%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%B5%B1%E4%B8%80/it_img_23_8.png)\n\n[https://dartpad.dev/?id=15705a2e37befec46ff388113c29bd23](https://dartpad.dev/?id=15705a2e37befec46ff388113c29bd23)\n\n使用時，就能透過 Theme.of(context).extension() 動態取得當前的樣式。當我們修改頂層樣式，從 light 切換成 dark 時，Flutter 也重新渲染畫面，讓這些樣式可以再次取得更改之後的 dark 樣式。\n\n![it_img_23_9.png](Day%2020%20-%20%E8%AE%93%E8%A8%AD%E8%A8%88%E8%88%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%B5%B1%E4%B8%80/it_img_23_9.png)\n\n使用 ThemeExtension 取代靜態樣式類別，除了能保有自定義的樣式設計，也能讓我們程式具備動態切換樣式的能力。\n\n## 結論\n\n在開發客端應用程式時，設計師往往都會使用一些設計原則，並套用在設計稿上。當我們開發時，也把相同的設計原則直接用程式碼實作，這樣能讓程式碼與設計有一致的語言。未來當設計變化時，程式也能直接跟著設計調整，而不用辛苦一個一個地方修改。\n\n## 參考\n\n- flutter_gen：[https://pub.dev/packages/flutter_gen](https://pub.dev/packages/flutter_gen)",
          "id": "b92ec84b0cfc4e8581cd590951e0f84b",
          "filename": "Day 20 - 讓設計與程式碼統一 b92ec84b0cfc4e8581cd590951e0f84b.md",
          "folderName": "Day 20 - 讓設計與程式碼統一",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 21 - 避免讓資料源綁架程式",
          "summary": "note: 不要讓外部依賴綁架你 id: 21 tag: 設計 不管是前端或是後端，我們總有許許多多時候會需要存取外部資源，以 App 來說，大多時候我們都會需要呼叫外部 API，獲取當前頁面所需要的資料。外部 API 的種類則有許多形式，例如最常見的 Web API、各種 Firebase 套件提...",
          "content": "note: 不要讓外部依賴綁架你\nid: 21\ntag: 設計\n\n不管是前端或是後端，我們總有許許多多時候會需要存取外部資源，以 App 來說，大多時候我們都會需要呼叫外部 API，獲取當前頁面所需要的資料。外部 API 的種類則有許多形式，例如最常見的 Web API、各種 Firebase 套件提供的方法，或者是 sqlite。\n\n## 舉個例子\n\n假設我們正在寫一個顯示最新新聞的 App，在 App 被打開時，App 會使用後端 API 撈取最新幾筆的新聞，並顯示在畫面上。\n\n![it_img_19_1.png](Day%2021%20-%20%E9%81%BF%E5%85%8D%E8%AE%93%E8%B3%87%E6%96%99%E6%BA%90%E7%B6%81%E6%9E%B6%E7%A8%8B%E5%BC%8F/it_img_19_1.png)\n\n[https://dartpad.dev/?id=f4078ffd93946af325b8d30ce6fa2584](https://dartpad.dev/?id=f4078ffd93946af325b8d30ce6fa2584)\n\n上面的程式碼乍看之下好像沒什麼問題，但是仔細想想就會發現，這段程式違反了 DIP 原則。我們讀取資料的邏輯緊緊地與呼叫外部 API 程式碼綁在一起。其中造成許多問題，而其中一個問題是，當我們想要改成資料從 sqlite 讀取時，由於 sqlite 類別有著不同的方法，我們就會被迫修改 initState 中的呼叫。\n\n![it_img_19_2.png](Day%2021%20-%20%E9%81%BF%E5%85%8D%E8%AE%93%E8%B3%87%E6%96%99%E6%BA%90%E7%B6%81%E6%9E%B6%E7%A8%8B%E5%BC%8F/it_img_19_2.png)\n\n與第一段程式碼相比，我們不只把 HttpDataSource 換成了 SqliteDataSource，也把呼叫的方法換成 queryNews 了。\n\n## 用 Repository 改善\n\n為了解決這個問題，我們可以引入 [Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html) 來處理。定義一個 NewsRepository 介面，在介面中宣告存取資料的方法，並透過給定實作類別，決定到底是要打 Web API 拿資料，或者是從 Sqlite 讀取。\n\n> Repository：*Mediates between the domain and data mapping layers using a collection-like interface for accessing domain objects.*\n> \n\n![it_img_19_3.png](Day%2021%20-%20%E9%81%BF%E5%85%8D%E8%AE%93%E8%B3%87%E6%96%99%E6%BA%90%E7%B6%81%E6%9E%B6%E7%A8%8B%E5%BC%8F/it_img_19_3.png)\n\n[https://dartpad.dev/?id=31cada35220319817d6a66e06ab6a926](https://dartpad.dev/?id=31cada35220319817d6a66e06ab6a926)\n\n透過實作這個模式，當我們想換實作時，只在修改實作的類別，就可以輕鬆切換。因為使用的地方是依照介面來呼叫的，所以當不同資料源的類別都實作相同介面，我們就不用修改其他程式碼，只要切換實作類別即可。\n\n## 用狀態管理轉接\n\n在上面的例子中，我們都是直接在 Widget 中使用 Repositroy，但是這種為了讓例子變得簡潔的作法。在真實情況中，大多時候我們會使用狀態管理套件去存取 Repository，當狀態管理套件取得資料時，再通知 Widget 更新畫面。通常我們不會讓 Widget 直接存取 Repository。\n\n若用 [flutter_bloc](https://pub.dev/packages/flutter_bloc) 來修改上面的例子，我們建立了一個 NewsCubit，並在裡頭使用 NewsRepository 這個介面去存取資料，然後再建構子決定使用哪種 DataSource。\n\n![it_img_19_4.png](Day%2021%20-%20%E9%81%BF%E5%85%8D%E8%AE%93%E8%B3%87%E6%96%99%E6%BA%90%E7%B6%81%E6%9E%B6%E7%A8%8B%E5%BC%8F/it_img_19_4.png)\n\n最後則是畫面會監聽 NewsCubit 的狀態，並依據狀態即時更新畫面，顯示新聞\n\n![it_img_19_6.png](Day%2021%20-%20%E9%81%BF%E5%85%8D%E8%AE%93%E8%B3%87%E6%96%99%E6%BA%90%E7%B6%81%E6%9E%B6%E7%A8%8B%E5%BC%8F/it_img_19_6.png)\n\n[https://dartpad.dev/?id=63b00dc1b668d8094108c505f11abe4f](https://dartpad.dev/?id=63b00dc1b668d8094108c505f11abe4f)\n\n利用以上作法，當我們想抽換 Repository 實作時，只要到 NewsCubit 中修改即可，至於使用 NewsRepository 的地方無需修改。\n\n## 結論\n\n其實 Repository 被廣泛運用在各類應用程式中，不只是 Flutter，像是 [Android 官方推薦的架構](https://developer.android.com/topic/architecture#recommended-app-arch)中，也可以看到 Repository 身影，透過墊了一層 Repository 隔開了商業邏輯與資料存取。\n\n## 參考\n\n- Repository：[https://martinfowler.com/eaaCatalog/repository.html](https://martinfowler.com/eaaCatalog/repository.html)\n- flutter_bloc：[https://pub.dev/packages/flutter_bloc](https://pub.dev/packages/flutter_bloc)\n- Android 推薦架構：[https://developer.android.com/topic/architecture#recommended-app-arch](https://developer.android.com/topic/architecture#recommended-app-arch)\n\n如果我們在程式中直接使用這些外部的 API 的話，當我們在想要抽換時，就會因為邏輯與外部 API 相依過深，導致程式十分難以修改。為了解決這個問題，我們通常會使用 Repository Pattern 來解決這個問題。\n\n[https://martinfowler.com/eaaCatalog/repository.html](https://martinfowler.com/eaaCatalog/repository.html)\n\n[https://blog.logrocket.com/implementing-repository-pattern-flutter/](https://blog.logrocket.com/implementing-repository-pattern-flutter/)\n\n[https://codewithandrea.com/articles/flutter-repository-pattern/](https://codewithandrea.com/articles/flutter-repository-pattern/)\n\n[https://weblogs.asp.net/fredriknormen/what-purpose-does-the-repository-pattern-have](https://weblogs.asp.net/fredriknormen/what-purpose-does-the-repository-pattern-have)",
          "id": "772ea465c5fb4b09a8dcf54ad364e1f0",
          "filename": "Day 21 - 避免讓資料源綁架程式 772ea465c5fb4b09a8dcf54ad364e1f0.md",
          "folderName": "Day 21 - 避免讓資料源綁架程式",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 22 - 使用依賴注入元件",
          "summary": "id: 22 昨天我們談到使用 Repository 隔離使用端與實作端的直接相依，讓修改實作時變得容易一些。但是如果大家仔細想想可能會發現，假設今天我們有許多地方都使用了 NewsRepositroy，而每個地方都自己指定 NewsRepository 的實作。當今天我們真的想抽換實作時，雖然只要...",
          "content": "id: 22\n\n昨天我們談到使用 Repository 隔離使用端與實作端的直接相依，讓修改實作時變得容易一些。但是如果大家仔細想想可能會發現，假設今天我們有許多地方都使用了 NewsRepositroy，而每個地方都自己指定 NewsRepository 的實作。當今天我們真的想抽換實作時，雖然只要修改建構子的實作指定就好，還是不免要到每個使用到的地方去修改，今天我們就來聊聊如何解決這個問題。\n\n![it_img_20_1.png](Day%2022%20-%20%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E5%85%83%E4%BB%B6/it_img_20_1.png)\n\n[https://dartpad.dev/?id=139bddfa16e5fb65fbc99734380a8406](https://dartpad.dev/?id=139bddfa16e5fb65fbc99734380a8406)\n\n## 依賴注入\n\n為了解決這個問題，我們可以引入依賴注入的技術，讓 NewsCubit 不再是自己建立 NewsRepositroy 的實作，而是跟依賴注入容器索取。以上面的例子來說，我們可以在 App 最外層包一個 RepositoryProvider，並在這邊決定 NewsRepository 的實作。\n\n![it_img_20_2.png](Day%2022%20-%20%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E5%85%83%E4%BB%B6/it_img_20_2.png)\n\n當建立 NewsCubit 時，則透過 [context.read](http://context.read) 取得 NewsRepository，由建構子注入 NewsCubit，NewsCubit 再也不需要負責建立 NewsRepository 了。\n\n![it_img_20_3.png](Day%2022%20-%20%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E5%85%83%E4%BB%B6/it_img_20_3.png)\n\n[https://dartpad.dev/?id=d2e40b92642ef82f5f164c0a78fb5b5a](https://dartpad.dev/?id=d2e40b92642ef82f5f164c0a78fb5b5a)\n\n這也是依賴注入的功能之一：控制物件的生命週期，將管理物件生命週期的職責，從每個物件中轉移到依賴注入框架中。\n\n## 抽換實作\n\n當我們使用依賴注入框架，我們是在設定的地方決定實作。當我們決定把 NewsRepository 換成 SqliteDataSource 時，所有使用依賴注入取得 NewsRepository 的地方，都會轉而使用 SqliteDataSource，省去修改每一個類別。\n\n![it_img_20_4.png](Day%2022%20-%20%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E5%85%83%E4%BB%B6/it_img_20_4.png)\n\n使用依賴注入框架，當我們更換實作時，我們就不需要逐一到每個使用到的地方更換實作。\n\n## 其他依賴注入的方式\n\n由於 Flutter 框架本身並沒有提供依賴注入的功能，而在上面的例子中，我們使用 Bloc 提供的 RepositoryProvider 幫助我們在 Flutter 中把相依注入到 News。但是並非所有專案都選擇 Bloc 或 Provider 來做狀態管理。所幸我們還是能從 Flutter 眾多套中之尋找適合的依賴注入套件來搭配使用，我們就用 get_it + injectable 來改造一下範例吧。\n\n首先我們還是得先把套件加入專案中\n\n```bash\nflutter pub add get_it\nflutter pub add injectable\nflutter pub add --dev injectable_generator\nflutter pub add --dev build_runner\n```\n\n然後我們就能在 Repository 的實作中，設定依賴注入的規則\n\n![it_img_20_5.png](Day%2022%20-%20%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E5%85%83%E4%BB%B6/it_img_20_5.png)\n\n[https://gist.github.com/a40e02de994bbff456358f3152d13234/revisions](https://gist.github.com/a40e02de994bbff456358f3152d13234/revisions)\n\n最後當我們建立 NewsCubit 時，就能從 getIt 中取得相對應的實作。\n\n![it_img_20_6.png](Day%2022%20-%20%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E5%85%83%E4%BB%B6/it_img_20_6.png)\n\n不知道有沒有讀者會好奇，既然 Flutter 沒有反射，那又是如何從依賴注入中取得相對應的實作的呢？其實秘密是利用 build runner 幫我們產生依賴設定的程式碼，像是下圖那樣。\n\n![it_img_20_7.png](Day%2022%20-%20%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E5%85%83%E4%BB%B6/it_img_20_7.png)\n\n## Provider V.S. GetIt\n\n最後我們來思考一下，當我們想使用依賴注入時，該使用 Provider 或者是 GetIt 呢？在討論之前，我們先來看看兩者的使用方法。這兩種使用方式都有一個共通點，那就是都是 [Service Locator](https://en.wikipedia.org/wiki/Service_locator_pattern) 的方式取得相依，也就是無可避免的，我們的程式碼一定會相依於依賴注入框架。\n\n```dart\n// Provider\ncontext.read<NewsRepositroy>();\n\n// GetIt\ngetIt<NewsRepository>()\n```\n\n再來讓我們看看不同之處，當使用 Provider 取得相依時，必須有 context 才可以呼叫，原因是 Provider 尋找相依的方式是基於 Widget 樹，也就是說，只有在 View 層的程式碼，我們才能使用 [context.read](http://context.read) 來尋找相依。當今天使用的地方不在 View 時，我們就無法取得 context，也就無法取得相依，使用的地方會相對於 GetIt 更為受限。\n\n## 結論\n\n使用依賴注入，將物件建立與管理的職責可以轉移到依賴注入框架中，讓我們的程式碼可以專注如何與依賴注入框架互動即可。當我們想抽換實作，也可以直接修改依賴注入設定即可，而不必修改使用端程式碼。\n\n## 參考\n\n- 依賴注入：[https://zh.wikipedia.org/zh-tw/依赖注入](https://zh.wikipedia.org/zh-tw/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)\n- Service Locator：[https://en.wikipedia.org/wiki/Service_locator_pattern](https://en.wikipedia.org/wiki/Service_locator_pattern)\n- get_it：[https://pub.dev/packages/get_it](https://pub.dev/packages/get_it)\n- injectable：[https://pub.dev/packages/injectable](https://pub.dev/packages/injectable)\n- injectable_generator：[https://pub.dev/packages/injectable_generator/install](https://pub.dev/packages/injectable_generator/install)\n\n為了解決這個問題我們使用介面先使用介面來加上依賴注入來解決這個問題。讓使用資料的類別與讀取資料的類別分開，並讓兩者之間相依於介面，而不是實作。\n\nex: code\n\n當我們把程式改成這樣之後，我們也能更簡單的測試程式碼了，只要在測試程式中讓假物件實作介面，我們就能輕鬆的測試程式了。我們把這些介接資料於商業邏輯的類別稱為 Repository。",
          "id": "1aa98902814c44daabb96926f4431093",
          "filename": "Day 22 - 使用依賴注入元件 1aa98902814c44daabb96926f4431093.md",
          "folderName": "Day 22 - 使用依賴注入元件",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 23 - 暫存一些資料，增加使用者體驗",
          "summary": "note: 職責分離 開放封閉原則 id: 23 tag: 設計 當我們在開發應用程式的時候，常常會遇到一種需要 Cache 資料的情境：當使用者打開畫面，我們從 API 或 DB 讀取資料，讓資料成功顯示在畫面上。過了一段時間，使用再次打開相同畫面時，我們希望不要再次呼叫 API，直接顯示上一次取...",
          "content": "note: 職責分離 開放封閉原則\nid: 23\ntag: 設計\n\n當我們在開發應用程式的時候，常常會遇到一種需要 Cache 資料的情境：當使用者打開畫面，我們從 API 或 DB 讀取資料，讓資料成功顯示在畫面上。過了一段時間，使用再次打開相同畫面時，我們希望不要再次呼叫 API，直接顯示上一次取得的資料，以節省流量。為了完成這個功能，我們從會在原本的程式碼中，加上一段 Cache 資料的實作。\n\n![it_img_22_1.png](Day%2023%20-%20%E6%9A%AB%E5%AD%98%E4%B8%80%E4%BA%9B%E8%B3%87%E6%96%99%EF%BC%8C%E5%A2%9E%E5%8A%A0%E4%BD%BF%E7%94%A8%E8%80%85%E9%AB%94%E9%A9%97/it_img_22_1.png)\n\n[https://dartpad.dev/?id=4f6412479033c28f75da665ca1ed433d](https://dartpad.dev/?id=4f6412479033c28f75da665ca1ed433d)\n\n這個做法雖然可以滿足我們的需求，但是也帶來了一個問題。這段類別違反了單一職責，他同時具備了 Cache 的職責與讀取資料的職責。假設今天我們不想把資料暫存在記憶體中，而是想暫存在 sqlite 中，我們就會需要回頭修改這個類別。其次，雖然 NewsRepository 的設計本身符合[開放封閉原則](https://zh.wikipedia.org/zh-tw/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99)，但是我們修改時卻不是拓展而是修改，反而讓設計不符合原則了。\n\n## 裝飾者模式 (Decorator Pattern)\n\n為了尋求更好的設計，我們可以使用[裝飾者模式](https://zh.wikipedia.org/zh-tw/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F)。我們建立一個 NewsCachedDecorator，讓它實作與 NewsRepository 相同的介面，並把 NewsRepostory 傳入裝飾者中。\n\n![it_img_22_2.png](Day%2023%20-%20%E6%9A%AB%E5%AD%98%E4%B8%80%E4%BA%9B%E8%B3%87%E6%96%99%EF%BC%8C%E5%A2%9E%E5%8A%A0%E4%BD%BF%E7%94%A8%E8%80%85%E9%AB%94%E9%A9%97/it_img_22_2.png)\n\n[https://dartpad.dev/?id=faa4503480e41c56bbf62248da73c225](https://dartpad.dev/?id=faa4503480e41c56bbf62248da73c225)\n\n最後再依賴注入的時候，CachedDecorator 包在實作外面，當畫面呼叫 NewsRepository 時，自然會先經過 Cache，由 Cache 決定是否重打 API。\n\n![it_img_22_3.png](Day%2023%20-%20%E6%9A%AB%E5%AD%98%E4%B8%80%E4%BA%9B%E8%B3%87%E6%96%99%EF%BC%8C%E5%A2%9E%E5%8A%A0%E4%BD%BF%E7%94%A8%E8%80%85%E9%AB%94%E9%A9%97/it_img_22_3.png)\n\n## 當變化來臨時\n\n假設今天我們不需要 Cache 了，我們可以直接移除 Cache 裝飾者就好。\n\n![it_img_22_4.png](Day%2023%20-%20%E6%9A%AB%E5%AD%98%E4%B8%80%E4%BA%9B%E8%B3%87%E6%96%99%EF%BC%8C%E5%A2%9E%E5%8A%A0%E4%BD%BF%E7%94%A8%E8%80%85%E9%AB%94%E9%A9%97/it_img_22_4.png)\n\n或者，我們想更換 Cache 的實作方式，改成使用套件而非自己實作時，也可以修改 Cache 裝飾者就好，而不用修改原本的 NewsRepository 實作。\n\n![it_img_22_5.png](Day%2023%20-%20%E6%9A%AB%E5%AD%98%E4%B8%80%E4%BA%9B%E8%B3%87%E6%96%99%EF%BC%8C%E5%A2%9E%E5%8A%A0%E4%BD%BF%E7%94%A8%E8%80%85%E9%AB%94%E9%A9%97/it_img_22_5.png)\n\n## 應該在哪邊 Cache 呢？\n\n在上面的例子中，我們把 Cache 設計在 Repository 層，但是其實我們也可以把 Cache 的職責，往上放到狀態管理層，往下放到實際呼叫 Web API 的地方。許多套件本身也都有提供 Cache 的功能，讓開發者可以更簡單的 Cache API 的回傳值。那到底我們應該放在哪邊才對呢？其實這個問題並沒有正確答案，需要讀者根據自己的情境選擇。當我們很確定所有 API 都有相同的 Cache 行為時，那把 Cache 職責放在呼叫 Web API 的地方可能會適合。但是當今天我們需要根據不同資料，而有不同的 Cache 行為時，放在 Repository 可能比較合適。\n\n## 結論\n\nCache 是一種很常見的使用場景，透過裝飾者模式分離 Cache 與呼叫 API 的職責，讓程式符合單一職責與開放封閉原則。當時決定要使用 Cache 時，也需要決定要把 Cache 實作在什麼地方，這其中就需要讀者根據需求與專案的狀況選擇。\n\n## 參考\n\n- 開放封閉原則：[https://zh.wikipedia.org/zh-tw/开闭原则](https://zh.wikipedia.org/zh-tw/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99)\n- 裝飾者模式：[https://zh.wikipedia.org/zh-tw/修饰模式](https://zh.wikipedia.org/zh-tw/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F)\n- async：[https://api.flutter.dev/flutter/async/async-library.html](https://api.flutter.dev/flutter/async/async-library.html)\n\n最後讓使用端使用 Cache 裝飾者，由 Cache 裝飾者決定使用 Cache 或者呼叫 API。由於使用端是用介面來操作 Repository，所以使用端並不需要為了增加 Cache 而修改原本的代碼。",
          "id": "3b9b955853e745dbafba46eb11b56183",
          "filename": "Day 23 - 暫存一些資料，增加使用者體驗 3b9b955853e745dbafba46eb11b56183.md",
          "folderName": "Day 23 - 暫存一些資料，增加使用者體驗",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 24 - 利用 Interceptor 處理  Token",
          "summary": "note: 職責分離 開放封閉原則 id: 24 tag: 設計 當我們在開發一個完整的應用程式時，不管是 App 或者是 Web，通常會需要拿著 Token 去問 API，然後才能拿回想要的資料。在這個過程中，無可避免的是，Token 會有失效的時候，此時我們會再去跟 API 要一個新的 Toke...",
          "content": "note: 職責分離 開放封閉原則\nid: 24\ntag: 設計\n\n當我們在開發一個完整的應用程式時，不管是 App 或者是 Web，通常會需要拿著 Token 去問 API，然後才能拿回想要的資料。在這個過程中，無可避免的是，Token 會有失效的時候，此時我們會再去跟 API 要一個新的 Token，然後才打 API。\n\n![it_img_24_1.png](Day%2024%20-%20%E5%88%A9%E7%94%A8%20Interceptor%20%E8%99%95%E7%90%86%20Token/it_img_24_1.png)\n\n[https://dartpad.dev/?id=5d1c608cb191a595c22c17abf82dcb27](https://dartpad.dev/?id=5d1c608cb191a595c22c17abf82dcb27)\n\n## 依舊是職責的問題\n\n在上面這段程式碼中，我們可以發現 get 方法中，不僅處理了 Token 的更新，也處理了 Response 的解碼，兩份工作被同時塞在小小的 get 方法中。我們可以透過抽取方法來解決，讓 get 方法只負責控制流程，把工作交給其他方法。\n\n![it_img_24_2.png](Day%2024%20-%20%E5%88%A9%E7%94%A8%20Interceptor%20%E8%99%95%E7%90%86%20Token/it_img_24_2.png)\n\n[https://dartpad.dev/?id=d2f993fbb457329db1d410e5215395f9](https://dartpad.dev/?id=d2f993fbb457329db1d410e5215395f9)\n\n也可以使用昨天的文章中提到的裝飾者模式，將 Token 更新的職責放到 TokenDecorator 中，讓 TokenDecorator 去負責 Token 的維護，而 HttpProviderImpl 就能專注在呼叫 API 的工作上。\n\n![it_img_24_3.png](Day%2024%20-%20%E5%88%A9%E7%94%A8%20Interceptor%20%E8%99%95%E7%90%86%20Token/it_img_24_3.png)\n\n[https://dartpad.dev/?id=de4e8caf5686c83d084eae77c98499c8](https://dartpad.dev/?id=de4e8caf5686c83d084eae77c98499c8)\n\n除了自己實作裝飾者模式之外，許多呼叫 Web API 的相關套件，都有提供類似的功能，讓我們不必重造輪子。\n\n## 使用 Interceptor\n\n當今天大家使用 [http](https://pub.dev/packages/http) 套件作為呼叫 Web API 的選擇時，我們可以再加上 [http_interceptor](https://pub.dev/packages/http_interceptor)，為 http 套件外掛上 interceptor 的功能。\n\n![it_img_24_4.png](Day%2024%20-%20%E5%88%A9%E7%94%A8%20Interceptor%20%E8%99%95%E7%90%86%20Token/it_img_24_4.png)\n\n[https://dartpad.dev/?id=0f5258241320409a0a3b52605288fbdd](https://dartpad.dev/?id=0f5258241320409a0a3b52605288fbdd)\n\n當今天任何使用端發出任何 Request 時，都會走近 interceptRequest 方法，此時我們有機會檢查 Token 是否過期，並在適當時機更新 Token，然後程式就會穿過 interceptor 呼叫 API。\n\n![it_img_24_5.png](Day%2024%20-%20%E5%88%A9%E7%94%A8%20Interceptor%20%E8%99%95%E7%90%86%20Token/it_img_24_5.png)\n\n相比於自己實現裝飾者模式，使用套件的 Interceptor 功能，能讓我們有機會處理每個 Request 的 header。在上面的程式碼中，我們也可以直接在 Interceptor 把 token 放進 header 中，這樣一來 HttpProvider 也可以避免自已處理 token，讓職責分工更明確。\n\n![it_img_24_6.png](Day%2024%20-%20%E5%88%A9%E7%94%A8%20Interceptor%20%E8%99%95%E7%90%86%20Token/it_img_24_6.png)\n\n[https://dartpad.dev/?id=0f5258241320409a0a3b52605288fbdd](https://dartpad.dev/?id=0f5258241320409a0a3b52605288fbdd)\n\n## 除了 Token 之外\n\n使用 Interceptor，我們不只能處理 Token，我們也能處理各式各樣的通用邏輯，例如：Logging 或者是 Caching。將不同的職責分配到不同的 Interceptor 也是實現 [AOP](https://zh.wikipedia.org/zh-tw/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1) 的一種方式。\n\n## 不只 http 套件有 Interceptor\n\n在開發 Flutter 時，除了可以使用 http 來呼叫 Web API 之外，還有 [dio](https://pub.dev/packages/dio) 套件也是熱門選項之一。相比於 http 套件，dio 套件本身就自帶有 interceptor 的功能。我們修改一下上面的例子，再看一下程式碼，就會發現他們其實十分相似。\n\n![it_img_24_7.png](Day%2024%20-%20%E5%88%A9%E7%94%A8%20Interceptor%20%E8%99%95%E7%90%86%20Token/it_img_24_7.png)\n\n[https://dartpad.dev/?id=c15e7eb118a20cd06499adc10dfc8a5d](https://dartpad.dev/?id=c15e7eb118a20cd06499adc10dfc8a5d)\n\n## 結論\n\n大多時候，客端程式或多或少，都會需要呼叫 Web API 來取得一些後端資料。我們也常常需要使用 Token 來向後端證明自己合法的使用者，在使用 Token 的過程中，利用裝飾者模式或者 Interceptor 將 Token 管理的職責從實際呼叫 API 的地方分離，除了能讓程式碼職責更明確之外，也讓其符合開放封閉原則。\n\n## 參考\n\n- http：[https://pub.dev/packages/http](https://pub.dev/packages/http)\n- http_interceptor：[https://pub.dev/packages/http_interceptor](https://pub.dev/packages/http_interceptor)\n- AOP：[https://zh.wikipedia.org/zh-tw/面向切面的程序设计](https://zh.wikipedia.org/zh-tw/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)\n- dio：[https://pub.dev/packages/dio](https://pub.dev/packages/dio)\n\n有 ExpireTime 將 expireTime 紀錄在 local，\n\n在要打 API 之前先去先去問\n\n重複的 getToken 存在每一個 API 呼叫中",
          "id": "2a1121063fa04806822bef0793c34951",
          "filename": "Day 24 - 利用 Interceptor 處理 Token 2a1121063fa04806822bef0793c34951.md",
          "folderName": "Day 24 - 利用 Interceptor 處理 Token",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 25 - 追蹤使用者行為",
          "summary": "note: 寫在每一個頁面，違反單一職責 id: 25 tag: 設計 常常我們在開發完功能之後，UX 設計師可能會想知道使用者如何使用這些功能，並建立漏斗來觀察每一個步驟的使用量。一種常見的方式在各個頁面中埋下分析追蹤碼，由此就可以追蹤使用者在每個頁面的使用晴望。為了完成這個功能，Flutter ...",
          "content": "note: 寫在每一個頁面，違反單一職責\nid: 25\ntag: 設計\n\n常常我們在開發完功能之後，UX 設計師可能會想知道使用者如何使用這些功能，並建立漏斗來觀察每一個步驟的使用量。一種常見的方式在各個頁面中埋下分析追蹤碼，由此就可以追蹤使用者在每個頁面的使用晴望。為了完成這個功能，Flutter 開發者們常常會需要在各個頁面開啟時，埋下紀錄 Firebase Event 以紀錄使用者打開了這個頁面。\n\n## 舉個例子\n\n假設我們有一個頁面，我們可能會把追蹤碼埋在這個頁面的 initState 中。\n\n![it_img_25_1.png](Day%2025%20-%20%E8%BF%BD%E8%B9%A4%E4%BD%BF%E7%94%A8%E8%80%85%E8%A1%8C%E7%82%BA/it_img_25_1.png)\n\n[https://dartpad.dev/?id=fff2ddf023791abf37fb2ac34fb6cd04](https://dartpad.dev/?id=fff2ddf023791abf37fb2ac34fb6cd04)\n\n但是當我們頁面一多時，就會發現需要每一頁都要埋，著實有些麻煩。當我們想修改頁面的顯示或者 Event 紀錄方式時，都會修改到這個類別，也暗示這個類別違反了單一職責。頁面工作應該是負責顯示使用者需要的資料，而不是紀錄 Event。\n\n## 使用 FirebaseAnalyticsObserver\n\n所幸，Firebase Analytics 套件提供了一個稱為 FirebaseAnalyticsObserver 元件，使用這個元件，當頁面切換 Route 路徑變化時，元件就會幫我們紀錄事件。\n\n![it_img_25_2.png](Day%2025%20-%20%E8%BF%BD%E8%B9%A4%E4%BD%BF%E7%94%A8%E8%80%85%E8%A1%8C%E7%82%BA/it_img_25_2.png)\n\n[https://dartpad.dev/?id=256f40433e970c7edfc77ff6b14c8a24](https://dartpad.dev/?id=256f40433e970c7edfc77ff6b14c8a24)\n\n如此一來，我們就不需要辛苦的在每個一個頁面的 initState 紀錄事件，能把紀錄事件的職責交給 FirebaseAnalyticsObserver 元件，每個頁面的的職責也回歸單一。當我們想要排除一些頁面的事件紀錄時，也可以使用 routeFilter 來解決。\n\n![it_img_25_3.png](Day%2025%20-%20%E8%BF%BD%E8%B9%A4%E4%BD%BF%E7%94%A8%E8%80%85%E8%A1%8C%E7%82%BA/it_img_25_3.png)\n\n[https://dartpad.dev/?id=2c4e2f3a65da38a8be7856fc501ccb1f](https://dartpad.dev/?id=2c4e2f3a65da38a8be7856fc501ccb1f)\n\n但是使用什麼服務來紀錄事件有許多選擇，甚至是自己實作。在這些情況下，我們就沒有好用 FirebaseAnalyticsObserver 元件可以使用了。\n\n## Route Observer\n\n為了解決這個問題，我們可以仿造 FirebaseAnalyticsObserver 使用 Flutter 提供的 Route Observer，建立一個 EventLoggingRouteObserver 來幫助我們紀錄事件，並把它放進 MaterialApp 中。\n\n![it_img_25_4.png](Day%2025%20-%20%E8%BF%BD%E8%B9%A4%E4%BD%BF%E7%94%A8%E8%80%85%E8%A1%8C%E7%82%BA/it_img_25_4.png)\n\n[https://dartpad.dev/?id=e31de5f6efcd14138f919972010c5a8a](https://dartpad.dev/?id=e31de5f6efcd14138f919972010c5a8a)\n\n使用客製的 RouteObserver，還能讓我們有機會針對不同的頁面，增加不同的參數，讓我們能準確紀錄使用者行為。\n\n![it_img_25_5.png](Day%2025%20-%20%E8%BF%BD%E8%B9%A4%E4%BD%BF%E7%94%A8%E8%80%85%E8%A1%8C%E7%82%BA/it_img_25_5.png)\n\n[https://dartpad.dev/?id=3aad943d59ef905d21ca60184dcc9031](https://dartpad.dev/?id=3aad943d59ef905d21ca60184dcc9031)\n\n當我們今天不需要紀錄頁面開啟/關閉事件時，我們也可以直接移除掉 RouteObserver 就好，而無需到每個頁面去移除紀錄事件的程式碼，也符合開放封閉的原則。\n\n## 將事件紀錄封裝\n\n大部分的 Firebase 套件，都使用 [Singleton 模式](https://zh.wikipedia.org/zh-tw/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)。當我們想使用時，只要使用 FirebaseAnalytics.instance 就能使用方法。\n\n```dart\nFirebaseAnalytics.instance.logEvent(name: \"event_name\");\n```\n\n但是如果我們直接程式碼中呼叫 FirebaseAnalytics.instance，會讓使用的類別直接與 FirebaseAnalytics 相依。相信讀者們一定知道這會產生什麼問題，當我們想更換事件紀錄的方式時，就會忙著到所有使用到的類別修改。除此之外，當我們想進行單元測試時，也會因為 FirebaseAnalytics 而無法測試，因為會造成執行測試時，還是嘗試去尋找 Firebase 設定，但單元測試不會有這些東西，所以測試就壞了。\n\n為了解決這些問題，我們可以使用前幾天提到的技巧：依賴注入。我們可以寫一個類別封裝 FirebaseAnalytics 並繼承 Analytics 介面。\n\n![it_img_25_6.png](Day%2025%20-%20%E8%BF%BD%E8%B9%A4%E4%BD%BF%E7%94%A8%E8%80%85%E8%A1%8C%E7%82%BA/it_img_25_6.png)\n\n然後把實作放進依賴注入框架中。\n\n![it_img_25_7.png](Day%2025%20-%20%E8%BF%BD%E8%B9%A4%E4%BD%BF%E7%94%A8%E8%80%85%E8%A1%8C%E7%82%BA/it_img_25_7.png)\n\n最後使用 Service Locator 取得 Analytics，並使用其紀錄事件。\n\n![it_img_25_8.png](Day%2025%20-%20%E8%BF%BD%E8%B9%A4%E4%BD%BF%E7%94%A8%E8%80%85%E8%A1%8C%E7%82%BA/it_img_25_8.png)\n\n[https://dartpad.dev/?id=090270a32c7e1175d6e5e94f988c9796](https://dartpad.dev/?id=090270a32c7e1175d6e5e94f988c9796)\n\n## 結論\n\n紀錄頁面開啟/關閉的事件是一種常見的事件紀錄，將紀錄事件的程式碼與畫面渲染的程式碼分開，能有效提升程式的可維護性。另外除了上述的事件之外，還有另外一種常見的事件紀錄情境是：當使用者點下某個按鈕時，我們也希望紀錄使用點擊了哪個按鈕，此時如果我們直接使用 FirebaseAnalytics.instance，會讓程式碼逐漸僵化，同時也失去可測試性，此時我們可以使用依賴注入解決，避免軟體漸漸變成硬體。\n\n## 參考\n\n- firebase_analytics：[https://pub.dev/packages/firebase_analytics](https://pub.dev/packages/firebase_analytics)\n- FirebaseAnalyticsObserver：[https://pub.dev/documentation/firebase_analytics/latest/observer/FirebaseAnalyticsObserver-class.html](https://pub.dev/documentation/firebase_analytics/latest/observer/FirebaseAnalyticsObserver-class.html)",
          "id": "9fbe1b22ce0f44dd8c26c95a8484819c",
          "filename": "Day 25 - 追蹤使用者行為 9fbe1b22ce0f44dd8c26c95a8484819c.md",
          "folderName": "Day 25 - 追蹤使用者行為",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 26 - Flutter 例外的流程處理",
          "summary": "note: 絕不姑息錯誤 讓錯誤要媽通知使用者 要媽通知開發者 id: 26 tag: 設計 開發任何程式時，如何正確的錯誤處理，不只讓讓開發者能更好除錯，也讓程式可以更加穩定。今天就來聊聊如何在 Flutter 中處理例外。 在 Flutter 中，有兩種例外類別，一種是 Exception，而另...",
          "content": "note: 絕不姑息錯誤 讓錯誤要媽通知使用者 要媽通知開發者\nid: 26\ntag: 設計\n\n開發任何程式時，如何正確的錯誤處理，不只讓讓開發者能更好除錯，也讓程式可以更加穩定。今天就來聊聊如何在 Flutter 中處理例外。\n\n## Exception vs Error\n\n在 Flutter 中，有兩種例外類別，一種是 Exception，而另一種是 Error，類似於 Java 的 Checked Excpetion 與 Runtime Exception，但不同的是，編譯器並不會幫忙檢查。其中 Exception 通常用於，我們知道如何處理並且應該正確處理的錯誤，而另外一種則是不預期的錯誤，例如：OutOfMemoryError、StackOverflowError… 等等，相關的討論可以看[這邊](https://groups.google.com/a/dartlang.org/g/misc/c/lx9CXiV3o30/m/s5l_PwpHUGAJ)。今天就先讓我們針對第一種錯誤來進行討論。\n\n## 非正常流程\n\n在開發的過程中，我們常常會處理一些發生錯誤的流程，例如：購買商品時，而後端因為商品數量不足而回報錯誤。由於可能同時有許多使用者都在購買相同商品，所以比較低的機率使得使用者按下購買按鈕前，商品就已經賣光。在這種情況中，我們可以預期這種錯誤的發生，我們可能也會準備合適的錯誤畫面，讓使用了解狀況。\n\n![it_img_26_1.png](Day%2026%20-%20Flutter%20%E4%BE%8B%E5%A4%96%E7%9A%84%E6%B5%81%E7%A8%8B%E8%99%95%E7%90%86/it_img_26_1.png)\n\n當 QuantityInsuffientException 的例外從 buy 方法拋出時，呼叫 buy 方法的程式碼，也會準好一段例外處理的流程。當例外處理攔截到 Exception 時，就會顯示 Product is sold out 的訊息給使用者，讓使用者知道商品已經賣光。\n\n![it_img_26_2.png](Day%2026%20-%20Flutter%20%E4%BE%8B%E5%A4%96%E7%9A%84%E6%B5%81%E7%A8%8B%E8%99%95%E7%90%86/it_img_26_2.png)\n\n[https://dartpad.dev/?id=d7f905f548a1035b2c0da359ead719a2](https://dartpad.dev/?id=d7f905f548a1035b2c0da359ead719a2)\n\n## 另一種狀況 timeout\n\n在上面的例子中，我們把只處理的 Status code 為 400 的狀況，但有些時候，有可能是使用者正坐在高鐵上，網路不穩定而導致打 API 失敗，如果我們馬上就顯示錯誤畫面給使用者，使用者體驗可能就沒有這好。\n\n![it_img_26_3.png](Day%2026%20-%20Flutter%20%E4%BE%8B%E5%A4%96%E7%9A%84%E6%B5%81%E7%A8%8B%E8%99%95%E7%90%86/it_img_26_3.png)\n\n[https://dartpad.dev/?id=57e8c1e5adbc38ac2c171765962e3383](https://dartpad.dev/?id=57e8c1e5adbc38ac2c171765962e3383)\n\n為了解決這種問題，我們常使用的方法就是 Retry。也就是當失敗時，等一段時間，再試一次。運用這種方式，我們能降低一點網路波動的影響，讓我們的應用程式使用起來更穩定。\n\n![it_img_26_4.png](Day%2026%20-%20Flutter%20%E4%BE%8B%E5%A4%96%E7%9A%84%E6%B5%81%E7%A8%8B%E8%99%95%E7%90%86/it_img_26_4.png)\n\n[https://dartpad.dev/?id=332910b1ae8c3cdda240685134275ba8](https://dartpad.dev/?id=332910b1ae8c3cdda240685134275ba8)\n\n那是否要在每個例外處理的地方都要 Retry 呢？這個答案就不一定了，需要聰明的讀者們依照實際需求來決定，到底我的應用程式需要多穩定，也可以選擇某些功能使用 Retry，某些功能則是直接讓使用者知道發生錯誤。當使用 Retry 的地方多了，我們也可以選擇使用[套件](https://pub.dev/packages/retry)來幫我們 Retry，就不需要自己辛苦的到處實作 Retry 邏輯。\n\n![it_img_26_5.png](Day%2026%20-%20Flutter%20%E4%BE%8B%E5%A4%96%E7%9A%84%E6%B5%81%E7%A8%8B%E8%99%95%E7%90%86/it_img_26_5.png)\n\n[https://dartpad.dev/?id=ac01f65887e1a57f4b0bac802d846c5a](https://dartpad.dev/?id=ac01f65887e1a57f4b0bac802d846c5a)\n\n## 從錯誤中回歸正確狀態\n\n有些時候，我們在 try 中可能會處理很多事情，當其中一行 statement 發生錯誤時，流程就斷在某一處，使得整個應用程式的狀態不正確。例如：使用第三方身份驗證服務時，我們通常也會在後端建立其他與使用者相關的資料。\n\n![it_img_26_6.png](Day%2026%20-%20Flutter%20%E4%BE%8B%E5%A4%96%E7%9A%84%E6%B5%81%E7%A8%8B%E8%99%95%E7%90%86/it_img_26_6.png)\n\n[https://dartpad.dev/?id=0e5842ff0f62f2670514058d062c722b](https://dartpad.dev/?id=0e5842ff0f62f2670514058d062c722b)\n\n假設今天發生了宜種情況：當 firebaseLogin 成功，但是 createuserIfNeed 卻失敗。當這個狀況發生時，由於 firebaseLogin 已經完成，應用程式此時的狀態已經是登入成功，創建使用者失敗，如果使用者繼續使用登入狀態去操作應用程式，就會造成許多不預期的狀況。\n為此，除了回報錯誤給使用者之外，我們也應該把登入狀態從應用程式中清除，讓應用程式回歸未登入狀態。\n\n![it_img_26_7.png](Day%2026%20-%20Flutter%20%E4%BE%8B%E5%A4%96%E7%9A%84%E6%B5%81%E7%A8%8B%E8%99%95%E7%90%86/it_img_26_7.png)\n\n[https://dartpad.dev/?id=7ac1a4906b6624c9dde3af109d3ab06a](https://dartpad.dev/?id=7ac1a4906b6624c9dde3af109d3ab06a)\n\n例外處理除了要把讓使用者知道現在發生什麼狀況之外，還必須讓應用程式維持正確的狀態。這樣一來，當我們處理完例外時，應用程式才能正常地繼續使用。否則，每當使用者發生錯誤，就要手動重啟應用程式，只要再發生個幾次，使用者就會感到煩躁，再也不會回來了。\n\n## 結論\n\n當程式執行時，發生錯誤是無可避免的。如何識別錯誤，並正確的處理錯誤，才能讓程式不受錯誤影響，維持正確狀態，提升使用者體驗。今天討論的是如何處理可預期的錯誤，在這種錯誤中，我們通常知道如何做像對應的處置，但有些時候，程式還是會發生一些非預期的狀況，有可能是因為程式寫錯，有可能是因為裝置記憶題不足，明天我們會繼續討論這個問題。\n\n## 參考\n\n- Exception vs Error：[https://groups.google.com/a/dartlang.org/g/misc/c/lx9CXiV3o30/m/s5l_PwpHUGAJ](https://groups.google.com/a/dartlang.org/g/misc/c/lx9CXiV3o30/m/s5l_PwpHUGAJ)\n- retry：[https://pub.dev/packages/retry](https://pub.dev/packages/retry)\n- Firebase 身份驗證：[https://firebase.google.com/docs/auth](https://firebase.google.com/docs/auth)",
          "id": "57aabf591ca94c6d8a92ced1508246b9",
          "filename": "Day 26 - Flutter 例外的流程處理 57aabf591ca94c6d8a92ced1508246b9.md",
          "folderName": "Day 26 - Flutter 例外的流程處理",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 27 - 不預期的錯誤",
          "summary": "id: 27 昨天我們討論了如何處理可預期的錯誤狀況，並針對不同情況，討論了幾種不同的處理方式。但是錯誤並非總是可以預期的，有些時候，我們的應用程式還是會發生一些不預期的狀況，例如：當 API 出現 Bug，回了一個不認識的 response，當我們的應用程式嘗試去解析 response 時，就會發...",
          "content": "id: 27\n\n昨天我們討論了如何處理可預期的錯誤狀況，並針對不同情況，討論了幾種不同的處理方式。但是錯誤並非總是可以預期的，有些時候，我們的應用程式還是會發生一些不預期的狀況，例如：當 API 出現 Bug，回了一個不認識的 response，當我們的應用程式嘗試去解析 response 時，就會發生 json parse fail 的錯誤，又或者當網路斷線時，我們打任何 API 也都會得到網路不通的錯誤。\n\n## 容錯設計\n\n無論是網路斷線，或者程式有 Bug，這些狀況都不是我們可以預期的，所以我們也更不可能知道如何正確的處理這些錯誤。在這種情況下，應用程式可能因為這些錯誤而直接掛掉，此時，我們應該把錯誤到後台，並且通知開發者，讓開發者可以盡快的修復問題。\n\n但是有些情況，即使應用程式發生了不預期的錯誤，我們還是希望應用程式能繼續正常的運行，例如：當我們在開發與醫療相關的程式時，可能就不能讓應用程式因為錯誤而掛掉，畢竟是人命關天的事情。此時，我們就會做一些容錯設計，讓應用程式在發生不預期錯誤的情況下，也能繼續運行，加強程式的穩定性。\n\n## 處理 Flutter 非預期錯誤\n\n在開發 Flutter 的時候，我們可能需要處理幾種情況下發生的非預期錯誤：\n\n1. Build 畫面時\n2. 其他呼叫時\n\n聽起來好像我們需要處理很多事情，但其實 Flutter 已經為我們處理了，使用 Flutter 的 API，並帶入錯誤處理的方法。當錯誤發生時，App 不會停止運行，我們也能收到錯誤相關資訊。\n\n## 處理 Build 畫面時的錯誤\n\n如果開發過 Flutter 的讀者，可能曾經看過下面這個灰畫面的狀況。當我們沒有處理 Build 畫面時的錯誤，當 Build 畫面時失敗時，Flutter 不會讓程式停止運行，取而代之的是，在原本 Widget 該出現的地方，會出現這個灰畫面。\n\n![it_img_27_1.png](Day%2027%20-%20%E4%B8%8D%E9%A0%90%E6%9C%9F%E7%9A%84%E9%8C%AF%E8%AA%A4/it_img_27_1.png)\n\n我們可以設定 ErrorWidget.builder，告訴 Flutter 當畫面出錯時，我們希望出現什麼 Widget，藉此，我們就可以替換一個符合當前 App 設計的錯誤畫面。同時，我們也要把錯誤回報到後台，讓我們可以知道使用者遇到了什麼問題。\n\n![it_img_27_2.png](Day%2027%20-%20%E4%B8%8D%E9%A0%90%E6%9C%9F%E7%9A%84%E9%8C%AF%E8%AA%A4/it_img_27_2.png)\n\n[https://dartpad.dev/?id=9c42a1505016b24a0e22c47a2b8e7534](https://dartpad.dev/?id=9c42a1505016b24a0e22c47a2b8e7534)\n\n![Screenshot_20221010_232120.png](Day%2027%20-%20%E4%B8%8D%E9%A0%90%E6%9C%9F%E7%9A%84%E9%8C%AF%E8%AA%A4/Screenshot_20221010_232120.png)\n\n## 回報錯誤\n\n若我們只是顯示錯誤畫面，那還不夠，我們還少做了一件事情：把錯誤回報給開發者。由於 App 是客端應用程式，當使用者發生錯誤時，有時候是錯在他的裝置上，開發者沒有任何機會知道使用者遇到了錯誤。所以，我們除了顯示錯誤畫面外外，還把錯誤回報給開發者。此時，我們必須把設定錯誤處理到 FlutterError.onError\n\n![it_img_27_4_5.png](Day%2027%20-%20%E4%B8%8D%E9%A0%90%E6%9C%9F%E7%9A%84%E9%8C%AF%E8%AA%A4/it_img_27_4_5.png)\n\n## 處理其他呼叫時的錯誤\n\n同樣的，當非同步呼叫時出錯時，Flutter 也幫我們處理了錯誤，所以 App 並不會停止運行，畫面也不會出錯。但是如果有遇過這問題的讀者，可能會發現錯誤還是在 Console 中出現。我們並不希望錯誤只出現在 Console 中，因為這樣我們就不知道 Bug 的發生，所以必須像上一小節一樣，我們得把錯誤回報。\n\n![it_img_27_4.png](Day%2027%20-%20%E4%B8%8D%E9%A0%90%E6%9C%9F%E7%9A%84%E9%8C%AF%E8%AA%A4/it_img_27_4.png)\n\n透過設定使用 runZoneGuard 來捕捉這些非同步的錯誤，並在相對應的 Callback 中回報錯誤。\n\n![it_img_27_5.png](Day%2027%20-%20%E4%B8%8D%E9%A0%90%E6%9C%9F%E7%9A%84%E9%8C%AF%E8%AA%A4/it_img_27_5.png)\n\n[https://dartpad.dev/?id=b4486b56d859177ed861784b5bc09862](https://dartpad.dev/?id=b4486b56d859177ed861784b5bc09862)\n\n## Flutter 3.3 之後\n\n當我們更新 Flutter 到 3.3 之後，我可以使用 PlatformDispatcher.instance.onError 來取代 runZoneGuard。\n\n![it_img_27_6.png](Day%2027%20-%20%E4%B8%8D%E9%A0%90%E6%9C%9F%E7%9A%84%E9%8C%AF%E8%AA%A4/it_img_27_6.png)\n\n[https://dartpad.dev/?id=b4486b56d859177ed861784b5bc09862](https://dartpad.dev/?id=b4486b56d859177ed861784b5bc09862)\n\n## 結論\n\n在 Flutter 中，由於 Flutter 本身已經提供相對於完善的容錯設計，對於如何處理非預期錯誤並不困難，我們只要正確認識如何使用 API，就能在保證 APP 穩定的同時，也能讓開發者發現錯誤，進而修復錯誤。\n\n## 參考\n\n- Handling errors in Flutter**：**[https://docs.flutter.dev/testing/errors](https://docs.flutter.dev/testing/errors)\n- [https://github.com/flutter/engine/pull/32078](https://github.com/flutter/engine/pull/32078)",
          "id": "f6a5338b909443daa8e498281b9be87f",
          "filename": "Day 27 - 不預期的錯誤 f6a5338b909443daa8e498281b9be87f.md",
          "folderName": "Day 27 - 不預期的錯誤",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 28 - 為程式撰寫單元測試",
          "summary": "note: 測試 route 行為 id: 28 tag: 設計 大多時候，我們花許多時間在開發功能，隨著功能越來越多，功能之間也互相影響。有時候，我們改了一個功能，另外一個功能卻壞了，但是我們卻沒發現。如果有 QA 幫忙測試，或許還能透過專業的測試手法找到，萬一今天只有我們自己測試，而我們又沒花太...",
          "content": "note: 測試 route 行為\nid: 28\ntag: 設計\n\n大多時候，我們花許多時間在開發功能，隨著功能越來越多，功能之間也互相影響。有時候，我們改了一個功能，另外一個功能卻壞了，但是我們卻沒發現。如果有 QA 幫忙測試，或許還能透過專業的測試手法找到，萬一今天只有我們自己測試，而我們又沒花太多時間測試，就會把 Bug release 出去了。\n\n為此，我們可以進行單元測試，測試我們開發的功能。當我們每次新增功能，也為他加上測試，這些測試就能保護我們的功能，在我們因為新增其他功能而改壞或者重構有問題時，就會在我們執行時讓我們知道，哪些地方改壞了。\n\n## 開始測試\n\n在這邊就讓我們測試一下 Day 8 的 SelectedPhotos 類別的 select 方法。\n\n![it_img_28_1.png](Day%2028%20-%20%E7%82%BA%E7%A8%8B%E5%BC%8F%E6%92%B0%E5%AF%AB%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/it_img_28_1.png)\n\n[https://dartpad.dev/?id=886bcbddaf299475a141d22e7d099a4e](https://dartpad.dev/?id=886bcbddaf299475a141d22e7d099a4e)\n\n從這個類別中，我們可以看出 select 有幾個行為，並為其列下測試案例：\n\n1. 當 photo 未被選擇，也沒超過限制時，就會能成功選擇 photo\n2. 當 photo 被選擇時，呼叫 select 會取消選擇\n3. 當選擇 photo 檔案大小總和超過 250 時，就會丟出 OverLimitException\n4. 當選擇 photo 超過 5 張時，就會丟出 OverLimitException\n\n## 測試第一個案例\n\n在 Flutter 中，我們會把測試寫在 main 方法中，並在 main 方法中放入單元測試。在單元測試中，透過實現 3A 原則：Arrange、Act、和 Assert，從準備 photo 資料、實際執行 select 方法，最後確認 photo 已經被選擇。當我們完成每一個步驟後，執行測試就從 IDE 看到一個測試通過了。\n\n![it_img_28_2.png](Day%2028%20-%20%E7%82%BA%E7%A8%8B%E5%BC%8F%E6%92%B0%E5%AF%AB%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/it_img_28_2.png)\n\n[https://dartpad.dev/?id=886bcbddaf299475a141d22e7d099a4e](https://dartpad.dev/?id=886bcbddaf299475a141d22e7d099a4e)\n\n如果讀者們有興趣，也可以自己嘗試第二個測試案例。讓我們跳過第二個，嘗試測試一下非正常的流程。\n\n## 測試非正常流程\n\n當選擇的總檔案大小超過 250 時，我們執行 select 時，就會拋出一個 OverLimitException。如果我們直接在測試中執行 selectedPhotos.select，測試就會因為 OverLimitException 被拋出而失敗。所以在這測試案例中，我們不能直接呼叫 select 方法。而是必須使用 callback 的方式，把呼叫 select 的工作傳給，expect 方法，並讓 expect 方法幫我們檢查是否 select 方法有正確的拋出 OverLimitException。\n\n![it_img_28_3.png](Day%2028%20-%20%E7%82%BA%E7%A8%8B%E5%BC%8F%E6%92%B0%E5%AF%AB%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/it_img_28_3.png)\n\n[https://dartpad.dev/?id=381128d4a7999a0a086055bd61e28bb1](https://dartpad.dev/?id=381128d4a7999a0a086055bd61e28bb1)\n\n同樣的，如果讀者們有興趣，也可以自己嘗試第四個測試案例。\n\n## 設定假資料\n\n有些時候，我們測試目標會相依於其他類別，與其他類別互動，最後完成工作。像是下面例子中 NewsRepository 並不會自己打 API，而是透過 HttpProvider 呼叫。在單元測試中，我們希望能避免直接呼叫真的 API 或使用 DB 等外部資源，我們必須做假這些互動。\n\n![it_img_28_4.png](Day%2028%20-%20%E7%82%BA%E7%A8%8B%E5%BC%8F%E6%92%B0%E5%AF%AB%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/it_img_28_4.png)\n\n在這些測試中，我們會使用 mock 套件來幫助我們做假這些互動，讓我們更好測試。在 Flutter 中，我們可以選擇使用 [mockito](https://www.notion.so/Null-safety-mockito-any-4df501b643a04bb29c701f53db896d45?pvs=21) 或 [mocktail](https://pub.dev/packages/mocktail) 來幫助我們做假。在這邊，我們使用 mocktail 來示範。\n\n![it_img_28_5.png](Day%2028%20-%20%E7%82%BA%E7%A8%8B%E5%BC%8F%E6%92%B0%E5%AF%AB%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/it_img_28_5.png)\n\n[https://dartpad.dev/?id=73c5804efc8ce14db9b2d7c727ee369e](https://dartpad.dev/?id=73c5804efc8ce14db9b2d7c727ee369e)\n\n雖然這個測試與 selectedPhotos 的測試看起來不太一樣，但其實還是符合 3A 原則的。\n\n1. Arrange：透過 mocktail 的 API 來做假 HttpProvider 的回傳資料\n2. Act：呼叫 NewsRepository.get \n3. Assert：驗證 NewsRepository.get 的回傳資料使否符合預期\n\n## 測試也需要重構\n\n由於測試方法裡頭充滿了細節，讓我們可能不太好看出測試的流程。所以我們應該也要對測試進行重構，讓測試也具備可讀性。如此一來，當測試失敗時，我們才不會花一大堆時間看懂測試，然後才知道什麼東西出錯了。\n\n![it_img_28_6.png](Day%2028%20-%20%E7%82%BA%E7%A8%8B%E5%BC%8F%E6%92%B0%E5%AF%AB%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/it_img_28_6.png)\n\n[https://dartpad.dev/?id=9fb4a07b2877366e73b2c1401dc051ca](https://dartpad.dev/?id=9fb4a07b2877366e73b2c1401dc051ca)\n\n當我們重構測試之後，測試也從長長一串，變短一些，也隱藏一些測試實作的細節，讓我們能更專注在測試的流程上。\n\n## 當測試很難寫時\n\n有些時候，我們會發現我們很難進行單元測試，有些時候是需要 mock 太多東西，有些時候是為了測試，需要準備很多資料。其實當我們發現測試很難寫時，也可能表示類別的設計有問題，可能是職責太多，也可能是直接使用了靜態外部套件，這些問題都會讓我們測試時遇到很多困難。\n\n所以當我們發現不好測試時，應該適時的檢視當前設計，看看是否應該把類別的職責再拆小一點，或者其他各種方式，提升程式的可測試性。\n\n## 結論\n\n單元測試看起來雖然簡單，但其實並不容易。我們在這篇文章中，簡單介紹了測試時會需要的東西，並未討論深入討論各種關於單元測試的知識，例如：各種測試替身，和如何設計測試案例 …等。關於這個議題推薦大家去閱讀各路大神的文章，了解更多關於單元測試的知識。\n\n有些人可能會覺得 ui 很容易變動  所以不需要花時間測試\n\n我覺得正因為容易變動 更有改\n\n更該測試 避免更該的時候造成 資訊遺失\n\n我們不需要花太多力氣測試樣式 而是該測試資訊\n\n通常資訊比較固定 而樣式比較容易變化\n\n```dart\n\n```",
          "id": "1c505c1919bd40ca84963f98c22c4258",
          "filename": "Day 28 - 為程式撰寫單元測試 1c505c1919bd40ca84963f98c22c4258.md",
          "folderName": "Day 28 - 為程式撰寫單元測試",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 29 - 用 Widget Test 測試畫面行為",
          "summary": "id: 29 Flutter 是一個開發客端框架，我們在開發過程中寫的大多數的程式碼，都是關於 UI。有如果我們只針對 UI 之外的程式碼做單元測試，有些行爲會變得難以測試到，或者是會使得測試變得異常麻煩且不必要。此時，我們就可以使用 Widget Test 來協助我們進行與 UI 相關的測試。 如...",
          "content": "id: 29\n\nFlutter 是一個開發客端框架，我們在開發過程中寫的大多數的程式碼，都是關於 UI。有如果我們只針對 UI 之外的程式碼做單元測試，有些行爲會變得難以測試到，或者是會使得測試變得異常麻煩且不必要。此時，我們就可以使用 Widget Test 來協助我們進行與 UI 相關的測試。\n\n## Counter 範例\n\n如果大家使用 Flutter 建立新專案，就會獲得一份 Counter App，而其中也包含了基本的 Widget Test。\n\n![it_img_29_1.png](Day%2029%20-%20%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%E7%95%AB%E9%9D%A2%E8%A1%8C%E7%82%BA/it_img_29_1.png)\n\n[https://dartpad.dev/?id=020c618ae0aeb6d080e370bd4382a46c](https://dartpad.dev/?id=020c618ae0aeb6d080e370bd4382a46c)\n\n在 test 資料夾中，我們可以找到測試 counter 功能的 Widget Test。與單元測試相似，我們也可以用 3A 原則來寫 Widget Test：準備待測 Widget、與 Widget 進行互動、驗證畫面狀態是否符合期。\n\n![it_img_29_2.png](Day%2029%20-%20%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%E7%95%AB%E9%9D%A2%E8%A1%8C%E7%82%BA/it_img_29_2.png)\n\n[https://dartpad.dev/?id=c28a6f6170e7a5a2dba2ba0025843463](https://dartpad.dev/?id=c28a6f6170e7a5a2dba2ba0025843463)\n\n在 Widget Test 中，與單元測試不同的是，我們使用 testWidgets 方法來建立測試，在測試中，會頻繁使用 WidgetTester 協助我們 Flutter 框架互動。比如我們會用 Widget.pumpWidget(…) 來建立想要測試的 Widget，然後使用 WidgetTester.tap(…) 點擊畫面中的某個元素。最後我們使用 expect 來驗證畫面是否有我們預期的元素，以 counter 來說，expect(find.text(’1’), findsOneWidget) 表示我們預期畫面上能找到 1 這個文字。\n\n## 像單元測試一樣 Spy\n\n在單元測試中，我們常常使用 Spy 來驗證類別是否正確與其他類別互動，同樣的，我們也希望能測試 Widget 是否與其他類別正確的互動，假設我們稍微修改一下 counter 的範例，讓 counter 也紀錄一份在 local storage 中，讓下次打開 App 能從上一次的狀態開始計數。\n\n![it_img_29_3.png](Day%2029%20-%20%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%E7%95%AB%E9%9D%A2%E8%A1%8C%E7%82%BA/it_img_29_3.png)\n\n[https://dartpad.dev/?id=167328c440e09b6c1f6ae60c7464acc9](https://dartpad.dev/?id=167328c440e09b6c1f6ae60c7464acc9)\n\n此時，我們當除了驗證畫面是否正確之外，我們也希望驗證 Widget 是否有正確的呼叫 LocalStorageRepository。此時我們可使用單元測試的技巧，建立一個 MockLocalStorageRepository，並在測試中利用 Provider 注入這個假的 Repository。\n\n![it_img_29_4.png](Day%2029%20-%20%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%E7%95%AB%E9%9D%A2%E8%A1%8C%E7%82%BA/it_img_29_4.png)\n\n[https://dartpad.dev/?id=4122918819fc339b3a387f1721bbd859](https://dartpad.dev/?id=4122918819fc339b3a387f1721bbd859)\n\n最後我們就能利用 verfiy 檢查，當使用者按下 + 按鈕後，畫面除了能找到 1 的文字之外，也有正確的呼叫了 LocalStorageRepository 的 setCounter 方法。\n\n## Routing 測試\n\nRouting 是一種 UI 中常見的行為，當使用者按了某個按鈕，或完成某個操作，都有可能需要使用 Routing 將使用者導向其他頁面。有些時候，一些重要流程會包含許多頁面的切換，此時測試頁面是否正確的轉換了，就是一件重要的事情。讓我們稍微修改一下 counter 的例子，讓今天 + 按鈕不是直接把數字 + 1，而是跳到其他頁面，讓使用者輸入數字，並回頭把數字加到 counter 上。\n\n![it_img_29_5.png](Day%2029%20-%20%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%E7%95%AB%E9%9D%A2%E8%A1%8C%E7%82%BA/it_img_29_5.png)\n\n[https://dartpad.dev/?id=90e9763769ae9d14b25816f6adba7ded](https://dartpad.dev/?id=90e9763769ae9d14b25816f6adba7ded)\n\n使用 Widget Test，我們一樣也能測試使用者切換畫面的操作，按下 + 按鈕，跳到 AddPage 並輸入數字，最後回傳結果並加到 countter 上。\n\n![it_img_29_6.png](Day%2029%20-%20%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%E7%95%AB%E9%9D%A2%E8%A1%8C%E7%82%BA/it_img_29_6.png)\n\n[https://dartpad.dev/?id=11acccdbf195f0608b53af547e40442e](https://dartpad.dev/?id=11acccdbf195f0608b53af547e40442e)\n\n有些時候，如果 Widget Test 涉及多個頁面，會帶來一些麻煩。想像一下，在上面的例子中，HomePage 依賴某個 Repository，而 AddPage 依賴於另一個 Repository。此時，如果我們想順利進行測試，我們必須同時 Mock 兩個 Repository 並在測試中注入。當 Widget Test 涉及的頁面越多，我們的測試就越難寫。\n\n![it_img_29_7.png](Day%2029%20-%20%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%E7%95%AB%E9%9D%A2%E8%A1%8C%E7%82%BA/it_img_29_7.png)\n\n而此時我們可以發現，或許我們測試的範圍太大了。在這邊，我們能把原本的測試拆小，拆成兩個測試案例：\n\n1. 當按下 MyHomePage 的 + 按鈕時，是否能正確 route 到 AddPage\n2. 當從 AddPage 回來且帶有數字時，counter 數字是否正確的增加\n\n## 做一個假的 RouteObserver\n\n在開發中，Flutter 提供 RouteObserver 類別讓我們實作，讓我們可以在 App 運行中觀察 Route 的變化，我們在[這篇文章](https://ithelp.ithome.com.tw/articles/10305875)中也有提到，在此不作過多贅述。在 Widget Test 中，我們也能利用這個類別，來驗證是否有正確的 Route。\n\n![it_img_29_8.png](Day%2029%20-%20%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%E7%95%AB%E9%9D%A2%E8%A1%8C%E7%82%BA/it_img_29_8.png)\n\n[https://dartpad.dev/?id=cb00828fac11ba0a7787caa0cbc9d269](https://dartpad.dev/?id=cb00828fac11ba0a7787caa0cbc9d269)\n\n在上面的測試中，我們把 observer 放進測試中，在測試執行的最後，我們驗證了 observer 是否有正確的觀測到 addPageRoute 被 push。\n\n## 直接使用 Navigator 做假回傳\n\n在第二個測試中，由於我們再也不會切換到真的 AddPage 了，所以我們理當也不會得到一個合法的回傳。為此，我們可以在測試中操作 Navigator，直接使用 Navigator 把頁面切回上一頁，並且帶入我們想帶入的假資料。\n\n![it_img_29_9.png](Day%2029%20-%20%E7%94%A8%20Widget%20Test%20%E6%B8%AC%E8%A9%A6%E7%95%AB%E9%9D%A2%E8%A1%8C%E7%82%BA/it_img_29_9.png)\n\n[https://dartpad.dev/?id=cb00828fac11ba0a7787caa0cbc9d269](https://dartpad.dev/?id=cb00828fac11ba0a7787caa0cbc9d269)\n\n最後我們就能驗證結果，驗證畫面有正常的加上我們做假的數字。在上面兩個測試案例中，我們可以獨立的測試把 MyHomePage 的行為，而不引入其他頁面的實作，使得這個測試能更加堅固一點，不會因為 AddPage 的改變了實作，使得 MyHomePage 的測試也要修改。如果昨天的文章提到的，測試也需要重構，由於這兩個的測試把細節都暴露在測試中，使得測試並不容易閱讀，所以當完成測試通過之後，我們也必須重構這些測試，增加其可讀性，在這邊就不特別在展示了。\n\n## 結論\n\nWidget Test 能讓我們從使用者的操作的角度來進行測試。由於 Widget Test 並非真正的把 Flutter 框架跑起來，而是只是模擬畫面的執行，所以執行速度不慢，且不像真正的 UI Test 那般不穩定。結合單元測試的技巧，我們能測試 UI 是否有正確的狀態，也能測試 UI 是否正確的與其他元件互動。使用單元測試加上 Widget Test，才能讓我們的 Flutter 程式有完整的測試保護。\n\n## 題外話\n\n值得注意的是 flutter 渲染畫面的概念與遊戲相似，都是每一秒鐘都會重新渲染好幾的 Frame。但在測試中，我們必須使用 WidgetTester.pump() 驅動重新渲染一個 Frame。當我們使用動畫時，可能要好幾個 Frame 才能動畫跑完，此時就需要使用 WidgetTester.pumpAndSettle()，讓 Widget 持續畫到沒有新的 Frame 要更新為止。",
          "id": "ae62d83899074b17af73fe90d9802dc4",
          "filename": "Day 29 - 用 Widget Test 測試畫面行為 ae62d83899074b17af73fe90d9802dc4.md",
          "folderName": "Day 29 - 用 Widget Test 測試畫面行為",
          "seriesName": "30 天學會 Flutter 設計"
        },
        {
          "title": "Day 30 - 更好的設計",
          "summary": "id: 30 在過去的二十幾天中，我們從畫面開始到 API 呼叫，由外往內的討論了每一層，也討論單元測試與 Widget Test。在每一層中，我們討論了許多比較常見的問題，針對每個問題，也討論這樣設計會造成什麼問題。但是否我們在專案剛開始時，就開始引入狀態管理套件、使用裝飾者模式或 Interce...",
          "content": "id: 30\n\n在過去的二十幾天中，我們從畫面開始到 API 呼叫，由外往內的討論了每一層，也討論單元測試與 Widget Test。在每一層中，我們討論了許多比較常見的問題，針對每個問題，也討論這樣設計會造成什麼問題。但是否我們在專案剛開始時，就開始引入狀態管理套件、使用裝飾者模式或 Interceptor 呢？\n\n## 過度設計\n\n大多時候，如果我們還沒看到問題，就想著用什麼作法，常常會導致程式過度設計。因為使用場景還沒出現，我們假設了未來會這麼用，萬一想像中未來沒有發生，那這些拆的很乾淨的程式碼除了影響閱讀之外，一無是處。每一個解法都應該對應著一個想解決的問題，只有當問題發生時，我們針對問題解決，才不會讓程式碼變得過度設計。\n\n## 四眼原則\n\n雖然我們總想著不要過度設計，但是有時就是無法避免，畢竟如果是一個人開發，再厲害的人有時也是會有盲點的。為了減緩這麼問題，我們可以透過 Pair Programming 和 Code Review，多一個人一起思考討論作法，能讓設計有機會變得更好。有人可能會覺得兩個人做同一件事情很浪費時間，但是如果仔細想想，如果常常一個人寫 Code，卻又在 Code Review 得到許多需要修改的回饋，然後轉頭再花時間修改，那不是一件更浪費時間的事情。如果多一個人同時思考討論，是不是也能降低 Bug 發生的機會，省下許多修 Bug 的時間。\n\n## 精進自己\n\n如果今天我們與其他的同事一起 pair，我們也能從 pair 的過程中學習許多自己不知道的技巧，進而提升自己的能力。或許同事的打字速度很快，快捷鍵使用的很熟練，不會因為打字太慢而中斷思考，我們也就知道學習這些技巧，能為我們帶來什麼好處。除了透過 Pair Programming 之外，閱讀大師的著作也能讓我們更全面的了解一些設計的意義，或更好的作法或架構。也有許多大師願意花時間開課傳授自己畢生的功力，例如：[91 敏捷開發之路](https://www.facebook.com/91agile/)、[搞笑談軟工](http://teddy-chen-tw.blogspot.com/) …等，都是能有效精進自己的設計能力的方法。\n\n## 最後\n\n唯有持續的學習，了解每個設計背後的問題，並且針對問題與當下的情境，選擇最合適的作法，才能讓程式處在易於修改又容易閱讀的狀態。在過去的二十幾天中，我們討論了許多問題，也有許多問題沒有被討論到，或許以後有機會再跟大家分享，也歡迎大家來我的 [Medium](https://easylive1989.medium.com/)，也謝謝大家三十天以來的觀看。\n\n## 最好的解法\n\n我們有很多做法，從最僵化的寫法容易讓我們程式腐化，難以修改。但是最彈性的寫法是否真的是最好的法呢？\n\n如果我們沒有再次經過 Code Review，或者自己再多思考一點。\n\n三十天中，肯定還有許多沒討論的場景與其設計\n\n設計是一門藝術，並沒有對與錯 而是只有合適與不合適\n\n除了這幾天提到的例子，還有許多例子是程式設計中，但因為與 Flutter 或 Dart 沒有多大關係，就沒有特別開一篇討論\n\n## \n\n## 精進自己\n\n- 91 AOP\n- 91 單元測試\n- [https://teddysoft.tw/courses/exception-handling/](https://teddysoft.tw/courses/exception-handling/)\n\n看書\n\nClean Architecture\n\nDependency Injection",
          "id": "fae720c89b0048bb886f5aa60d0d9710",
          "filename": "Day 30 - 更好的設計 fae720c89b0048bb886f5aa60d0d9710.md",
          "folderName": "Day 30 - 更好的設計",
          "seriesName": "30 天學會 Flutter 設計"
        }
      ]
    }
  ],
  "generatedAt": "2025-10-26T13:40:10.569Z"
}